Args: ../Polygeist/build/bin/cgeist ../in/test.c -S --function=example --debug -opaque-pointers=0 
Load new dialect in Context builtin
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SubElementTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ShapedType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemRefLayoutAttrInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SubElementAttrInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ElementsAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::TypedAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionKindInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CastOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffectOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ResourceBlobManagerDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BytecodeDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineBinaryOpExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineConstantExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineDimExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineMapStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::IntegerSetStorage)
Load new dialect in Context affine
Load new dialect in Context arith
ImplicitTypeIDRegistry::lookupOrInsert(mlir::VectorUnrollOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferTypeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferIntRangeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DialectInlinerInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::AffineDmaStartOp)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::AffineMapAccessInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::AffineDmaWaitOp)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LoopLikeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::AffineReadOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::AffineWriteOpInterface)
Load new dialect in Context func
Load new dialect in Context cf
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BranchOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolUserOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::FunctionOpInterface)
Load new dialect in Context dlti
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutEntryAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutEntryInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutSpecAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutSpecInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutDialectInterface)
Load new dialect in Context scf
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchTerminatorOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ParallelCombiningOpInterface)
Load new dialect in Context async
Load new dialect in Context llvm
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMVoidType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMPPCFP128Type)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMX86MMXType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMTokenType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMLabelType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMMetadataType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMFunctionType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMPointerType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMFixedVectorType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMScalableVectorType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMArrayType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMStructType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::FastmathFlagsInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVMTranslationDialectInterface)
Load new dialect in Context nvvm
Load new dialect in Context gpu
ImplicitTypeIDRegistry::lookupOrInsert(mlir::gpu::AsyncTokenType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::gpu::MMAMatrixType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::gpu::AsyncOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutOpInterface)
Load new dialect in Context omp
ImplicitTypeIDRegistry::lookupOrInsert(mlir::omp::OutlineableOpenMPOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::omp::ReductionClauseInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::omp::PointerLikeType)
Load new dialect in Context math
Load new dialect in Context memref
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CopyOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ViewLikeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OffsetSizeAndStrideOpInterface)
Load new dialect in Context linalg
Load new dialect in Context tensor
Load new dialect in Context complex
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ReifyRankedShapedTypeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::linalg::DestinationStyleOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::linalg::LinalgOp)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::linalg::ContractionOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::linalg::ConvolutionOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::linalg::FillOpInterface)
Load new dialect in Context polygeist
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemRefElementTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::PointerElementTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneRegion<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroResults<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroSuccessors<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NoRegionArguments<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NoTerminator<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SingleBlock<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OpInvariants<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AffineScope<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsIsolatedFromAbove<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SymbolTable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionKindInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasOnlyGraphRegion<Empty>)
../in/test.c:4:10: fatal error: 'math.h' file not found
#include <math.h>
         ^~~~~~~~
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AutomaticAllocationScope<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallableOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::FunctionOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroRegions<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneResult<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::VariadicOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AttrSizedOperandSegments<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffectOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ConstantLike<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferIntRangeInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferTypeOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp, mlir::scf::ForOp, mlir::scf::IfOp, mlir::scf::ParallelOp, mlir::scf::WhileOp>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ReturnLike<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsTerminator<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::VariadicResults<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolUserOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneSuccessor<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BranchOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NSuccessors<2>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AtLeastNOperands<1>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NRegions<2>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneOperand<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasRecursiveSideEffects<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::MemRefsNormalizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::OpToOpPassAdaptor)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DominanceInfo)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsCommutative<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffects::Allocate)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SideEffects::AutomaticAllocationScopeResource)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffects::Read)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SameOperandsAndResultShape<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CastOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ViewLikeOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AtLeastNOperands<2>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffects::Write)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SideEffects::DefaultResource)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NOperands<2>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SameTypeOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::VectorUnrollOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Elementwise<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Scalarizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Vectorizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Tensorizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsIdempotent<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SameOperandsAndResultType<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::PostDominanceInfo)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::PreservedAnalyses::AllAnalysesType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DialectFoldInterface)

//===-------------------------------------------===//
Processing operation : 'func.return'(0x7fbd9800c610) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd98166820) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd98166790) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.execute_region'(0x7fbd981668c0) {

  * Pattern SingleBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "SingleBlockExecuteInliner"
    ** Replace : 'scf.execute_region'(0x7fbd981668c0)
    ** Erase   : 'scf.yield'(0x7fbd9800c5c0)
"SingleBlockExecuteInliner" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %true = arith.constant true
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<1xi32>
  %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
  memref.store %2, %4[%c0] : memref<?xi32>
  %5 = memref.alloca() : memref<1xi32>
  %6 = memref.cast %5 : memref<1xi32> to memref<?xi32>
  memref.store %2, %6[%c0] : memref<?xi32>
  %7 = memref.alloca() : memref<1xi32>
  %8 = memref.cast %7 : memref<1xi32> to memref<?xi32>
  memref.store %2, %8[%c0] : memref<?xi32>
  %9 = memref.alloca() : memref<1xmemref<?xf32>>
  %10 = memref.cast %9 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %11 = memref.alloca() : memref<1xmemref<?xf32>>
  %12 = memref.cast %11 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %13 = memref.alloca() : memref<1xmemref<?xf32>>
  %14 = memref.cast %13 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %15 = memref.alloca() : memref<1xmemref<?xf32>>
  %16 = memref.cast %15 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  memref.store %arg0, %16[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg1, %14[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg2, %12[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg3, %10[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg4, %8[%c0] : memref<?xi32>
  %17 = memref.alloca() : memref<i1>
  %18 = memref.alloca() : memref<i1>
  memref.store %true, %18[] : memref<i1>
  memref.store %true, %17[] : memref<i1>
  %19 = memref.load %17[] : memref<i1>
  scf.if %19 {
    %20 = memref.load %17[] : memref<i1>
    scf.if %20 {
      scf.execute_region {
        %21 = memref.load %17[] : memref<i1>
        scf.if %21 {
          scf.execute_region {
            %34 = memref.get_global @kbm3 : memref<1xi32>
            %35 = memref.cast %34 : memref<1xi32> to memref<?xi32>
            %36 = memref.load %35[%c0] : memref<?xi32>
            memref.store %36, %6[%c0] : memref<?xi32>
            scf.yield
          }
        }
        %22 = memref.alloca() : memref<i1>
        %23 = memref.alloca() : memref<i1>
        memref.store %true, %23[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %24 = memref.load %6[%c0] : memref<?xi32>
        %25 = arith.cmpi sgt, %24, %c0_i32 : i32
        %26 = arith.extsi %25 : i1 to i32
        %27 = arith.cmpi ne, %26, %c0_i32 : i32
        %28 = memref.load %23[] : memref<i1>
        %29 = arith.andi %27, %28 : i1
        cf.cond_br %29, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %30 = memref.load %23[] : memref<i1>
        memref.store %30, %22[] : memref<i1>
        %31 = memref.load %22[] : memref<i1>
        scf.if %31 {
          scf.execute_region {
            %34 = memref.load %22[] : memref<i1>
            scf.if %34 {
              scf.execute_region {
                %35 = memref.load %22[] : memref<i1>
                scf.if %35 {
                  scf.execute_region {
                    memref.store %c0_i32, %4[%c0] : memref<?xi32>
                    scf.yield
                  }
                }
                %36 = memref.alloca() : memref<i1>
                %37 = memref.alloca() : memref<i1>
                memref.store %true, %37[] : memref<i1>
                cf.br ^bb1
              ^bb1:  // 2 preds: ^bb0, ^bb2
                %38 = memref.load %4[%c0] : memref<?xi32>
                %39 = memref.get_global @jm : memref<1xi32>
                %40 = memref.cast %39 : memref<1xi32> to memref<?xi32>
                %41 = memref.load %40[%c0] : memref<?xi32>
                %42 = arith.cmpi slt, %38, %41 : i32
                %43 = arith.extsi %42 : i1 to i32
                %44 = arith.cmpi ne, %43, %c0_i32 : i32
                %45 = memref.load %37[] : memref<i1>
                %46 = arith.andi %44, %45 : i1
                cf.cond_br %46, ^bb2, ^bb3
              ^bb2:  // pred: ^bb1
                %47 = memref.load %37[] : memref<i1>
                memref.store %47, %36[] : memref<i1>
                %48 = memref.load %36[] : memref<i1>
                scf.if %48 {
                  scf.execute_region {
                    %51 = memref.load %36[] : memref<i1>
                    scf.if %51 {
                      scf.execute_region {
                        %52 = memref.load %36[] : memref<i1>
                        scf.if %52 {
                          scf.execute_region {
                            memref.store %c0_i32, %1[%c0] : memref<?xi32>
                            scf.yield
                          }
                        }
                        %53 = memref.alloca() : memref<i1>
                        %54 = memref.alloca() : memref<i1>
                        memref.store %true, %54[] : memref<i1>
                        cf.br ^bb1
                      ^bb1:  // 2 preds: ^bb0, ^bb2
                        %55 = memref.load %1[%c0] : memref<?xi32>
                        %56 = memref.get_global @im : memref<1xi32>
                        %57 = memref.cast %56 : memref<1xi32> to memref<?xi32>
                        %58 = memref.load %57[%c0] : memref<?xi32>
                        %59 = arith.cmpi slt, %55, %58 : i32
                        %60 = arith.extsi %59 : i1 to i32
                        %61 = arith.cmpi ne, %60, %c0_i32 : i32
                        %62 = memref.load %54[] : memref<i1>
                        %63 = arith.andi %61, %62 : i1
                        cf.cond_br %63, ^bb2, ^bb3
                      ^bb2:  // pred: ^bb1
                        %64 = memref.load %54[] : memref<i1>
                        memref.store %64, %53[] : memref<i1>
                        %65 = memref.load %53[] : memref<i1>
                        scf.if %65 {
                          scf.execute_region {
                            %68 = memref.load %12[%c0] : memref<?xmemref<?xf32>>
                            %69 = memref.load %1[%c0] : memref<?xi32>
                            %70 = memref.load %4[%c0] : memref<?xi32>
                            %71 = memref.load %57[%c0] : memref<?xi32>
                            %72 = arith.muli %70, %71 : i32
                            %73 = arith.addi %69, %72 : i32
                            %74 = memref.load %6[%c0] : memref<?xi32>
                            %75 = arith.muli %74, %71 : i32
                            %76 = memref.load %40[%c0] : memref<?xi32>
                            %77 = arith.muli %75, %76 : i32
                            %78 = arith.addi %73, %77 : i32
                            %79 = arith.index_cast %78 : i32 to index
                            %80 = "polygeist.subindex"(%68, %79) : (memref<?xf32>, index) -> memref<?xf32>
                            %81 = "polygeist.subindex"(%80, %c0) : (memref<?xf32>, index) -> memref<?xf32>
                            %82 = memref.load %16[%c0] : memref<?xmemref<?xf32>>
                            %83 = arith.subi %74, %c1_i32 : i32
                            %84 = arith.muli %83, %71 : i32
                            %85 = arith.muli %84, %76 : i32
                            %86 = arith.addi %73, %85 : i32
                            %87 = arith.index_cast %86 : i32 to index
                            %88 = "polygeist.subindex"(%82, %87) : (memref<?xf32>, index) -> memref<?xf32>
                            %89 = "polygeist.subindex"(%88, %c0) : (memref<?xf32>, index) -> memref<?xf32>
                            %90 = memref.load %89[%c0] : memref<?xf32>
                            memref.store %90, %81[%c0] : memref<?xf32>
                            scf.yield
                          }
                        }
                        %66 = memref.load %54[] : memref<i1>
                        memref.store %66, %53[] : memref<i1>
                        %67 = memref.load %53[] : memref<i1>
                        scf.if %67 {
                          scf.execute_region {
                            %68 = memref.load %1[%c0] : memref<?xi32>
                            %69 = arith.addi %68, %c1_i32 : i32
                            memref.store %69, %1[%c0] : memref<?xi32>
                            scf.yield
                          }
                        }
                        cf.br ^bb1
                      ^bb3:  // pred: ^bb1
                        scf.yield
                      }
                    }
                    scf.yield
                  }
                }
                %49 = memref.load %37[] : memref<i1>
                memref.store %49, %36[] : memref<i1>
                %50 = memref.load %36[] : memref<i1>
                scf.if %50 {
                  scf.execute_region {
                    %51 = memref.load %4[%c0] : memref<?xi32>
                    %52 = arith.addi %51, %c1_i32 : i32
                    memref.store %52, %4[%c0] : memref<?xi32>
                    scf.yield
                  }
                }
                cf.br ^bb1
              ^bb3:  // pred: ^bb1
                scf.yield
              }
            }
            scf.yield
          }
        }
        %32 = memref.load %23[] : memref<i1>
        memref.store %32, %22[] : memref<i1>
        %33 = memref.load %22[] : memref<i1>
        scf.if %33 {
          scf.execute_region {
            %34 = memref.load %6[%c0] : memref<?xi32>
            %35 = arith.subi %34, %c1_i32 : i32
            memref.store %35, %6[%c0] : memref<?xi32>
            scf.yield
          }
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd98166a90) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd98166a40) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.execute_region'(0x7fbd98166b30) {

  * Pattern SingleBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "SingleBlockExecuteInliner"
"SingleBlockExecuteInliner" result 0
  } -> failure : pattern failed to match

  * Pattern MultiBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "MultiBlockExecuteInliner"
"MultiBlockExecuteInliner" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9800c570) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9800c500) {
  "cf.br"()[^bb1] : () -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9800c080) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9800c010) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.execute_region'(0x7fbd9800c120) {

  * Pattern SingleBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "SingleBlockExecuteInliner"
    ** Replace : 'scf.execute_region'(0x7fbd9800c120)
    ** Erase   : 'scf.yield'(0x7fbd9800c4b0)
"SingleBlockExecuteInliner" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %true = arith.constant true
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<1xi32>
  %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
  memref.store %2, %4[%c0] : memref<?xi32>
  %5 = memref.alloca() : memref<1xi32>
  %6 = memref.cast %5 : memref<1xi32> to memref<?xi32>
  memref.store %2, %6[%c0] : memref<?xi32>
  %7 = memref.alloca() : memref<1xi32>
  %8 = memref.cast %7 : memref<1xi32> to memref<?xi32>
  memref.store %2, %8[%c0] : memref<?xi32>
  %9 = memref.alloca() : memref<1xmemref<?xf32>>
  %10 = memref.cast %9 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %11 = memref.alloca() : memref<1xmemref<?xf32>>
  %12 = memref.cast %11 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %13 = memref.alloca() : memref<1xmemref<?xf32>>
  %14 = memref.cast %13 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %15 = memref.alloca() : memref<1xmemref<?xf32>>
  %16 = memref.cast %15 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  memref.store %arg0, %16[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg1, %14[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg2, %12[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg3, %10[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg4, %8[%c0] : memref<?xi32>
  %17 = memref.alloca() : memref<i1>
  %18 = memref.alloca() : memref<i1>
  memref.store %true, %18[] : memref<i1>
  memref.store %true, %17[] : memref<i1>
  %19 = memref.load %17[] : memref<i1>
  scf.if %19 {
    %20 = memref.load %17[] : memref<i1>
    scf.if %20 {
      scf.execute_region {
        %21 = memref.load %17[] : memref<i1>
        scf.if %21 {
          scf.execute_region {
            %34 = memref.get_global @kbm3 : memref<1xi32>
            %35 = memref.cast %34 : memref<1xi32> to memref<?xi32>
            %36 = memref.load %35[%c0] : memref<?xi32>
            memref.store %36, %6[%c0] : memref<?xi32>
            scf.yield
          }
        }
        %22 = memref.alloca() : memref<i1>
        %23 = memref.alloca() : memref<i1>
        memref.store %true, %23[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %24 = memref.load %6[%c0] : memref<?xi32>
        %25 = arith.cmpi sgt, %24, %c0_i32 : i32
        %26 = arith.extsi %25 : i1 to i32
        %27 = arith.cmpi ne, %26, %c0_i32 : i32
        %28 = memref.load %23[] : memref<i1>
        %29 = arith.andi %27, %28 : i1
        cf.cond_br %29, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %30 = memref.load %23[] : memref<i1>
        memref.store %30, %22[] : memref<i1>
        %31 = memref.load %22[] : memref<i1>
        scf.if %31 {
          scf.execute_region {
            %34 = memref.load %22[] : memref<i1>
            scf.if %34 {
              scf.execute_region {
                %35 = memref.load %22[] : memref<i1>
                scf.if %35 {
                  scf.execute_region {
                    memref.store %c0_i32, %4[%c0] : memref<?xi32>
                    scf.yield
                  }
                }
                %36 = memref.alloca() : memref<i1>
                %37 = memref.alloca() : memref<i1>
                memref.store %true, %37[] : memref<i1>
                cf.br ^bb1
              ^bb1:  // 2 preds: ^bb0, ^bb2
                %38 = memref.load %4[%c0] : memref<?xi32>
                %39 = memref.get_global @jm : memref<1xi32>
                %40 = memref.cast %39 : memref<1xi32> to memref<?xi32>
                %41 = memref.load %40[%c0] : memref<?xi32>
                %42 = arith.cmpi slt, %38, %41 : i32
                %43 = arith.extsi %42 : i1 to i32
                %44 = arith.cmpi ne, %43, %c0_i32 : i32
                %45 = memref.load %37[] : memref<i1>
                %46 = arith.andi %44, %45 : i1
                cf.cond_br %46, ^bb2, ^bb3
              ^bb2:  // pred: ^bb1
                %47 = memref.load %37[] : memref<i1>
                memref.store %47, %36[] : memref<i1>
                %48 = memref.load %36[] : memref<i1>
                scf.if %48 {
                  scf.execute_region {
                    %51 = memref.load %36[] : memref<i1>
                    scf.if %51 {
                      scf.execute_region {
                        %52 = memref.load %36[] : memref<i1>
                        scf.if %52 {
                          scf.execute_region {
                            memref.store %c0_i32, %1[%c0] : memref<?xi32>
                            scf.yield
                          }
                        }
                        %53 = memref.alloca() : memref<i1>
                        %54 = memref.alloca() : memref<i1>
                        memref.store %true, %54[] : memref<i1>
                        cf.br ^bb1
                      ^bb1:  // 2 preds: ^bb0, ^bb2
                        %55 = memref.load %1[%c0] : memref<?xi32>
                        %56 = memref.get_global @im : memref<1xi32>
                        %57 = memref.cast %56 : memref<1xi32> to memref<?xi32>
                        %58 = memref.load %57[%c0] : memref<?xi32>
                        %59 = arith.cmpi slt, %55, %58 : i32
                        %60 = arith.extsi %59 : i1 to i32
                        %61 = arith.cmpi ne, %60, %c0_i32 : i32
                        %62 = memref.load %54[] : memref<i1>
                        %63 = arith.andi %61, %62 : i1
                        cf.cond_br %63, ^bb2, ^bb3
                      ^bb2:  // pred: ^bb1
                        %64 = memref.load %54[] : memref<i1>
                        memref.store %64, %53[] : memref<i1>
                        %65 = memref.load %53[] : memref<i1>
                        scf.if %65 {
                          scf.execute_region {
                            %68 = memref.load %12[%c0] : memref<?xmemref<?xf32>>
                            %69 = memref.load %1[%c0] : memref<?xi32>
                            %70 = memref.load %4[%c0] : memref<?xi32>
                            %71 = memref.load %57[%c0] : memref<?xi32>
                            %72 = arith.muli %70, %71 : i32
                            %73 = arith.addi %69, %72 : i32
                            %74 = memref.load %6[%c0] : memref<?xi32>
                            %75 = arith.muli %74, %71 : i32
                            %76 = memref.load %40[%c0] : memref<?xi32>
                            %77 = arith.muli %75, %76 : i32
                            %78 = arith.addi %73, %77 : i32
                            %79 = arith.index_cast %78 : i32 to index
                            %80 = "polygeist.subindex"(%68, %79) : (memref<?xf32>, index) -> memref<?xf32>
                            %81 = "polygeist.subindex"(%80, %c0) : (memref<?xf32>, index) -> memref<?xf32>
                            %82 = memref.load %16[%c0] : memref<?xmemref<?xf32>>
                            %83 = arith.subi %74, %c1_i32 : i32
                            %84 = arith.muli %83, %71 : i32
                            %85 = arith.muli %84, %76 : i32
                            %86 = arith.addi %73, %85 : i32
                            %87 = arith.index_cast %86 : i32 to index
                            %88 = "polygeist.subindex"(%82, %87) : (memref<?xf32>, index) -> memref<?xf32>
                            %89 = "polygeist.subindex"(%88, %c0) : (memref<?xf32>, index) -> memref<?xf32>
                            %90 = memref.load %89[%c0] : memref<?xf32>
                            memref.store %90, %81[%c0] : memref<?xf32>
                            scf.yield
                          }
                        }
                        %66 = memref.load %54[] : memref<i1>
                        memref.store %66, %53[] : memref<i1>
                        %67 = memref.load %53[] : memref<i1>
                        scf.if %67 {
                          scf.execute_region {
                            %68 = memref.load %1[%c0] : memref<?xi32>
                            %69 = arith.addi %68, %c1_i32 : i32
                            memref.store %69, %1[%c0] : memref<?xi32>
                            scf.yield
                          }
                        }
                        cf.br ^bb1
                      ^bb3:  // pred: ^bb1
                        scf.yield
                      }
                    }
                    scf.yield
                  }
                }
                %49 = memref.load %37[] : memref<i1>
                memref.store %49, %36[] : memref<i1>
                %50 = memref.load %36[] : memref<i1>
                scf.if %50 {
                  scf.execute_region {
                    %51 = memref.load %4[%c0] : memref<?xi32>
                    %52 = arith.addi %51, %c1_i32 : i32
                    memref.store %52, %4[%c0] : memref<?xi32>
                    scf.yield
                  }
                }
                cf.br ^bb1
              ^bb3:  // pred: ^bb1
                scf.yield
              }
            }
            scf.yield
          }
        }
        %32 = memref.load %23[] : memref<i1>
        memref.store %32, %22[] : memref<i1>
        %33 = memref.load %22[] : memref<i1>
        scf.if %33 {
          %34 = memref.load %6[%c0] : memref<?xi32>
          %35 = arith.subi %34, %c1_i32 : i32
          memref.store %35, %6[%c0] : memref<?xi32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9800c400) {
  "memref.store"(%39, %10, %3) : (i32, memref<?xi32>, index) -> ()

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9800c320) {
  %39 = "arith.subi"(%38, %0) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9800c230) {
  %38 = "memref.load"(%10, %3) : (memref<?xi32>, index) -> i32

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match

* Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9800bf50) {
  %37 = "memref.load"(%26) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9800beb0) {
  "memref.store"(%36, %26) : (i1, memref<i1>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9800be40) {
  %36 = "memref.load"(%27) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd981688b0) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd98168820) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.execute_region'(0x7fbd98168950) {

  * Pattern SingleBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "SingleBlockExecuteInliner"
    ** Replace : 'scf.execute_region'(0x7fbd98168950)
    ** Erase   : 'scf.yield'(0x7fbd9800bde0)
"SingleBlockExecuteInliner" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %true = arith.constant true
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<1xi32>
  %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
  memref.store %2, %4[%c0] : memref<?xi32>
  %5 = memref.alloca() : memref<1xi32>
  %6 = memref.cast %5 : memref<1xi32> to memref<?xi32>
  memref.store %2, %6[%c0] : memref<?xi32>
  %7 = memref.alloca() : memref<1xi32>
  %8 = memref.cast %7 : memref<1xi32> to memref<?xi32>
  memref.store %2, %8[%c0] : memref<?xi32>
  %9 = memref.alloca() : memref<1xmemref<?xf32>>
  %10 = memref.cast %9 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %11 = memref.alloca() : memref<1xmemref<?xf32>>
  %12 = memref.cast %11 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %13 = memref.alloca() : memref<1xmemref<?xf32>>
  %14 = memref.cast %13 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %15 = memref.alloca() : memref<1xmemref<?xf32>>
  %16 = memref.cast %15 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  memref.store %arg0, %16[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg1, %14[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg2, %12[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg3, %10[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg4, %8[%c0] : memref<?xi32>
  %17 = memref.alloca() : memref<i1>
  %18 = memref.alloca() : memref<i1>
  memref.store %true, %18[] : memref<i1>
  memref.store %true, %17[] : memref<i1>
  %19 = memref.load %17[] : memref<i1>
  scf.if %19 {
    %20 = memref.load %17[] : memref<i1>
    scf.if %20 {
      scf.execute_region {
        %21 = memref.load %17[] : memref<i1>
        scf.if %21 {
          scf.execute_region {
            %34 = memref.get_global @kbm3 : memref<1xi32>
            %35 = memref.cast %34 : memref<1xi32> to memref<?xi32>
            %36 = memref.load %35[%c0] : memref<?xi32>
            memref.store %36, %6[%c0] : memref<?xi32>
            scf.yield
          }
        }
        %22 = memref.alloca() : memref<i1>
        %23 = memref.alloca() : memref<i1>
        memref.store %true, %23[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %24 = memref.load %6[%c0] : memref<?xi32>
        %25 = arith.cmpi sgt, %24, %c0_i32 : i32
        %26 = arith.extsi %25 : i1 to i32
        %27 = arith.cmpi ne, %26, %c0_i32 : i32
        %28 = memref.load %23[] : memref<i1>
        %29 = arith.andi %27, %28 : i1
        cf.cond_br %29, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %30 = memref.load %23[] : memref<i1>
        memref.store %30, %22[] : memref<i1>
        %31 = memref.load %22[] : memref<i1>
        scf.if %31 {
          %34 = memref.load %22[] : memref<i1>
          scf.if %34 {
            scf.execute_region {
              %35 = memref.load %22[] : memref<i1>
              scf.if %35 {
                scf.execute_region {
                  memref.store %c0_i32, %4[%c0] : memref<?xi32>
                  scf.yield
                }
              }
              %36 = memref.alloca() : memref<i1>
              %37 = memref.alloca() : memref<i1>
              memref.store %true, %37[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %38 = memref.load %4[%c0] : memref<?xi32>
              %39 = memref.get_global @jm : memref<1xi32>
              %40 = memref.cast %39 : memref<1xi32> to memref<?xi32>
              %41 = memref.load %40[%c0] : memref<?xi32>
              %42 = arith.cmpi slt, %38, %41 : i32
              %43 = arith.extsi %42 : i1 to i32
              %44 = arith.cmpi ne, %43, %c0_i32 : i32
              %45 = memref.load %37[] : memref<i1>
              %46 = arith.andi %44, %45 : i1
              cf.cond_br %46, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %47 = memref.load %37[] : memref<i1>
              memref.store %47, %36[] : memref<i1>
              %48 = memref.load %36[] : memref<i1>
              scf.if %48 {
                scf.execute_region {
                  %51 = memref.load %36[] : memref<i1>
                  scf.if %51 {
                    scf.execute_region {
                      %52 = memref.load %36[] : memref<i1>
                      scf.if %52 {
                        scf.execute_region {
                          memref.store %c0_i32, %1[%c0] : memref<?xi32>
                          scf.yield
                        }
                      }
                      %53 = memref.alloca() : memref<i1>
                      %54 = memref.alloca() : memref<i1>
                      memref.store %true, %54[] : memref<i1>
                      cf.br ^bb1
                    ^bb1:  // 2 preds: ^bb0, ^bb2
                      %55 = memref.load %1[%c0] : memref<?xi32>
                      %56 = memref.get_global @im : memref<1xi32>
                      %57 = memref.cast %56 : memref<1xi32> to memref<?xi32>
                      %58 = memref.load %57[%c0] : memref<?xi32>
                      %59 = arith.cmpi slt, %55, %58 : i32
                      %60 = arith.extsi %59 : i1 to i32
                      %61 = arith.cmpi ne, %60, %c0_i32 : i32
                      %62 = memref.load %54[] : memref<i1>
                      %63 = arith.andi %61, %62 : i1
                      cf.cond_br %63, ^bb2, ^bb3
                    ^bb2:  // pred: ^bb1
                      %64 = memref.load %54[] : memref<i1>
                      memref.store %64, %53[] : memref<i1>
                      %65 = memref.load %53[] : memref<i1>
                      scf.if %65 {
                        scf.execute_region {
                          %68 = memref.load %12[%c0] : memref<?xmemref<?xf32>>
                          %69 = memref.load %1[%c0] : memref<?xi32>
                          %70 = memref.load %4[%c0] : memref<?xi32>
                          %71 = memref.load %57[%c0] : memref<?xi32>
                          %72 = arith.muli %70, %71 : i32
                          %73 = arith.addi %69, %72 : i32
                          %74 = memref.load %6[%c0] : memref<?xi32>
                          %75 = arith.muli %74, %71 : i32
                          %76 = memref.load %40[%c0] : memref<?xi32>
                          %77 = arith.muli %75, %76 : i32
                          %78 = arith.addi %73, %77 : i32
                          %79 = arith.index_cast %78 : i32 to index
                          %80 = "polygeist.subindex"(%68, %79) : (memref<?xf32>, index) -> memref<?xf32>
                          %81 = "polygeist.subindex"(%80, %c0) : (memref<?xf32>, index) -> memref<?xf32>
                          %82 = memref.load %16[%c0] : memref<?xmemref<?xf32>>
                          %83 = arith.subi %74, %c1_i32 : i32
                          %84 = arith.muli %83, %71 : i32
                          %85 = arith.muli %84, %76 : i32
                          %86 = arith.addi %73, %85 : i32
                          %87 = arith.index_cast %86 : i32 to index
                          %88 = "polygeist.subindex"(%82, %87) : (memref<?xf32>, index) -> memref<?xf32>
                          %89 = "polygeist.subindex"(%88, %c0) : (memref<?xf32>, index) -> memref<?xf32>
                          %90 = memref.load %89[%c0] : memref<?xf32>
                          memref.store %90, %81[%c0] : memref<?xf32>
                          scf.yield
                        }
                      }
                      %66 = memref.load %54[] : memref<i1>
                      memref.store %66, %53[] : memref<i1>
                      %67 = memref.load %53[] : memref<i1>
                      scf.if %67 {
                        scf.execute_region {
                          %68 = memref.load %1[%c0] : memref<?xi32>
                          %69 = arith.addi %68, %c1_i32 : i32
                          memref.store %69, %1[%c0] : memref<?xi32>
                          scf.yield
                        }
                      }
                      cf.br ^bb1
                    ^bb3:  // pred: ^bb1
                      scf.yield
                    }
                  }
                  scf.yield
                }
              }
              %49 = memref.load %37[] : memref<i1>
              memref.store %49, %36[] : memref<i1>
              %50 = memref.load %36[] : memref<i1>
              scf.if %50 {
                scf.execute_region {
                  %51 = memref.load %4[%c0] : memref<?xi32>
                  %52 = arith.addi %51, %c1_i32 : i32
                  memref.store %52, %4[%c0] : memref<?xi32>
                  scf.yield
                }
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %32 = memref.load %23[] : memref<i1>
        memref.store %32, %22[] : memref<i1>
        %33 = memref.load %22[] : memref<i1>
        scf.if %33 {
          %34 = memref.load %5[%c0] : memref<1xi32>
          %35 = arith.subi %34, %c1_i32 : i32
          memref.store %35, %5[%c0] : memref<1xi32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd98168b20) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd98168ad0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.execute_region'(0x7fbd98168bc0) {

  * Pattern SingleBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "SingleBlockExecuteInliner"
"SingleBlockExecuteInliner" result 0
  } -> failure : pattern failed to match

  * Pattern MultiBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "MultiBlockExecuteInliner"
"MultiBlockExecuteInliner" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9800bd90) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9800bd20) {
  "cf.br"()[^bb1] : () -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9800a0e0) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9800a090) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.execute_region'(0x7fbd9800a8d0) {

  * Pattern SingleBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "SingleBlockExecuteInliner"
    ** Replace : 'scf.execute_region'(0x7fbd9800a8d0)
    ** Erase   : 'scf.yield'(0x7fbd9800bcd0)
"SingleBlockExecuteInliner" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %true = arith.constant true
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<1xi32>
  %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
  memref.store %2, %4[%c0] : memref<?xi32>
  %5 = memref.alloca() : memref<1xi32>
  %6 = memref.cast %5 : memref<1xi32> to memref<?xi32>
  memref.store %2, %6[%c0] : memref<?xi32>
  %7 = memref.alloca() : memref<1xi32>
  %8 = memref.cast %7 : memref<1xi32> to memref<?xi32>
  memref.store %2, %8[%c0] : memref<?xi32>
  %9 = memref.alloca() : memref<1xmemref<?xf32>>
  %10 = memref.cast %9 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %11 = memref.alloca() : memref<1xmemref<?xf32>>
  %12 = memref.cast %11 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %13 = memref.alloca() : memref<1xmemref<?xf32>>
  %14 = memref.cast %13 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %15 = memref.alloca() : memref<1xmemref<?xf32>>
  %16 = memref.cast %15 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  memref.store %arg0, %16[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg1, %14[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg2, %12[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg3, %10[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg4, %8[%c0] : memref<?xi32>
  %17 = memref.alloca() : memref<i1>
  %18 = memref.alloca() : memref<i1>
  memref.store %true, %18[] : memref<i1>
  memref.store %true, %17[] : memref<i1>
  %19 = memref.load %17[] : memref<i1>
  scf.if %19 {
    %20 = memref.load %17[] : memref<i1>
    scf.if %20 {
      scf.execute_region {
        %21 = memref.load %17[] : memref<i1>
        scf.if %21 {
          scf.execute_region {
            %34 = memref.get_global @kbm3 : memref<1xi32>
            %35 = memref.cast %34 : memref<1xi32> to memref<?xi32>
            %36 = memref.load %35[%c0] : memref<?xi32>
            memref.store %36, %6[%c0] : memref<?xi32>
            scf.yield
          }
        }
        %22 = memref.alloca() : memref<i1>
        %23 = memref.alloca() : memref<i1>
        memref.store %true, %23[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %24 = memref.load %6[%c0] : memref<?xi32>
        %25 = arith.cmpi sgt, %24, %c0_i32 : i32
        %26 = arith.extsi %25 : i1 to i32
        %27 = arith.cmpi ne, %26, %c0_i32 : i32
        %28 = memref.load %23[] : memref<i1>
        %29 = arith.andi %27, %28 : i1
        cf.cond_br %29, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %30 = memref.load %23[] : memref<i1>
        memref.store %30, %22[] : memref<i1>
        %31 = memref.load %22[] : memref<i1>
        scf.if %31 {
          %34 = memref.load %22[] : memref<i1>
          scf.if %34 {
            scf.execute_region {
              %35 = memref.load %22[] : memref<i1>
              scf.if %35 {
                scf.execute_region {
                  memref.store %c0_i32, %4[%c0] : memref<?xi32>
                  scf.yield
                }
              }
              %36 = memref.alloca() : memref<i1>
              %37 = memref.alloca() : memref<i1>
              memref.store %true, %37[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %38 = memref.load %4[%c0] : memref<?xi32>
              %39 = memref.get_global @jm : memref<1xi32>
              %40 = memref.cast %39 : memref<1xi32> to memref<?xi32>
              %41 = memref.load %40[%c0] : memref<?xi32>
              %42 = arith.cmpi slt, %38, %41 : i32
              %43 = arith.extsi %42 : i1 to i32
              %44 = arith.cmpi ne, %43, %c0_i32 : i32
              %45 = memref.load %37[] : memref<i1>
              %46 = arith.andi %44, %45 : i1
              cf.cond_br %46, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %47 = memref.load %37[] : memref<i1>
              memref.store %47, %36[] : memref<i1>
              %48 = memref.load %36[] : memref<i1>
              scf.if %48 {
                scf.execute_region {
                  %51 = memref.load %36[] : memref<i1>
                  scf.if %51 {
                    scf.execute_region {
                      %52 = memref.load %36[] : memref<i1>
                      scf.if %52 {
                        scf.execute_region {
                          memref.store %c0_i32, %1[%c0] : memref<?xi32>
                          scf.yield
                        }
                      }
                      %53 = memref.alloca() : memref<i1>
                      %54 = memref.alloca() : memref<i1>
                      memref.store %true, %54[] : memref<i1>
                      cf.br ^bb1
                    ^bb1:  // 2 preds: ^bb0, ^bb2
                      %55 = memref.load %1[%c0] : memref<?xi32>
                      %56 = memref.get_global @im : memref<1xi32>
                      %57 = memref.cast %56 : memref<1xi32> to memref<?xi32>
                      %58 = memref.load %57[%c0] : memref<?xi32>
                      %59 = arith.cmpi slt, %55, %58 : i32
                      %60 = arith.extsi %59 : i1 to i32
                      %61 = arith.cmpi ne, %60, %c0_i32 : i32
                      %62 = memref.load %54[] : memref<i1>
                      %63 = arith.andi %61, %62 : i1
                      cf.cond_br %63, ^bb2, ^bb3
                    ^bb2:  // pred: ^bb1
                      %64 = memref.load %54[] : memref<i1>
                      memref.store %64, %53[] : memref<i1>
                      %65 = memref.load %53[] : memref<i1>
                      scf.if %65 {
                        scf.execute_region {
                          %68 = memref.load %12[%c0] : memref<?xmemref<?xf32>>
                          %69 = memref.load %1[%c0] : memref<?xi32>
                          %70 = memref.load %4[%c0] : memref<?xi32>
                          %71 = memref.load %57[%c0] : memref<?xi32>
                          %72 = arith.muli %70, %71 : i32
                          %73 = arith.addi %69, %72 : i32
                          %74 = memref.load %6[%c0] : memref<?xi32>
                          %75 = arith.muli %74, %71 : i32
                          %76 = memref.load %40[%c0] : memref<?xi32>
                          %77 = arith.muli %75, %76 : i32
                          %78 = arith.addi %73, %77 : i32
                          %79 = arith.index_cast %78 : i32 to index
                          %80 = "polygeist.subindex"(%68, %79) : (memref<?xf32>, index) -> memref<?xf32>
                          %81 = "polygeist.subindex"(%80, %c0) : (memref<?xf32>, index) -> memref<?xf32>
                          %82 = memref.load %16[%c0] : memref<?xmemref<?xf32>>
                          %83 = arith.subi %74, %c1_i32 : i32
                          %84 = arith.muli %83, %71 : i32
                          %85 = arith.muli %84, %76 : i32
                          %86 = arith.addi %73, %85 : i32
                          %87 = arith.index_cast %86 : i32 to index
                          %88 = "polygeist.subindex"(%82, %87) : (memref<?xf32>, index) -> memref<?xf32>
                          %89 = "polygeist.subindex"(%88, %c0) : (memref<?xf32>, index) -> memref<?xf32>
                          %90 = memref.load %89[%c0] : memref<?xf32>
                          memref.store %90, %81[%c0] : memref<?xf32>
                          scf.yield
                        }
                      }
                      %66 = memref.load %54[] : memref<i1>
                      memref.store %66, %53[] : memref<i1>
                      %67 = memref.load %53[] : memref<i1>
                      scf.if %67 {
                        scf.execute_region {
                          %68 = memref.load %1[%c0] : memref<?xi32>
                          %69 = arith.addi %68, %c1_i32 : i32
                          memref.store %69, %1[%c0] : memref<?xi32>
                          scf.yield
                        }
                      }
                      cf.br ^bb1
                    ^bb3:  // pred: ^bb1
                      scf.yield
                    }
                  }
                  scf.yield
                }
              }
              %49 = memref.load %37[] : memref<i1>
              memref.store %49, %36[] : memref<i1>
              %50 = memref.load %36[] : memref<i1>
              scf.if %50 {
                %51 = memref.load %4[%c0] : memref<?xi32>
                %52 = arith.addi %51, %c1_i32 : i32
                memref.store %52, %4[%c0] : memref<?xi32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %32 = memref.load %23[] : memref<i1>
        memref.store %32, %22[] : memref<i1>
        %33 = memref.load %22[] : memref<i1>
        scf.if %33 {
          %34 = memref.load %5[%c0] : memref<1xi32>
          %35 = arith.subi %34, %c1_i32 : i32
          memref.store %35, %5[%c0] : memref<1xi32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9800bc20) {
  "memref.store"(%56, %8, %3) : (i32, memref<?xi32>, index) -> ()

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %56 = "arith.addi"(%55, %0) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9800baa0) {
  %55 = "memref.load"(%8, %3) : (memref<?xi32>, index) -> i32

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match

* Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98009fd0) {
  %54 = "memref.load"(%40) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd98009f30) {
  "memref.store"(%53, %40) : (i1, memref<i1>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98009ec0) {
  %53 = "memref.load"(%41) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9816a370) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9816a300) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.execute_region'(0x7fbd9816a410) {

  * Pattern SingleBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "SingleBlockExecuteInliner"
    ** Replace : 'scf.execute_region'(0x7fbd9816a410)
    ** Erase   : 'scf.yield'(0x7fbd9800a880)
"SingleBlockExecuteInliner" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %true = arith.constant true
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<1xi32>
  %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
  memref.store %2, %4[%c0] : memref<?xi32>
  %5 = memref.alloca() : memref<1xi32>
  %6 = memref.cast %5 : memref<1xi32> to memref<?xi32>
  memref.store %2, %6[%c0] : memref<?xi32>
  %7 = memref.alloca() : memref<1xi32>
  %8 = memref.cast %7 : memref<1xi32> to memref<?xi32>
  memref.store %2, %8[%c0] : memref<?xi32>
  %9 = memref.alloca() : memref<1xmemref<?xf32>>
  %10 = memref.cast %9 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %11 = memref.alloca() : memref<1xmemref<?xf32>>
  %12 = memref.cast %11 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %13 = memref.alloca() : memref<1xmemref<?xf32>>
  %14 = memref.cast %13 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %15 = memref.alloca() : memref<1xmemref<?xf32>>
  %16 = memref.cast %15 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  memref.store %arg0, %16[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg1, %14[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg2, %12[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg3, %10[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg4, %8[%c0] : memref<?xi32>
  %17 = memref.alloca() : memref<i1>
  %18 = memref.alloca() : memref<i1>
  memref.store %true, %18[] : memref<i1>
  memref.store %true, %17[] : memref<i1>
  %19 = memref.load %17[] : memref<i1>
  scf.if %19 {
    %20 = memref.load %17[] : memref<i1>
    scf.if %20 {
      scf.execute_region {
        %21 = memref.load %17[] : memref<i1>
        scf.if %21 {
          scf.execute_region {
            %34 = memref.get_global @kbm3 : memref<1xi32>
            %35 = memref.cast %34 : memref<1xi32> to memref<?xi32>
            %36 = memref.load %35[%c0] : memref<?xi32>
            memref.store %36, %6[%c0] : memref<?xi32>
            scf.yield
          }
        }
        %22 = memref.alloca() : memref<i1>
        %23 = memref.alloca() : memref<i1>
        memref.store %true, %23[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %24 = memref.load %6[%c0] : memref<?xi32>
        %25 = arith.cmpi sgt, %24, %c0_i32 : i32
        %26 = arith.extsi %25 : i1 to i32
        %27 = arith.cmpi ne, %26, %c0_i32 : i32
        %28 = memref.load %23[] : memref<i1>
        %29 = arith.andi %27, %28 : i1
        cf.cond_br %29, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %30 = memref.load %23[] : memref<i1>
        memref.store %30, %22[] : memref<i1>
        %31 = memref.load %22[] : memref<i1>
        scf.if %31 {
          %34 = memref.load %22[] : memref<i1>
          scf.if %34 {
            scf.execute_region {
              %35 = memref.load %22[] : memref<i1>
              scf.if %35 {
                scf.execute_region {
                  memref.store %c0_i32, %4[%c0] : memref<?xi32>
                  scf.yield
                }
              }
              %36 = memref.alloca() : memref<i1>
              %37 = memref.alloca() : memref<i1>
              memref.store %true, %37[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %38 = memref.load %4[%c0] : memref<?xi32>
              %39 = memref.get_global @jm : memref<1xi32>
              %40 = memref.cast %39 : memref<1xi32> to memref<?xi32>
              %41 = memref.load %40[%c0] : memref<?xi32>
              %42 = arith.cmpi slt, %38, %41 : i32
              %43 = arith.extsi %42 : i1 to i32
              %44 = arith.cmpi ne, %43, %c0_i32 : i32
              %45 = memref.load %37[] : memref<i1>
              %46 = arith.andi %44, %45 : i1
              cf.cond_br %46, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %47 = memref.load %37[] : memref<i1>
              memref.store %47, %36[] : memref<i1>
              %48 = memref.load %36[] : memref<i1>
              scf.if %48 {
                %51 = memref.load %36[] : memref<i1>
                scf.if %51 {
                  scf.execute_region {
                    %52 = memref.load %36[] : memref<i1>
                    scf.if %52 {
                      scf.execute_region {
                        memref.store %c0_i32, %1[%c0] : memref<?xi32>
                        scf.yield
                      }
                    }
                    %53 = memref.alloca() : memref<i1>
                    %54 = memref.alloca() : memref<i1>
                    memref.store %true, %54[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %55 = memref.load %1[%c0] : memref<?xi32>
                    %56 = memref.get_global @im : memref<1xi32>
                    %57 = memref.cast %56 : memref<1xi32> to memref<?xi32>
                    %58 = memref.load %57[%c0] : memref<?xi32>
                    %59 = arith.cmpi slt, %55, %58 : i32
                    %60 = arith.extsi %59 : i1 to i32
                    %61 = arith.cmpi ne, %60, %c0_i32 : i32
                    %62 = memref.load %54[] : memref<i1>
                    %63 = arith.andi %61, %62 : i1
                    cf.cond_br %63, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %64 = memref.load %54[] : memref<i1>
                    memref.store %64, %53[] : memref<i1>
                    %65 = memref.load %53[] : memref<i1>
                    scf.if %65 {
                      scf.execute_region {
                        %68 = memref.load %12[%c0] : memref<?xmemref<?xf32>>
                        %69 = memref.load %1[%c0] : memref<?xi32>
                        %70 = memref.load %4[%c0] : memref<?xi32>
                        %71 = memref.load %57[%c0] : memref<?xi32>
                        %72 = arith.muli %70, %71 : i32
                        %73 = arith.addi %69, %72 : i32
                        %74 = memref.load %6[%c0] : memref<?xi32>
                        %75 = arith.muli %74, %71 : i32
                        %76 = memref.load %40[%c0] : memref<?xi32>
                        %77 = arith.muli %75, %76 : i32
                        %78 = arith.addi %73, %77 : i32
                        %79 = arith.index_cast %78 : i32 to index
                        %80 = "polygeist.subindex"(%68, %79) : (memref<?xf32>, index) -> memref<?xf32>
                        %81 = "polygeist.subindex"(%80, %c0) : (memref<?xf32>, index) -> memref<?xf32>
                        %82 = memref.load %16[%c0] : memref<?xmemref<?xf32>>
                        %83 = arith.subi %74, %c1_i32 : i32
                        %84 = arith.muli %83, %71 : i32
                        %85 = arith.muli %84, %76 : i32
                        %86 = arith.addi %73, %85 : i32
                        %87 = arith.index_cast %86 : i32 to index
                        %88 = "polygeist.subindex"(%82, %87) : (memref<?xf32>, index) -> memref<?xf32>
                        %89 = "polygeist.subindex"(%88, %c0) : (memref<?xf32>, index) -> memref<?xf32>
                        %90 = memref.load %89[%c0] : memref<?xf32>
                        memref.store %90, %81[%c0] : memref<?xf32>
                        scf.yield
                      }
                    }
                    %66 = memref.load %54[] : memref<i1>
                    memref.store %66, %53[] : memref<i1>
                    %67 = memref.load %53[] : memref<i1>
                    scf.if %67 {
                      scf.execute_region {
                        %68 = memref.load %1[%c0] : memref<?xi32>
                        %69 = arith.addi %68, %c1_i32 : i32
                        memref.store %69, %1[%c0] : memref<?xi32>
                        scf.yield
                      }
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %49 = memref.load %37[] : memref<i1>
              memref.store %49, %36[] : memref<i1>
              %50 = memref.load %36[] : memref<i1>
              scf.if %50 {
                %51 = memref.load %3[%c0] : memref<1xi32>
                %52 = arith.addi %51, %c1_i32 : i32
                memref.store %52, %3[%c0] : memref<1xi32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %32 = memref.load %23[] : memref<i1>
        memref.store %32, %22[] : memref<i1>
        %33 = memref.load %22[] : memref<i1>
        scf.if %33 {
          %34 = memref.load %5[%c0] : memref<1xi32>
          %35 = arith.subi %34, %c1_i32 : i32
          memref.store %35, %5[%c0] : memref<1xi32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9816a5e0) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9816a590) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.execute_region'(0x7fbd9816a680) {

  * Pattern SingleBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "SingleBlockExecuteInliner"
"SingleBlockExecuteInliner" result 0
  } -> failure : pattern failed to match

  * Pattern MultiBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "MultiBlockExecuteInliner"
"MultiBlockExecuteInliner" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9800a830) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd98009270) {
  "cf.br"()[^bb1] : () -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd98305250) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd983051c0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.execute_region'(0x7fbd983052f0) {

  * Pattern SingleBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "SingleBlockExecuteInliner"
    ** Replace : 'scf.execute_region'(0x7fbd983052f0)
    ** Erase   : 'scf.yield'(0x7fbd98305680)
"SingleBlockExecuteInliner" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %true = arith.constant true
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<1xi32>
  %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
  memref.store %2, %4[%c0] : memref<?xi32>
  %5 = memref.alloca() : memref<1xi32>
  %6 = memref.cast %5 : memref<1xi32> to memref<?xi32>
  memref.store %2, %6[%c0] : memref<?xi32>
  %7 = memref.alloca() : memref<1xi32>
  %8 = memref.cast %7 : memref<1xi32> to memref<?xi32>
  memref.store %2, %8[%c0] : memref<?xi32>
  %9 = memref.alloca() : memref<1xmemref<?xf32>>
  %10 = memref.cast %9 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %11 = memref.alloca() : memref<1xmemref<?xf32>>
  %12 = memref.cast %11 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %13 = memref.alloca() : memref<1xmemref<?xf32>>
  %14 = memref.cast %13 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %15 = memref.alloca() : memref<1xmemref<?xf32>>
  %16 = memref.cast %15 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  memref.store %arg0, %16[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg1, %14[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg2, %12[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg3, %10[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg4, %8[%c0] : memref<?xi32>
  %17 = memref.alloca() : memref<i1>
  %18 = memref.alloca() : memref<i1>
  memref.store %true, %18[] : memref<i1>
  memref.store %true, %17[] : memref<i1>
  %19 = memref.load %17[] : memref<i1>
  scf.if %19 {
    %20 = memref.load %17[] : memref<i1>
    scf.if %20 {
      scf.execute_region {
        %21 = memref.load %17[] : memref<i1>
        scf.if %21 {
          scf.execute_region {
            %34 = memref.get_global @kbm3 : memref<1xi32>
            %35 = memref.cast %34 : memref<1xi32> to memref<?xi32>
            %36 = memref.load %35[%c0] : memref<?xi32>
            memref.store %36, %6[%c0] : memref<?xi32>
            scf.yield
          }
        }
        %22 = memref.alloca() : memref<i1>
        %23 = memref.alloca() : memref<i1>
        memref.store %true, %23[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %24 = memref.load %6[%c0] : memref<?xi32>
        %25 = arith.cmpi sgt, %24, %c0_i32 : i32
        %26 = arith.extsi %25 : i1 to i32
        %27 = arith.cmpi ne, %26, %c0_i32 : i32
        %28 = memref.load %23[] : memref<i1>
        %29 = arith.andi %27, %28 : i1
        cf.cond_br %29, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %30 = memref.load %23[] : memref<i1>
        memref.store %30, %22[] : memref<i1>
        %31 = memref.load %22[] : memref<i1>
        scf.if %31 {
          %34 = memref.load %22[] : memref<i1>
          scf.if %34 {
            scf.execute_region {
              %35 = memref.load %22[] : memref<i1>
              scf.if %35 {
                scf.execute_region {
                  memref.store %c0_i32, %4[%c0] : memref<?xi32>
                  scf.yield
                }
              }
              %36 = memref.alloca() : memref<i1>
              %37 = memref.alloca() : memref<i1>
              memref.store %true, %37[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %38 = memref.load %4[%c0] : memref<?xi32>
              %39 = memref.get_global @jm : memref<1xi32>
              %40 = memref.cast %39 : memref<1xi32> to memref<?xi32>
              %41 = memref.load %40[%c0] : memref<?xi32>
              %42 = arith.cmpi slt, %38, %41 : i32
              %43 = arith.extsi %42 : i1 to i32
              %44 = arith.cmpi ne, %43, %c0_i32 : i32
              %45 = memref.load %37[] : memref<i1>
              %46 = arith.andi %44, %45 : i1
              cf.cond_br %46, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %47 = memref.load %37[] : memref<i1>
              memref.store %47, %36[] : memref<i1>
              %48 = memref.load %36[] : memref<i1>
              scf.if %48 {
                %51 = memref.load %36[] : memref<i1>
                scf.if %51 {
                  scf.execute_region {
                    %52 = memref.load %36[] : memref<i1>
                    scf.if %52 {
                      scf.execute_region {
                        memref.store %c0_i32, %1[%c0] : memref<?xi32>
                        scf.yield
                      }
                    }
                    %53 = memref.alloca() : memref<i1>
                    %54 = memref.alloca() : memref<i1>
                    memref.store %true, %54[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %55 = memref.load %1[%c0] : memref<?xi32>
                    %56 = memref.get_global @im : memref<1xi32>
                    %57 = memref.cast %56 : memref<1xi32> to memref<?xi32>
                    %58 = memref.load %57[%c0] : memref<?xi32>
                    %59 = arith.cmpi slt, %55, %58 : i32
                    %60 = arith.extsi %59 : i1 to i32
                    %61 = arith.cmpi ne, %60, %c0_i32 : i32
                    %62 = memref.load %54[] : memref<i1>
                    %63 = arith.andi %61, %62 : i1
                    cf.cond_br %63, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %64 = memref.load %54[] : memref<i1>
                    memref.store %64, %53[] : memref<i1>
                    %65 = memref.load %53[] : memref<i1>
                    scf.if %65 {
                      scf.execute_region {
                        %68 = memref.load %12[%c0] : memref<?xmemref<?xf32>>
                        %69 = memref.load %1[%c0] : memref<?xi32>
                        %70 = memref.load %4[%c0] : memref<?xi32>
                        %71 = memref.load %57[%c0] : memref<?xi32>
                        %72 = arith.muli %70, %71 : i32
                        %73 = arith.addi %69, %72 : i32
                        %74 = memref.load %6[%c0] : memref<?xi32>
                        %75 = arith.muli %74, %71 : i32
                        %76 = memref.load %40[%c0] : memref<?xi32>
                        %77 = arith.muli %75, %76 : i32
                        %78 = arith.addi %73, %77 : i32
                        %79 = arith.index_cast %78 : i32 to index
                        %80 = "polygeist.subindex"(%68, %79) : (memref<?xf32>, index) -> memref<?xf32>
                        %81 = "polygeist.subindex"(%80, %c0) : (memref<?xf32>, index) -> memref<?xf32>
                        %82 = memref.load %16[%c0] : memref<?xmemref<?xf32>>
                        %83 = arith.subi %74, %c1_i32 : i32
                        %84 = arith.muli %83, %71 : i32
                        %85 = arith.muli %84, %76 : i32
                        %86 = arith.addi %73, %85 : i32
                        %87 = arith.index_cast %86 : i32 to index
                        %88 = "polygeist.subindex"(%82, %87) : (memref<?xf32>, index) -> memref<?xf32>
                        %89 = "polygeist.subindex"(%88, %c0) : (memref<?xf32>, index) -> memref<?xf32>
                        %90 = memref.load %89[%c0] : memref<?xf32>
                        memref.store %90, %81[%c0] : memref<?xf32>
                        scf.yield
                      }
                    }
                    %66 = memref.load %54[] : memref<i1>
                    memref.store %66, %53[] : memref<i1>
                    %67 = memref.load %53[] : memref<i1>
                    scf.if %67 {
                      %68 = memref.load %1[%c0] : memref<?xi32>
                      %69 = arith.addi %68, %c1_i32 : i32
                      memref.store %69, %1[%c0] : memref<?xi32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %49 = memref.load %37[] : memref<i1>
              memref.store %49, %36[] : memref<i1>
              %50 = memref.load %36[] : memref<i1>
              scf.if %50 {
                %51 = memref.load %3[%c0] : memref<1xi32>
                %52 = arith.addi %51, %c1_i32 : i32
                memref.store %52, %3[%c0] : memref<1xi32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %32 = memref.load %23[] : memref<i1>
        memref.store %32, %22[] : memref<i1>
        %33 = memref.load %22[] : memref<i1>
        scf.if %33 {
          %34 = memref.load %5[%c0] : memref<1xi32>
          %35 = arith.subi %34, %c1_i32 : i32
          memref.store %35, %5[%c0] : memref<1xi32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd983055d0) {
  "memref.store"(%73, %5, %3) : (i32, memref<?xi32>, index) -> ()

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %73 = "arith.addi"(%72, %0) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98305400) {
  %72 = "memref.load"(%5, %3) : (memref<?xi32>, index) -> i32

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match

* Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd983050e0) {
  %71 = "memref.load"(%57) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd98305040) {
  "memref.store"(%70, %57) : (i1, memref<i1>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98304fd0) {
  %70 = "memref.load"(%58) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9816bdc0) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9816bd70) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.execute_region'(0x7fbd9816be60) {

  * Pattern SingleBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "SingleBlockExecuteInliner"
    ** Replace : 'scf.execute_region'(0x7fbd9816be60)
    ** Erase   : 'scf.yield'(0x7fbd98304f70)
"SingleBlockExecuteInliner" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %true = arith.constant true
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<1xi32>
  %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
  memref.store %2, %4[%c0] : memref<?xi32>
  %5 = memref.alloca() : memref<1xi32>
  %6 = memref.cast %5 : memref<1xi32> to memref<?xi32>
  memref.store %2, %6[%c0] : memref<?xi32>
  %7 = memref.alloca() : memref<1xi32>
  %8 = memref.cast %7 : memref<1xi32> to memref<?xi32>
  memref.store %2, %8[%c0] : memref<?xi32>
  %9 = memref.alloca() : memref<1xmemref<?xf32>>
  %10 = memref.cast %9 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %11 = memref.alloca() : memref<1xmemref<?xf32>>
  %12 = memref.cast %11 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %13 = memref.alloca() : memref<1xmemref<?xf32>>
  %14 = memref.cast %13 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %15 = memref.alloca() : memref<1xmemref<?xf32>>
  %16 = memref.cast %15 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  memref.store %arg0, %16[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg1, %14[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg2, %12[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg3, %10[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg4, %8[%c0] : memref<?xi32>
  %17 = memref.alloca() : memref<i1>
  %18 = memref.alloca() : memref<i1>
  memref.store %true, %18[] : memref<i1>
  memref.store %true, %17[] : memref<i1>
  %19 = memref.load %17[] : memref<i1>
  scf.if %19 {
    %20 = memref.load %17[] : memref<i1>
    scf.if %20 {
      scf.execute_region {
        %21 = memref.load %17[] : memref<i1>
        scf.if %21 {
          scf.execute_region {
            %34 = memref.get_global @kbm3 : memref<1xi32>
            %35 = memref.cast %34 : memref<1xi32> to memref<?xi32>
            %36 = memref.load %35[%c0] : memref<?xi32>
            memref.store %36, %6[%c0] : memref<?xi32>
            scf.yield
          }
        }
        %22 = memref.alloca() : memref<i1>
        %23 = memref.alloca() : memref<i1>
        memref.store %true, %23[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %24 = memref.load %6[%c0] : memref<?xi32>
        %25 = arith.cmpi sgt, %24, %c0_i32 : i32
        %26 = arith.extsi %25 : i1 to i32
        %27 = arith.cmpi ne, %26, %c0_i32 : i32
        %28 = memref.load %23[] : memref<i1>
        %29 = arith.andi %27, %28 : i1
        cf.cond_br %29, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %30 = memref.load %23[] : memref<i1>
        memref.store %30, %22[] : memref<i1>
        %31 = memref.load %22[] : memref<i1>
        scf.if %31 {
          %34 = memref.load %22[] : memref<i1>
          scf.if %34 {
            scf.execute_region {
              %35 = memref.load %22[] : memref<i1>
              scf.if %35 {
                scf.execute_region {
                  memref.store %c0_i32, %4[%c0] : memref<?xi32>
                  scf.yield
                }
              }
              %36 = memref.alloca() : memref<i1>
              %37 = memref.alloca() : memref<i1>
              memref.store %true, %37[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %38 = memref.load %4[%c0] : memref<?xi32>
              %39 = memref.get_global @jm : memref<1xi32>
              %40 = memref.cast %39 : memref<1xi32> to memref<?xi32>
              %41 = memref.load %40[%c0] : memref<?xi32>
              %42 = arith.cmpi slt, %38, %41 : i32
              %43 = arith.extsi %42 : i1 to i32
              %44 = arith.cmpi ne, %43, %c0_i32 : i32
              %45 = memref.load %37[] : memref<i1>
              %46 = arith.andi %44, %45 : i1
              cf.cond_br %46, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %47 = memref.load %37[] : memref<i1>
              memref.store %47, %36[] : memref<i1>
              %48 = memref.load %36[] : memref<i1>
              scf.if %48 {
                %51 = memref.load %36[] : memref<i1>
                scf.if %51 {
                  scf.execute_region {
                    %52 = memref.load %36[] : memref<i1>
                    scf.if %52 {
                      scf.execute_region {
                        memref.store %c0_i32, %1[%c0] : memref<?xi32>
                        scf.yield
                      }
                    }
                    %53 = memref.alloca() : memref<i1>
                    %54 = memref.alloca() : memref<i1>
                    memref.store %true, %54[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %55 = memref.load %1[%c0] : memref<?xi32>
                    %56 = memref.get_global @im : memref<1xi32>
                    %57 = memref.cast %56 : memref<1xi32> to memref<?xi32>
                    %58 = memref.load %57[%c0] : memref<?xi32>
                    %59 = arith.cmpi slt, %55, %58 : i32
                    %60 = arith.extsi %59 : i1 to i32
                    %61 = arith.cmpi ne, %60, %c0_i32 : i32
                    %62 = memref.load %54[] : memref<i1>
                    %63 = arith.andi %61, %62 : i1
                    cf.cond_br %63, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %64 = memref.load %54[] : memref<i1>
                    memref.store %64, %53[] : memref<i1>
                    %65 = memref.load %53[] : memref<i1>
                    scf.if %65 {
                      %68 = memref.load %12[%c0] : memref<?xmemref<?xf32>>
                      %69 = memref.load %1[%c0] : memref<?xi32>
                      %70 = memref.load %4[%c0] : memref<?xi32>
                      %71 = memref.load %57[%c0] : memref<?xi32>
                      %72 = arith.muli %70, %71 : i32
                      %73 = arith.addi %69, %72 : i32
                      %74 = memref.load %6[%c0] : memref<?xi32>
                      %75 = arith.muli %74, %71 : i32
                      %76 = memref.load %40[%c0] : memref<?xi32>
                      %77 = arith.muli %75, %76 : i32
                      %78 = arith.addi %73, %77 : i32
                      %79 = arith.index_cast %78 : i32 to index
                      %80 = "polygeist.subindex"(%68, %79) : (memref<?xf32>, index) -> memref<?xf32>
                      %81 = "polygeist.subindex"(%80, %c0) : (memref<?xf32>, index) -> memref<?xf32>
                      %82 = memref.load %16[%c0] : memref<?xmemref<?xf32>>
                      %83 = arith.subi %74, %c1_i32 : i32
                      %84 = arith.muli %83, %71 : i32
                      %85 = arith.muli %84, %76 : i32
                      %86 = arith.addi %73, %85 : i32
                      %87 = arith.index_cast %86 : i32 to index
                      %88 = "polygeist.subindex"(%82, %87) : (memref<?xf32>, index) -> memref<?xf32>
                      %89 = "polygeist.subindex"(%88, %c0) : (memref<?xf32>, index) -> memref<?xf32>
                      %90 = memref.load %89[%c0] : memref<?xf32>
                      memref.store %90, %81[%c0] : memref<?xf32>
                    }
                    %66 = memref.load %54[] : memref<i1>
                    memref.store %66, %53[] : memref<i1>
                    %67 = memref.load %53[] : memref<i1>
                    scf.if %67 {
                      %68 = memref.load %0[%c0] : memref<1xi32>
                      %69 = arith.addi %68, %c1_i32 : i32
                      memref.store %69, %0[%c0] : memref<1xi32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %49 = memref.load %37[] : memref<i1>
              memref.store %49, %36[] : memref<i1>
              %50 = memref.load %36[] : memref<i1>
              scf.if %50 {
                %51 = memref.load %3[%c0] : memref<1xi32>
                %52 = arith.addi %51, %c1_i32 : i32
                memref.store %52, %3[%c0] : memref<1xi32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %32 = memref.load %23[] : memref<i1>
        memref.store %32, %22[] : memref<i1>
        %33 = memref.load %22[] : memref<i1>
        scf.if %33 {
          %34 = memref.load %5[%c0] : memref<1xi32>
          %35 = arith.subi %34, %c1_i32 : i32
          memref.store %35, %5[%c0] : memref<1xi32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd98304ec0) {
  "memref.store"(%94, %85, %3) : (f32, memref<?xf32>, index) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98304de0) {
  %94 = "memref.load"(%93, %3) : (memref<?xf32>, index) -> f32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'polygeist.subindex'(0x7fbd98304cf0) {
  %93 = "polygeist.subindex"(%92, %3) : (memref<?xf32>, index) -> memref<?xf32>

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98304de0) {
  %93 = "memref.load"(%92, %3) : (memref<?xf32>, index) -> f32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'polygeist.subindex'(0x7fbd98304c50) {
  %92 = "polygeist.subindex"(%86, %91) : (memref<?xf32>, index) -> memref<?xf32>


  * Pattern SubIndex2 : 'polygeist.subindex -> ()' {
Trying to match "SubIndex2"
"SubIndex2" result 0
  } -> failure : pattern failed to match

  * Pattern SubToCast : 'polygeist.subindex -> ()' {
Trying to match "SubToCast"
"SubToCast" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifySubIndexUsers : 'polygeist.subindex -> ()' {
Trying to match "SimplifySubIndexUsers"
    ** Insert  : 'arith.addi'(0x7fbd9b0040e0)
    ** Insert  : 'memref.load'(0x7fbd9b004180)
    ** Replace : 'memref.load'(0x7fbd98304de0)
"SimplifySubIndexUsers" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %true = arith.constant true
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<1xi32>
  %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
  memref.store %2, %4[%c0] : memref<?xi32>
  %5 = memref.alloca() : memref<1xi32>
  %6 = memref.cast %5 : memref<1xi32> to memref<?xi32>
  memref.store %2, %6[%c0] : memref<?xi32>
  %7 = memref.alloca() : memref<1xi32>
  %8 = memref.cast %7 : memref<1xi32> to memref<?xi32>
  memref.store %2, %8[%c0] : memref<?xi32>
  %9 = memref.alloca() : memref<1xmemref<?xf32>>
  %10 = memref.cast %9 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %11 = memref.alloca() : memref<1xmemref<?xf32>>
  %12 = memref.cast %11 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %13 = memref.alloca() : memref<1xmemref<?xf32>>
  %14 = memref.cast %13 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %15 = memref.alloca() : memref<1xmemref<?xf32>>
  %16 = memref.cast %15 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  memref.store %arg0, %16[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg1, %14[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg2, %12[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg3, %10[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg4, %8[%c0] : memref<?xi32>
  %17 = memref.alloca() : memref<i1>
  %18 = memref.alloca() : memref<i1>
  memref.store %true, %18[] : memref<i1>
  memref.store %true, %17[] : memref<i1>
  %19 = memref.load %17[] : memref<i1>
  scf.if %19 {
    %20 = memref.load %17[] : memref<i1>
    scf.if %20 {
      scf.execute_region {
        %21 = memref.load %17[] : memref<i1>
        scf.if %21 {
          scf.execute_region {
            %34 = memref.get_global @kbm3 : memref<1xi32>
            %35 = memref.cast %34 : memref<1xi32> to memref<?xi32>
            %36 = memref.load %35[%c0] : memref<?xi32>
            memref.store %36, %6[%c0] : memref<?xi32>
            scf.yield
          }
        }
        %22 = memref.alloca() : memref<i1>
        %23 = memref.alloca() : memref<i1>
        memref.store %true, %23[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %24 = memref.load %6[%c0] : memref<?xi32>
        %25 = arith.cmpi sgt, %24, %c0_i32 : i32
        %26 = arith.extsi %25 : i1 to i32
        %27 = arith.cmpi ne, %26, %c0_i32 : i32
        %28 = memref.load %23[] : memref<i1>
        %29 = arith.andi %27, %28 : i1
        cf.cond_br %29, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %30 = memref.load %23[] : memref<i1>
        memref.store %30, %22[] : memref<i1>
        %31 = memref.load %22[] : memref<i1>
        scf.if %31 {
          %34 = memref.load %22[] : memref<i1>
          scf.if %34 {
            scf.execute_region {
              %35 = memref.load %22[] : memref<i1>
              scf.if %35 {
                scf.execute_region {
                  memref.store %c0_i32, %4[%c0] : memref<?xi32>
                  scf.yield
                }
              }
              %36 = memref.alloca() : memref<i1>
              %37 = memref.alloca() : memref<i1>
              memref.store %true, %37[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %38 = memref.load %4[%c0] : memref<?xi32>
              %39 = memref.get_global @jm : memref<1xi32>
              %40 = memref.cast %39 : memref<1xi32> to memref<?xi32>
              %41 = memref.load %40[%c0] : memref<?xi32>
              %42 = arith.cmpi slt, %38, %41 : i32
              %43 = arith.extsi %42 : i1 to i32
              %44 = arith.cmpi ne, %43, %c0_i32 : i32
              %45 = memref.load %37[] : memref<i1>
              %46 = arith.andi %44, %45 : i1
              cf.cond_br %46, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %47 = memref.load %37[] : memref<i1>
              memref.store %47, %36[] : memref<i1>
              %48 = memref.load %36[] : memref<i1>
              scf.if %48 {
                %51 = memref.load %36[] : memref<i1>
                scf.if %51 {
                  scf.execute_region {
                    %52 = memref.load %36[] : memref<i1>
                    scf.if %52 {
                      scf.execute_region {
                        memref.store %c0_i32, %1[%c0] : memref<?xi32>
                        scf.yield
                      }
                    }
                    %53 = memref.alloca() : memref<i1>
                    %54 = memref.alloca() : memref<i1>
                    memref.store %true, %54[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %55 = memref.load %1[%c0] : memref<?xi32>
                    %56 = memref.get_global @im : memref<1xi32>
                    %57 = memref.cast %56 : memref<1xi32> to memref<?xi32>
                    %58 = memref.load %57[%c0] : memref<?xi32>
                    %59 = arith.cmpi slt, %55, %58 : i32
                    %60 = arith.extsi %59 : i1 to i32
                    %61 = arith.cmpi ne, %60, %c0_i32 : i32
                    %62 = memref.load %54[] : memref<i1>
                    %63 = arith.andi %61, %62 : i1
                    cf.cond_br %63, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %64 = memref.load %54[] : memref<i1>
                    memref.store %64, %53[] : memref<i1>
                    %65 = memref.load %53[] : memref<i1>
                    scf.if %65 {
                      %68 = memref.load %12[%c0] : memref<?xmemref<?xf32>>
                      %69 = memref.load %1[%c0] : memref<?xi32>
                      %70 = memref.load %4[%c0] : memref<?xi32>
                      %71 = memref.load %57[%c0] : memref<?xi32>
                      %72 = arith.muli %70, %71 : i32
                      %73 = arith.addi %69, %72 : i32
                      %74 = memref.load %6[%c0] : memref<?xi32>
                      %75 = arith.muli %74, %71 : i32
                      %76 = memref.load %40[%c0] : memref<?xi32>
                      %77 = arith.muli %75, %76 : i32
                      %78 = arith.addi %73, %77 : i32
                      %79 = arith.index_cast %78 : i32 to index
                      %80 = "polygeist.subindex"(%68, %79) : (memref<?xf32>, index) -> memref<?xf32>
                      %81 = "polygeist.subindex"(%80, %c0) : (memref<?xf32>, index) -> memref<?xf32>
                      %82 = memref.load %16[%c0] : memref<?xmemref<?xf32>>
                      %83 = arith.subi %74, %c1_i32 : i32
                      %84 = arith.muli %83, %71 : i32
                      %85 = arith.muli %84, %76 : i32
                      %86 = arith.addi %73, %85 : i32
                      %87 = arith.index_cast %86 : i32 to index
                      %88 = "polygeist.subindex"(%82, %87) : (memref<?xf32>, index) -> memref<?xf32>
                      %89 = arith.addi %c0, %87 : index
                      %90 = memref.load %82[%89] : memref<?xf32>
                      memref.store %90, %81[%c0] : memref<?xf32>
                    }
                    %66 = memref.load %54[] : memref<i1>
                    memref.store %66, %53[] : memref<i1>
                    %67 = memref.load %53[] : memref<i1>
                    scf.if %67 {
                      %68 = memref.load %0[%c0] : memref<1xi32>
                      %69 = arith.addi %68, %c1_i32 : i32
                      memref.store %69, %0[%c0] : memref<1xi32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %49 = memref.load %37[] : memref<i1>
              memref.store %49, %36[] : memref<i1>
              %50 = memref.load %36[] : memref<i1>
              scf.if %50 {
                %51 = memref.load %3[%c0] : memref<1xi32>
                %52 = arith.addi %51, %c1_i32 : i32
                memref.store %52, %3[%c0] : memref<1xi32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %32 = memref.load %23[] : memref<i1>
        memref.store %32, %22[] : memref<i1>
        %33 = memref.load %22[] : memref<i1>
        scf.if %33 {
          %34 = memref.load %5[%c0] : memref<1xi32>
          %35 = arith.subi %34, %c1_i32 : i32
          memref.store %35, %5[%c0] : memref<1xi32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'polygeist.subindex'(0x7fbd98304c50) {
  %92 = "polygeist.subindex"(%86, %91) : (memref<?xf32>, index) -> memref<?xf32>

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd98304ec0) {
  "memref.store"(%93, %85, %3) : (f32, memref<?xf32>, index) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %93 = "memref.load"(%86, %92) : (memref<?xf32>, index) -> f32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b0040e0) {
  %92 = "arith.addi"(%3, %91) : (index, index) -> index

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
  ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
} -> failure : pattern failed to match

* Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
  ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
} -> failure : pattern failed to match

* Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
  ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd98304bd0) {
  %91 = "arith.index_cast"(%90) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98304b30) {
  %90 = "arith.addi"(%77, %89) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304a90) {
  %89 = "arith.muli"(%88, %80) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %88 = "arith.muli"(%87, %75) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd983045d0) {
  %87 = "arith.subi"(%78, %0) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98304580) {
  %0 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816cdd0) {
  %86 = "memref.load"(%20, %3) : (memref<?xmemref<?xf32>>, index) -> memref<?xf32>

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match

* Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'polygeist.subindex'(0x7fbd9816cce0) {
  %85 = "polygeist.subindex"(%84, %3) : (memref<?xf32>, index) -> memref<?xf32>

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd98304ec0) {
  "memref.store"(%92, %84, %3) : (f32, memref<?xf32>, index) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'polygeist.subindex'(0x7fbd9816cbc0) {
  %84 = "polygeist.subindex"(%72, %83) : (memref<?xf32>, index) -> memref<?xf32>


  * Pattern SubIndex2 : 'polygeist.subindex -> ()' {
Trying to match "SubIndex2"
"SubIndex2" result 0
  } -> failure : pattern failed to match

  * Pattern SubToCast : 'polygeist.subindex -> ()' {
Trying to match "SubToCast"
"SubToCast" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifySubIndexUsers : 'polygeist.subindex -> ()' {
Trying to match "SimplifySubIndexUsers"
    ** Insert  : 'arith.addi'(0x7fbd98165e60)
    ** Insert  : 'memref.store'(0x7fbd9816a410)
    ** Replace : 'memref.store'(0x7fbd98304ec0)
"SimplifySubIndexUsers" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %true = arith.constant true
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<1xi32>
  %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
  memref.store %2, %4[%c0] : memref<?xi32>
  %5 = memref.alloca() : memref<1xi32>
  %6 = memref.cast %5 : memref<1xi32> to memref<?xi32>
  memref.store %2, %6[%c0] : memref<?xi32>
  %7 = memref.alloca() : memref<1xi32>
  %8 = memref.cast %7 : memref<1xi32> to memref<?xi32>
  memref.store %2, %8[%c0] : memref<?xi32>
  %9 = memref.alloca() : memref<1xmemref<?xf32>>
  %10 = memref.cast %9 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %11 = memref.alloca() : memref<1xmemref<?xf32>>
  %12 = memref.cast %11 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %13 = memref.alloca() : memref<1xmemref<?xf32>>
  %14 = memref.cast %13 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %15 = memref.alloca() : memref<1xmemref<?xf32>>
  %16 = memref.cast %15 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  memref.store %arg0, %16[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg1, %14[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg2, %12[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg3, %10[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg4, %8[%c0] : memref<?xi32>
  %17 = memref.alloca() : memref<i1>
  %18 = memref.alloca() : memref<i1>
  memref.store %true, %18[] : memref<i1>
  memref.store %true, %17[] : memref<i1>
  %19 = memref.load %17[] : memref<i1>
  scf.if %19 {
    %20 = memref.load %17[] : memref<i1>
    scf.if %20 {
      scf.execute_region {
        %21 = memref.load %17[] : memref<i1>
        scf.if %21 {
          scf.execute_region {
            %34 = memref.get_global @kbm3 : memref<1xi32>
            %35 = memref.cast %34 : memref<1xi32> to memref<?xi32>
            %36 = memref.load %35[%c0] : memref<?xi32>
            memref.store %36, %6[%c0] : memref<?xi32>
            scf.yield
          }
        }
        %22 = memref.alloca() : memref<i1>
        %23 = memref.alloca() : memref<i1>
        memref.store %true, %23[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %24 = memref.load %6[%c0] : memref<?xi32>
        %25 = arith.cmpi sgt, %24, %c0_i32 : i32
        %26 = arith.extsi %25 : i1 to i32
        %27 = arith.cmpi ne, %26, %c0_i32 : i32
        %28 = memref.load %23[] : memref<i1>
        %29 = arith.andi %27, %28 : i1
        cf.cond_br %29, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %30 = memref.load %23[] : memref<i1>
        memref.store %30, %22[] : memref<i1>
        %31 = memref.load %22[] : memref<i1>
        scf.if %31 {
          %34 = memref.load %22[] : memref<i1>
          scf.if %34 {
            scf.execute_region {
              %35 = memref.load %22[] : memref<i1>
              scf.if %35 {
                scf.execute_region {
                  memref.store %c0_i32, %4[%c0] : memref<?xi32>
                  scf.yield
                }
              }
              %36 = memref.alloca() : memref<i1>
              %37 = memref.alloca() : memref<i1>
              memref.store %true, %37[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %38 = memref.load %4[%c0] : memref<?xi32>
              %39 = memref.get_global @jm : memref<1xi32>
              %40 = memref.cast %39 : memref<1xi32> to memref<?xi32>
              %41 = memref.load %40[%c0] : memref<?xi32>
              %42 = arith.cmpi slt, %38, %41 : i32
              %43 = arith.extsi %42 : i1 to i32
              %44 = arith.cmpi ne, %43, %c0_i32 : i32
              %45 = memref.load %37[] : memref<i1>
              %46 = arith.andi %44, %45 : i1
              cf.cond_br %46, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %47 = memref.load %37[] : memref<i1>
              memref.store %47, %36[] : memref<i1>
              %48 = memref.load %36[] : memref<i1>
              scf.if %48 {
                %51 = memref.load %36[] : memref<i1>
                scf.if %51 {
                  scf.execute_region {
                    %52 = memref.load %36[] : memref<i1>
                    scf.if %52 {
                      scf.execute_region {
                        memref.store %c0_i32, %1[%c0] : memref<?xi32>
                        scf.yield
                      }
                    }
                    %53 = memref.alloca() : memref<i1>
                    %54 = memref.alloca() : memref<i1>
                    memref.store %true, %54[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %55 = memref.load %1[%c0] : memref<?xi32>
                    %56 = memref.get_global @im : memref<1xi32>
                    %57 = memref.cast %56 : memref<1xi32> to memref<?xi32>
                    %58 = memref.load %57[%c0] : memref<?xi32>
                    %59 = arith.cmpi slt, %55, %58 : i32
                    %60 = arith.extsi %59 : i1 to i32
                    %61 = arith.cmpi ne, %60, %c0_i32 : i32
                    %62 = memref.load %54[] : memref<i1>
                    %63 = arith.andi %61, %62 : i1
                    cf.cond_br %63, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %64 = memref.load %54[] : memref<i1>
                    memref.store %64, %53[] : memref<i1>
                    %65 = memref.load %53[] : memref<i1>
                    scf.if %65 {
                      %68 = memref.load %12[%c0] : memref<?xmemref<?xf32>>
                      %69 = memref.load %1[%c0] : memref<?xi32>
                      %70 = memref.load %4[%c0] : memref<?xi32>
                      %71 = memref.load %57[%c0] : memref<?xi32>
                      %72 = arith.muli %70, %71 : i32
                      %73 = arith.addi %69, %72 : i32
                      %74 = memref.load %6[%c0] : memref<?xi32>
                      %75 = arith.muli %74, %71 : i32
                      %76 = memref.load %40[%c0] : memref<?xi32>
                      %77 = arith.muli %75, %76 : i32
                      %78 = arith.addi %73, %77 : i32
                      %79 = arith.index_cast %78 : i32 to index
                      %80 = "polygeist.subindex"(%68, %79) : (memref<?xf32>, index) -> memref<?xf32>
                      %81 = memref.load %15[%c0] : memref<1xmemref<?xf32>>
                      %82 = arith.subi %74, %c1_i32 : i32
                      %83 = arith.muli %82, %71 : i32
                      %84 = arith.muli %83, %76 : i32
                      %85 = arith.addi %73, %84 : i32
                      %86 = arith.index_cast %85 : i32 to index
                      %87 = arith.addi %86, %c0 : index
                      %88 = memref.load %81[%87] : memref<?xf32>
                      %89 = arith.addi %c0, %79 : index
                      memref.store %88, %68[%89] : memref<?xf32>
                    }
                    %66 = memref.load %54[] : memref<i1>
                    memref.store %66, %53[] : memref<i1>
                    %67 = memref.load %53[] : memref<i1>
                    scf.if %67 {
                      %68 = memref.load %0[%c0] : memref<1xi32>
                      %69 = arith.addi %68, %c1_i32 : i32
                      memref.store %69, %0[%c0] : memref<1xi32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %49 = memref.load %37[] : memref<i1>
              memref.store %49, %36[] : memref<i1>
              %50 = memref.load %36[] : memref<i1>
              scf.if %50 {
                %51 = memref.load %3[%c0] : memref<1xi32>
                %52 = arith.addi %51, %c1_i32 : i32
                memref.store %52, %3[%c0] : memref<1xi32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %32 = memref.load %23[] : memref<i1>
        memref.store %32, %22[] : memref<i1>
        %33 = memref.load %22[] : memref<i1>
        scf.if %33 {
          %34 = memref.load %5[%c0] : memref<1xi32>
          %35 = arith.subi %34, %c1_i32 : i32
          memref.store %35, %5[%c0] : memref<1xi32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'polygeist.subindex'(0x7fbd9816cbc0) {
  %84 = "polygeist.subindex"(%72, %83) : (memref<?xf32>, index) -> memref<?xf32>

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%91, %72, %92) : (f32, memref<?xf32>, index) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98165e60) {
  %92 = "arith.addi"(%3, %83) : (index, index) -> index

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
  ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
} -> failure : pattern failed to match

* Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
  ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
} -> failure : pattern failed to match

* Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
  ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9816cb40) {
  %83 = "arith.index_cast"(%82) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816caa0) {
  %82 = "arith.addi"(%77, %81) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816ca00) {
  %81 = "arith.muli"(%79, %80) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816c960) {
  %80 = "memref.load"(%44, %3) : (memref<?xi32>, index) -> i32

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match

* Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %79 = "arith.muli"(%78, %75) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816c540) {
  %78 = "memref.load"(%10, %3) : (memref<?xi32>, index) -> i32

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match

* Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %77 = "arith.addi"(%73, %76) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %76 = "arith.muli"(%74, %75) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816c310) {
  %75 = "memref.load"(%61, %3) : (memref<?xi32>, index) -> i32

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match

* Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816c150) {
  %74 = "memref.load"(%8, %3) : (memref<?xi32>, index) -> i32

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match

* Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816c060) {
  %73 = "memref.load"(%5, %3) : (memref<?xi32>, index) -> i32

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match

* Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816bf70) {
  %72 = "memref.load"(%16, %3) : (memref<?xmemref<?xf32>>, index) -> memref<?xf32>

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match

* Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816bcb0) {
  %69 = "memref.load"(%57) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816bc10) {
  "memref.store"(%68, %57) : (i1, memref<i1>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816bba0) {
  %68 = "memref.load"(%58) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd9816bae0) {
  "cf.cond_br"(%67)[^bb2, ^bb3] {operand_segment_sizes = array<i32: 1, 0, 0>} : (i1) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors"
"(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition"
"(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CondBranchTruthPropagation : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::CondBranchTruthPropagation"
"(anonymous namespace)::CondBranchTruthPropagation" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.andi'(0x7fbd9816ba50) {
  %67 = "arith.andi"(%65, %66) : (i1, i1) -> i1


  * Pattern (anonymous namespace)::AndOfExtUI : 'arith.andi -> (arith.andi, arith.extui)' {
Trying to match "(anonymous namespace)::AndOfExtUI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtUIOp type
"(anonymous namespace)::AndOfExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AndOfExtSI : 'arith.andi -> (arith.andi, arith.extsi)' {
Trying to match "(anonymous namespace)::AndOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::AndOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816b9d0) {
  %66 = "memref.load"(%58) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b930) {
  %65 = "arith.cmpi"(%64, %1) {predicate = 1 : i64} : (i32, i32) -> i1

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.andi'(0x7fbd9816ba50) {
  %66 = "arith.andi"(%63, %65) : (i1, i1) -> i1


  * Pattern (anonymous namespace)::AndOfExtUI : 'arith.andi -> (arith.andi, arith.extui)' {
Trying to match "(anonymous namespace)::AndOfExtUI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtUIOp type
"(anonymous namespace)::AndOfExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AndOfExtSI : 'arith.andi -> (arith.andi, arith.extsi)' {
Trying to match "(anonymous namespace)::AndOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::AndOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.extsi'(0x7fbd9816b860) {
  %64 = "arith.extsi"(%63) : (i1) -> i32

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %63 = "arith.cmpi"(%59, %62) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtUIOp type
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816b720) {
  %62 = "memref.load"(%61, %3) : (memref<?xi32>, index) -> i32

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match

* Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.cast'(0x7fbd9816b650) {
  %61 = "memref.cast"(%60) : (memref<1xi32>) -> memref<?xi32>

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9816b600) {
  %60 = "memref.get_global"() {name = @im} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816b3a0) {
  %59 = "memref.load"(%5, %3) : (memref<?xi32>, index) -> i32

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match

* Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9816b2d0) {
  "cf.br"()[^bb1] : () -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816b150) {
  "memref.store"(%2, %58) : (i1, memref<i1>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd9816b100) {
  %58 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<i1>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%54 = memref.alloca() : memref<i1>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %true, %54[] : memref<i1>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd9816b0a0) {
  %57 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<i1>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%53 = memref.alloca() : memref<i1>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %63, %53[] : memref<i1>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9816a880) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9816a830) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.execute_region'(0x7fbd9816a920) {

  * Pattern SingleBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "SingleBlockExecuteInliner"
    ** Replace : 'scf.execute_region'(0x7fbd9816a920)
    ** Erase   : 'scf.yield'(0x7fbd9816aff0)
"SingleBlockExecuteInliner" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %true = arith.constant true
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<1xi32>
  %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
  memref.store %2, %4[%c0] : memref<?xi32>
  %5 = memref.alloca() : memref<1xi32>
  %6 = memref.cast %5 : memref<1xi32> to memref<?xi32>
  memref.store %2, %6[%c0] : memref<?xi32>
  %7 = memref.alloca() : memref<1xi32>
  %8 = memref.cast %7 : memref<1xi32> to memref<?xi32>
  memref.store %2, %8[%c0] : memref<?xi32>
  %9 = memref.alloca() : memref<1xmemref<?xf32>>
  %10 = memref.cast %9 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %11 = memref.alloca() : memref<1xmemref<?xf32>>
  %12 = memref.cast %11 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %13 = memref.alloca() : memref<1xmemref<?xf32>>
  %14 = memref.cast %13 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %15 = memref.alloca() : memref<1xmemref<?xf32>>
  %16 = memref.cast %15 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  memref.store %arg0, %16[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg1, %14[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg2, %12[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg3, %10[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg4, %8[%c0] : memref<?xi32>
  %17 = memref.alloca() : memref<i1>
  %18 = memref.alloca() : memref<i1>
  memref.store %true, %18[] : memref<i1>
  memref.store %true, %17[] : memref<i1>
  %19 = memref.load %17[] : memref<i1>
  scf.if %19 {
    %20 = memref.load %17[] : memref<i1>
    scf.if %20 {
      scf.execute_region {
        %21 = memref.load %17[] : memref<i1>
        scf.if %21 {
          scf.execute_region {
            %34 = memref.get_global @kbm3 : memref<1xi32>
            %35 = memref.cast %34 : memref<1xi32> to memref<?xi32>
            %36 = memref.load %35[%c0] : memref<?xi32>
            memref.store %36, %6[%c0] : memref<?xi32>
            scf.yield
          }
        }
        %22 = memref.alloca() : memref<i1>
        %23 = memref.alloca() : memref<i1>
        memref.store %true, %23[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %24 = memref.load %6[%c0] : memref<?xi32>
        %25 = arith.cmpi sgt, %24, %c0_i32 : i32
        %26 = arith.extsi %25 : i1 to i32
        %27 = arith.cmpi ne, %26, %c0_i32 : i32
        %28 = memref.load %23[] : memref<i1>
        %29 = arith.andi %27, %28 : i1
        cf.cond_br %29, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %30 = memref.load %23[] : memref<i1>
        memref.store %30, %22[] : memref<i1>
        %31 = memref.load %22[] : memref<i1>
        scf.if %31 {
          %34 = memref.load %22[] : memref<i1>
          scf.if %34 {
            scf.execute_region {
              %35 = memref.load %22[] : memref<i1>
              scf.if %35 {
                scf.execute_region {
                  memref.store %c0_i32, %4[%c0] : memref<?xi32>
                  scf.yield
                }
              }
              %36 = memref.alloca() : memref<i1>
              %37 = memref.alloca() : memref<i1>
              memref.store %true, %37[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %38 = memref.load %4[%c0] : memref<?xi32>
              %39 = memref.get_global @jm : memref<1xi32>
              %40 = memref.cast %39 : memref<1xi32> to memref<?xi32>
              %41 = memref.load %40[%c0] : memref<?xi32>
              %42 = arith.cmpi slt, %38, %41 : i32
              %43 = arith.extsi %42 : i1 to i32
              %44 = arith.cmpi ne, %43, %c0_i32 : i32
              %45 = memref.load %37[] : memref<i1>
              %46 = arith.andi %44, %45 : i1
              cf.cond_br %46, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %47 = memref.load %37[] : memref<i1>
              memref.store %47, %36[] : memref<i1>
              %48 = memref.load %36[] : memref<i1>
              scf.if %48 {
                %51 = memref.load %36[] : memref<i1>
                scf.if %51 {
                  scf.execute_region {
                    %52 = memref.load %36[] : memref<i1>
                    scf.if %52 {
                      memref.store %c0_i32, %1[%c0] : memref<?xi32>
                    }
                    %53 = memref.alloca() : memref<i1>
                    %54 = memref.alloca() : memref<i1>
                    memref.store %true, %54[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %55 = memref.load %0[%c0] : memref<1xi32>
                    %56 = memref.get_global @im : memref<1xi32>
                    %57 = memref.load %56[%c0] : memref<1xi32>
                    %58 = arith.cmpi slt, %55, %57 : i32
                    %59 = memref.load %54[] : memref<i1>
                    %60 = arith.andi %58, %59 : i1
                    cf.cond_br %60, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %61 = memref.load %54[] : memref<i1>
                    memref.store %61, %53[] : memref<i1>
                    %62 = memref.load %53[] : memref<i1>
                    scf.if %62 {
                      %65 = memref.load %11[%c0] : memref<1xmemref<?xf32>>
                      %66 = memref.load %0[%c0] : memref<1xi32>
                      %67 = memref.load %3[%c0] : memref<1xi32>
                      %68 = memref.load %56[%c0] : memref<1xi32>
                      %69 = arith.muli %67, %68 : i32
                      %70 = arith.addi %66, %69 : i32
                      %71 = memref.load %5[%c0] : memref<1xi32>
                      %72 = arith.muli %71, %68 : i32
                      %73 = memref.load %39[%c0] : memref<1xi32>
                      %74 = arith.muli %72, %73 : i32
                      %75 = arith.addi %70, %74 : i32
                      %76 = arith.index_cast %75 : i32 to index
                      %77 = memref.load %15[%c0] : memref<1xmemref<?xf32>>
                      %78 = arith.subi %71, %c1_i32 : i32
                      %79 = arith.muli %78, %68 : i32
                      %80 = arith.muli %79, %73 : i32
                      %81 = arith.addi %70, %80 : i32
                      %82 = arith.index_cast %81 : i32 to index
                      %83 = arith.addi %82, %c0 : index
                      %84 = memref.load %77[%83] : memref<?xf32>
                      %85 = arith.addi %76, %c0 : index
                      memref.store %84, %65[%85] : memref<?xf32>
                    }
                    %63 = memref.load %54[] : memref<i1>
                    memref.store %63, %53[] : memref<i1>
                    %64 = memref.load %53[] : memref<i1>
                    scf.if %64 {
                      %65 = memref.load %0[%c0] : memref<1xi32>
                      %66 = arith.addi %65, %c1_i32 : i32
                      memref.store %66, %0[%c0] : memref<1xi32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %49 = memref.load %37[] : memref<i1>
              memref.store %49, %36[] : memref<i1>
              %50 = memref.load %36[] : memref<i1>
              scf.if %50 {
                %51 = memref.load %3[%c0] : memref<1xi32>
                %52 = arith.addi %51, %c1_i32 : i32
                memref.store %52, %3[%c0] : memref<1xi32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %32 = memref.load %23[] : memref<i1>
        memref.store %32, %22[] : memref<i1>
        %33 = memref.load %22[] : memref<i1>
        scf.if %33 {
          %34 = memref.load %5[%c0] : memref<1xi32>
          %35 = arith.subi %34, %c1_i32 : i32
          memref.store %35, %5[%c0] : memref<1xi32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816af40) {
  "memref.store"(%1, %5, %3) : (i32, memref<?xi32>, index) -> ()

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816a770) {
  %56 = "memref.load"(%40) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816a4d0) {
  %55 = "memref.load"(%40) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816a240) {
  %52 = "memref.load"(%40) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a160) {
  "memref.store"(%51, %40) : (i1, memref<i1>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816a0f0) {
  %51 = "memref.load"(%41) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd9816a030) {
  "cf.cond_br"(%50)[^bb2, ^bb3] {operand_segment_sizes = array<i32: 1, 0, 0>} : (i1) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors"
"(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition"
"(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CondBranchTruthPropagation : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::CondBranchTruthPropagation"
"(anonymous namespace)::CondBranchTruthPropagation" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.andi'(0x7fbd98169fa0) {
  %50 = "arith.andi"(%48, %49) : (i1, i1) -> i1


  * Pattern (anonymous namespace)::AndOfExtUI : 'arith.andi -> (arith.andi, arith.extui)' {
Trying to match "(anonymous namespace)::AndOfExtUI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtUIOp type
"(anonymous namespace)::AndOfExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AndOfExtSI : 'arith.andi -> (arith.andi, arith.extsi)' {
Trying to match "(anonymous namespace)::AndOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::AndOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98169f20) {
  %49 = "memref.load"(%41) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169e80) {
  %48 = "arith.cmpi"(%47, %1) {predicate = 1 : i64} : (i32, i32) -> i1

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.andi'(0x7fbd98169fa0) {
  %49 = "arith.andi"(%46, %48) : (i1, i1) -> i1


  * Pattern (anonymous namespace)::AndOfExtUI : 'arith.andi -> (arith.andi, arith.extui)' {
Trying to match "(anonymous namespace)::AndOfExtUI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtUIOp type
"(anonymous namespace)::AndOfExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AndOfExtSI : 'arith.andi -> (arith.andi, arith.extsi)' {
Trying to match "(anonymous namespace)::AndOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::AndOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.extsi'(0x7fbd98169db0) {
  %47 = "arith.extsi"(%46) : (i1) -> i32

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %46 = "arith.cmpi"(%42, %45) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtUIOp type
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98169b40) {
  %45 = "memref.load"(%44, %3) : (memref<?xi32>, index) -> i32

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match

* Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.cast'(0x7fbd98169a70) {
  %44 = "memref.cast"(%43) : (memref<1xi32>) -> memref<?xi32>

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd98169a20) {
  %43 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98169780) {
  %42 = "memref.load"(%8, %3) : (memref<?xi32>, index) -> i32

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match

* Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd981696b0) {
  "cf.br"()[^bb1] : () -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd98169530) {
  "memref.store"(%2, %41) : (i1, memref<i1>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd981694e0) {
  %41 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<i1>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%37 = memref.alloca() : memref<i1>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %true, %37[] : memref<i1>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd98169480) {
  %40 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<i1>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%36 = memref.alloca() : memref<i1>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %46, %36[] : memref<i1>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd98168f00) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd98168e70) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.execute_region'(0x7fbd98168fa0) {

  * Pattern SingleBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "SingleBlockExecuteInliner"
    ** Replace : 'scf.execute_region'(0x7fbd98168fa0)
    ** Erase   : 'scf.yield'(0x7fbd981693d0)
"SingleBlockExecuteInliner" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %true = arith.constant true
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<1xi32>
  %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
  memref.store %2, %4[%c0] : memref<?xi32>
  %5 = memref.alloca() : memref<1xi32>
  %6 = memref.cast %5 : memref<1xi32> to memref<?xi32>
  memref.store %2, %6[%c0] : memref<?xi32>
  %7 = memref.alloca() : memref<1xi32>
  %8 = memref.cast %7 : memref<1xi32> to memref<?xi32>
  memref.store %2, %8[%c0] : memref<?xi32>
  %9 = memref.alloca() : memref<1xmemref<?xf32>>
  %10 = memref.cast %9 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %11 = memref.alloca() : memref<1xmemref<?xf32>>
  %12 = memref.cast %11 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %13 = memref.alloca() : memref<1xmemref<?xf32>>
  %14 = memref.cast %13 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %15 = memref.alloca() : memref<1xmemref<?xf32>>
  %16 = memref.cast %15 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  memref.store %arg0, %16[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg1, %14[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg2, %12[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg3, %10[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg4, %8[%c0] : memref<?xi32>
  %17 = memref.alloca() : memref<i1>
  %18 = memref.alloca() : memref<i1>
  memref.store %true, %18[] : memref<i1>
  memref.store %true, %17[] : memref<i1>
  %19 = memref.load %17[] : memref<i1>
  scf.if %19 {
    %20 = memref.load %17[] : memref<i1>
    scf.if %20 {
      scf.execute_region {
        %21 = memref.load %17[] : memref<i1>
        scf.if %21 {
          scf.execute_region {
            %34 = memref.get_global @kbm3 : memref<1xi32>
            %35 = memref.cast %34 : memref<1xi32> to memref<?xi32>
            %36 = memref.load %35[%c0] : memref<?xi32>
            memref.store %36, %6[%c0] : memref<?xi32>
            scf.yield
          }
        }
        %22 = memref.alloca() : memref<i1>
        %23 = memref.alloca() : memref<i1>
        memref.store %true, %23[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %24 = memref.load %6[%c0] : memref<?xi32>
        %25 = arith.cmpi sgt, %24, %c0_i32 : i32
        %26 = arith.extsi %25 : i1 to i32
        %27 = arith.cmpi ne, %26, %c0_i32 : i32
        %28 = memref.load %23[] : memref<i1>
        %29 = arith.andi %27, %28 : i1
        cf.cond_br %29, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %30 = memref.load %23[] : memref<i1>
        memref.store %30, %22[] : memref<i1>
        %31 = memref.load %22[] : memref<i1>
        scf.if %31 {
          %34 = memref.load %22[] : memref<i1>
          scf.if %34 {
            scf.execute_region {
              %35 = memref.load %22[] : memref<i1>
              scf.if %35 {
                memref.store %c0_i32, %4[%c0] : memref<?xi32>
              }
              %36 = memref.alloca() : memref<i1>
              %37 = memref.alloca() : memref<i1>
              memref.store %true, %37[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %38 = memref.load %3[%c0] : memref<1xi32>
              %39 = memref.get_global @jm : memref<1xi32>
              %40 = memref.load %39[%c0] : memref<1xi32>
              %41 = arith.cmpi slt, %38, %40 : i32
              %42 = memref.load %37[] : memref<i1>
              %43 = arith.andi %41, %42 : i1
              cf.cond_br %43, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %44 = memref.load %37[] : memref<i1>
              memref.store %44, %36[] : memref<i1>
              %45 = memref.load %36[] : memref<i1>
              scf.if %45 {
                %48 = memref.load %36[] : memref<i1>
                scf.if %48 {
                  scf.execute_region {
                    %49 = memref.load %36[] : memref<i1>
                    scf.if %49 {
                      memref.store %c0_i32, %0[%c0] : memref<1xi32>
                    }
                    %50 = memref.alloca() : memref<i1>
                    %51 = memref.alloca() : memref<i1>
                    memref.store %true, %51[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %52 = memref.load %0[%c0] : memref<1xi32>
                    %53 = memref.get_global @im : memref<1xi32>
                    %54 = memref.load %53[%c0] : memref<1xi32>
                    %55 = arith.cmpi slt, %52, %54 : i32
                    %56 = memref.load %51[] : memref<i1>
                    %57 = arith.andi %55, %56 : i1
                    cf.cond_br %57, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %58 = memref.load %51[] : memref<i1>
                    memref.store %58, %50[] : memref<i1>
                    %59 = memref.load %50[] : memref<i1>
                    scf.if %59 {
                      %62 = memref.load %11[%c0] : memref<1xmemref<?xf32>>
                      %63 = memref.load %0[%c0] : memref<1xi32>
                      %64 = memref.load %3[%c0] : memref<1xi32>
                      %65 = memref.load %53[%c0] : memref<1xi32>
                      %66 = arith.muli %64, %65 : i32
                      %67 = arith.addi %63, %66 : i32
                      %68 = memref.load %5[%c0] : memref<1xi32>
                      %69 = arith.muli %68, %65 : i32
                      %70 = memref.load %39[%c0] : memref<1xi32>
                      %71 = arith.muli %69, %70 : i32
                      %72 = arith.addi %67, %71 : i32
                      %73 = arith.index_cast %72 : i32 to index
                      %74 = memref.load %15[%c0] : memref<1xmemref<?xf32>>
                      %75 = arith.subi %68, %c1_i32 : i32
                      %76 = arith.muli %75, %65 : i32
                      %77 = arith.muli %76, %70 : i32
                      %78 = arith.addi %67, %77 : i32
                      %79 = arith.index_cast %78 : i32 to index
                      %80 = arith.addi %79, %c0 : index
                      %81 = memref.load %74[%80] : memref<?xf32>
                      %82 = arith.addi %73, %c0 : index
                      memref.store %81, %62[%82] : memref<?xf32>
                    }
                    %60 = memref.load %51[] : memref<i1>
                    memref.store %60, %50[] : memref<i1>
                    %61 = memref.load %50[] : memref<i1>
                    scf.if %61 {
                      %62 = memref.load %0[%c0] : memref<1xi32>
                      %63 = arith.addi %62, %c1_i32 : i32
                      memref.store %63, %0[%c0] : memref<1xi32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %46 = memref.load %37[] : memref<i1>
              memref.store %46, %36[] : memref<i1>
              %47 = memref.load %36[] : memref<i1>
              scf.if %47 {
                %48 = memref.load %3[%c0] : memref<1xi32>
                %49 = arith.addi %48, %c1_i32 : i32
                memref.store %49, %3[%c0] : memref<1xi32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %32 = memref.load %23[] : memref<i1>
        memref.store %32, %22[] : memref<i1>
        %33 = memref.load %22[] : memref<i1>
        scf.if %33 {
          %34 = memref.load %5[%c0] : memref<1xi32>
          %35 = arith.subi %34, %c1_i32 : i32
          memref.store %35, %5[%c0] : memref<1xi32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd98169320) {
  "memref.store"(%1, %8, %3) : (i32, memref<?xi32>, index) -> ()

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98168db0) {
  %39 = "memref.load"(%26) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98168a10) {
  %38 = "memref.load"(%26) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98168760) {
  %35 = "memref.load"(%26) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd981686c0) {
  "memref.store"(%34, %26) : (i1, memref<i1>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98168650) {
  %34 = "memref.load"(%27) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd98168590) {
  "cf.cond_br"(%33)[^bb2, ^bb3] {operand_segment_sizes = array<i32: 1, 0, 0>} : (i1) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors"
"(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition"
"(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CondBranchTruthPropagation : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::CondBranchTruthPropagation"
"(anonymous namespace)::CondBranchTruthPropagation" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.andi'(0x7fbd981683d0) {
  %33 = "arith.andi"(%31, %32) : (i1, i1) -> i1


  * Pattern (anonymous namespace)::AndOfExtUI : 'arith.andi -> (arith.andi, arith.extui)' {
Trying to match "(anonymous namespace)::AndOfExtUI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtUIOp type
"(anonymous namespace)::AndOfExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AndOfExtSI : 'arith.andi -> (arith.andi, arith.extsi)' {
Trying to match "(anonymous namespace)::AndOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::AndOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98168350) {
  %32 = "memref.load"(%27) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd981682b0) {
  %31 = "arith.cmpi"(%30, %1) {predicate = 1 : i64} : (i32, i32) -> i1

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.andi'(0x7fbd981683d0) {
  %32 = "arith.andi"(%29, %31) : (i1, i1) -> i1


  * Pattern (anonymous namespace)::AndOfExtUI : 'arith.andi -> (arith.andi, arith.extui)' {
Trying to match "(anonymous namespace)::AndOfExtUI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtUIOp type
"(anonymous namespace)::AndOfExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AndOfExtSI : 'arith.andi -> (arith.andi, arith.extsi)' {
Trying to match "(anonymous namespace)::AndOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::AndOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.extsi'(0x7fbd981680b0) {
  %30 = "arith.extsi"(%29) : (i1) -> i32

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98168010) {
  %29 = "arith.cmpi"(%28, %1) {predicate = 4 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtUIOp type
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98167e90) {
  %1 = "arith.constant"() {value = 0 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98167df0) {
  %28 = "memref.load"(%10, %3) : (memref<?xi32>, index) -> i32

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match

* Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd98167bf0) {
  "cf.br"()[^bb1] : () -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd98167a70) {
  "memref.store"(%2, %27) : (i1, memref<i1>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd98167a20) {
  %27 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<i1>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%23 = memref.alloca() : memref<i1>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %true, %23[] : memref<i1>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd981679c0) {
  %26 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<i1>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%22 = memref.alloca() : memref<i1>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %30, %22[] : memref<i1>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd98166d40) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd98166cb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.execute_region'(0x7fbd98166de0) {

  * Pattern SingleBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "SingleBlockExecuteInliner"
    ** Replace : 'scf.execute_region'(0x7fbd98166de0)
    ** Erase   : 'scf.yield'(0x7fbd98167910)
"SingleBlockExecuteInliner" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %true = arith.constant true
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<1xi32>
  %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
  memref.store %2, %4[%c0] : memref<?xi32>
  %5 = memref.alloca() : memref<1xi32>
  %6 = memref.cast %5 : memref<1xi32> to memref<?xi32>
  memref.store %2, %6[%c0] : memref<?xi32>
  %7 = memref.alloca() : memref<1xi32>
  %8 = memref.cast %7 : memref<1xi32> to memref<?xi32>
  memref.store %2, %8[%c0] : memref<?xi32>
  %9 = memref.alloca() : memref<1xmemref<?xf32>>
  %10 = memref.cast %9 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %11 = memref.alloca() : memref<1xmemref<?xf32>>
  %12 = memref.cast %11 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %13 = memref.alloca() : memref<1xmemref<?xf32>>
  %14 = memref.cast %13 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %15 = memref.alloca() : memref<1xmemref<?xf32>>
  %16 = memref.cast %15 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  memref.store %arg0, %16[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg1, %14[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg2, %12[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg3, %10[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg4, %8[%c0] : memref<?xi32>
  %17 = memref.alloca() : memref<i1>
  %18 = memref.alloca() : memref<i1>
  memref.store %true, %18[] : memref<i1>
  memref.store %true, %17[] : memref<i1>
  %19 = memref.load %17[] : memref<i1>
  scf.if %19 {
    %20 = memref.load %17[] : memref<i1>
    scf.if %20 {
      scf.execute_region {
        %21 = memref.load %17[] : memref<i1>
        scf.if %21 {
          %32 = memref.get_global @kbm3 : memref<1xi32>
          %33 = memref.cast %32 : memref<1xi32> to memref<?xi32>
          %34 = memref.load %33[%c0] : memref<?xi32>
          memref.store %34, %6[%c0] : memref<?xi32>
        }
        %22 = memref.alloca() : memref<i1>
        %23 = memref.alloca() : memref<i1>
        memref.store %true, %23[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %24 = memref.load %5[%c0] : memref<1xi32>
        %25 = arith.cmpi sgt, %24, %c0_i32 : i32
        %26 = memref.load %23[] : memref<i1>
        %27 = arith.andi %25, %26 : i1
        cf.cond_br %27, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %28 = memref.load %23[] : memref<i1>
        memref.store %28, %22[] : memref<i1>
        %29 = memref.load %22[] : memref<i1>
        scf.if %29 {
          %32 = memref.load %22[] : memref<i1>
          scf.if %32 {
            scf.execute_region {
              %33 = memref.load %22[] : memref<i1>
              scf.if %33 {
                memref.store %c0_i32, %3[%c0] : memref<1xi32>
              }
              %34 = memref.alloca() : memref<i1>
              %35 = memref.alloca() : memref<i1>
              memref.store %true, %35[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %36 = memref.load %3[%c0] : memref<1xi32>
              %37 = memref.get_global @jm : memref<1xi32>
              %38 = memref.load %37[%c0] : memref<1xi32>
              %39 = arith.cmpi slt, %36, %38 : i32
              %40 = memref.load %35[] : memref<i1>
              %41 = arith.andi %39, %40 : i1
              cf.cond_br %41, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %42 = memref.load %35[] : memref<i1>
              memref.store %42, %34[] : memref<i1>
              %43 = memref.load %34[] : memref<i1>
              scf.if %43 {
                %46 = memref.load %34[] : memref<i1>
                scf.if %46 {
                  scf.execute_region {
                    %47 = memref.load %34[] : memref<i1>
                    scf.if %47 {
                      memref.store %c0_i32, %0[%c0] : memref<1xi32>
                    }
                    %48 = memref.alloca() : memref<i1>
                    %49 = memref.alloca() : memref<i1>
                    memref.store %true, %49[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %50 = memref.load %0[%c0] : memref<1xi32>
                    %51 = memref.get_global @im : memref<1xi32>
                    %52 = memref.load %51[%c0] : memref<1xi32>
                    %53 = arith.cmpi slt, %50, %52 : i32
                    %54 = memref.load %49[] : memref<i1>
                    %55 = arith.andi %53, %54 : i1
                    cf.cond_br %55, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %56 = memref.load %49[] : memref<i1>
                    memref.store %56, %48[] : memref<i1>
                    %57 = memref.load %48[] : memref<i1>
                    scf.if %57 {
                      %60 = memref.load %11[%c0] : memref<1xmemref<?xf32>>
                      %61 = memref.load %0[%c0] : memref<1xi32>
                      %62 = memref.load %3[%c0] : memref<1xi32>
                      %63 = memref.load %51[%c0] : memref<1xi32>
                      %64 = arith.muli %62, %63 : i32
                      %65 = arith.addi %61, %64 : i32
                      %66 = memref.load %5[%c0] : memref<1xi32>
                      %67 = arith.muli %66, %63 : i32
                      %68 = memref.load %37[%c0] : memref<1xi32>
                      %69 = arith.muli %67, %68 : i32
                      %70 = arith.addi %65, %69 : i32
                      %71 = arith.index_cast %70 : i32 to index
                      %72 = memref.load %15[%c0] : memref<1xmemref<?xf32>>
                      %73 = arith.subi %66, %c1_i32 : i32
                      %74 = arith.muli %73, %63 : i32
                      %75 = arith.muli %74, %68 : i32
                      %76 = arith.addi %65, %75 : i32
                      %77 = arith.index_cast %76 : i32 to index
                      %78 = arith.addi %77, %c0 : index
                      %79 = memref.load %72[%78] : memref<?xf32>
                      %80 = arith.addi %71, %c0 : index
                      memref.store %79, %60[%80] : memref<?xf32>
                    }
                    %58 = memref.load %49[] : memref<i1>
                    memref.store %58, %48[] : memref<i1>
                    %59 = memref.load %48[] : memref<i1>
                    scf.if %59 {
                      %60 = memref.load %0[%c0] : memref<1xi32>
                      %61 = arith.addi %60, %c1_i32 : i32
                      memref.store %61, %0[%c0] : memref<1xi32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %44 = memref.load %35[] : memref<i1>
              memref.store %44, %34[] : memref<i1>
              %45 = memref.load %34[] : memref<i1>
              scf.if %45 {
                %46 = memref.load %3[%c0] : memref<1xi32>
                %47 = arith.addi %46, %c1_i32 : i32
                memref.store %47, %3[%c0] : memref<1xi32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %30 = memref.load %23[] : memref<i1>
        memref.store %30, %22[] : memref<i1>
        %31 = memref.load %22[] : memref<i1>
        scf.if %31 {
          %32 = memref.load %5[%c0] : memref<1xi32>
          %33 = arith.subi %32, %c1_i32 : i32
          memref.store %33, %5[%c0] : memref<1xi32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd98167860) {
  "memref.store"(%38, %10, %3) : (i32, memref<?xi32>, index) -> ()

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98167510) {
  %38 = "memref.load"(%37, %3) : (memref<?xi32>, index) -> i32

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match

* Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.cast'(0x7fbd98167440) {
  %37 = "memref.cast"(%36) : (memref<1xi32>) -> memref<?xi32>

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd981673f0) {
  %36 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98166bf0) {
  %25 = "memref.load"(%21) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98166980) {
  %24 = "memref.load"(%21) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd981666b0) {
  %23 = "memref.load"(%21) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd98166610) {
  "memref.store"(%2, %21) : (i1, memref<i1>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd98166580) {
  "memref.store"(%2, %22) : (i1, memref<i1>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd98166530) {
  %22 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<i1>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%18 = memref.alloca() : memref<i1>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %true, %18[] : memref<i1>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
    ** Erase   : 'memref.store'(0x7fbd98166580)
    ** Erase   : 'memref.alloca'(0x7fbd98166530)
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %true = arith.constant true
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<1xi32>
  %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
  memref.store %2, %4[%c0] : memref<?xi32>
  %5 = memref.alloca() : memref<1xi32>
  %6 = memref.cast %5 : memref<1xi32> to memref<?xi32>
  memref.store %2, %6[%c0] : memref<?xi32>
  %7 = memref.alloca() : memref<1xi32>
  %8 = memref.cast %7 : memref<1xi32> to memref<?xi32>
  memref.store %2, %8[%c0] : memref<?xi32>
  %9 = memref.alloca() : memref<1xmemref<?xf32>>
  %10 = memref.cast %9 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %11 = memref.alloca() : memref<1xmemref<?xf32>>
  %12 = memref.cast %11 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %13 = memref.alloca() : memref<1xmemref<?xf32>>
  %14 = memref.cast %13 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %15 = memref.alloca() : memref<1xmemref<?xf32>>
  %16 = memref.cast %15 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  memref.store %arg0, %16[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg1, %14[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg2, %12[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg3, %10[%c0] : memref<?xmemref<?xf32>>
  memref.store %arg4, %8[%c0] : memref<?xi32>
  %17 = memref.alloca() : memref<i1>
  memref.store %true, %17[] : memref<i1>
  %18 = memref.load %17[] : memref<i1>
  scf.if %18 {
    %19 = memref.load %17[] : memref<i1>
    scf.if %19 {
      scf.execute_region {
        %20 = memref.load %17[] : memref<i1>
        scf.if %20 {
          %31 = memref.get_global @kbm3 : memref<1xi32>
          %32 = memref.load %31[%c0] : memref<1xi32>
          memref.store %32, %5[%c0] : memref<1xi32>
        }
        %21 = memref.alloca() : memref<i1>
        %22 = memref.alloca() : memref<i1>
        memref.store %true, %22[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %23 = memref.load %5[%c0] : memref<1xi32>
        %24 = arith.cmpi sgt, %23, %c0_i32 : i32
        %25 = memref.load %22[] : memref<i1>
        %26 = arith.andi %24, %25 : i1
        cf.cond_br %26, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %27 = memref.load %22[] : memref<i1>
        memref.store %27, %21[] : memref<i1>
        %28 = memref.load %21[] : memref<i1>
        scf.if %28 {
          %31 = memref.load %21[] : memref<i1>
          scf.if %31 {
            scf.execute_region {
              %32 = memref.load %21[] : memref<i1>
              scf.if %32 {
                memref.store %c0_i32, %3[%c0] : memref<1xi32>
              }
              %33 = memref.alloca() : memref<i1>
              %34 = memref.alloca() : memref<i1>
              memref.store %true, %34[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %35 = memref.load %3[%c0] : memref<1xi32>
              %36 = memref.get_global @jm : memref<1xi32>
              %37 = memref.load %36[%c0] : memref<1xi32>
              %38 = arith.cmpi slt, %35, %37 : i32
              %39 = memref.load %34[] : memref<i1>
              %40 = arith.andi %38, %39 : i1
              cf.cond_br %40, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %41 = memref.load %34[] : memref<i1>
              memref.store %41, %33[] : memref<i1>
              %42 = memref.load %33[] : memref<i1>
              scf.if %42 {
                %45 = memref.load %33[] : memref<i1>
                scf.if %45 {
                  scf.execute_region {
                    %46 = memref.load %33[] : memref<i1>
                    scf.if %46 {
                      memref.store %c0_i32, %0[%c0] : memref<1xi32>
                    }
                    %47 = memref.alloca() : memref<i1>
                    %48 = memref.alloca() : memref<i1>
                    memref.store %true, %48[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %49 = memref.load %0[%c0] : memref<1xi32>
                    %50 = memref.get_global @im : memref<1xi32>
                    %51 = memref.load %50[%c0] : memref<1xi32>
                    %52 = arith.cmpi slt, %49, %51 : i32
                    %53 = memref.load %48[] : memref<i1>
                    %54 = arith.andi %52, %53 : i1
                    cf.cond_br %54, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %55 = memref.load %48[] : memref<i1>
                    memref.store %55, %47[] : memref<i1>
                    %56 = memref.load %47[] : memref<i1>
                    scf.if %56 {
                      %59 = memref.load %11[%c0] : memref<1xmemref<?xf32>>
                      %60 = memref.load %0[%c0] : memref<1xi32>
                      %61 = memref.load %3[%c0] : memref<1xi32>
                      %62 = memref.load %50[%c0] : memref<1xi32>
                      %63 = arith.muli %61, %62 : i32
                      %64 = arith.addi %60, %63 : i32
                      %65 = memref.load %5[%c0] : memref<1xi32>
                      %66 = arith.muli %65, %62 : i32
                      %67 = memref.load %36[%c0] : memref<1xi32>
                      %68 = arith.muli %66, %67 : i32
                      %69 = arith.addi %64, %68 : i32
                      %70 = arith.index_cast %69 : i32 to index
                      %71 = memref.load %15[%c0] : memref<1xmemref<?xf32>>
                      %72 = arith.subi %65, %c1_i32 : i32
                      %73 = arith.muli %72, %62 : i32
                      %74 = arith.muli %73, %67 : i32
                      %75 = arith.addi %64, %74 : i32
                      %76 = arith.index_cast %75 : i32 to index
                      %77 = arith.addi %76, %c0 : index
                      %78 = memref.load %71[%77] : memref<?xf32>
                      %79 = arith.addi %70, %c0 : index
                      memref.store %78, %59[%79] : memref<?xf32>
                    }
                    %57 = memref.load %48[] : memref<i1>
                    memref.store %57, %47[] : memref<i1>
                    %58 = memref.load %47[] : memref<i1>
                    scf.if %58 {
                      %59 = memref.load %0[%c0] : memref<1xi32>
                      %60 = arith.addi %59, %c1_i32 : i32
                      memref.store %60, %0[%c0] : memref<1xi32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %43 = memref.load %34[] : memref<i1>
              memref.store %43, %33[] : memref<i1>
              %44 = memref.load %33[] : memref<i1>
              scf.if %44 {
                %45 = memref.load %3[%c0] : memref<1xi32>
                %46 = arith.addi %45, %c1_i32 : i32
                memref.store %46, %3[%c0] : memref<1xi32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %29 = memref.load %22[] : memref<i1>
        memref.store %29, %21[] : memref<i1>
        %30 = memref.load %21[] : memref<i1>
        scf.if %30 {
          %31 = memref.load %5[%c0] : memref<1xi32>
          %32 = arith.subi %31, %c1_i32 : i32
          memref.store %32, %5[%c0] : memref<1xi32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd981664d0) {
  %21 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<i1>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%17 = memref.alloca() : memref<i1>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %true, %17[] : memref<i1>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98166480) {
  %2 = "arith.constant"() {value = true} : () -> i1

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd98166030) {
  "memref.store"(%arg4, %12, %3) : (i32, memref<?xi32>, index) -> ()

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd98165930) {
  "memref.store"(%arg3, %14, %3) : (memref<?xf32>, memref<?xmemref<?xf32>>, index) -> ()

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd98165710) {
  "memref.store"(%arg2, %16, %3) : (memref<?xf32>, memref<?xmemref<?xf32>>, index) -> ()

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd981654f0) {
  "memref.store"(%arg1, %18, %3) : (memref<?xf32>, memref<?xmemref<?xf32>>, index) -> ()

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd981652d0) {
  "memref.store"(%arg0, %20, %3) : (memref<?xf32>, memref<?xmemref<?xf32>>, index) -> ()

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.cast'(0x7fbd981650e0) {
  %20 = "memref.cast"(%19) : (memref<1xmemref<?xf32>>) -> memref<?xmemref<?xf32>>

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd98165080) {
  %19 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<1xmemref<?xf32>>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
    ** Insert  : 'memref.alloca'(0x7fbd9b304090)
    ** Insert  : 'arith.constant'(0x7fbd9b3040f0)
    ** Insert  : 'arith.cmpi'(0x7fbd9b304140)
    ** Insert  : 'scf.yield'(0x7fbd9b304240)
    ** Insert  : 'scf.if'(0x7fbd9b3042d0)
    ** Replace : 'memref.store'(0x7fbd981652d0)
    ** Insert  : 'memref.store'(0x7fbd9b304370)
    ** Insert  : 'memref.load'(0x7fbd9b304410)
    ** Replace : 'memref.load'(0x7fbd9816cdd0)
    ** Erase   : 'memref.alloca'(0x7fbd98165080)
"ConstantRankReduction" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %true = arith.constant true
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<1xi32>
  %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
  memref.store %2, %4[%c0] : memref<?xi32>
  %5 = memref.alloca() : memref<1xi32>
  %6 = memref.cast %5 : memref<1xi32> to memref<?xi32>
  memref.store %2, %6[%c0] : memref<?xi32>
  %7 = memref.alloca() : memref<1xi32>
  %8 = memref.cast %7 : memref<1xi32> to memref<?xi32>
  memref.store %2, %8[%c0] : memref<?xi32>
  %9 = memref.alloca() : memref<1xmemref<?xf32>>
  %10 = memref.cast %9 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %11 = memref.alloca() : memref<1xmemref<?xf32>>
  %12 = memref.cast %11 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %13 = memref.alloca() : memref<1xmemref<?xf32>>
  %14 = memref.cast %13 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %15 = memref.alloca() : memref<memref<?xf32>>
  %c0_0 = arith.constant 0 : index
  %16 = arith.cmpi eq, %c0, %c0_0 : index
  scf.if %16 {
    memref.store %arg0, %15[] : memref<memref<?xf32>>
  }
  memref.store %arg1, %13[%c0] : memref<1xmemref<?xf32>>
  memref.store %arg2, %11[%c0] : memref<1xmemref<?xf32>>
  memref.store %arg3, %9[%c0] : memref<1xmemref<?xf32>>
  memref.store %arg4, %7[%c0] : memref<1xi32>
  %17 = memref.alloca() : memref<i1>
  memref.store %true, %17[] : memref<i1>
  %18 = memref.load %17[] : memref<i1>
  scf.if %18 {
    %19 = memref.load %17[] : memref<i1>
    scf.if %19 {
      scf.execute_region {
        %20 = memref.load %17[] : memref<i1>
        scf.if %20 {
          %31 = memref.get_global @kbm3 : memref<1xi32>
          %32 = memref.load %31[%c0] : memref<1xi32>
          memref.store %32, %5[%c0] : memref<1xi32>
        }
        %21 = memref.alloca() : memref<i1>
        %22 = memref.alloca() : memref<i1>
        memref.store %true, %22[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %23 = memref.load %5[%c0] : memref<1xi32>
        %24 = arith.cmpi sgt, %23, %c0_i32 : i32
        %25 = memref.load %22[] : memref<i1>
        %26 = arith.andi %24, %25 : i1
        cf.cond_br %26, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %27 = memref.load %22[] : memref<i1>
        memref.store %27, %21[] : memref<i1>
        %28 = memref.load %21[] : memref<i1>
        scf.if %28 {
          %31 = memref.load %21[] : memref<i1>
          scf.if %31 {
            scf.execute_region {
              %32 = memref.load %21[] : memref<i1>
              scf.if %32 {
                memref.store %c0_i32, %3[%c0] : memref<1xi32>
              }
              %33 = memref.alloca() : memref<i1>
              %34 = memref.alloca() : memref<i1>
              memref.store %true, %34[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %35 = memref.load %3[%c0] : memref<1xi32>
              %36 = memref.get_global @jm : memref<1xi32>
              %37 = memref.load %36[%c0] : memref<1xi32>
              %38 = arith.cmpi slt, %35, %37 : i32
              %39 = memref.load %34[] : memref<i1>
              %40 = arith.andi %38, %39 : i1
              cf.cond_br %40, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %41 = memref.load %34[] : memref<i1>
              memref.store %41, %33[] : memref<i1>
              %42 = memref.load %33[] : memref<i1>
              scf.if %42 {
                %45 = memref.load %33[] : memref<i1>
                scf.if %45 {
                  scf.execute_region {
                    %46 = memref.load %33[] : memref<i1>
                    scf.if %46 {
                      memref.store %c0_i32, %0[%c0] : memref<1xi32>
                    }
                    %47 = memref.alloca() : memref<i1>
                    %48 = memref.alloca() : memref<i1>
                    memref.store %true, %48[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %49 = memref.load %0[%c0] : memref<1xi32>
                    %50 = memref.get_global @im : memref<1xi32>
                    %51 = memref.load %50[%c0] : memref<1xi32>
                    %52 = arith.cmpi slt, %49, %51 : i32
                    %53 = memref.load %48[] : memref<i1>
                    %54 = arith.andi %52, %53 : i1
                    cf.cond_br %54, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %55 = memref.load %48[] : memref<i1>
                    memref.store %55, %47[] : memref<i1>
                    %56 = memref.load %47[] : memref<i1>
                    scf.if %56 {
                      %59 = memref.load %11[%c0] : memref<1xmemref<?xf32>>
                      %60 = memref.load %0[%c0] : memref<1xi32>
                      %61 = memref.load %3[%c0] : memref<1xi32>
                      %62 = memref.load %50[%c0] : memref<1xi32>
                      %63 = arith.muli %61, %62 : i32
                      %64 = arith.addi %60, %63 : i32
                      %65 = memref.load %5[%c0] : memref<1xi32>
                      %66 = arith.muli %65, %62 : i32
                      %67 = memref.load %36[%c0] : memref<1xi32>
                      %68 = arith.muli %66, %67 : i32
                      %69 = arith.addi %64, %68 : i32
                      %70 = arith.index_cast %69 : i32 to index
                      %71 = memref.load %15[] : memref<memref<?xf32>>
                      %72 = arith.subi %65, %c1_i32 : i32
                      %73 = arith.muli %72, %62 : i32
                      %74 = arith.muli %73, %67 : i32
                      %75 = arith.addi %64, %74 : i32
                      %76 = arith.index_cast %75 : i32 to index
                      %77 = arith.addi %76, %c0 : index
                      %78 = memref.load %71[%77] : memref<?xf32>
                      %79 = arith.addi %70, %c0 : index
                      memref.store %78, %59[%79] : memref<?xf32>
                    }
                    %57 = memref.load %48[] : memref<i1>
                    memref.store %57, %47[] : memref<i1>
                    %58 = memref.load %47[] : memref<i1>
                    scf.if %58 {
                      %59 = memref.load %0[%c0] : memref<1xi32>
                      %60 = arith.addi %59, %c1_i32 : i32
                      memref.store %60, %0[%c0] : memref<1xi32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %43 = memref.load %34[] : memref<i1>
              memref.store %43, %33[] : memref<i1>
              %44 = memref.load %33[] : memref<i1>
              scf.if %44 {
                %45 = memref.load %3[%c0] : memref<1xi32>
                %46 = arith.addi %45, %c1_i32 : i32
                memref.store %46, %3[%c0] : memref<1xi32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %29 = memref.load %22[] : memref<i1>
        memref.store %29, %21[] : memref<i1>
        %30 = memref.load %21[] : memref<i1>
        scf.if %30 {
          %31 = memref.load %5[%c0] : memref<1xi32>
          %32 = arith.subi %31, %c1_i32 : i32
          memref.store %32, %5[%c0] : memref<1xi32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %83 = "memref.load"(%76, %82) : (memref<?xf32>, index) -> f32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b304410) {
  %76 = "memref.load"(%19) : (memref<memref<?xf32>>) -> memref<?xf32>


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9b304370) {
  "memref.store"(%arg0, %19) : (memref<?xf32>, memref<memref<?xf32>>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b3042d0) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b304240) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9b304140) {
  %21 = "arith.cmpi"(%3, %20) {predicate = 0 : i64} : (index, index) -> i1

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b3042d0) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
    ** Replace : 'scf.if'(0x7fbd9b3042d0)
    ** Erase   : 'scf.yield'(0x7fbd9b304240)
"(anonymous namespace)::RemoveStaticCondition" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<1xi32>
  %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
  memref.store %2, %4[%c0] : memref<?xi32>
  %5 = memref.alloca() : memref<1xi32>
  %6 = memref.cast %5 : memref<1xi32> to memref<?xi32>
  memref.store %2, %6[%c0] : memref<?xi32>
  %7 = memref.alloca() : memref<1xi32>
  %8 = memref.cast %7 : memref<1xi32> to memref<?xi32>
  memref.store %2, %8[%c0] : memref<?xi32>
  %9 = memref.alloca() : memref<1xmemref<?xf32>>
  %10 = memref.cast %9 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %11 = memref.alloca() : memref<1xmemref<?xf32>>
  %12 = memref.cast %11 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %13 = memref.alloca() : memref<1xmemref<?xf32>>
  %14 = memref.cast %13 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %15 = memref.alloca() : memref<memref<?xf32>>
  %c0_0 = arith.constant 0 : index
  memref.store %arg0, %15[] : memref<memref<?xf32>>
  memref.store %arg1, %13[%c0] : memref<1xmemref<?xf32>>
  memref.store %arg2, %11[%c0] : memref<1xmemref<?xf32>>
  memref.store %arg3, %9[%c0] : memref<1xmemref<?xf32>>
  memref.store %arg4, %7[%c0] : memref<1xi32>
  %16 = memref.alloca() : memref<i1>
  memref.store %true, %16[] : memref<i1>
  %17 = memref.load %16[] : memref<i1>
  scf.if %17 {
    %18 = memref.load %16[] : memref<i1>
    scf.if %18 {
      scf.execute_region {
        %19 = memref.load %16[] : memref<i1>
        scf.if %19 {
          %30 = memref.get_global @kbm3 : memref<1xi32>
          %31 = memref.load %30[%c0] : memref<1xi32>
          memref.store %31, %5[%c0] : memref<1xi32>
        }
        %20 = memref.alloca() : memref<i1>
        %21 = memref.alloca() : memref<i1>
        memref.store %true, %21[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %22 = memref.load %5[%c0] : memref<1xi32>
        %23 = arith.cmpi sgt, %22, %c0_i32 : i32
        %24 = memref.load %21[] : memref<i1>
        %25 = arith.andi %23, %24 : i1
        cf.cond_br %25, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %26 = memref.load %21[] : memref<i1>
        memref.store %26, %20[] : memref<i1>
        %27 = memref.load %20[] : memref<i1>
        scf.if %27 {
          %30 = memref.load %20[] : memref<i1>
          scf.if %30 {
            scf.execute_region {
              %31 = memref.load %20[] : memref<i1>
              scf.if %31 {
                memref.store %c0_i32, %3[%c0] : memref<1xi32>
              }
              %32 = memref.alloca() : memref<i1>
              %33 = memref.alloca() : memref<i1>
              memref.store %true, %33[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %34 = memref.load %3[%c0] : memref<1xi32>
              %35 = memref.get_global @jm : memref<1xi32>
              %36 = memref.load %35[%c0] : memref<1xi32>
              %37 = arith.cmpi slt, %34, %36 : i32
              %38 = memref.load %33[] : memref<i1>
              %39 = arith.andi %37, %38 : i1
              cf.cond_br %39, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %40 = memref.load %33[] : memref<i1>
              memref.store %40, %32[] : memref<i1>
              %41 = memref.load %32[] : memref<i1>
              scf.if %41 {
                %44 = memref.load %32[] : memref<i1>
                scf.if %44 {
                  scf.execute_region {
                    %45 = memref.load %32[] : memref<i1>
                    scf.if %45 {
                      memref.store %c0_i32, %0[%c0] : memref<1xi32>
                    }
                    %46 = memref.alloca() : memref<i1>
                    %47 = memref.alloca() : memref<i1>
                    memref.store %true, %47[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %48 = memref.load %0[%c0] : memref<1xi32>
                    %49 = memref.get_global @im : memref<1xi32>
                    %50 = memref.load %49[%c0] : memref<1xi32>
                    %51 = arith.cmpi slt, %48, %50 : i32
                    %52 = memref.load %47[] : memref<i1>
                    %53 = arith.andi %51, %52 : i1
                    cf.cond_br %53, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %54 = memref.load %47[] : memref<i1>
                    memref.store %54, %46[] : memref<i1>
                    %55 = memref.load %46[] : memref<i1>
                    scf.if %55 {
                      %58 = memref.load %11[%c0] : memref<1xmemref<?xf32>>
                      %59 = memref.load %0[%c0] : memref<1xi32>
                      %60 = memref.load %3[%c0] : memref<1xi32>
                      %61 = memref.load %49[%c0] : memref<1xi32>
                      %62 = arith.muli %60, %61 : i32
                      %63 = arith.addi %59, %62 : i32
                      %64 = memref.load %5[%c0] : memref<1xi32>
                      %65 = arith.muli %64, %61 : i32
                      %66 = memref.load %35[%c0] : memref<1xi32>
                      %67 = arith.muli %65, %66 : i32
                      %68 = arith.addi %63, %67 : i32
                      %69 = arith.index_cast %68 : i32 to index
                      %70 = memref.load %15[] : memref<memref<?xf32>>
                      %71 = arith.subi %64, %c1_i32 : i32
                      %72 = arith.muli %71, %61 : i32
                      %73 = arith.muli %72, %66 : i32
                      %74 = arith.addi %63, %73 : i32
                      %75 = arith.index_cast %74 : i32 to index
                      %76 = arith.addi %75, %c0 : index
                      %77 = memref.load %70[%76] : memref<?xf32>
                      %78 = arith.addi %69, %c0 : index
                      memref.store %77, %58[%78] : memref<?xf32>
                    }
                    %56 = memref.load %47[] : memref<i1>
                    memref.store %56, %46[] : memref<i1>
                    %57 = memref.load %46[] : memref<i1>
                    scf.if %57 {
                      %58 = memref.load %0[%c0] : memref<1xi32>
                      %59 = arith.addi %58, %c1_i32 : i32
                      memref.store %59, %0[%c0] : memref<1xi32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %42 = memref.load %33[] : memref<i1>
              memref.store %42, %32[] : memref<i1>
              %43 = memref.load %32[] : memref<i1>
              scf.if %43 {
                %44 = memref.load %3[%c0] : memref<1xi32>
                %45 = arith.addi %44, %c1_i32 : i32
                memref.store %45, %3[%c0] : memref<1xi32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %28 = memref.load %21[] : memref<i1>
        memref.store %28, %20[] : memref<i1>
        %29 = memref.load %20[] : memref<i1>
        scf.if %29 {
          %30 = memref.load %5[%c0] : memref<1xi32>
          %31 = arith.subi %30, %c1_i32 : i32
          memref.store %31, %5[%c0] : memref<1xi32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98166480) {
  %0 = "arith.constant"() {value = true} : () -> i1

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b3040f0) {
  %20 = "arith.constant"() {value = 0 : index} : () -> index

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd9b304090) {
  %19 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<memref<?xf32>>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%15 = memref.alloca() : memref<memref<?xf32>>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %arg0, %15[] : memref<memref<?xf32>>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.cast'(0x7fbd981653f0) {
  %18 = "memref.cast"(%17) : (memref<1xmemref<?xf32>>) -> memref<?xmemref<?xf32>>

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd98165390) {
  %17 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<1xmemref<?xf32>>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%13 = memref.alloca() : memref<1xmemref<?xf32>>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %arg1, %13[%c0] : memref<1xmemref<?xf32>>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
    ** Erase   : 'memref.store'(0x7fbd981654f0)
    ** Erase   : 'memref.alloca'(0x7fbd98165390)
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<1xi32>
  %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
  memref.store %2, %4[%c0] : memref<?xi32>
  %5 = memref.alloca() : memref<1xi32>
  %6 = memref.cast %5 : memref<1xi32> to memref<?xi32>
  memref.store %2, %6[%c0] : memref<?xi32>
  %7 = memref.alloca() : memref<1xi32>
  %8 = memref.cast %7 : memref<1xi32> to memref<?xi32>
  memref.store %2, %8[%c0] : memref<?xi32>
  %9 = memref.alloca() : memref<1xmemref<?xf32>>
  %10 = memref.cast %9 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %11 = memref.alloca() : memref<1xmemref<?xf32>>
  %12 = memref.cast %11 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %13 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %13[] : memref<memref<?xf32>>
  memref.store %arg2, %11[%c0] : memref<1xmemref<?xf32>>
  memref.store %arg3, %9[%c0] : memref<1xmemref<?xf32>>
  memref.store %arg4, %7[%c0] : memref<1xi32>
  %14 = memref.alloca() : memref<i1>
  memref.store %true, %14[] : memref<i1>
  %15 = memref.load %14[] : memref<i1>
  scf.if %15 {
    %16 = memref.load %14[] : memref<i1>
    scf.if %16 {
      scf.execute_region {
        %17 = memref.load %14[] : memref<i1>
        scf.if %17 {
          %28 = memref.get_global @kbm3 : memref<1xi32>
          %29 = memref.load %28[%c0] : memref<1xi32>
          memref.store %29, %5[%c0] : memref<1xi32>
        }
        %18 = memref.alloca() : memref<i1>
        %19 = memref.alloca() : memref<i1>
        memref.store %true, %19[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %20 = memref.load %5[%c0] : memref<1xi32>
        %21 = arith.cmpi sgt, %20, %c0_i32 : i32
        %22 = memref.load %19[] : memref<i1>
        %23 = arith.andi %21, %22 : i1
        cf.cond_br %23, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %24 = memref.load %19[] : memref<i1>
        memref.store %24, %18[] : memref<i1>
        %25 = memref.load %18[] : memref<i1>
        scf.if %25 {
          %28 = memref.load %18[] : memref<i1>
          scf.if %28 {
            scf.execute_region {
              %29 = memref.load %18[] : memref<i1>
              scf.if %29 {
                memref.store %c0_i32, %3[%c0] : memref<1xi32>
              }
              %30 = memref.alloca() : memref<i1>
              %31 = memref.alloca() : memref<i1>
              memref.store %true, %31[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %32 = memref.load %3[%c0] : memref<1xi32>
              %33 = memref.get_global @jm : memref<1xi32>
              %34 = memref.load %33[%c0] : memref<1xi32>
              %35 = arith.cmpi slt, %32, %34 : i32
              %36 = memref.load %31[] : memref<i1>
              %37 = arith.andi %35, %36 : i1
              cf.cond_br %37, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %38 = memref.load %31[] : memref<i1>
              memref.store %38, %30[] : memref<i1>
              %39 = memref.load %30[] : memref<i1>
              scf.if %39 {
                %42 = memref.load %30[] : memref<i1>
                scf.if %42 {
                  scf.execute_region {
                    %43 = memref.load %30[] : memref<i1>
                    scf.if %43 {
                      memref.store %c0_i32, %0[%c0] : memref<1xi32>
                    }
                    %44 = memref.alloca() : memref<i1>
                    %45 = memref.alloca() : memref<i1>
                    memref.store %true, %45[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %46 = memref.load %0[%c0] : memref<1xi32>
                    %47 = memref.get_global @im : memref<1xi32>
                    %48 = memref.load %47[%c0] : memref<1xi32>
                    %49 = arith.cmpi slt, %46, %48 : i32
                    %50 = memref.load %45[] : memref<i1>
                    %51 = arith.andi %49, %50 : i1
                    cf.cond_br %51, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %52 = memref.load %45[] : memref<i1>
                    memref.store %52, %44[] : memref<i1>
                    %53 = memref.load %44[] : memref<i1>
                    scf.if %53 {
                      %56 = memref.load %11[%c0] : memref<1xmemref<?xf32>>
                      %57 = memref.load %0[%c0] : memref<1xi32>
                      %58 = memref.load %3[%c0] : memref<1xi32>
                      %59 = memref.load %47[%c0] : memref<1xi32>
                      %60 = arith.muli %58, %59 : i32
                      %61 = arith.addi %57, %60 : i32
                      %62 = memref.load %5[%c0] : memref<1xi32>
                      %63 = arith.muli %62, %59 : i32
                      %64 = memref.load %33[%c0] : memref<1xi32>
                      %65 = arith.muli %63, %64 : i32
                      %66 = arith.addi %61, %65 : i32
                      %67 = arith.index_cast %66 : i32 to index
                      %68 = memref.load %13[] : memref<memref<?xf32>>
                      %69 = arith.subi %62, %c1_i32 : i32
                      %70 = arith.muli %69, %59 : i32
                      %71 = arith.muli %70, %64 : i32
                      %72 = arith.addi %61, %71 : i32
                      %73 = arith.index_cast %72 : i32 to index
                      %74 = arith.addi %73, %c0 : index
                      %75 = memref.load %68[%74] : memref<?xf32>
                      %76 = arith.addi %67, %c0 : index
                      memref.store %75, %56[%76] : memref<?xf32>
                    }
                    %54 = memref.load %45[] : memref<i1>
                    memref.store %54, %44[] : memref<i1>
                    %55 = memref.load %44[] : memref<i1>
                    scf.if %55 {
                      %56 = memref.load %0[%c0] : memref<1xi32>
                      %57 = arith.addi %56, %c1_i32 : i32
                      memref.store %57, %0[%c0] : memref<1xi32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %40 = memref.load %31[] : memref<i1>
              memref.store %40, %30[] : memref<i1>
              %41 = memref.load %30[] : memref<i1>
              scf.if %41 {
                %42 = memref.load %3[%c0] : memref<1xi32>
                %43 = arith.addi %42, %c1_i32 : i32
                memref.store %43, %3[%c0] : memref<1xi32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %26 = memref.load %19[] : memref<i1>
        memref.store %26, %18[] : memref<i1>
        %27 = memref.load %18[] : memref<i1>
        scf.if %27 {
          %28 = memref.load %5[%c0] : memref<1xi32>
          %29 = arith.subi %28, %c1_i32 : i32
          memref.store %29, %5[%c0] : memref<1xi32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.cast'(0x7fbd98165610) {
  %16 = "memref.cast"(%15) : (memref<1xmemref<?xf32>>) -> memref<?xmemref<?xf32>>

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd981655b0) {
  %15 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<1xmemref<?xf32>>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
    ** Insert  : 'memref.alloca'(0x7fbd96f10380)
    ** Insert  : 'arith.constant'(0x7fbd96f05c30)
    ** Insert  : 'arith.cmpi'(0x7fbd96f18d30)
    ** Insert  : 'scf.yield'(0x7fbd96f18e10)
    ** Insert  : 'scf.if'(0x7fbd96f14700)
    ** Replace : 'memref.store'(0x7fbd98165710)
    ** Insert  : 'memref.store'(0x7fbd96f147a0)
    ** Insert  : 'memref.load'(0x7fbd96f14840)
    ** Replace : 'memref.load'(0x7fbd9816bf70)
    ** Erase   : 'memref.alloca'(0x7fbd981655b0)
"ConstantRankReduction" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<1xi32>
  %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
  memref.store %2, %4[%c0] : memref<?xi32>
  %5 = memref.alloca() : memref<1xi32>
  %6 = memref.cast %5 : memref<1xi32> to memref<?xi32>
  memref.store %2, %6[%c0] : memref<?xi32>
  %7 = memref.alloca() : memref<1xi32>
  %8 = memref.cast %7 : memref<1xi32> to memref<?xi32>
  memref.store %2, %8[%c0] : memref<?xi32>
  %9 = memref.alloca() : memref<1xmemref<?xf32>>
  %10 = memref.cast %9 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %11 = memref.alloca() : memref<memref<?xf32>>
  %12 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %12[] : memref<memref<?xf32>>
  %c0_0 = arith.constant 0 : index
  %13 = arith.cmpi eq, %c0, %c0_0 : index
  scf.if %13 {
    memref.store %arg2, %11[] : memref<memref<?xf32>>
  }
  memref.store %arg3, %9[%c0] : memref<1xmemref<?xf32>>
  memref.store %arg4, %7[%c0] : memref<1xi32>
  %14 = memref.alloca() : memref<i1>
  memref.store %true, %14[] : memref<i1>
  %15 = memref.load %14[] : memref<i1>
  scf.if %15 {
    %16 = memref.load %14[] : memref<i1>
    scf.if %16 {
      scf.execute_region {
        %17 = memref.load %14[] : memref<i1>
        scf.if %17 {
          %28 = memref.get_global @kbm3 : memref<1xi32>
          %29 = memref.load %28[%c0] : memref<1xi32>
          memref.store %29, %5[%c0] : memref<1xi32>
        }
        %18 = memref.alloca() : memref<i1>
        %19 = memref.alloca() : memref<i1>
        memref.store %true, %19[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %20 = memref.load %5[%c0] : memref<1xi32>
        %21 = arith.cmpi sgt, %20, %c0_i32 : i32
        %22 = memref.load %19[] : memref<i1>
        %23 = arith.andi %21, %22 : i1
        cf.cond_br %23, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %24 = memref.load %19[] : memref<i1>
        memref.store %24, %18[] : memref<i1>
        %25 = memref.load %18[] : memref<i1>
        scf.if %25 {
          %28 = memref.load %18[] : memref<i1>
          scf.if %28 {
            scf.execute_region {
              %29 = memref.load %18[] : memref<i1>
              scf.if %29 {
                memref.store %c0_i32, %3[%c0] : memref<1xi32>
              }
              %30 = memref.alloca() : memref<i1>
              %31 = memref.alloca() : memref<i1>
              memref.store %true, %31[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %32 = memref.load %3[%c0] : memref<1xi32>
              %33 = memref.get_global @jm : memref<1xi32>
              %34 = memref.load %33[%c0] : memref<1xi32>
              %35 = arith.cmpi slt, %32, %34 : i32
              %36 = memref.load %31[] : memref<i1>
              %37 = arith.andi %35, %36 : i1
              cf.cond_br %37, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %38 = memref.load %31[] : memref<i1>
              memref.store %38, %30[] : memref<i1>
              %39 = memref.load %30[] : memref<i1>
              scf.if %39 {
                %42 = memref.load %30[] : memref<i1>
                scf.if %42 {
                  scf.execute_region {
                    %43 = memref.load %30[] : memref<i1>
                    scf.if %43 {
                      memref.store %c0_i32, %0[%c0] : memref<1xi32>
                    }
                    %44 = memref.alloca() : memref<i1>
                    %45 = memref.alloca() : memref<i1>
                    memref.store %true, %45[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %46 = memref.load %0[%c0] : memref<1xi32>
                    %47 = memref.get_global @im : memref<1xi32>
                    %48 = memref.load %47[%c0] : memref<1xi32>
                    %49 = arith.cmpi slt, %46, %48 : i32
                    %50 = memref.load %45[] : memref<i1>
                    %51 = arith.andi %49, %50 : i1
                    cf.cond_br %51, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %52 = memref.load %45[] : memref<i1>
                    memref.store %52, %44[] : memref<i1>
                    %53 = memref.load %44[] : memref<i1>
                    scf.if %53 {
                      %56 = memref.load %11[] : memref<memref<?xf32>>
                      %57 = memref.load %0[%c0] : memref<1xi32>
                      %58 = memref.load %3[%c0] : memref<1xi32>
                      %59 = memref.load %47[%c0] : memref<1xi32>
                      %60 = arith.muli %58, %59 : i32
                      %61 = arith.addi %57, %60 : i32
                      %62 = memref.load %5[%c0] : memref<1xi32>
                      %63 = arith.muli %62, %59 : i32
                      %64 = memref.load %33[%c0] : memref<1xi32>
                      %65 = arith.muli %63, %64 : i32
                      %66 = arith.addi %61, %65 : i32
                      %67 = arith.index_cast %66 : i32 to index
                      %68 = memref.load %12[] : memref<memref<?xf32>>
                      %69 = arith.subi %62, %c1_i32 : i32
                      %70 = arith.muli %69, %59 : i32
                      %71 = arith.muli %70, %64 : i32
                      %72 = arith.addi %61, %71 : i32
                      %73 = arith.index_cast %72 : i32 to index
                      %74 = arith.addi %73, %c0 : index
                      %75 = memref.load %68[%74] : memref<?xf32>
                      %76 = arith.addi %67, %c0 : index
                      memref.store %75, %56[%76] : memref<?xf32>
                    }
                    %54 = memref.load %45[] : memref<i1>
                    memref.store %54, %44[] : memref<i1>
                    %55 = memref.load %44[] : memref<i1>
                    scf.if %55 {
                      %56 = memref.load %0[%c0] : memref<1xi32>
                      %57 = arith.addi %56, %c1_i32 : i32
                      memref.store %57, %0[%c0] : memref<1xi32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %40 = memref.load %31[] : memref<i1>
              memref.store %40, %30[] : memref<i1>
              %41 = memref.load %30[] : memref<i1>
              scf.if %41 {
                %42 = memref.load %3[%c0] : memref<1xi32>
                %43 = arith.addi %42, %c1_i32 : i32
                memref.store %43, %3[%c0] : memref<1xi32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %26 = memref.load %19[] : memref<i1>
        memref.store %26, %18[] : memref<i1>
        %27 = memref.load %18[] : memref<i1>
        scf.if %27 {
          %28 = memref.load %5[%c0] : memref<1xi32>
          %29 = arith.subi %28, %c1_i32 : i32
          memref.store %29, %5[%c0] : memref<1xi32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%80, %61, %81) : (f32, memref<?xf32>, index) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd96f14840) {
  %61 = "memref.load"(%15) : (memref<memref<?xf32>>) -> memref<?xf32>


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd96f147a0) {
  "memref.store"(%arg2, %15) : (memref<?xf32>, memref<memref<?xf32>>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd96f14700) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd96f18e10) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd96f18d30) {
  %18 = "arith.cmpi"(%3, %17) {predicate = 0 : i64} : (index, index) -> i1

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd96f14700) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
    ** Replace : 'scf.if'(0x7fbd96f14700)
    ** Erase   : 'scf.yield'(0x7fbd96f18e10)
"(anonymous namespace)::RemoveStaticCondition" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<1xi32>
  %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
  memref.store %2, %4[%c0] : memref<?xi32>
  %5 = memref.alloca() : memref<1xi32>
  %6 = memref.cast %5 : memref<1xi32> to memref<?xi32>
  memref.store %2, %6[%c0] : memref<?xi32>
  %7 = memref.alloca() : memref<1xi32>
  %8 = memref.cast %7 : memref<1xi32> to memref<?xi32>
  memref.store %2, %8[%c0] : memref<?xi32>
  %9 = memref.alloca() : memref<1xmemref<?xf32>>
  %10 = memref.cast %9 : memref<1xmemref<?xf32>> to memref<?xmemref<?xf32>>
  %11 = memref.alloca() : memref<memref<?xf32>>
  %12 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %12[] : memref<memref<?xf32>>
  %c0_0 = arith.constant 0 : index
  memref.store %arg2, %11[] : memref<memref<?xf32>>
  memref.store %arg3, %9[%c0] : memref<1xmemref<?xf32>>
  memref.store %arg4, %7[%c0] : memref<1xi32>
  %13 = memref.alloca() : memref<i1>
  memref.store %true, %13[] : memref<i1>
  %14 = memref.load %13[] : memref<i1>
  scf.if %14 {
    %15 = memref.load %13[] : memref<i1>
    scf.if %15 {
      scf.execute_region {
        %16 = memref.load %13[] : memref<i1>
        scf.if %16 {
          %27 = memref.get_global @kbm3 : memref<1xi32>
          %28 = memref.load %27[%c0] : memref<1xi32>
          memref.store %28, %5[%c0] : memref<1xi32>
        }
        %17 = memref.alloca() : memref<i1>
        %18 = memref.alloca() : memref<i1>
        memref.store %true, %18[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %19 = memref.load %5[%c0] : memref<1xi32>
        %20 = arith.cmpi sgt, %19, %c0_i32 : i32
        %21 = memref.load %18[] : memref<i1>
        %22 = arith.andi %20, %21 : i1
        cf.cond_br %22, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %23 = memref.load %18[] : memref<i1>
        memref.store %23, %17[] : memref<i1>
        %24 = memref.load %17[] : memref<i1>
        scf.if %24 {
          %27 = memref.load %17[] : memref<i1>
          scf.if %27 {
            scf.execute_region {
              %28 = memref.load %17[] : memref<i1>
              scf.if %28 {
                memref.store %c0_i32, %3[%c0] : memref<1xi32>
              }
              %29 = memref.alloca() : memref<i1>
              %30 = memref.alloca() : memref<i1>
              memref.store %true, %30[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %31 = memref.load %3[%c0] : memref<1xi32>
              %32 = memref.get_global @jm : memref<1xi32>
              %33 = memref.load %32[%c0] : memref<1xi32>
              %34 = arith.cmpi slt, %31, %33 : i32
              %35 = memref.load %30[] : memref<i1>
              %36 = arith.andi %34, %35 : i1
              cf.cond_br %36, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %37 = memref.load %30[] : memref<i1>
              memref.store %37, %29[] : memref<i1>
              %38 = memref.load %29[] : memref<i1>
              scf.if %38 {
                %41 = memref.load %29[] : memref<i1>
                scf.if %41 {
                  scf.execute_region {
                    %42 = memref.load %29[] : memref<i1>
                    scf.if %42 {
                      memref.store %c0_i32, %0[%c0] : memref<1xi32>
                    }
                    %43 = memref.alloca() : memref<i1>
                    %44 = memref.alloca() : memref<i1>
                    memref.store %true, %44[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %45 = memref.load %0[%c0] : memref<1xi32>
                    %46 = memref.get_global @im : memref<1xi32>
                    %47 = memref.load %46[%c0] : memref<1xi32>
                    %48 = arith.cmpi slt, %45, %47 : i32
                    %49 = memref.load %44[] : memref<i1>
                    %50 = arith.andi %48, %49 : i1
                    cf.cond_br %50, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %51 = memref.load %44[] : memref<i1>
                    memref.store %51, %43[] : memref<i1>
                    %52 = memref.load %43[] : memref<i1>
                    scf.if %52 {
                      %55 = memref.load %11[] : memref<memref<?xf32>>
                      %56 = memref.load %0[%c0] : memref<1xi32>
                      %57 = memref.load %3[%c0] : memref<1xi32>
                      %58 = memref.load %46[%c0] : memref<1xi32>
                      %59 = arith.muli %57, %58 : i32
                      %60 = arith.addi %56, %59 : i32
                      %61 = memref.load %5[%c0] : memref<1xi32>
                      %62 = arith.muli %61, %58 : i32
                      %63 = memref.load %32[%c0] : memref<1xi32>
                      %64 = arith.muli %62, %63 : i32
                      %65 = arith.addi %60, %64 : i32
                      %66 = arith.index_cast %65 : i32 to index
                      %67 = memref.load %12[] : memref<memref<?xf32>>
                      %68 = arith.subi %61, %c1_i32 : i32
                      %69 = arith.muli %68, %58 : i32
                      %70 = arith.muli %69, %63 : i32
                      %71 = arith.addi %60, %70 : i32
                      %72 = arith.index_cast %71 : i32 to index
                      %73 = arith.addi %72, %c0 : index
                      %74 = memref.load %67[%73] : memref<?xf32>
                      %75 = arith.addi %66, %c0 : index
                      memref.store %74, %55[%75] : memref<?xf32>
                    }
                    %53 = memref.load %44[] : memref<i1>
                    memref.store %53, %43[] : memref<i1>
                    %54 = memref.load %43[] : memref<i1>
                    scf.if %54 {
                      %55 = memref.load %0[%c0] : memref<1xi32>
                      %56 = arith.addi %55, %c1_i32 : i32
                      memref.store %56, %0[%c0] : memref<1xi32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %39 = memref.load %30[] : memref<i1>
              memref.store %39, %29[] : memref<i1>
              %40 = memref.load %29[] : memref<i1>
              scf.if %40 {
                %41 = memref.load %3[%c0] : memref<1xi32>
                %42 = arith.addi %41, %c1_i32 : i32
                memref.store %42, %3[%c0] : memref<1xi32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %25 = memref.load %18[] : memref<i1>
        memref.store %25, %17[] : memref<i1>
        %26 = memref.load %17[] : memref<i1>
        scf.if %26 {
          %27 = memref.load %5[%c0] : memref<1xi32>
          %28 = arith.subi %27, %c1_i32 : i32
          memref.store %28, %5[%c0] : memref<1xi32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd96f05c30) {
  %17 = "arith.constant"() {value = 0 : index} : () -> index

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd96f10380) {
  %15 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<memref<?xf32>>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%11 = memref.alloca() : memref<memref<?xf32>>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %arg2, %11[] : memref<memref<?xf32>>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.cast'(0x7fbd98165830) {
  %14 = "memref.cast"(%13) : (memref<1xmemref<?xf32>>) -> memref<?xmemref<?xf32>>

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd981657d0) {
  %13 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<1xmemref<?xf32>>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%9 = memref.alloca() : memref<1xmemref<?xf32>>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %arg3, %9[%c0] : memref<1xmemref<?xf32>>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
    ** Erase   : 'memref.store'(0x7fbd98165930)
    ** Erase   : 'memref.alloca'(0x7fbd981657d0)
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<1xi32>
  %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
  memref.store %2, %4[%c0] : memref<?xi32>
  %5 = memref.alloca() : memref<1xi32>
  %6 = memref.cast %5 : memref<1xi32> to memref<?xi32>
  memref.store %2, %6[%c0] : memref<?xi32>
  %7 = memref.alloca() : memref<1xi32>
  %8 = memref.cast %7 : memref<1xi32> to memref<?xi32>
  memref.store %2, %8[%c0] : memref<?xi32>
  %9 = memref.alloca() : memref<memref<?xf32>>
  %10 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %10[] : memref<memref<?xf32>>
  memref.store %arg2, %9[] : memref<memref<?xf32>>
  memref.store %arg4, %7[%c0] : memref<1xi32>
  %11 = memref.alloca() : memref<i1>
  memref.store %true, %11[] : memref<i1>
  %12 = memref.load %11[] : memref<i1>
  scf.if %12 {
    %13 = memref.load %11[] : memref<i1>
    scf.if %13 {
      scf.execute_region {
        %14 = memref.load %11[] : memref<i1>
        scf.if %14 {
          %25 = memref.get_global @kbm3 : memref<1xi32>
          %26 = memref.load %25[%c0] : memref<1xi32>
          memref.store %26, %5[%c0] : memref<1xi32>
        }
        %15 = memref.alloca() : memref<i1>
        %16 = memref.alloca() : memref<i1>
        memref.store %true, %16[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %17 = memref.load %5[%c0] : memref<1xi32>
        %18 = arith.cmpi sgt, %17, %c0_i32 : i32
        %19 = memref.load %16[] : memref<i1>
        %20 = arith.andi %18, %19 : i1
        cf.cond_br %20, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %21 = memref.load %16[] : memref<i1>
        memref.store %21, %15[] : memref<i1>
        %22 = memref.load %15[] : memref<i1>
        scf.if %22 {
          %25 = memref.load %15[] : memref<i1>
          scf.if %25 {
            scf.execute_region {
              %26 = memref.load %15[] : memref<i1>
              scf.if %26 {
                memref.store %c0_i32, %3[%c0] : memref<1xi32>
              }
              %27 = memref.alloca() : memref<i1>
              %28 = memref.alloca() : memref<i1>
              memref.store %true, %28[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %29 = memref.load %3[%c0] : memref<1xi32>
              %30 = memref.get_global @jm : memref<1xi32>
              %31 = memref.load %30[%c0] : memref<1xi32>
              %32 = arith.cmpi slt, %29, %31 : i32
              %33 = memref.load %28[] : memref<i1>
              %34 = arith.andi %32, %33 : i1
              cf.cond_br %34, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %35 = memref.load %28[] : memref<i1>
              memref.store %35, %27[] : memref<i1>
              %36 = memref.load %27[] : memref<i1>
              scf.if %36 {
                %39 = memref.load %27[] : memref<i1>
                scf.if %39 {
                  scf.execute_region {
                    %40 = memref.load %27[] : memref<i1>
                    scf.if %40 {
                      memref.store %c0_i32, %0[%c0] : memref<1xi32>
                    }
                    %41 = memref.alloca() : memref<i1>
                    %42 = memref.alloca() : memref<i1>
                    memref.store %true, %42[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %43 = memref.load %0[%c0] : memref<1xi32>
                    %44 = memref.get_global @im : memref<1xi32>
                    %45 = memref.load %44[%c0] : memref<1xi32>
                    %46 = arith.cmpi slt, %43, %45 : i32
                    %47 = memref.load %42[] : memref<i1>
                    %48 = arith.andi %46, %47 : i1
                    cf.cond_br %48, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %49 = memref.load %42[] : memref<i1>
                    memref.store %49, %41[] : memref<i1>
                    %50 = memref.load %41[] : memref<i1>
                    scf.if %50 {
                      %53 = memref.load %9[] : memref<memref<?xf32>>
                      %54 = memref.load %0[%c0] : memref<1xi32>
                      %55 = memref.load %3[%c0] : memref<1xi32>
                      %56 = memref.load %44[%c0] : memref<1xi32>
                      %57 = arith.muli %55, %56 : i32
                      %58 = arith.addi %54, %57 : i32
                      %59 = memref.load %5[%c0] : memref<1xi32>
                      %60 = arith.muli %59, %56 : i32
                      %61 = memref.load %30[%c0] : memref<1xi32>
                      %62 = arith.muli %60, %61 : i32
                      %63 = arith.addi %58, %62 : i32
                      %64 = arith.index_cast %63 : i32 to index
                      %65 = memref.load %10[] : memref<memref<?xf32>>
                      %66 = arith.subi %59, %c1_i32 : i32
                      %67 = arith.muli %66, %56 : i32
                      %68 = arith.muli %67, %61 : i32
                      %69 = arith.addi %58, %68 : i32
                      %70 = arith.index_cast %69 : i32 to index
                      %71 = arith.addi %70, %c0 : index
                      %72 = memref.load %65[%71] : memref<?xf32>
                      %73 = arith.addi %64, %c0 : index
                      memref.store %72, %53[%73] : memref<?xf32>
                    }
                    %51 = memref.load %42[] : memref<i1>
                    memref.store %51, %41[] : memref<i1>
                    %52 = memref.load %41[] : memref<i1>
                    scf.if %52 {
                      %53 = memref.load %0[%c0] : memref<1xi32>
                      %54 = arith.addi %53, %c1_i32 : i32
                      memref.store %54, %0[%c0] : memref<1xi32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %37 = memref.load %28[] : memref<i1>
              memref.store %37, %27[] : memref<i1>
              %38 = memref.load %27[] : memref<i1>
              scf.if %38 {
                %39 = memref.load %3[%c0] : memref<1xi32>
                %40 = arith.addi %39, %c1_i32 : i32
                memref.store %40, %3[%c0] : memref<1xi32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %23 = memref.load %16[] : memref<i1>
        memref.store %23, %15[] : memref<i1>
        %24 = memref.load %15[] : memref<i1>
        scf.if %24 {
          %25 = memref.load %5[%c0] : memref<1xi32>
          %26 = arith.subi %25, %c1_i32 : i32
          memref.store %26, %5[%c0] : memref<1xi32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd98165ef0) {
  "memref.store"(%6, %12, %3) : (i32, memref<?xi32>, index) -> ()

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.cast'(0x7fbd98165de0) {
  %12 = "memref.cast"(%11) : (memref<1xi32>) -> memref<?xi32>

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd98165d80) {
  %11 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<1xi32>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%7 = memref.alloca() : memref<1xi32>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %2, %7[%c0] : memref<1xi32>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
    ** Erase   : 'memref.store'(0x7fbd98165ef0)
    ** Erase   : 'memref.store'(0x7fbd98166030)
    ** Erase   : 'memref.alloca'(0x7fbd98165d80)
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<1xi32>
  %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
  memref.store %2, %4[%c0] : memref<?xi32>
  %5 = memref.alloca() : memref<1xi32>
  %6 = memref.cast %5 : memref<1xi32> to memref<?xi32>
  memref.store %2, %6[%c0] : memref<?xi32>
  %7 = memref.alloca() : memref<memref<?xf32>>
  %8 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %8[] : memref<memref<?xf32>>
  memref.store %arg2, %7[] : memref<memref<?xf32>>
  %9 = memref.alloca() : memref<i1>
  memref.store %true, %9[] : memref<i1>
  %10 = memref.load %9[] : memref<i1>
  scf.if %10 {
    %11 = memref.load %9[] : memref<i1>
    scf.if %11 {
      scf.execute_region {
        %12 = memref.load %9[] : memref<i1>
        scf.if %12 {
          %23 = memref.get_global @kbm3 : memref<1xi32>
          %24 = memref.load %23[%c0] : memref<1xi32>
          memref.store %24, %5[%c0] : memref<1xi32>
        }
        %13 = memref.alloca() : memref<i1>
        %14 = memref.alloca() : memref<i1>
        memref.store %true, %14[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %15 = memref.load %5[%c0] : memref<1xi32>
        %16 = arith.cmpi sgt, %15, %c0_i32 : i32
        %17 = memref.load %14[] : memref<i1>
        %18 = arith.andi %16, %17 : i1
        cf.cond_br %18, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %19 = memref.load %14[] : memref<i1>
        memref.store %19, %13[] : memref<i1>
        %20 = memref.load %13[] : memref<i1>
        scf.if %20 {
          %23 = memref.load %13[] : memref<i1>
          scf.if %23 {
            scf.execute_region {
              %24 = memref.load %13[] : memref<i1>
              scf.if %24 {
                memref.store %c0_i32, %3[%c0] : memref<1xi32>
              }
              %25 = memref.alloca() : memref<i1>
              %26 = memref.alloca() : memref<i1>
              memref.store %true, %26[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %27 = memref.load %3[%c0] : memref<1xi32>
              %28 = memref.get_global @jm : memref<1xi32>
              %29 = memref.load %28[%c0] : memref<1xi32>
              %30 = arith.cmpi slt, %27, %29 : i32
              %31 = memref.load %26[] : memref<i1>
              %32 = arith.andi %30, %31 : i1
              cf.cond_br %32, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %33 = memref.load %26[] : memref<i1>
              memref.store %33, %25[] : memref<i1>
              %34 = memref.load %25[] : memref<i1>
              scf.if %34 {
                %37 = memref.load %25[] : memref<i1>
                scf.if %37 {
                  scf.execute_region {
                    %38 = memref.load %25[] : memref<i1>
                    scf.if %38 {
                      memref.store %c0_i32, %0[%c0] : memref<1xi32>
                    }
                    %39 = memref.alloca() : memref<i1>
                    %40 = memref.alloca() : memref<i1>
                    memref.store %true, %40[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %41 = memref.load %0[%c0] : memref<1xi32>
                    %42 = memref.get_global @im : memref<1xi32>
                    %43 = memref.load %42[%c0] : memref<1xi32>
                    %44 = arith.cmpi slt, %41, %43 : i32
                    %45 = memref.load %40[] : memref<i1>
                    %46 = arith.andi %44, %45 : i1
                    cf.cond_br %46, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %47 = memref.load %40[] : memref<i1>
                    memref.store %47, %39[] : memref<i1>
                    %48 = memref.load %39[] : memref<i1>
                    scf.if %48 {
                      %51 = memref.load %7[] : memref<memref<?xf32>>
                      %52 = memref.load %0[%c0] : memref<1xi32>
                      %53 = memref.load %3[%c0] : memref<1xi32>
                      %54 = memref.load %42[%c0] : memref<1xi32>
                      %55 = arith.muli %53, %54 : i32
                      %56 = arith.addi %52, %55 : i32
                      %57 = memref.load %5[%c0] : memref<1xi32>
                      %58 = arith.muli %57, %54 : i32
                      %59 = memref.load %28[%c0] : memref<1xi32>
                      %60 = arith.muli %58, %59 : i32
                      %61 = arith.addi %56, %60 : i32
                      %62 = arith.index_cast %61 : i32 to index
                      %63 = memref.load %8[] : memref<memref<?xf32>>
                      %64 = arith.subi %57, %c1_i32 : i32
                      %65 = arith.muli %64, %54 : i32
                      %66 = arith.muli %65, %59 : i32
                      %67 = arith.addi %56, %66 : i32
                      %68 = arith.index_cast %67 : i32 to index
                      %69 = arith.addi %68, %c0 : index
                      %70 = memref.load %63[%69] : memref<?xf32>
                      %71 = arith.addi %62, %c0 : index
                      memref.store %70, %51[%71] : memref<?xf32>
                    }
                    %49 = memref.load %40[] : memref<i1>
                    memref.store %49, %39[] : memref<i1>
                    %50 = memref.load %39[] : memref<i1>
                    scf.if %50 {
                      %51 = memref.load %0[%c0] : memref<1xi32>
                      %52 = arith.addi %51, %c1_i32 : i32
                      memref.store %52, %0[%c0] : memref<1xi32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %35 = memref.load %26[] : memref<i1>
              memref.store %35, %25[] : memref<i1>
              %36 = memref.load %25[] : memref<i1>
              scf.if %36 {
                %37 = memref.load %3[%c0] : memref<1xi32>
                %38 = arith.addi %37, %c1_i32 : i32
                memref.store %38, %3[%c0] : memref<1xi32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %21 = memref.load %14[] : memref<i1>
        memref.store %21, %13[] : memref<i1>
        %22 = memref.load %13[] : memref<i1>
        scf.if %22 {
          %23 = memref.load %5[%c0] : memref<1xi32>
          %24 = arith.subi %23, %c1_i32 : i32
          memref.store %24, %5[%c0] : memref<1xi32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd98167720) {
  "memref.store"(%6, %10, %3) : (i32, memref<?xi32>, index) -> ()

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.cast'(0x7fbd98167610) {
  %10 = "memref.cast"(%9) : (memref<1xi32>) -> memref<?xi32>

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd981675b0) {
  %9 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<1xi32>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
    ** Insert  : 'memref.alloca'(0x7fbd9b1040e0)
    ** Insert  : 'arith.constant'(0x7fbd9b104090)
    ** Insert  : 'arith.cmpi'(0x7fbd9b104140)
    ** Insert  : 'scf.yield'(0x7fbd9800c3b0)
    ** Insert  : 'scf.if'(0x7fbd9800a880)
    ** Replace : 'memref.store'(0x7fbd98167720)
    ** Insert  : 'memref.store'(0x7fbd9800a750)
    ** Insert  : 'arith.constant'(0x7fbd9800c5d0)
    ** Insert  : 'arith.cmpi'(0x7fbd9800c130)
    ** Insert  : 'scf.yield'(0x7fbd9800a180)
    ** Insert  : 'scf.if'(0x7fbd9800ed20)
    ** Replace : 'memref.store'(0x7fbd98167860)
    ** Insert  : 'memref.store'(0x7fbd9800edc0)
    ** Insert  : 'memref.load'(0x7fbd9800ee60)
    ** Replace : 'memref.load'(0x7fbd98167df0)
    ** Insert  : 'memref.load'(0x7fbd9800eee0)
    ** Replace : 'memref.load'(0x7fbd9816c540)
    ** Insert  : 'memref.load'(0x7fbd9800ef60)
    ** Replace : 'memref.load'(0x7fbd9800c230)
    ** Insert  : 'arith.constant'(0x7fbd9800bbe0)
    ** Insert  : 'arith.cmpi'(0x7fbd9800c230)
    ** Insert  : 'scf.yield'(0x7fbd9800bde0)
    ** Insert  : 'scf.if'(0x7fbd9800efd0)
    ** Replace : 'memref.store'(0x7fbd9800c400)
    ** Insert  : 'memref.store'(0x7fbd9800f070)
    ** Erase   : 'memref.alloca'(0x7fbd981675b0)
"ConstantRankReduction" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<1xi32>
  %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
  memref.store %2, %4[%c0] : memref<?xi32>
  %5 = memref.alloca() : memref<i32>
  %c0_0 = arith.constant 0 : index
  %6 = arith.cmpi eq, %c0, %c0_0 : index
  scf.if %6 {
    memref.store %2, %5[] : memref<i32>
  }
  %7 = memref.alloca() : memref<memref<?xf32>>
  %8 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %8[] : memref<memref<?xf32>>
  memref.store %arg2, %7[] : memref<memref<?xf32>>
  %9 = memref.alloca() : memref<i1>
  memref.store %true, %9[] : memref<i1>
  %10 = memref.load %9[] : memref<i1>
  scf.if %10 {
    %11 = memref.load %9[] : memref<i1>
    scf.if %11 {
      scf.execute_region {
        %12 = memref.load %9[] : memref<i1>
        scf.if %12 {
          %23 = memref.get_global @kbm3 : memref<1xi32>
          %24 = memref.load %23[%c0] : memref<1xi32>
          %c0_1 = arith.constant 0 : index
          %25 = arith.cmpi eq, %c0, %c0_1 : index
          scf.if %25 {
            memref.store %24, %5[] : memref<i32>
          }
        }
        %13 = memref.alloca() : memref<i1>
        %14 = memref.alloca() : memref<i1>
        memref.store %true, %14[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %15 = memref.load %5[] : memref<i32>
        %16 = arith.cmpi sgt, %15, %c0_i32 : i32
        %17 = memref.load %14[] : memref<i1>
        %18 = arith.andi %16, %17 : i1
        cf.cond_br %18, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %19 = memref.load %14[] : memref<i1>
        memref.store %19, %13[] : memref<i1>
        %20 = memref.load %13[] : memref<i1>
        scf.if %20 {
          %23 = memref.load %13[] : memref<i1>
          scf.if %23 {
            scf.execute_region {
              %24 = memref.load %13[] : memref<i1>
              scf.if %24 {
                memref.store %c0_i32, %3[%c0] : memref<1xi32>
              }
              %25 = memref.alloca() : memref<i1>
              %26 = memref.alloca() : memref<i1>
              memref.store %true, %26[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %27 = memref.load %3[%c0] : memref<1xi32>
              %28 = memref.get_global @jm : memref<1xi32>
              %29 = memref.load %28[%c0] : memref<1xi32>
              %30 = arith.cmpi slt, %27, %29 : i32
              %31 = memref.load %26[] : memref<i1>
              %32 = arith.andi %30, %31 : i1
              cf.cond_br %32, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %33 = memref.load %26[] : memref<i1>
              memref.store %33, %25[] : memref<i1>
              %34 = memref.load %25[] : memref<i1>
              scf.if %34 {
                %37 = memref.load %25[] : memref<i1>
                scf.if %37 {
                  scf.execute_region {
                    %38 = memref.load %25[] : memref<i1>
                    scf.if %38 {
                      memref.store %c0_i32, %0[%c0] : memref<1xi32>
                    }
                    %39 = memref.alloca() : memref<i1>
                    %40 = memref.alloca() : memref<i1>
                    memref.store %true, %40[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %41 = memref.load %0[%c0] : memref<1xi32>
                    %42 = memref.get_global @im : memref<1xi32>
                    %43 = memref.load %42[%c0] : memref<1xi32>
                    %44 = arith.cmpi slt, %41, %43 : i32
                    %45 = memref.load %40[] : memref<i1>
                    %46 = arith.andi %44, %45 : i1
                    cf.cond_br %46, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %47 = memref.load %40[] : memref<i1>
                    memref.store %47, %39[] : memref<i1>
                    %48 = memref.load %39[] : memref<i1>
                    scf.if %48 {
                      %51 = memref.load %7[] : memref<memref<?xf32>>
                      %52 = memref.load %0[%c0] : memref<1xi32>
                      %53 = memref.load %3[%c0] : memref<1xi32>
                      %54 = memref.load %42[%c0] : memref<1xi32>
                      %55 = arith.muli %53, %54 : i32
                      %56 = arith.addi %52, %55 : i32
                      %57 = memref.load %5[] : memref<i32>
                      %58 = arith.muli %57, %54 : i32
                      %59 = memref.load %28[%c0] : memref<1xi32>
                      %60 = arith.muli %58, %59 : i32
                      %61 = arith.addi %56, %60 : i32
                      %62 = arith.index_cast %61 : i32 to index
                      %63 = memref.load %8[] : memref<memref<?xf32>>
                      %64 = arith.subi %57, %c1_i32 : i32
                      %65 = arith.muli %64, %54 : i32
                      %66 = arith.muli %65, %59 : i32
                      %67 = arith.addi %56, %66 : i32
                      %68 = arith.index_cast %67 : i32 to index
                      %69 = arith.addi %68, %c0 : index
                      %70 = memref.load %63[%69] : memref<?xf32>
                      %71 = arith.addi %62, %c0 : index
                      memref.store %70, %51[%71] : memref<?xf32>
                    }
                    %49 = memref.load %40[] : memref<i1>
                    memref.store %49, %39[] : memref<i1>
                    %50 = memref.load %39[] : memref<i1>
                    scf.if %50 {
                      %51 = memref.load %0[%c0] : memref<1xi32>
                      %52 = arith.addi %51, %c1_i32 : i32
                      memref.store %52, %0[%c0] : memref<1xi32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %35 = memref.load %26[] : memref<i1>
              memref.store %35, %25[] : memref<i1>
              %36 = memref.load %25[] : memref<i1>
              scf.if %36 {
                %37 = memref.load %3[%c0] : memref<1xi32>
                %38 = arith.addi %37, %c1_i32 : i32
                memref.store %38, %3[%c0] : memref<1xi32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %21 = memref.load %14[] : memref<i1>
        memref.store %21, %13[] : memref<i1>
        %22 = memref.load %13[] : memref<i1>
        scf.if %22 {
          %23 = memref.load %5[] : memref<i32>
          %24 = arith.subi %23, %c1_i32 : i32
          %c0_1 = arith.constant 0 : index
          %25 = arith.cmpi eq, %c0, %c0_1 : index
          scf.if %25 {
            memref.store %24, %5[] : memref<i32>
          }
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9800f070) {
  "memref.store"(%29, %9) : (i32, memref<i32>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9800efd0) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9800bde0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9800c230) {
  %31 = "arith.cmpi"(%3, %30) {predicate = 0 : i64} : (index, index) -> i1

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9800efd0) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
    ** Replace : 'scf.if'(0x7fbd9800efd0)
    ** Erase   : 'scf.yield'(0x7fbd9800bde0)
"(anonymous namespace)::RemoveStaticCondition" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<1xi32>
  %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
  memref.store %2, %4[%c0] : memref<?xi32>
  %5 = memref.alloca() : memref<i32>
  %c0_0 = arith.constant 0 : index
  %6 = arith.cmpi eq, %c0, %c0_0 : index
  scf.if %6 {
    memref.store %2, %5[] : memref<i32>
  }
  %7 = memref.alloca() : memref<memref<?xf32>>
  %8 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %8[] : memref<memref<?xf32>>
  memref.store %arg2, %7[] : memref<memref<?xf32>>
  %9 = memref.alloca() : memref<i1>
  memref.store %true, %9[] : memref<i1>
  %10 = memref.load %9[] : memref<i1>
  scf.if %10 {
    %11 = memref.load %9[] : memref<i1>
    scf.if %11 {
      scf.execute_region {
        %12 = memref.load %9[] : memref<i1>
        scf.if %12 {
          %23 = memref.get_global @kbm3 : memref<1xi32>
          %24 = memref.load %23[%c0] : memref<1xi32>
          %c0_1 = arith.constant 0 : index
          %25 = arith.cmpi eq, %c0, %c0_1 : index
          scf.if %25 {
            memref.store %24, %5[] : memref<i32>
          }
        }
        %13 = memref.alloca() : memref<i1>
        %14 = memref.alloca() : memref<i1>
        memref.store %true, %14[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %15 = memref.load %5[] : memref<i32>
        %16 = arith.cmpi sgt, %15, %c0_i32 : i32
        %17 = memref.load %14[] : memref<i1>
        %18 = arith.andi %16, %17 : i1
        cf.cond_br %18, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %19 = memref.load %14[] : memref<i1>
        memref.store %19, %13[] : memref<i1>
        %20 = memref.load %13[] : memref<i1>
        scf.if %20 {
          %23 = memref.load %13[] : memref<i1>
          scf.if %23 {
            scf.execute_region {
              %24 = memref.load %13[] : memref<i1>
              scf.if %24 {
                memref.store %c0_i32, %3[%c0] : memref<1xi32>
              }
              %25 = memref.alloca() : memref<i1>
              %26 = memref.alloca() : memref<i1>
              memref.store %true, %26[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %27 = memref.load %3[%c0] : memref<1xi32>
              %28 = memref.get_global @jm : memref<1xi32>
              %29 = memref.load %28[%c0] : memref<1xi32>
              %30 = arith.cmpi slt, %27, %29 : i32
              %31 = memref.load %26[] : memref<i1>
              %32 = arith.andi %30, %31 : i1
              cf.cond_br %32, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %33 = memref.load %26[] : memref<i1>
              memref.store %33, %25[] : memref<i1>
              %34 = memref.load %25[] : memref<i1>
              scf.if %34 {
                %37 = memref.load %25[] : memref<i1>
                scf.if %37 {
                  scf.execute_region {
                    %38 = memref.load %25[] : memref<i1>
                    scf.if %38 {
                      memref.store %c0_i32, %0[%c0] : memref<1xi32>
                    }
                    %39 = memref.alloca() : memref<i1>
                    %40 = memref.alloca() : memref<i1>
                    memref.store %true, %40[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %41 = memref.load %0[%c0] : memref<1xi32>
                    %42 = memref.get_global @im : memref<1xi32>
                    %43 = memref.load %42[%c0] : memref<1xi32>
                    %44 = arith.cmpi slt, %41, %43 : i32
                    %45 = memref.load %40[] : memref<i1>
                    %46 = arith.andi %44, %45 : i1
                    cf.cond_br %46, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %47 = memref.load %40[] : memref<i1>
                    memref.store %47, %39[] : memref<i1>
                    %48 = memref.load %39[] : memref<i1>
                    scf.if %48 {
                      %51 = memref.load %7[] : memref<memref<?xf32>>
                      %52 = memref.load %0[%c0] : memref<1xi32>
                      %53 = memref.load %3[%c0] : memref<1xi32>
                      %54 = memref.load %42[%c0] : memref<1xi32>
                      %55 = arith.muli %53, %54 : i32
                      %56 = arith.addi %52, %55 : i32
                      %57 = memref.load %5[] : memref<i32>
                      %58 = arith.muli %57, %54 : i32
                      %59 = memref.load %28[%c0] : memref<1xi32>
                      %60 = arith.muli %58, %59 : i32
                      %61 = arith.addi %56, %60 : i32
                      %62 = arith.index_cast %61 : i32 to index
                      %63 = memref.load %8[] : memref<memref<?xf32>>
                      %64 = arith.subi %57, %c1_i32 : i32
                      %65 = arith.muli %64, %54 : i32
                      %66 = arith.muli %65, %59 : i32
                      %67 = arith.addi %56, %66 : i32
                      %68 = arith.index_cast %67 : i32 to index
                      %69 = arith.addi %68, %c0 : index
                      %70 = memref.load %63[%69] : memref<?xf32>
                      %71 = arith.addi %62, %c0 : index
                      memref.store %70, %51[%71] : memref<?xf32>
                    }
                    %49 = memref.load %40[] : memref<i1>
                    memref.store %49, %39[] : memref<i1>
                    %50 = memref.load %39[] : memref<i1>
                    scf.if %50 {
                      %51 = memref.load %0[%c0] : memref<1xi32>
                      %52 = arith.addi %51, %c1_i32 : i32
                      memref.store %52, %0[%c0] : memref<1xi32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %35 = memref.load %26[] : memref<i1>
              memref.store %35, %25[] : memref<i1>
              %36 = memref.load %25[] : memref<i1>
              scf.if %36 {
                %37 = memref.load %3[%c0] : memref<1xi32>
                %38 = arith.addi %37, %c1_i32 : i32
                memref.store %38, %3[%c0] : memref<1xi32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %21 = memref.load %14[] : memref<i1>
        memref.store %21, %13[] : memref<i1>
        %22 = memref.load %13[] : memref<i1>
        scf.if %22 {
          %23 = memref.load %5[] : memref<i32>
          %24 = arith.subi %23, %c1_i32 : i32
          %c0_1 = arith.constant 0 : index
          memref.store %24, %5[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9800bbe0) {
  %30 = "arith.constant"() {value = 0 : index} : () -> index

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9800c320) {
  %29 = "arith.subi"(%28, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9800ef60) {
  %28 = "memref.load"(%9) : (memref<i32>) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %63 = "arith.muli"(%62, %59) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd983045d0) {
  %69 = "arith.subi"(%62, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9800eee0) {
  %62 = "memref.load"(%9) : (memref<i32>) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98168010) {
  %21 = "arith.cmpi"(%20, %2) {predicate = 4 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtUIOp type
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9800ee60) {
  %20 = "memref.load"(%9) : (memref<i32>) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9800edc0) {
  "memref.store"(%29, %9) : (i32, memref<i32>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98167510) {
  %29 = "memref.load"(%28, %3) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9800ed20) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9800a180) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9800c130) {
  %31 = "arith.cmpi"(%3, %30) {predicate = 0 : i64} : (index, index) -> i1

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9800ed20) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
    ** Replace : 'scf.if'(0x7fbd9800ed20)
    ** Erase   : 'scf.yield'(0x7fbd9800a180)
"(anonymous namespace)::RemoveStaticCondition" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<1xi32>
  %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
  memref.store %2, %4[%c0] : memref<?xi32>
  %5 = memref.alloca() : memref<i32>
  %c0_0 = arith.constant 0 : index
  %6 = arith.cmpi eq, %c0, %c0_0 : index
  scf.if %6 {
    memref.store %2, %5[] : memref<i32>
  }
  %7 = memref.alloca() : memref<memref<?xf32>>
  %8 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %8[] : memref<memref<?xf32>>
  memref.store %arg2, %7[] : memref<memref<?xf32>>
  %9 = memref.alloca() : memref<i1>
  memref.store %true, %9[] : memref<i1>
  %10 = memref.load %9[] : memref<i1>
  scf.if %10 {
    %11 = memref.load %9[] : memref<i1>
    scf.if %11 {
      scf.execute_region {
        %12 = memref.load %9[] : memref<i1>
        scf.if %12 {
          %23 = memref.get_global @kbm3 : memref<1xi32>
          %24 = memref.load %23[%c0] : memref<1xi32>
          %c0_1 = arith.constant 0 : index
          memref.store %24, %5[] : memref<i32>
        }
        %13 = memref.alloca() : memref<i1>
        %14 = memref.alloca() : memref<i1>
        memref.store %true, %14[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %15 = memref.load %5[] : memref<i32>
        %16 = arith.cmpi sgt, %15, %c0_i32 : i32
        %17 = memref.load %14[] : memref<i1>
        %18 = arith.andi %16, %17 : i1
        cf.cond_br %18, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %19 = memref.load %14[] : memref<i1>
        memref.store %19, %13[] : memref<i1>
        %20 = memref.load %13[] : memref<i1>
        scf.if %20 {
          %23 = memref.load %13[] : memref<i1>
          scf.if %23 {
            scf.execute_region {
              %24 = memref.load %13[] : memref<i1>
              scf.if %24 {
                memref.store %c0_i32, %3[%c0] : memref<1xi32>
              }
              %25 = memref.alloca() : memref<i1>
              %26 = memref.alloca() : memref<i1>
              memref.store %true, %26[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %27 = memref.load %3[%c0] : memref<1xi32>
              %28 = memref.get_global @jm : memref<1xi32>
              %29 = memref.load %28[%c0] : memref<1xi32>
              %30 = arith.cmpi slt, %27, %29 : i32
              %31 = memref.load %26[] : memref<i1>
              %32 = arith.andi %30, %31 : i1
              cf.cond_br %32, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %33 = memref.load %26[] : memref<i1>
              memref.store %33, %25[] : memref<i1>
              %34 = memref.load %25[] : memref<i1>
              scf.if %34 {
                %37 = memref.load %25[] : memref<i1>
                scf.if %37 {
                  scf.execute_region {
                    %38 = memref.load %25[] : memref<i1>
                    scf.if %38 {
                      memref.store %c0_i32, %0[%c0] : memref<1xi32>
                    }
                    %39 = memref.alloca() : memref<i1>
                    %40 = memref.alloca() : memref<i1>
                    memref.store %true, %40[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %41 = memref.load %0[%c0] : memref<1xi32>
                    %42 = memref.get_global @im : memref<1xi32>
                    %43 = memref.load %42[%c0] : memref<1xi32>
                    %44 = arith.cmpi slt, %41, %43 : i32
                    %45 = memref.load %40[] : memref<i1>
                    %46 = arith.andi %44, %45 : i1
                    cf.cond_br %46, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %47 = memref.load %40[] : memref<i1>
                    memref.store %47, %39[] : memref<i1>
                    %48 = memref.load %39[] : memref<i1>
                    scf.if %48 {
                      %51 = memref.load %7[] : memref<memref<?xf32>>
                      %52 = memref.load %0[%c0] : memref<1xi32>
                      %53 = memref.load %3[%c0] : memref<1xi32>
                      %54 = memref.load %42[%c0] : memref<1xi32>
                      %55 = arith.muli %53, %54 : i32
                      %56 = arith.addi %52, %55 : i32
                      %57 = memref.load %5[] : memref<i32>
                      %58 = arith.muli %57, %54 : i32
                      %59 = memref.load %28[%c0] : memref<1xi32>
                      %60 = arith.muli %58, %59 : i32
                      %61 = arith.addi %56, %60 : i32
                      %62 = arith.index_cast %61 : i32 to index
                      %63 = memref.load %8[] : memref<memref<?xf32>>
                      %64 = arith.subi %57, %c1_i32 : i32
                      %65 = arith.muli %64, %54 : i32
                      %66 = arith.muli %65, %59 : i32
                      %67 = arith.addi %56, %66 : i32
                      %68 = arith.index_cast %67 : i32 to index
                      %69 = arith.addi %68, %c0 : index
                      %70 = memref.load %63[%69] : memref<?xf32>
                      %71 = arith.addi %62, %c0 : index
                      memref.store %70, %51[%71] : memref<?xf32>
                    }
                    %49 = memref.load %40[] : memref<i1>
                    memref.store %49, %39[] : memref<i1>
                    %50 = memref.load %39[] : memref<i1>
                    scf.if %50 {
                      %51 = memref.load %0[%c0] : memref<1xi32>
                      %52 = arith.addi %51, %c1_i32 : i32
                      memref.store %52, %0[%c0] : memref<1xi32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %35 = memref.load %26[] : memref<i1>
              memref.store %35, %25[] : memref<i1>
              %36 = memref.load %25[] : memref<i1>
              scf.if %36 {
                %37 = memref.load %3[%c0] : memref<1xi32>
                %38 = arith.addi %37, %c1_i32 : i32
                memref.store %38, %3[%c0] : memref<1xi32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %21 = memref.load %14[] : memref<i1>
        memref.store %21, %13[] : memref<i1>
        %22 = memref.load %13[] : memref<i1>
        scf.if %22 {
          %23 = memref.load %5[] : memref<i32>
          %24 = arith.subi %23, %c1_i32 : i32
          memref.store %24, %5[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9800c5d0) {
  %30 = "arith.constant"() {value = 0 : index} : () -> index

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9800a750) {
  "memref.store"(%6, %9) : (i32, memref<i32>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9800a880) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9800c3b0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9b104140) {
  %11 = "arith.cmpi"(%3, %10) {predicate = 0 : i64} : (index, index) -> i1

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9800a880) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
    ** Replace : 'scf.if'(0x7fbd9800a880)
    ** Erase   : 'scf.yield'(0x7fbd9800c3b0)
"(anonymous namespace)::RemoveStaticCondition" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<1xi32>
  %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
  memref.store %2, %4[%c0] : memref<?xi32>
  %5 = memref.alloca() : memref<i32>
  %c0_0 = arith.constant 0 : index
  memref.store %2, %5[] : memref<i32>
  %6 = memref.alloca() : memref<memref<?xf32>>
  %7 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %7[] : memref<memref<?xf32>>
  memref.store %arg2, %6[] : memref<memref<?xf32>>
  %8 = memref.alloca() : memref<i1>
  memref.store %true, %8[] : memref<i1>
  %9 = memref.load %8[] : memref<i1>
  scf.if %9 {
    %10 = memref.load %8[] : memref<i1>
    scf.if %10 {
      scf.execute_region {
        %11 = memref.load %8[] : memref<i1>
        scf.if %11 {
          %22 = memref.get_global @kbm3 : memref<1xi32>
          %23 = memref.load %22[%c0] : memref<1xi32>
          memref.store %23, %5[] : memref<i32>
        }
        %12 = memref.alloca() : memref<i1>
        %13 = memref.alloca() : memref<i1>
        memref.store %true, %13[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %14 = memref.load %5[] : memref<i32>
        %15 = arith.cmpi sgt, %14, %c0_i32 : i32
        %16 = memref.load %13[] : memref<i1>
        %17 = arith.andi %15, %16 : i1
        cf.cond_br %17, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %18 = memref.load %13[] : memref<i1>
        memref.store %18, %12[] : memref<i1>
        %19 = memref.load %12[] : memref<i1>
        scf.if %19 {
          %22 = memref.load %12[] : memref<i1>
          scf.if %22 {
            scf.execute_region {
              %23 = memref.load %12[] : memref<i1>
              scf.if %23 {
                memref.store %c0_i32, %3[%c0] : memref<1xi32>
              }
              %24 = memref.alloca() : memref<i1>
              %25 = memref.alloca() : memref<i1>
              memref.store %true, %25[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %26 = memref.load %3[%c0] : memref<1xi32>
              %27 = memref.get_global @jm : memref<1xi32>
              %28 = memref.load %27[%c0] : memref<1xi32>
              %29 = arith.cmpi slt, %26, %28 : i32
              %30 = memref.load %25[] : memref<i1>
              %31 = arith.andi %29, %30 : i1
              cf.cond_br %31, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %32 = memref.load %25[] : memref<i1>
              memref.store %32, %24[] : memref<i1>
              %33 = memref.load %24[] : memref<i1>
              scf.if %33 {
                %36 = memref.load %24[] : memref<i1>
                scf.if %36 {
                  scf.execute_region {
                    %37 = memref.load %24[] : memref<i1>
                    scf.if %37 {
                      memref.store %c0_i32, %0[%c0] : memref<1xi32>
                    }
                    %38 = memref.alloca() : memref<i1>
                    %39 = memref.alloca() : memref<i1>
                    memref.store %true, %39[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %40 = memref.load %0[%c0] : memref<1xi32>
                    %41 = memref.get_global @im : memref<1xi32>
                    %42 = memref.load %41[%c0] : memref<1xi32>
                    %43 = arith.cmpi slt, %40, %42 : i32
                    %44 = memref.load %39[] : memref<i1>
                    %45 = arith.andi %43, %44 : i1
                    cf.cond_br %45, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %46 = memref.load %39[] : memref<i1>
                    memref.store %46, %38[] : memref<i1>
                    %47 = memref.load %38[] : memref<i1>
                    scf.if %47 {
                      %50 = memref.load %6[] : memref<memref<?xf32>>
                      %51 = memref.load %0[%c0] : memref<1xi32>
                      %52 = memref.load %3[%c0] : memref<1xi32>
                      %53 = memref.load %41[%c0] : memref<1xi32>
                      %54 = arith.muli %52, %53 : i32
                      %55 = arith.addi %51, %54 : i32
                      %56 = memref.load %5[] : memref<i32>
                      %57 = arith.muli %56, %53 : i32
                      %58 = memref.load %27[%c0] : memref<1xi32>
                      %59 = arith.muli %57, %58 : i32
                      %60 = arith.addi %55, %59 : i32
                      %61 = arith.index_cast %60 : i32 to index
                      %62 = memref.load %7[] : memref<memref<?xf32>>
                      %63 = arith.subi %56, %c1_i32 : i32
                      %64 = arith.muli %63, %53 : i32
                      %65 = arith.muli %64, %58 : i32
                      %66 = arith.addi %55, %65 : i32
                      %67 = arith.index_cast %66 : i32 to index
                      %68 = arith.addi %67, %c0 : index
                      %69 = memref.load %62[%68] : memref<?xf32>
                      %70 = arith.addi %61, %c0 : index
                      memref.store %69, %50[%70] : memref<?xf32>
                    }
                    %48 = memref.load %39[] : memref<i1>
                    memref.store %48, %38[] : memref<i1>
                    %49 = memref.load %38[] : memref<i1>
                    scf.if %49 {
                      %50 = memref.load %0[%c0] : memref<1xi32>
                      %51 = arith.addi %50, %c1_i32 : i32
                      memref.store %51, %0[%c0] : memref<1xi32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %34 = memref.load %25[] : memref<i1>
              memref.store %34, %24[] : memref<i1>
              %35 = memref.load %24[] : memref<i1>
              scf.if %35 {
                %36 = memref.load %3[%c0] : memref<1xi32>
                %37 = arith.addi %36, %c1_i32 : i32
                memref.store %37, %3[%c0] : memref<1xi32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %20 = memref.load %13[] : memref<i1>
        memref.store %20, %12[] : memref<i1>
        %21 = memref.load %12[] : memref<i1>
        scf.if %21 {
          %22 = memref.load %5[] : memref<i32>
          %23 = arith.subi %22, %c1_i32 : i32
          memref.store %23, %5[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b104090) {
  %10 = "arith.constant"() {value = 0 : index} : () -> index

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd9b1040e0) {
  %9 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<i32>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%5 = memref.alloca() : memref<i32>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %23, %5[] : memref<i32>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd98169220) {
  "memref.store"(%6, %8, %3) : (i32, memref<?xi32>, index) -> ()

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.cast'(0x7fbd98169110) {
  %8 = "memref.cast"(%7) : (memref<1xi32>) -> memref<?xi32>

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd981690b0) {
  %7 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<1xi32>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
    ** Insert  : 'memref.alloca'(0x7fbd9b304300)
    ** Insert  : 'arith.constant'(0x7fbd9b3040f0)
    ** Insert  : 'arith.cmpi'(0x7fbd9b304140)
    ** Insert  : 'scf.yield'(0x7fbd9b304220)
    ** Insert  : 'scf.if'(0x7fbd9b304480)
    ** Replace : 'memref.store'(0x7fbd98169220)
    ** Insert  : 'memref.store'(0x7fbd9b304520)
    ** Insert  : 'arith.constant'(0x7fbd9b3045c0)
    ** Insert  : 'arith.cmpi'(0x7fbd9b304610)
    ** Insert  : 'scf.yield'(0x7fbd9b3046f0)
    ** Insert  : 'scf.if'(0x7fbd9b304740)
    ** Replace : 'memref.store'(0x7fbd98169320)
    ** Insert  : 'memref.store'(0x7fbd9b3047e0)
    ** Insert  : 'memref.load'(0x7fbd9b304880)
    ** Replace : 'memref.load'(0x7fbd98169780)
    ** Insert  : 'memref.load'(0x7fbd9800ed30)
    ** Replace : 'memref.load'(0x7fbd9816c150)
    ** Insert  : 'memref.load'(0x7fbd9800efe0)
    ** Replace : 'memref.load'(0x7fbd9800baa0)
    ** Insert  : 'arith.constant'(0x7fbd9800c5d0)
    ** Insert  : 'arith.cmpi'(0x7fbd9800baa0)
    ** Insert  : 'scf.yield'(0x7fbd9800bcd0)
    ** Insert  : 'scf.if'(0x7fbd9800a880)
    ** Replace : 'memref.store'(0x7fbd9800bc20)
    ** Insert  : 'memref.store'(0x7fbd9800c3b0)
    ** Erase   : 'memref.alloca'(0x7fbd981690b0)
"ConstantRankReduction" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<i32>
  %c0_0 = arith.constant 0 : index
  %4 = arith.cmpi eq, %c0, %c0_0 : index
  scf.if %4 {
    memref.store %2, %3[] : memref<i32>
  }
  %5 = memref.alloca() : memref<i32>
  memref.store %2, %5[] : memref<i32>
  %6 = memref.alloca() : memref<memref<?xf32>>
  %7 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %7[] : memref<memref<?xf32>>
  memref.store %arg2, %6[] : memref<memref<?xf32>>
  %8 = memref.alloca() : memref<i1>
  memref.store %true, %8[] : memref<i1>
  %9 = memref.load %8[] : memref<i1>
  scf.if %9 {
    %10 = memref.load %8[] : memref<i1>
    scf.if %10 {
      scf.execute_region {
        %11 = memref.load %8[] : memref<i1>
        scf.if %11 {
          %22 = memref.get_global @kbm3 : memref<1xi32>
          %23 = memref.load %22[%c0] : memref<1xi32>
          memref.store %23, %5[] : memref<i32>
        }
        %12 = memref.alloca() : memref<i1>
        %13 = memref.alloca() : memref<i1>
        memref.store %true, %13[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %14 = memref.load %5[] : memref<i32>
        %15 = arith.cmpi sgt, %14, %c0_i32 : i32
        %16 = memref.load %13[] : memref<i1>
        %17 = arith.andi %15, %16 : i1
        cf.cond_br %17, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %18 = memref.load %13[] : memref<i1>
        memref.store %18, %12[] : memref<i1>
        %19 = memref.load %12[] : memref<i1>
        scf.if %19 {
          %22 = memref.load %12[] : memref<i1>
          scf.if %22 {
            scf.execute_region {
              %23 = memref.load %12[] : memref<i1>
              scf.if %23 {
                %c0_1 = arith.constant 0 : index
                %36 = arith.cmpi eq, %c0, %c0_1 : index
                scf.if %36 {
                  memref.store %c0_i32, %3[] : memref<i32>
                }
              }
              %24 = memref.alloca() : memref<i1>
              %25 = memref.alloca() : memref<i1>
              memref.store %true, %25[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %26 = memref.load %3[] : memref<i32>
              %27 = memref.get_global @jm : memref<1xi32>
              %28 = memref.load %27[%c0] : memref<1xi32>
              %29 = arith.cmpi slt, %26, %28 : i32
              %30 = memref.load %25[] : memref<i1>
              %31 = arith.andi %29, %30 : i1
              cf.cond_br %31, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %32 = memref.load %25[] : memref<i1>
              memref.store %32, %24[] : memref<i1>
              %33 = memref.load %24[] : memref<i1>
              scf.if %33 {
                %36 = memref.load %24[] : memref<i1>
                scf.if %36 {
                  scf.execute_region {
                    %37 = memref.load %24[] : memref<i1>
                    scf.if %37 {
                      memref.store %c0_i32, %0[%c0] : memref<1xi32>
                    }
                    %38 = memref.alloca() : memref<i1>
                    %39 = memref.alloca() : memref<i1>
                    memref.store %true, %39[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %40 = memref.load %0[%c0] : memref<1xi32>
                    %41 = memref.get_global @im : memref<1xi32>
                    %42 = memref.load %41[%c0] : memref<1xi32>
                    %43 = arith.cmpi slt, %40, %42 : i32
                    %44 = memref.load %39[] : memref<i1>
                    %45 = arith.andi %43, %44 : i1
                    cf.cond_br %45, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %46 = memref.load %39[] : memref<i1>
                    memref.store %46, %38[] : memref<i1>
                    %47 = memref.load %38[] : memref<i1>
                    scf.if %47 {
                      %50 = memref.load %6[] : memref<memref<?xf32>>
                      %51 = memref.load %0[%c0] : memref<1xi32>
                      %52 = memref.load %3[] : memref<i32>
                      %53 = memref.load %41[%c0] : memref<1xi32>
                      %54 = arith.muli %52, %53 : i32
                      %55 = arith.addi %51, %54 : i32
                      %56 = memref.load %5[] : memref<i32>
                      %57 = arith.muli %56, %53 : i32
                      %58 = memref.load %27[%c0] : memref<1xi32>
                      %59 = arith.muli %57, %58 : i32
                      %60 = arith.addi %55, %59 : i32
                      %61 = arith.index_cast %60 : i32 to index
                      %62 = memref.load %7[] : memref<memref<?xf32>>
                      %63 = arith.subi %56, %c1_i32 : i32
                      %64 = arith.muli %63, %53 : i32
                      %65 = arith.muli %64, %58 : i32
                      %66 = arith.addi %55, %65 : i32
                      %67 = arith.index_cast %66 : i32 to index
                      %68 = arith.addi %67, %c0 : index
                      %69 = memref.load %62[%68] : memref<?xf32>
                      %70 = arith.addi %61, %c0 : index
                      memref.store %69, %50[%70] : memref<?xf32>
                    }
                    %48 = memref.load %39[] : memref<i1>
                    memref.store %48, %38[] : memref<i1>
                    %49 = memref.load %38[] : memref<i1>
                    scf.if %49 {
                      %50 = memref.load %0[%c0] : memref<1xi32>
                      %51 = arith.addi %50, %c1_i32 : i32
                      memref.store %51, %0[%c0] : memref<1xi32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %34 = memref.load %25[] : memref<i1>
              memref.store %34, %24[] : memref<i1>
              %35 = memref.load %24[] : memref<i1>
              scf.if %35 {
                %36 = memref.load %3[] : memref<i32>
                %37 = arith.addi %36, %c1_i32 : i32
                %c0_1 = arith.constant 0 : index
                %38 = arith.cmpi eq, %c0, %c0_1 : index
                scf.if %38 {
                  memref.store %37, %3[] : memref<i32>
                }
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %20 = memref.load %13[] : memref<i1>
        memref.store %20, %12[] : memref<i1>
        %21 = memref.load %12[] : memref<i1>
        scf.if %21 {
          %22 = memref.load %5[] : memref<i32>
          %23 = arith.subi %22, %c1_i32 : i32
          memref.store %23, %5[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9800c3b0) {
  "memref.store"(%42, %7) : (i32, memref<i32>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9800a880) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9800bcd0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9800baa0) {
  %44 = "arith.cmpi"(%3, %43) {predicate = 0 : i64} : (index, index) -> i1

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9800a880) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
    ** Replace : 'scf.if'(0x7fbd9800a880)
    ** Erase   : 'scf.yield'(0x7fbd9800bcd0)
"(anonymous namespace)::RemoveStaticCondition" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<i32>
  %c0_0 = arith.constant 0 : index
  %4 = arith.cmpi eq, %c0, %c0_0 : index
  scf.if %4 {
    memref.store %2, %3[] : memref<i32>
  }
  %5 = memref.alloca() : memref<i32>
  memref.store %2, %5[] : memref<i32>
  %6 = memref.alloca() : memref<memref<?xf32>>
  %7 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %7[] : memref<memref<?xf32>>
  memref.store %arg2, %6[] : memref<memref<?xf32>>
  %8 = memref.alloca() : memref<i1>
  memref.store %true, %8[] : memref<i1>
  %9 = memref.load %8[] : memref<i1>
  scf.if %9 {
    %10 = memref.load %8[] : memref<i1>
    scf.if %10 {
      scf.execute_region {
        %11 = memref.load %8[] : memref<i1>
        scf.if %11 {
          %22 = memref.get_global @kbm3 : memref<1xi32>
          %23 = memref.load %22[%c0] : memref<1xi32>
          memref.store %23, %5[] : memref<i32>
        }
        %12 = memref.alloca() : memref<i1>
        %13 = memref.alloca() : memref<i1>
        memref.store %true, %13[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %14 = memref.load %5[] : memref<i32>
        %15 = arith.cmpi sgt, %14, %c0_i32 : i32
        %16 = memref.load %13[] : memref<i1>
        %17 = arith.andi %15, %16 : i1
        cf.cond_br %17, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %18 = memref.load %13[] : memref<i1>
        memref.store %18, %12[] : memref<i1>
        %19 = memref.load %12[] : memref<i1>
        scf.if %19 {
          %22 = memref.load %12[] : memref<i1>
          scf.if %22 {
            scf.execute_region {
              %23 = memref.load %12[] : memref<i1>
              scf.if %23 {
                %c0_1 = arith.constant 0 : index
                %36 = arith.cmpi eq, %c0, %c0_1 : index
                scf.if %36 {
                  memref.store %c0_i32, %3[] : memref<i32>
                }
              }
              %24 = memref.alloca() : memref<i1>
              %25 = memref.alloca() : memref<i1>
              memref.store %true, %25[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %26 = memref.load %3[] : memref<i32>
              %27 = memref.get_global @jm : memref<1xi32>
              %28 = memref.load %27[%c0] : memref<1xi32>
              %29 = arith.cmpi slt, %26, %28 : i32
              %30 = memref.load %25[] : memref<i1>
              %31 = arith.andi %29, %30 : i1
              cf.cond_br %31, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %32 = memref.load %25[] : memref<i1>
              memref.store %32, %24[] : memref<i1>
              %33 = memref.load %24[] : memref<i1>
              scf.if %33 {
                %36 = memref.load %24[] : memref<i1>
                scf.if %36 {
                  scf.execute_region {
                    %37 = memref.load %24[] : memref<i1>
                    scf.if %37 {
                      memref.store %c0_i32, %0[%c0] : memref<1xi32>
                    }
                    %38 = memref.alloca() : memref<i1>
                    %39 = memref.alloca() : memref<i1>
                    memref.store %true, %39[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %40 = memref.load %0[%c0] : memref<1xi32>
                    %41 = memref.get_global @im : memref<1xi32>
                    %42 = memref.load %41[%c0] : memref<1xi32>
                    %43 = arith.cmpi slt, %40, %42 : i32
                    %44 = memref.load %39[] : memref<i1>
                    %45 = arith.andi %43, %44 : i1
                    cf.cond_br %45, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %46 = memref.load %39[] : memref<i1>
                    memref.store %46, %38[] : memref<i1>
                    %47 = memref.load %38[] : memref<i1>
                    scf.if %47 {
                      %50 = memref.load %6[] : memref<memref<?xf32>>
                      %51 = memref.load %0[%c0] : memref<1xi32>
                      %52 = memref.load %3[] : memref<i32>
                      %53 = memref.load %41[%c0] : memref<1xi32>
                      %54 = arith.muli %52, %53 : i32
                      %55 = arith.addi %51, %54 : i32
                      %56 = memref.load %5[] : memref<i32>
                      %57 = arith.muli %56, %53 : i32
                      %58 = memref.load %27[%c0] : memref<1xi32>
                      %59 = arith.muli %57, %58 : i32
                      %60 = arith.addi %55, %59 : i32
                      %61 = arith.index_cast %60 : i32 to index
                      %62 = memref.load %7[] : memref<memref<?xf32>>
                      %63 = arith.subi %56, %c1_i32 : i32
                      %64 = arith.muli %63, %53 : i32
                      %65 = arith.muli %64, %58 : i32
                      %66 = arith.addi %55, %65 : i32
                      %67 = arith.index_cast %66 : i32 to index
                      %68 = arith.addi %67, %c0 : index
                      %69 = memref.load %62[%68] : memref<?xf32>
                      %70 = arith.addi %61, %c0 : index
                      memref.store %69, %50[%70] : memref<?xf32>
                    }
                    %48 = memref.load %39[] : memref<i1>
                    memref.store %48, %38[] : memref<i1>
                    %49 = memref.load %38[] : memref<i1>
                    scf.if %49 {
                      %50 = memref.load %0[%c0] : memref<1xi32>
                      %51 = arith.addi %50, %c1_i32 : i32
                      memref.store %51, %0[%c0] : memref<1xi32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %34 = memref.load %25[] : memref<i1>
              memref.store %34, %24[] : memref<i1>
              %35 = memref.load %24[] : memref<i1>
              scf.if %35 {
                %36 = memref.load %3[] : memref<i32>
                %37 = arith.addi %36, %c1_i32 : i32
                %c0_1 = arith.constant 0 : index
                memref.store %37, %3[] : memref<i32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %20 = memref.load %13[] : memref<i1>
        memref.store %20, %12[] : memref<i1>
        %21 = memref.load %12[] : memref<i1>
        scf.if %21 {
          %22 = memref.load %5[] : memref<i32>
          %23 = arith.subi %22, %c1_i32 : i32
          memref.store %23, %5[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9800c5d0) {
  %43 = "arith.constant"() {value = 0 : index} : () -> index

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %42 = "arith.addi"(%41, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9800efe0) {
  %41 = "memref.load"(%7) : (memref<i32>) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %59 = "arith.muli"(%57, %58) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9800ed30) {
  %57 = "memref.load"(%7) : (memref<i32>) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %34 = "arith.cmpi"(%31, %33) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtUIOp type
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b304880) {
  %31 = "memref.load"(%7) : (memref<i32>) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9b3047e0) {
  "memref.store"(%2, %7) : (i32, memref<i32>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b304740) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b3046f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9b304610) {
  %42 = "arith.cmpi"(%3, %41) {predicate = 0 : i64} : (index, index) -> i1

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b304740) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
    ** Replace : 'scf.if'(0x7fbd9b304740)
    ** Erase   : 'scf.yield'(0x7fbd9b3046f0)
"(anonymous namespace)::RemoveStaticCondition" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<i32>
  %c0_0 = arith.constant 0 : index
  %4 = arith.cmpi eq, %c0, %c0_0 : index
  scf.if %4 {
    memref.store %2, %3[] : memref<i32>
  }
  %5 = memref.alloca() : memref<i32>
  memref.store %2, %5[] : memref<i32>
  %6 = memref.alloca() : memref<memref<?xf32>>
  %7 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %7[] : memref<memref<?xf32>>
  memref.store %arg2, %6[] : memref<memref<?xf32>>
  %8 = memref.alloca() : memref<i1>
  memref.store %true, %8[] : memref<i1>
  %9 = memref.load %8[] : memref<i1>
  scf.if %9 {
    %10 = memref.load %8[] : memref<i1>
    scf.if %10 {
      scf.execute_region {
        %11 = memref.load %8[] : memref<i1>
        scf.if %11 {
          %22 = memref.get_global @kbm3 : memref<1xi32>
          %23 = memref.load %22[%c0] : memref<1xi32>
          memref.store %23, %5[] : memref<i32>
        }
        %12 = memref.alloca() : memref<i1>
        %13 = memref.alloca() : memref<i1>
        memref.store %true, %13[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %14 = memref.load %5[] : memref<i32>
        %15 = arith.cmpi sgt, %14, %c0_i32 : i32
        %16 = memref.load %13[] : memref<i1>
        %17 = arith.andi %15, %16 : i1
        cf.cond_br %17, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %18 = memref.load %13[] : memref<i1>
        memref.store %18, %12[] : memref<i1>
        %19 = memref.load %12[] : memref<i1>
        scf.if %19 {
          %22 = memref.load %12[] : memref<i1>
          scf.if %22 {
            scf.execute_region {
              %23 = memref.load %12[] : memref<i1>
              scf.if %23 {
                %c0_1 = arith.constant 0 : index
                memref.store %c0_i32, %3[] : memref<i32>
              }
              %24 = memref.alloca() : memref<i1>
              %25 = memref.alloca() : memref<i1>
              memref.store %true, %25[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %26 = memref.load %3[] : memref<i32>
              %27 = memref.get_global @jm : memref<1xi32>
              %28 = memref.load %27[%c0] : memref<1xi32>
              %29 = arith.cmpi slt, %26, %28 : i32
              %30 = memref.load %25[] : memref<i1>
              %31 = arith.andi %29, %30 : i1
              cf.cond_br %31, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %32 = memref.load %25[] : memref<i1>
              memref.store %32, %24[] : memref<i1>
              %33 = memref.load %24[] : memref<i1>
              scf.if %33 {
                %36 = memref.load %24[] : memref<i1>
                scf.if %36 {
                  scf.execute_region {
                    %37 = memref.load %24[] : memref<i1>
                    scf.if %37 {
                      memref.store %c0_i32, %0[%c0] : memref<1xi32>
                    }
                    %38 = memref.alloca() : memref<i1>
                    %39 = memref.alloca() : memref<i1>
                    memref.store %true, %39[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %40 = memref.load %0[%c0] : memref<1xi32>
                    %41 = memref.get_global @im : memref<1xi32>
                    %42 = memref.load %41[%c0] : memref<1xi32>
                    %43 = arith.cmpi slt, %40, %42 : i32
                    %44 = memref.load %39[] : memref<i1>
                    %45 = arith.andi %43, %44 : i1
                    cf.cond_br %45, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %46 = memref.load %39[] : memref<i1>
                    memref.store %46, %38[] : memref<i1>
                    %47 = memref.load %38[] : memref<i1>
                    scf.if %47 {
                      %50 = memref.load %6[] : memref<memref<?xf32>>
                      %51 = memref.load %0[%c0] : memref<1xi32>
                      %52 = memref.load %3[] : memref<i32>
                      %53 = memref.load %41[%c0] : memref<1xi32>
                      %54 = arith.muli %52, %53 : i32
                      %55 = arith.addi %51, %54 : i32
                      %56 = memref.load %5[] : memref<i32>
                      %57 = arith.muli %56, %53 : i32
                      %58 = memref.load %27[%c0] : memref<1xi32>
                      %59 = arith.muli %57, %58 : i32
                      %60 = arith.addi %55, %59 : i32
                      %61 = arith.index_cast %60 : i32 to index
                      %62 = memref.load %7[] : memref<memref<?xf32>>
                      %63 = arith.subi %56, %c1_i32 : i32
                      %64 = arith.muli %63, %53 : i32
                      %65 = arith.muli %64, %58 : i32
                      %66 = arith.addi %55, %65 : i32
                      %67 = arith.index_cast %66 : i32 to index
                      %68 = arith.addi %67, %c0 : index
                      %69 = memref.load %62[%68] : memref<?xf32>
                      %70 = arith.addi %61, %c0 : index
                      memref.store %69, %50[%70] : memref<?xf32>
                    }
                    %48 = memref.load %39[] : memref<i1>
                    memref.store %48, %38[] : memref<i1>
                    %49 = memref.load %38[] : memref<i1>
                    scf.if %49 {
                      %50 = memref.load %0[%c0] : memref<1xi32>
                      %51 = arith.addi %50, %c1_i32 : i32
                      memref.store %51, %0[%c0] : memref<1xi32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %34 = memref.load %25[] : memref<i1>
              memref.store %34, %24[] : memref<i1>
              %35 = memref.load %24[] : memref<i1>
              scf.if %35 {
                %36 = memref.load %3[] : memref<i32>
                %37 = arith.addi %36, %c1_i32 : i32
                memref.store %37, %3[] : memref<i32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %20 = memref.load %13[] : memref<i1>
        memref.store %20, %12[] : memref<i1>
        %21 = memref.load %12[] : memref<i1>
        scf.if %21 {
          %22 = memref.load %5[] : memref<i32>
          %23 = arith.subi %22, %c1_i32 : i32
          memref.store %23, %5[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b3045c0) {
  %41 = "arith.constant"() {value = 0 : index} : () -> index

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9b304520) {
  "memref.store"(%6, %7) : (i32, memref<i32>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b304480) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b304220) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9b304140) {
  %9 = "arith.cmpi"(%3, %8) {predicate = 0 : i64} : (index, index) -> i1

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b304480) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
    ** Replace : 'scf.if'(0x7fbd9b304480)
    ** Erase   : 'scf.yield'(0x7fbd9b304220)
"(anonymous namespace)::RemoveStaticCondition" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<1xi32>
  %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
  %2 = llvm.mlir.undef : i32
  memref.store %2, %1[%c0] : memref<?xi32>
  %3 = memref.alloca() : memref<i32>
  %c0_0 = arith.constant 0 : index
  memref.store %2, %3[] : memref<i32>
  %4 = memref.alloca() : memref<i32>
  memref.store %2, %4[] : memref<i32>
  %5 = memref.alloca() : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %6[] : memref<memref<?xf32>>
  memref.store %arg2, %5[] : memref<memref<?xf32>>
  %7 = memref.alloca() : memref<i1>
  memref.store %true, %7[] : memref<i1>
  %8 = memref.load %7[] : memref<i1>
  scf.if %8 {
    %9 = memref.load %7[] : memref<i1>
    scf.if %9 {
      scf.execute_region {
        %10 = memref.load %7[] : memref<i1>
        scf.if %10 {
          %21 = memref.get_global @kbm3 : memref<1xi32>
          %22 = memref.load %21[%c0] : memref<1xi32>
          memref.store %22, %4[] : memref<i32>
        }
        %11 = memref.alloca() : memref<i1>
        %12 = memref.alloca() : memref<i1>
        memref.store %true, %12[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %13 = memref.load %4[] : memref<i32>
        %14 = arith.cmpi sgt, %13, %c0_i32 : i32
        %15 = memref.load %12[] : memref<i1>
        %16 = arith.andi %14, %15 : i1
        cf.cond_br %16, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %17 = memref.load %12[] : memref<i1>
        memref.store %17, %11[] : memref<i1>
        %18 = memref.load %11[] : memref<i1>
        scf.if %18 {
          %21 = memref.load %11[] : memref<i1>
          scf.if %21 {
            scf.execute_region {
              %22 = memref.load %11[] : memref<i1>
              scf.if %22 {
                memref.store %c0_i32, %3[] : memref<i32>
              }
              %23 = memref.alloca() : memref<i1>
              %24 = memref.alloca() : memref<i1>
              memref.store %true, %24[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %25 = memref.load %3[] : memref<i32>
              %26 = memref.get_global @jm : memref<1xi32>
              %27 = memref.load %26[%c0] : memref<1xi32>
              %28 = arith.cmpi slt, %25, %27 : i32
              %29 = memref.load %24[] : memref<i1>
              %30 = arith.andi %28, %29 : i1
              cf.cond_br %30, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %31 = memref.load %24[] : memref<i1>
              memref.store %31, %23[] : memref<i1>
              %32 = memref.load %23[] : memref<i1>
              scf.if %32 {
                %35 = memref.load %23[] : memref<i1>
                scf.if %35 {
                  scf.execute_region {
                    %36 = memref.load %23[] : memref<i1>
                    scf.if %36 {
                      memref.store %c0_i32, %0[%c0] : memref<1xi32>
                    }
                    %37 = memref.alloca() : memref<i1>
                    %38 = memref.alloca() : memref<i1>
                    memref.store %true, %38[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %39 = memref.load %0[%c0] : memref<1xi32>
                    %40 = memref.get_global @im : memref<1xi32>
                    %41 = memref.load %40[%c0] : memref<1xi32>
                    %42 = arith.cmpi slt, %39, %41 : i32
                    %43 = memref.load %38[] : memref<i1>
                    %44 = arith.andi %42, %43 : i1
                    cf.cond_br %44, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %45 = memref.load %38[] : memref<i1>
                    memref.store %45, %37[] : memref<i1>
                    %46 = memref.load %37[] : memref<i1>
                    scf.if %46 {
                      %49 = memref.load %5[] : memref<memref<?xf32>>
                      %50 = memref.load %0[%c0] : memref<1xi32>
                      %51 = memref.load %3[] : memref<i32>
                      %52 = memref.load %40[%c0] : memref<1xi32>
                      %53 = arith.muli %51, %52 : i32
                      %54 = arith.addi %50, %53 : i32
                      %55 = memref.load %4[] : memref<i32>
                      %56 = arith.muli %55, %52 : i32
                      %57 = memref.load %26[%c0] : memref<1xi32>
                      %58 = arith.muli %56, %57 : i32
                      %59 = arith.addi %54, %58 : i32
                      %60 = arith.index_cast %59 : i32 to index
                      %61 = memref.load %6[] : memref<memref<?xf32>>
                      %62 = arith.subi %55, %c1_i32 : i32
                      %63 = arith.muli %62, %52 : i32
                      %64 = arith.muli %63, %57 : i32
                      %65 = arith.addi %54, %64 : i32
                      %66 = arith.index_cast %65 : i32 to index
                      %67 = arith.addi %66, %c0 : index
                      %68 = memref.load %61[%67] : memref<?xf32>
                      %69 = arith.addi %60, %c0 : index
                      memref.store %68, %49[%69] : memref<?xf32>
                    }
                    %47 = memref.load %38[] : memref<i1>
                    memref.store %47, %37[] : memref<i1>
                    %48 = memref.load %37[] : memref<i1>
                    scf.if %48 {
                      %49 = memref.load %0[%c0] : memref<1xi32>
                      %50 = arith.addi %49, %c1_i32 : i32
                      memref.store %50, %0[%c0] : memref<1xi32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %33 = memref.load %24[] : memref<i1>
              memref.store %33, %23[] : memref<i1>
              %34 = memref.load %23[] : memref<i1>
              scf.if %34 {
                %35 = memref.load %3[] : memref<i32>
                %36 = arith.addi %35, %c1_i32 : i32
                memref.store %36, %3[] : memref<i32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %19 = memref.load %12[] : memref<i1>
        memref.store %19, %11[] : memref<i1>
        %20 = memref.load %11[] : memref<i1>
        scf.if %20 {
          %21 = memref.load %4[] : memref<i32>
          %22 = arith.subi %21, %c1_i32 : i32
          memref.store %22, %4[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b3040f0) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd9b304300) {
  %7 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<i32>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%3 = memref.alloca() : memref<i32>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %36, %3[] : memref<i32>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816ae00) {
  "memref.store"(%6, %5, %3) : (i32, memref<?xi32>, index) -> ()

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.mlir.undef'(0x7fbd9816adc0) {
  %6 = "llvm.mlir.undef"() : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.cast'(0x7fbd9816acf0) {
  %5 = "memref.cast"(%4) : (memref<1xi32>) -> memref<?xi32>

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd9816ac90) {
  %4 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<1xi32>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
    ** Insert  : 'memref.alloca'(0x7fbd9b104140)
    ** Insert  : 'arith.constant'(0x7fbd9b1041a0)
    ** Insert  : 'arith.cmpi'(0x7fbd9b1041f0)
    ** Insert  : 'scf.yield'(0x7fbd9b1042d0)
    ** Insert  : 'scf.if'(0x7fbd9b104340)
    ** Replace : 'memref.store'(0x7fbd9816ae00)
    ** Insert  : 'memref.store'(0x7fbd9b1043e0)
    ** Insert  : 'arith.constant'(0x7fbd9b104090)
    ** Insert  : 'arith.cmpi'(0x7fbd9b104480)
    ** Insert  : 'scf.yield'(0x7fbd9b104560)
    ** Insert  : 'scf.if'(0x7fbd9b1045f0)
    ** Replace : 'memref.store'(0x7fbd9816af40)
    ** Insert  : 'memref.store'(0x7fbd9b104690)
    ** Insert  : 'memref.load'(0x7fbd9b104730)
    ** Replace : 'memref.load'(0x7fbd9816b3a0)
    ** Insert  : 'memref.load'(0x7fbd9b1047b0)
    ** Replace : 'memref.load'(0x7fbd9816c060)
    ** Insert  : 'memref.load'(0x7fbd9b104830)
    ** Replace : 'memref.load'(0x7fbd98305400)
    ** Insert  : 'arith.constant'(0x7fbd9b1048b0)
    ** Insert  : 'arith.cmpi'(0x7fbd9b104900)
    ** Insert  : 'scf.yield'(0x7fbd9b1049e0)
    ** Insert  : 'scf.if'(0x7fbd9b104a30)
    ** Replace : 'memref.store'(0x7fbd983055d0)
    ** Insert  : 'memref.store'(0x7fbd9b104ad0)
    ** Erase   : 'memref.alloca'(0x7fbd9816ac90)
"ConstantRankReduction" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  %c0_0 = arith.constant 0 : index
  %2 = arith.cmpi eq, %c0, %c0_0 : index
  scf.if %2 {
    memref.store %1, %0[] : memref<i32>
  }
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<i32>
  memref.store %1, %4[] : memref<i32>
  %5 = memref.alloca() : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %6[] : memref<memref<?xf32>>
  memref.store %arg2, %5[] : memref<memref<?xf32>>
  %7 = memref.alloca() : memref<i1>
  memref.store %true, %7[] : memref<i1>
  %8 = memref.load %7[] : memref<i1>
  scf.if %8 {
    %9 = memref.load %7[] : memref<i1>
    scf.if %9 {
      scf.execute_region {
        %10 = memref.load %7[] : memref<i1>
        scf.if %10 {
          %21 = memref.get_global @kbm3 : memref<1xi32>
          %22 = memref.load %21[%c0] : memref<1xi32>
          memref.store %22, %4[] : memref<i32>
        }
        %11 = memref.alloca() : memref<i1>
        %12 = memref.alloca() : memref<i1>
        memref.store %true, %12[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %13 = memref.load %4[] : memref<i32>
        %14 = arith.cmpi sgt, %13, %c0_i32 : i32
        %15 = memref.load %12[] : memref<i1>
        %16 = arith.andi %14, %15 : i1
        cf.cond_br %16, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %17 = memref.load %12[] : memref<i1>
        memref.store %17, %11[] : memref<i1>
        %18 = memref.load %11[] : memref<i1>
        scf.if %18 {
          %21 = memref.load %11[] : memref<i1>
          scf.if %21 {
            scf.execute_region {
              %22 = memref.load %11[] : memref<i1>
              scf.if %22 {
                memref.store %c0_i32, %3[] : memref<i32>
              }
              %23 = memref.alloca() : memref<i1>
              %24 = memref.alloca() : memref<i1>
              memref.store %true, %24[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %25 = memref.load %3[] : memref<i32>
              %26 = memref.get_global @jm : memref<1xi32>
              %27 = memref.load %26[%c0] : memref<1xi32>
              %28 = arith.cmpi slt, %25, %27 : i32
              %29 = memref.load %24[] : memref<i1>
              %30 = arith.andi %28, %29 : i1
              cf.cond_br %30, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %31 = memref.load %24[] : memref<i1>
              memref.store %31, %23[] : memref<i1>
              %32 = memref.load %23[] : memref<i1>
              scf.if %32 {
                %35 = memref.load %23[] : memref<i1>
                scf.if %35 {
                  scf.execute_region {
                    %36 = memref.load %23[] : memref<i1>
                    scf.if %36 {
                      %c0_1 = arith.constant 0 : index
                      %49 = arith.cmpi eq, %c0, %c0_1 : index
                      scf.if %49 {
                        memref.store %c0_i32, %0[] : memref<i32>
                      }
                    }
                    %37 = memref.alloca() : memref<i1>
                    %38 = memref.alloca() : memref<i1>
                    memref.store %true, %38[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %39 = memref.load %0[] : memref<i32>
                    %40 = memref.get_global @im : memref<1xi32>
                    %41 = memref.load %40[%c0] : memref<1xi32>
                    %42 = arith.cmpi slt, %39, %41 : i32
                    %43 = memref.load %38[] : memref<i1>
                    %44 = arith.andi %42, %43 : i1
                    cf.cond_br %44, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %45 = memref.load %38[] : memref<i1>
                    memref.store %45, %37[] : memref<i1>
                    %46 = memref.load %37[] : memref<i1>
                    scf.if %46 {
                      %49 = memref.load %5[] : memref<memref<?xf32>>
                      %50 = memref.load %0[] : memref<i32>
                      %51 = memref.load %3[] : memref<i32>
                      %52 = memref.load %40[%c0] : memref<1xi32>
                      %53 = arith.muli %51, %52 : i32
                      %54 = arith.addi %50, %53 : i32
                      %55 = memref.load %4[] : memref<i32>
                      %56 = arith.muli %55, %52 : i32
                      %57 = memref.load %26[%c0] : memref<1xi32>
                      %58 = arith.muli %56, %57 : i32
                      %59 = arith.addi %54, %58 : i32
                      %60 = arith.index_cast %59 : i32 to index
                      %61 = memref.load %6[] : memref<memref<?xf32>>
                      %62 = arith.subi %55, %c1_i32 : i32
                      %63 = arith.muli %62, %52 : i32
                      %64 = arith.muli %63, %57 : i32
                      %65 = arith.addi %54, %64 : i32
                      %66 = arith.index_cast %65 : i32 to index
                      %67 = arith.addi %66, %c0 : index
                      %68 = memref.load %61[%67] : memref<?xf32>
                      %69 = arith.addi %60, %c0 : index
                      memref.store %68, %49[%69] : memref<?xf32>
                    }
                    %47 = memref.load %38[] : memref<i1>
                    memref.store %47, %37[] : memref<i1>
                    %48 = memref.load %37[] : memref<i1>
                    scf.if %48 {
                      %49 = memref.load %0[] : memref<i32>
                      %50 = arith.addi %49, %c1_i32 : i32
                      %c0_1 = arith.constant 0 : index
                      %51 = arith.cmpi eq, %c0, %c0_1 : index
                      scf.if %51 {
                        memref.store %50, %0[] : memref<i32>
                      }
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %33 = memref.load %24[] : memref<i1>
              memref.store %33, %23[] : memref<i1>
              %34 = memref.load %23[] : memref<i1>
              scf.if %34 {
                %35 = memref.load %3[] : memref<i32>
                %36 = arith.addi %35, %c1_i32 : i32
                memref.store %36, %3[] : memref<i32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %19 = memref.load %12[] : memref<i1>
        memref.store %19, %11[] : memref<i1>
        %20 = memref.load %11[] : memref<i1>
        scf.if %20 {
          %21 = memref.load %4[] : memref<i32>
          %22 = arith.subi %21, %c1_i32 : i32
          memref.store %22, %4[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9b104ad0) {
  "memref.store"(%55, %4) : (i32, memref<i32>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b104a30) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1049e0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9b104900) {
  %57 = "arith.cmpi"(%3, %56) {predicate = 0 : i64} : (index, index) -> i1

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b104a30) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
    ** Replace : 'scf.if'(0x7fbd9b104a30)
    ** Erase   : 'scf.yield'(0x7fbd9b1049e0)
"(anonymous namespace)::RemoveStaticCondition" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  %c0_0 = arith.constant 0 : index
  %2 = arith.cmpi eq, %c0, %c0_0 : index
  scf.if %2 {
    memref.store %1, %0[] : memref<i32>
  }
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<i32>
  memref.store %1, %4[] : memref<i32>
  %5 = memref.alloca() : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %6[] : memref<memref<?xf32>>
  memref.store %arg2, %5[] : memref<memref<?xf32>>
  %7 = memref.alloca() : memref<i1>
  memref.store %true, %7[] : memref<i1>
  %8 = memref.load %7[] : memref<i1>
  scf.if %8 {
    %9 = memref.load %7[] : memref<i1>
    scf.if %9 {
      scf.execute_region {
        %10 = memref.load %7[] : memref<i1>
        scf.if %10 {
          %21 = memref.get_global @kbm3 : memref<1xi32>
          %22 = memref.load %21[%c0] : memref<1xi32>
          memref.store %22, %4[] : memref<i32>
        }
        %11 = memref.alloca() : memref<i1>
        %12 = memref.alloca() : memref<i1>
        memref.store %true, %12[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %13 = memref.load %4[] : memref<i32>
        %14 = arith.cmpi sgt, %13, %c0_i32 : i32
        %15 = memref.load %12[] : memref<i1>
        %16 = arith.andi %14, %15 : i1
        cf.cond_br %16, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %17 = memref.load %12[] : memref<i1>
        memref.store %17, %11[] : memref<i1>
        %18 = memref.load %11[] : memref<i1>
        scf.if %18 {
          %21 = memref.load %11[] : memref<i1>
          scf.if %21 {
            scf.execute_region {
              %22 = memref.load %11[] : memref<i1>
              scf.if %22 {
                memref.store %c0_i32, %3[] : memref<i32>
              }
              %23 = memref.alloca() : memref<i1>
              %24 = memref.alloca() : memref<i1>
              memref.store %true, %24[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %25 = memref.load %3[] : memref<i32>
              %26 = memref.get_global @jm : memref<1xi32>
              %27 = memref.load %26[%c0] : memref<1xi32>
              %28 = arith.cmpi slt, %25, %27 : i32
              %29 = memref.load %24[] : memref<i1>
              %30 = arith.andi %28, %29 : i1
              cf.cond_br %30, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %31 = memref.load %24[] : memref<i1>
              memref.store %31, %23[] : memref<i1>
              %32 = memref.load %23[] : memref<i1>
              scf.if %32 {
                %35 = memref.load %23[] : memref<i1>
                scf.if %35 {
                  scf.execute_region {
                    %36 = memref.load %23[] : memref<i1>
                    scf.if %36 {
                      %c0_1 = arith.constant 0 : index
                      %49 = arith.cmpi eq, %c0, %c0_1 : index
                      scf.if %49 {
                        memref.store %c0_i32, %0[] : memref<i32>
                      }
                    }
                    %37 = memref.alloca() : memref<i1>
                    %38 = memref.alloca() : memref<i1>
                    memref.store %true, %38[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %39 = memref.load %0[] : memref<i32>
                    %40 = memref.get_global @im : memref<1xi32>
                    %41 = memref.load %40[%c0] : memref<1xi32>
                    %42 = arith.cmpi slt, %39, %41 : i32
                    %43 = memref.load %38[] : memref<i1>
                    %44 = arith.andi %42, %43 : i1
                    cf.cond_br %44, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %45 = memref.load %38[] : memref<i1>
                    memref.store %45, %37[] : memref<i1>
                    %46 = memref.load %37[] : memref<i1>
                    scf.if %46 {
                      %49 = memref.load %5[] : memref<memref<?xf32>>
                      %50 = memref.load %0[] : memref<i32>
                      %51 = memref.load %3[] : memref<i32>
                      %52 = memref.load %40[%c0] : memref<1xi32>
                      %53 = arith.muli %51, %52 : i32
                      %54 = arith.addi %50, %53 : i32
                      %55 = memref.load %4[] : memref<i32>
                      %56 = arith.muli %55, %52 : i32
                      %57 = memref.load %26[%c0] : memref<1xi32>
                      %58 = arith.muli %56, %57 : i32
                      %59 = arith.addi %54, %58 : i32
                      %60 = arith.index_cast %59 : i32 to index
                      %61 = memref.load %6[] : memref<memref<?xf32>>
                      %62 = arith.subi %55, %c1_i32 : i32
                      %63 = arith.muli %62, %52 : i32
                      %64 = arith.muli %63, %57 : i32
                      %65 = arith.addi %54, %64 : i32
                      %66 = arith.index_cast %65 : i32 to index
                      %67 = arith.addi %66, %c0 : index
                      %68 = memref.load %61[%67] : memref<?xf32>
                      %69 = arith.addi %60, %c0 : index
                      memref.store %68, %49[%69] : memref<?xf32>
                    }
                    %47 = memref.load %38[] : memref<i1>
                    memref.store %47, %37[] : memref<i1>
                    %48 = memref.load %37[] : memref<i1>
                    scf.if %48 {
                      %49 = memref.load %0[] : memref<i32>
                      %50 = arith.addi %49, %c1_i32 : i32
                      %c0_1 = arith.constant 0 : index
                      memref.store %50, %0[] : memref<i32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %33 = memref.load %24[] : memref<i1>
              memref.store %33, %23[] : memref<i1>
              %34 = memref.load %23[] : memref<i1>
              scf.if %34 {
                %35 = memref.load %3[] : memref<i32>
                %36 = arith.addi %35, %c1_i32 : i32
                memref.store %36, %3[] : memref<i32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %19 = memref.load %12[] : memref<i1>
        memref.store %19, %11[] : memref<i1>
        %20 = memref.load %11[] : memref<i1>
        scf.if %20 {
          %21 = memref.load %4[] : memref<i32>
          %22 = arith.subi %21, %c1_i32 : i32
          memref.store %22, %4[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b1048b0) {
  %56 = "arith.constant"() {value = 0 : index} : () -> index

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %55 = "arith.addi"(%54, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b104830) {
  %54 = "memref.load"(%4) : (memref<i32>) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %59 = "arith.addi"(%55, %58) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b1047b0) {
  %55 = "memref.load"(%4) : (memref<i32>) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %47 = "arith.cmpi"(%44, %46) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtUIOp type
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b104730) {
  %44 = "memref.load"(%4) : (memref<i32>) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9b104690) {
  "memref.store"(%2, %4) : (i32, memref<i32>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b1045f0) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b104560) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9b104480) {
  %55 = "arith.cmpi"(%3, %54) {predicate = 0 : i64} : (index, index) -> i1

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b1045f0) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
    ** Replace : 'scf.if'(0x7fbd9b1045f0)
    ** Erase   : 'scf.yield'(0x7fbd9b104560)
"(anonymous namespace)::RemoveStaticCondition" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  %c0_0 = arith.constant 0 : index
  %2 = arith.cmpi eq, %c0, %c0_0 : index
  scf.if %2 {
    memref.store %1, %0[] : memref<i32>
  }
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<i32>
  memref.store %1, %4[] : memref<i32>
  %5 = memref.alloca() : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %6[] : memref<memref<?xf32>>
  memref.store %arg2, %5[] : memref<memref<?xf32>>
  %7 = memref.alloca() : memref<i1>
  memref.store %true, %7[] : memref<i1>
  %8 = memref.load %7[] : memref<i1>
  scf.if %8 {
    %9 = memref.load %7[] : memref<i1>
    scf.if %9 {
      scf.execute_region {
        %10 = memref.load %7[] : memref<i1>
        scf.if %10 {
          %21 = memref.get_global @kbm3 : memref<1xi32>
          %22 = memref.load %21[%c0] : memref<1xi32>
          memref.store %22, %4[] : memref<i32>
        }
        %11 = memref.alloca() : memref<i1>
        %12 = memref.alloca() : memref<i1>
        memref.store %true, %12[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %13 = memref.load %4[] : memref<i32>
        %14 = arith.cmpi sgt, %13, %c0_i32 : i32
        %15 = memref.load %12[] : memref<i1>
        %16 = arith.andi %14, %15 : i1
        cf.cond_br %16, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %17 = memref.load %12[] : memref<i1>
        memref.store %17, %11[] : memref<i1>
        %18 = memref.load %11[] : memref<i1>
        scf.if %18 {
          %21 = memref.load %11[] : memref<i1>
          scf.if %21 {
            scf.execute_region {
              %22 = memref.load %11[] : memref<i1>
              scf.if %22 {
                memref.store %c0_i32, %3[] : memref<i32>
              }
              %23 = memref.alloca() : memref<i1>
              %24 = memref.alloca() : memref<i1>
              memref.store %true, %24[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %25 = memref.load %3[] : memref<i32>
              %26 = memref.get_global @jm : memref<1xi32>
              %27 = memref.load %26[%c0] : memref<1xi32>
              %28 = arith.cmpi slt, %25, %27 : i32
              %29 = memref.load %24[] : memref<i1>
              %30 = arith.andi %28, %29 : i1
              cf.cond_br %30, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %31 = memref.load %24[] : memref<i1>
              memref.store %31, %23[] : memref<i1>
              %32 = memref.load %23[] : memref<i1>
              scf.if %32 {
                %35 = memref.load %23[] : memref<i1>
                scf.if %35 {
                  scf.execute_region {
                    %36 = memref.load %23[] : memref<i1>
                    scf.if %36 {
                      %c0_1 = arith.constant 0 : index
                      memref.store %c0_i32, %0[] : memref<i32>
                    }
                    %37 = memref.alloca() : memref<i1>
                    %38 = memref.alloca() : memref<i1>
                    memref.store %true, %38[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %39 = memref.load %0[] : memref<i32>
                    %40 = memref.get_global @im : memref<1xi32>
                    %41 = memref.load %40[%c0] : memref<1xi32>
                    %42 = arith.cmpi slt, %39, %41 : i32
                    %43 = memref.load %38[] : memref<i1>
                    %44 = arith.andi %42, %43 : i1
                    cf.cond_br %44, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %45 = memref.load %38[] : memref<i1>
                    memref.store %45, %37[] : memref<i1>
                    %46 = memref.load %37[] : memref<i1>
                    scf.if %46 {
                      %49 = memref.load %5[] : memref<memref<?xf32>>
                      %50 = memref.load %0[] : memref<i32>
                      %51 = memref.load %3[] : memref<i32>
                      %52 = memref.load %40[%c0] : memref<1xi32>
                      %53 = arith.muli %51, %52 : i32
                      %54 = arith.addi %50, %53 : i32
                      %55 = memref.load %4[] : memref<i32>
                      %56 = arith.muli %55, %52 : i32
                      %57 = memref.load %26[%c0] : memref<1xi32>
                      %58 = arith.muli %56, %57 : i32
                      %59 = arith.addi %54, %58 : i32
                      %60 = arith.index_cast %59 : i32 to index
                      %61 = memref.load %6[] : memref<memref<?xf32>>
                      %62 = arith.subi %55, %c1_i32 : i32
                      %63 = arith.muli %62, %52 : i32
                      %64 = arith.muli %63, %57 : i32
                      %65 = arith.addi %54, %64 : i32
                      %66 = arith.index_cast %65 : i32 to index
                      %67 = arith.addi %66, %c0 : index
                      %68 = memref.load %61[%67] : memref<?xf32>
                      %69 = arith.addi %60, %c0 : index
                      memref.store %68, %49[%69] : memref<?xf32>
                    }
                    %47 = memref.load %38[] : memref<i1>
                    memref.store %47, %37[] : memref<i1>
                    %48 = memref.load %37[] : memref<i1>
                    scf.if %48 {
                      %49 = memref.load %0[] : memref<i32>
                      %50 = arith.addi %49, %c1_i32 : i32
                      memref.store %50, %0[] : memref<i32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %33 = memref.load %24[] : memref<i1>
              memref.store %33, %23[] : memref<i1>
              %34 = memref.load %23[] : memref<i1>
              scf.if %34 {
                %35 = memref.load %3[] : memref<i32>
                %36 = arith.addi %35, %c1_i32 : i32
                memref.store %36, %3[] : memref<i32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %19 = memref.load %12[] : memref<i1>
        memref.store %19, %11[] : memref<i1>
        %20 = memref.load %11[] : memref<i1>
        scf.if %20 {
          %21 = memref.load %4[] : memref<i32>
          %22 = arith.subi %21, %c1_i32 : i32
          memref.store %22, %4[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b104090) {
  %54 = "arith.constant"() {value = 0 : index} : () -> index

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9b1043e0) {
  "memref.store"(%5, %4) : (i32, memref<i32>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b104340) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1042d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9b1041f0) {
  %7 = "arith.cmpi"(%3, %6) {predicate = 0 : i64} : (index, index) -> i1

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b104340) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
    ** Replace : 'scf.if'(0x7fbd9b104340)
    ** Erase   : 'scf.yield'(0x7fbd9b1042d0)
"(anonymous namespace)::RemoveStaticCondition" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  %c0_0 = arith.constant 0 : index
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %7 {
    %8 = memref.load %6[] : memref<i1>
    scf.if %8 {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        scf.if %9 {
          %20 = memref.get_global @kbm3 : memref<1xi32>
          %21 = memref.load %20[%c0] : memref<1xi32>
          memref.store %21, %3[] : memref<i32>
        }
        %10 = memref.alloca() : memref<i1>
        %11 = memref.alloca() : memref<i1>
        memref.store %true, %11[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %12 = memref.load %3[] : memref<i32>
        %13 = arith.cmpi sgt, %12, %c0_i32 : i32
        %14 = memref.load %11[] : memref<i1>
        %15 = arith.andi %13, %14 : i1
        cf.cond_br %15, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %16 = memref.load %11[] : memref<i1>
        memref.store %16, %10[] : memref<i1>
        %17 = memref.load %10[] : memref<i1>
        scf.if %17 {
          %20 = memref.load %10[] : memref<i1>
          scf.if %20 {
            scf.execute_region {
              %21 = memref.load %10[] : memref<i1>
              scf.if %21 {
                memref.store %c0_i32, %2[] : memref<i32>
              }
              %22 = memref.alloca() : memref<i1>
              %23 = memref.alloca() : memref<i1>
              memref.store %true, %23[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %24 = memref.load %2[] : memref<i32>
              %25 = memref.get_global @jm : memref<1xi32>
              %26 = memref.load %25[%c0] : memref<1xi32>
              %27 = arith.cmpi slt, %24, %26 : i32
              %28 = memref.load %23[] : memref<i1>
              %29 = arith.andi %27, %28 : i1
              cf.cond_br %29, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %30 = memref.load %23[] : memref<i1>
              memref.store %30, %22[] : memref<i1>
              %31 = memref.load %22[] : memref<i1>
              scf.if %31 {
                %34 = memref.load %22[] : memref<i1>
                scf.if %34 {
                  scf.execute_region {
                    %35 = memref.load %22[] : memref<i1>
                    scf.if %35 {
                      memref.store %c0_i32, %0[] : memref<i32>
                    }
                    %36 = memref.alloca() : memref<i1>
                    %37 = memref.alloca() : memref<i1>
                    memref.store %true, %37[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %38 = memref.load %0[] : memref<i32>
                    %39 = memref.get_global @im : memref<1xi32>
                    %40 = memref.load %39[%c0] : memref<1xi32>
                    %41 = arith.cmpi slt, %38, %40 : i32
                    %42 = memref.load %37[] : memref<i1>
                    %43 = arith.andi %41, %42 : i1
                    cf.cond_br %43, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %44 = memref.load %37[] : memref<i1>
                    memref.store %44, %36[] : memref<i1>
                    %45 = memref.load %36[] : memref<i1>
                    scf.if %45 {
                      %48 = memref.load %4[] : memref<memref<?xf32>>
                      %49 = memref.load %0[] : memref<i32>
                      %50 = memref.load %2[] : memref<i32>
                      %51 = memref.load %39[%c0] : memref<1xi32>
                      %52 = arith.muli %50, %51 : i32
                      %53 = arith.addi %49, %52 : i32
                      %54 = memref.load %3[] : memref<i32>
                      %55 = arith.muli %54, %51 : i32
                      %56 = memref.load %25[%c0] : memref<1xi32>
                      %57 = arith.muli %55, %56 : i32
                      %58 = arith.addi %53, %57 : i32
                      %59 = arith.index_cast %58 : i32 to index
                      %60 = memref.load %5[] : memref<memref<?xf32>>
                      %61 = arith.subi %54, %c1_i32 : i32
                      %62 = arith.muli %61, %51 : i32
                      %63 = arith.muli %62, %56 : i32
                      %64 = arith.addi %53, %63 : i32
                      %65 = arith.index_cast %64 : i32 to index
                      %66 = arith.addi %65, %c0 : index
                      %67 = memref.load %60[%66] : memref<?xf32>
                      %68 = arith.addi %59, %c0 : index
                      memref.store %67, %48[%68] : memref<?xf32>
                    }
                    %46 = memref.load %37[] : memref<i1>
                    memref.store %46, %36[] : memref<i1>
                    %47 = memref.load %36[] : memref<i1>
                    scf.if %47 {
                      %48 = memref.load %0[] : memref<i32>
                      %49 = arith.addi %48, %c1_i32 : i32
                      memref.store %49, %0[] : memref<i32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %32 = memref.load %23[] : memref<i1>
              memref.store %32, %22[] : memref<i1>
              %33 = memref.load %22[] : memref<i1>
              scf.if %33 {
                %34 = memref.load %2[] : memref<i32>
                %35 = arith.addi %34, %c1_i32 : i32
                memref.store %35, %2[] : memref<i32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %18 = memref.load %11[] : memref<i1>
        memref.store %18, %10[] : memref<i1>
        %19 = memref.load %10[] : memref<i1>
        scf.if %19 {
          %20 = memref.load %3[] : memref<i32>
          %21 = arith.subi %20, %c1_i32 : i32
          memref.store %21, %3[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b1041a0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd9b104140) {
  %4 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<i32>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%0 = memref.alloca() : memref<i32>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %49, %0[] : memref<i32>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9816cc60) {
  %3 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x7fbd9800c610) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd98166820) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd98166790) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd98166a90) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd98166a40) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.execute_region'(0x7fbd98166b30) {

  * Pattern SingleBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "SingleBlockExecuteInliner"
"SingleBlockExecuteInliner" result 0
  } -> failure : pattern failed to match

  * Pattern MultiBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "MultiBlockExecuteInliner"
"MultiBlockExecuteInliner" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9800c570) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9800c500) {
  "cf.br"()[^bb1] : () -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9800c080) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9800c010) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9800f070) {
  "memref.store"(%25, %7) : (i32, memref<i32>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9800c320) {
  %25 = "arith.subi"(%24, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9800ef60) {
  %24 = "memref.load"(%7) : (memref<i32>) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9800bf50) {
  %23 = "memref.load"(%14) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9800beb0) {
  "memref.store"(%22, %14) : (i1, memref<i1>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9800be40) {
  %22 = "memref.load"(%15) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd981688b0) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd98168820) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd98168b20) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd98168ad0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.execute_region'(0x7fbd98168bc0) {

  * Pattern SingleBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "SingleBlockExecuteInliner"
"SingleBlockExecuteInliner" result 0
  } -> failure : pattern failed to match

  * Pattern MultiBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "MultiBlockExecuteInliner"
"MultiBlockExecuteInliner" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9800bd90) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9800bd20) {
  "cf.br"()[^bb1] : () -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9800a0e0) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9800a090) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9800c3b0) {
  "memref.store"(%39, %6) : (i32, memref<i32>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %39 = "arith.addi"(%38, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9800efe0) {
  %38 = "memref.load"(%6) : (memref<i32>) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98009fd0) {
  %37 = "memref.load"(%26) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd98009f30) {
  "memref.store"(%36, %26) : (i1, memref<i1>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98009ec0) {
  %36 = "memref.load"(%27) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9816a370) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9816a300) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9816a5e0) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9816a590) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.execute_region'(0x7fbd9816a680) {

  * Pattern SingleBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "SingleBlockExecuteInliner"
"SingleBlockExecuteInliner" result 0
  } -> failure : pattern failed to match

  * Pattern MultiBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "MultiBlockExecuteInliner"
"MultiBlockExecuteInliner" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9800a830) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd98009270) {
  "cf.br"()[^bb1] : () -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd98305250) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd983051c0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9b104ad0) {
  "memref.store"(%53, %4) : (i32, memref<i32>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %53 = "arith.addi"(%52, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b104830) {
  %52 = "memref.load"(%4) : (memref<i32>) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd983050e0) {
  %51 = "memref.load"(%40) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd98305040) {
  "memref.store"(%50, %40) : (i1, memref<i1>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98304fd0) {
  %50 = "memref.load"(%41) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9816bdc0) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9816bd70) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%71, %52, %72) : (f32, memref<?xf32>, index) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98165e60) {
  %72 = "arith.addi"(%63, %3) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %71 = "memref.load"(%64, %70) : (memref<?xf32>, index) -> f32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b0040e0) {
  %70 = "arith.addi"(%69, %3) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd98304bd0) {
  %69 = "arith.index_cast"(%68) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98304b30) {
  %68 = "arith.addi"(%57, %67) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304a90) {
  %67 = "arith.muli"(%66, %60) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %66 = "arith.muli"(%65, %55) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd983045d0) {
  %65 = "arith.subi"(%58, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b304410) {
  %64 = "memref.load"(%9) : (memref<memref<?xf32>>) -> memref<?xf32>


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9816cb40) {
  %63 = "arith.index_cast"(%62) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816caa0) {
  %62 = "arith.addi"(%57, %61) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816ca00) {
  %61 = "arith.muli"(%59, %60) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816c960) {
  %60 = "memref.load"(%29, %3) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %59 = "arith.muli"(%58, %55) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9800eee0) {
  %58 = "memref.load"(%7) : (memref<i32>) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %57 = "arith.addi"(%53, %56) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %56 = "arith.muli"(%54, %55) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816c310) {
  %55 = "memref.load"(%43, %3) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9800ed30) {
  %54 = "memref.load"(%6) : (memref<i32>) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b1047b0) {
  %53 = "memref.load"(%4) : (memref<i32>) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd96f14840) {
  %52 = "memref.load"(%8) : (memref<memref<?xf32>>) -> memref<?xf32>


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816bcb0) {
  %49 = "memref.load"(%40) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816bc10) {
  "memref.store"(%48, %40) : (i1, memref<i1>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816bba0) {
  %48 = "memref.load"(%41) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd9816bae0) {
  "cf.cond_br"(%47)[^bb2, ^bb3] {operand_segment_sizes = array<i32: 1, 0, 0>} : (i1) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors"
"(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition"
"(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CondBranchTruthPropagation : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::CondBranchTruthPropagation"
"(anonymous namespace)::CondBranchTruthPropagation" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.andi'(0x7fbd9816ba50) {
  %47 = "arith.andi"(%45, %46) : (i1, i1) -> i1


  * Pattern (anonymous namespace)::AndOfExtUI : 'arith.andi -> (arith.andi, arith.extui)' {
Trying to match "(anonymous namespace)::AndOfExtUI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtUIOp type
"(anonymous namespace)::AndOfExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AndOfExtSI : 'arith.andi -> (arith.andi, arith.extsi)' {
Trying to match "(anonymous namespace)::AndOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::AndOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816b9d0) {
  %46 = "memref.load"(%41) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %45 = "arith.cmpi"(%42, %44) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtUIOp type
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816b720) {
  %44 = "memref.load"(%43, %3) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9816b600) {
  %43 = "memref.get_global"() {name = @im} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b104730) {
  %42 = "memref.load"(%4) : (memref<i32>) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9816b2d0) {
  "cf.br"()[^bb1] : () -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816b150) {
  "memref.store"(%0, %41) : (i1, memref<i1>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd9816b100) {
  %41 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<i1>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%37 = memref.alloca() : memref<i1>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %true, %37[] : memref<i1>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd9816b0a0) {
  %40 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<i1>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%36 = memref.alloca() : memref<i1>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %46, %36[] : memref<i1>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9816a880) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9816a830) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9b104690) {
  "memref.store"(%2, %4) : (i32, memref<i32>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816a770) {
  %39 = "memref.load"(%26) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816a4d0) {
  %38 = "memref.load"(%26) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816a240) {
  %35 = "memref.load"(%26) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a160) {
  "memref.store"(%34, %26) : (i1, memref<i1>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816a0f0) {
  %34 = "memref.load"(%27) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd9816a030) {
  "cf.cond_br"(%33)[^bb2, ^bb3] {operand_segment_sizes = array<i32: 1, 0, 0>} : (i1) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors"
"(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition"
"(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CondBranchTruthPropagation : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::CondBranchTruthPropagation"
"(anonymous namespace)::CondBranchTruthPropagation" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.andi'(0x7fbd98169fa0) {
  %33 = "arith.andi"(%31, %32) : (i1, i1) -> i1


  * Pattern (anonymous namespace)::AndOfExtUI : 'arith.andi -> (arith.andi, arith.extui)' {
Trying to match "(anonymous namespace)::AndOfExtUI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtUIOp type
"(anonymous namespace)::AndOfExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AndOfExtSI : 'arith.andi -> (arith.andi, arith.extsi)' {
Trying to match "(anonymous namespace)::AndOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::AndOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98169f20) {
  %32 = "memref.load"(%27) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %31 = "arith.cmpi"(%28, %30) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtUIOp type
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98169b40) {
  %30 = "memref.load"(%29, %3) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd98169a20) {
  %29 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b304880) {
  %28 = "memref.load"(%6) : (memref<i32>) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd981696b0) {
  "cf.br"()[^bb1] : () -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd98169530) {
  "memref.store"(%0, %27) : (i1, memref<i1>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd981694e0) {
  %27 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<i1>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%23 = memref.alloca() : memref<i1>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %true, %23[] : memref<i1>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd98169480) {
  %26 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<i1>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%22 = memref.alloca() : memref<i1>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %32, %22[] : memref<i1>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd98168f00) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd98168e70) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9b3047e0) {
  "memref.store"(%2, %6) : (i32, memref<i32>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98168db0) {
  %25 = "memref.load"(%14) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98168a10) {
  %24 = "memref.load"(%14) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98168760) {
  %21 = "memref.load"(%14) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd981686c0) {
  "memref.store"(%20, %14) : (i1, memref<i1>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98168650) {
  %20 = "memref.load"(%15) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd98168590) {
  "cf.cond_br"(%19)[^bb2, ^bb3] {operand_segment_sizes = array<i32: 1, 0, 0>} : (i1) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors"
"(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition"
"(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CondBranchTruthPropagation : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::CondBranchTruthPropagation"
"(anonymous namespace)::CondBranchTruthPropagation" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.andi'(0x7fbd981683d0) {
  %19 = "arith.andi"(%17, %18) : (i1, i1) -> i1


  * Pattern (anonymous namespace)::AndOfExtUI : 'arith.andi -> (arith.andi, arith.extui)' {
Trying to match "(anonymous namespace)::AndOfExtUI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtUIOp type
"(anonymous namespace)::AndOfExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AndOfExtSI : 'arith.andi -> (arith.andi, arith.extsi)' {
Trying to match "(anonymous namespace)::AndOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::AndOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98168350) {
  %18 = "memref.load"(%15) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98168010) {
  %17 = "arith.cmpi"(%16, %2) {predicate = 4 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtUIOp type
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9800ee60) {
  %16 = "memref.load"(%7) : (memref<i32>) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd98167bf0) {
  "cf.br"()[^bb1] : () -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd98167a70) {
  "memref.store"(%0, %15) : (i1, memref<i1>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd98167a20) {
  %15 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<i1>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%11 = memref.alloca() : memref<i1>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %true, %11[] : memref<i1>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd981679c0) {
  %14 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<i1>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%10 = memref.alloca() : memref<i1>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %18, %10[] : memref<i1>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd98166d40) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd98166cb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9800edc0) {
  "memref.store"(%25, %7) : (i32, memref<i32>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98167510) {
  %25 = "memref.load"(%24, %3) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd981673f0) {
  %24 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98166bf0) {
  %13 = "memref.load"(%10) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98166980) {
  %12 = "memref.load"(%10) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd981666b0) {
  %11 = "memref.load"(%10) : (memref<i1>) -> i1


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd98166610) {
  "memref.store"(%0, %10) : (i1, memref<i1>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd981664d0) {
  %10 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<i1>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%6 = memref.alloca() : memref<i1>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %true, %6[] : memref<i1>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd96f147a0) {
  "memref.store"(%arg2, %8) : (memref<?xf32>, memref<memref<?xf32>>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9b304370) {
  "memref.store"(%arg0, %9) : (memref<?xf32>, memref<memref<?xf32>>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd9b304090) {
  %9 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<memref<?xf32>>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%5 = memref.alloca() : memref<memref<?xf32>>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %arg0, %5[] : memref<memref<?xf32>>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd96f10380) {
  %8 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<memref<?xf32>>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%4 = memref.alloca() : memref<memref<?xf32>>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %arg2, %4[] : memref<memref<?xf32>>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9800a750) {
  "memref.store"(%5, %7) : (i32, memref<i32>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd9b1040e0) {
  %7 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<i32>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%3 = memref.alloca() : memref<i32>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %21, %3[] : memref<i32>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9b304520) {
  "memref.store"(%5, %6) : (i32, memref<i32>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd9b304300) {
  %6 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<i32>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%2 = memref.alloca() : memref<i32>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %35, %2[] : memref<i32>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9b1043e0) {
  "memref.store"(%5, %4) : (i32, memref<i32>) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.mlir.undef'(0x7fbd9816adc0) {
  %5 = "llvm.mlir.undef"() : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloca'(0x7fbd9b104140) {
  %4 = "memref.alloca"() {operand_segment_sizes = array<i32: 0, 0>} : () -> memref<i32>


  * Pattern ConstantRankReduction : 'memref.alloca -> ()' {
Trying to match "ConstantRankReduction"
"ConstantRankReduction" result 0
  } -> failure : pattern failed to match

  * Pattern BufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "BufferElimination<mlir::memref::AllocaOp>"
"BufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern AffineBufferElimination<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "AffineBufferElimination<mlir::memref::AllocaOp>"
 Attempting affine buffer elim of: mlir-asm-printer: Verifying operation: func.func
%0 = memref.alloca() : memref<i32>
 + unknown user mlir-asm-printer: Verifying operation: func.func
memref.store %49, %0[] : memref<i32>
"AffineBufferElimination<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern SimplifyDeadAllocV2<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "SimplifyDeadAllocV2<mlir::memref::AllocaOp>"
"SimplifyDeadAllocV2<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyAllocConst<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp> : 'memref.alloca -> ()' {
Trying to match "(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>"
"(anonymous namespace)::SimplifyDeadAlloc<mlir::memref::AllocaOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9816cc60) {
  %3 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98167e90) {
  %2 = "arith.constant"() {value = 0 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98304580) {
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98166480) {
  %0 = "arith.constant"() {value = true} : () -> i1

} -> failure : pattern failed to match
//===-------------------------------------------===//
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%0 = memref.alloca() : memref<i32>
 + forwarding vec to promote {} of mlir-asm-printer: Verifying operation: builtin.module
%0 = memref.alloca() : memref<i32>
Begin forwarding store of mlir-asm-printer: Verifying operation: builtin.module
%0 = memref.alloca() : memref<i32> to load
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %7 {
    %8 = memref.load %6[] : memref<i1>
    scf.if %8 {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        scf.if %9 {
          %20 = memref.get_global @kbm3 : memref<1xi32>
          %21 = memref.load %20[%c0] : memref<1xi32>
          memref.store %21, %3[] : memref<i32>
        }
        %10 = memref.alloca() : memref<i1>
        %11 = memref.alloca() : memref<i1>
        memref.store %true, %11[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %12 = memref.load %3[] : memref<i32>
        %13 = arith.cmpi sgt, %12, %c0_i32 : i32
        %14 = memref.load %11[] : memref<i1>
        %15 = arith.andi %13, %14 : i1
        cf.cond_br %15, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %16 = memref.load %11[] : memref<i1>
        memref.store %16, %10[] : memref<i1>
        %17 = memref.load %10[] : memref<i1>
        scf.if %17 {
          %20 = memref.load %10[] : memref<i1>
          scf.if %20 {
            scf.execute_region {
              %21 = memref.load %10[] : memref<i1>
              scf.if %21 {
                memref.store %c0_i32, %2[] : memref<i32>
              }
              %22 = memref.alloca() : memref<i1>
              %23 = memref.alloca() : memref<i1>
              memref.store %true, %23[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %24 = memref.load %2[] : memref<i32>
              %25 = memref.get_global @jm : memref<1xi32>
              %26 = memref.load %25[%c0] : memref<1xi32>
              %27 = arith.cmpi slt, %24, %26 : i32
              %28 = memref.load %23[] : memref<i1>
              %29 = arith.andi %27, %28 : i1
              cf.cond_br %29, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %30 = memref.load %23[] : memref<i1>
              memref.store %30, %22[] : memref<i1>
              %31 = memref.load %22[] : memref<i1>
              scf.if %31 {
                %34 = memref.load %22[] : memref<i1>
                scf.if %34 {
                  scf.execute_region {
                    %35 = memref.load %22[] : memref<i1>
                    scf.if %35 {
                      memref.store %c0_i32, %0[] : memref<i32>
                    }
                    %36 = memref.alloca() : memref<i1>
                    %37 = memref.alloca() : memref<i1>
                    memref.store %true, %37[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %38 = memref.load %0[] : memref<i32>
                    %39 = memref.get_global @im : memref<1xi32>
                    %40 = memref.load %39[%c0] : memref<1xi32>
                    %41 = arith.cmpi slt, %38, %40 : i32
                    %42 = memref.load %37[] : memref<i1>
                    %43 = arith.andi %41, %42 : i1
                    cf.cond_br %43, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %44 = memref.load %37[] : memref<i1>
                    memref.store %44, %36[] : memref<i1>
                    %45 = memref.load %36[] : memref<i1>
                    scf.if %45 {
                      %48 = memref.load %4[] : memref<memref<?xf32>>
                      %49 = memref.load %0[] : memref<i32>
                      %50 = memref.load %2[] : memref<i32>
                      %51 = memref.load %39[%c0] : memref<1xi32>
                      %52 = arith.muli %50, %51 : i32
                      %53 = arith.addi %49, %52 : i32
                      %54 = memref.load %3[] : memref<i32>
                      %55 = arith.muli %54, %51 : i32
                      %56 = memref.load %25[%c0] : memref<1xi32>
                      %57 = arith.muli %55, %56 : i32
                      %58 = arith.addi %53, %57 : i32
                      %59 = arith.index_cast %58 : i32 to index
                      %60 = memref.load %5[] : memref<memref<?xf32>>
                      %61 = arith.subi %54, %c1_i32 : i32
                      %62 = arith.muli %61, %51 : i32
                      %63 = arith.muli %62, %56 : i32
                      %64 = arith.addi %53, %63 : i32
                      %65 = arith.index_cast %64 : i32 to index
                      %66 = arith.addi %65, %c0 : index
                      %67 = memref.load %60[%66] : memref<?xf32>
                      %68 = arith.addi %59, %c0 : index
                      memref.store %67, %48[%68] : memref<?xf32>
                    }
                    %46 = memref.load %37[] : memref<i1>
                    memref.store %46, %36[] : memref<i1>
                    %47 = memref.load %36[] : memref<i1>
                    scf.if %47 {
                      %48 = memref.load %0[] : memref<i32>
                      %49 = arith.addi %48, %c1_i32 : i32
                      memref.store %49, %0[] : memref<i32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %32 = memref.load %23[] : memref<i1>
              memref.store %32, %22[] : memref<i1>
              %33 = memref.load %22[] : memref<i1>
              scf.if %33 {
                %34 = memref.load %2[] : memref<i32>
                %35 = arith.addi %34, %c1_i32 : i32
                memref.store %35, %2[] : memref<i32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %18 = memref.load %11[] : memref<i1>
        memref.store %18, %10[] : memref<i1>
        %19 = memref.load %10[] : memref<i1>
        scf.if %19 {
          %20 = memref.load %3[] : memref<i32>
          %21 = arith.subi %20, %c1_i32 : i32
          memref.store %21, %3[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}
Matching Store: mlir-asm-printer: Verifying operation: func.func
memref.store %49, %0[] : memref<i32>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%48 = memref.load %0[] : memref<i32>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%49 = memref.load %0[] : memref<i32>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%38 = memref.load %0[] : memref<i32>
Matching Store: mlir-asm-printer: Verifying operation: func.func
memref.store %c0_i32, %0[] : memref<i32>
Matching Store: mlir-asm-printer: Verifying operation: func.func
memref.store %1, %0[] : memref<i32>
 storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %1, %0[] : memref<i32>
 storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %c0_i32, %0[] : memref<i32>
 storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %49, %0[] : memref<i32>
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9816a7e0
 derived storing block: 0x7fbd9816a6e0
 initial storing block: 0x7fbd98305170
 derived storing block: 0x7fbd9816b230
 initial storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9816a6e0
 derived storing block: 0x7fbd9816a540
 initial storing block: 0x7fbd9816b230
 derived storing block: 0x7fbd9816a540
 initial storing block: 0x7fbd9816a540
 derived storing block: 0x7fbd9816a2b0
 initial storing block: 0x7fbd9816a540
 derived storing block: 0x7fbd9816a2b0
 initial storing block: 0x7fbd9816a2b0
 derived storing block: 0x7fbd98169610
 initial storing block: 0x7fbd9816a2b0
 derived storing block: 0x7fbd98169610
 initial storing block: 0x7fbd98169610
 derived storing block: 0x7fbd98168a80
 initial storing block: 0x7fbd98169610
 derived storing block: 0x7fbd98168a80
 initial storing block: 0x7fbd98168a80
 derived storing block: 0x7fbd981687d0
 initial storing block: 0x7fbd98168a80
 derived storing block: 0x7fbd981687d0
 initial storing block: 0x7fbd981687d0
 derived storing block: 0x7fbd98167b50
 initial storing block: 0x7fbd981687d0
 derived storing block: 0x7fbd98167b50
 initial storing block: 0x7fbd98167b50
 derived storing block: 0x7fbd981669f0
 initial storing block: 0x7fbd98167b50
 derived storing block: 0x7fbd981669f0
 initial storing block: 0x7fbd981669f0
 derived storing block: 0x7fbd98166740
 initial storing block: 0x7fbd981669f0
 derived storing block: 0x7fbd98166740
 initial storing block: 0x7fbd98166740
 derived storing block: 0x7fbd98164100
 initial storing block: 0x7fbd98166740
 derived storing block: 0x7fbd98164100
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32):
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %7 {
    %8 = memref.load %6[] : memref<i1>
    scf.if %8 {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        scf.if %9 {
          %20 = memref.get_global @kbm3 : memref<1xi32>
          %21 = memref.load %20[%c0] : memref<1xi32>
          memref.store %21, %3[] : memref<i32>
        }
        %10 = memref.alloca() : memref<i1>
        %11 = memref.alloca() : memref<i1>
        memref.store %true, %11[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %12 = memref.load %3[] : memref<i32>
        %13 = arith.cmpi sgt, %12, %c0_i32 : i32
        %14 = memref.load %11[] : memref<i1>
        %15 = arith.andi %13, %14 : i1
        cf.cond_br %15, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %16 = memref.load %11[] : memref<i1>
        memref.store %16, %10[] : memref<i1>
        %17 = memref.load %10[] : memref<i1>
        scf.if %17 {
          %20 = memref.load %10[] : memref<i1>
          scf.if %20 {
            scf.execute_region {
              %21 = memref.load %10[] : memref<i1>
              scf.if %21 {
                memref.store %c0_i32, %2[] : memref<i32>
              }
              %22 = memref.alloca() : memref<i1>
              %23 = memref.alloca() : memref<i1>
              memref.store %true, %23[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %24 = memref.load %2[] : memref<i32>
              %25 = memref.get_global @jm : memref<1xi32>
              %26 = memref.load %25[%c0] : memref<1xi32>
              %27 = arith.cmpi slt, %24, %26 : i32
              %28 = memref.load %23[] : memref<i1>
              %29 = arith.andi %27, %28 : i1
              cf.cond_br %29, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %30 = memref.load %23[] : memref<i1>
              memref.store %30, %22[] : memref<i1>
              %31 = memref.load %22[] : memref<i1>
              scf.if %31 {
                %34 = memref.load %22[] : memref<i1>
                scf.if %34 {
                  scf.execute_region {
                    %35 = memref.load %22[] : memref<i1>
                    scf.if %35 {
                      memref.store %c0_i32, %0[] : memref<i32>
                    }
                    %36 = memref.alloca() : memref<i1>
                    %37 = memref.alloca() : memref<i1>
                    memref.store %true, %37[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %38 = memref.load %0[] : memref<i32>
                    %39 = memref.get_global @im : memref<1xi32>
                    %40 = memref.load %39[%c0] : memref<1xi32>
                    %41 = arith.cmpi slt, %38, %40 : i32
                    %42 = memref.load %37[] : memref<i1>
                    %43 = arith.andi %41, %42 : i1
                    cf.cond_br %43, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %44 = memref.load %37[] : memref<i1>
                    memref.store %44, %36[] : memref<i1>
                    %45 = memref.load %36[] : memref<i1>
                    scf.if %45 {
                      %48 = memref.load %4[] : memref<memref<?xf32>>
                      %49 = memref.load %0[] : memref<i32>
                      %50 = memref.load %2[] : memref<i32>
                      %51 = memref.load %39[%c0] : memref<1xi32>
                      %52 = arith.muli %50, %51 : i32
                      %53 = arith.addi %49, %52 : i32
                      %54 = memref.load %3[] : memref<i32>
                      %55 = arith.muli %54, %51 : i32
                      %56 = memref.load %25[%c0] : memref<1xi32>
                      %57 = arith.muli %55, %56 : i32
                      %58 = arith.addi %53, %57 : i32
                      %59 = arith.index_cast %58 : i32 to index
                      %60 = memref.load %5[] : memref<memref<?xf32>>
                      %61 = arith.subi %54, %c1_i32 : i32
                      %62 = arith.muli %61, %51 : i32
                      %63 = arith.muli %62, %56 : i32
                      %64 = arith.addi %53, %63 : i32
                      %65 = arith.index_cast %64 : i32 to index
                      %66 = arith.addi %65, %c0 : index
                      %67 = memref.load %60[%66] : memref<?xf32>
                      %68 = arith.addi %59, %c0 : index
                      memref.store %67, %48[%68] : memref<?xf32>
                    }
                    %46 = memref.load %37[] : memref<i1>
                    memref.store %46, %36[] : memref<i1>
                    %47 = memref.load %36[] : memref<i1>
                    scf.if %47 {
                      %48 = memref.load %0[] : memref<i32>
                      %49 = arith.addi %48, %c1_i32 : i32
                      memref.store %49, %0[] : memref<i32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %32 = memref.load %23[] : memref<i1>
              memref.store %32, %22[] : memref<i1>
              %33 = memref.load %22[] : memref<i1>
              scf.if %33 {
                %34 = memref.load %2[] : memref<i32>
                %35 = arith.addi %34, %c1_i32 : i32
                memref.store %35, %2[] : memref<i32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %18 = memref.load %11[] : memref<i1>
        memref.store %18, %10[] : memref<i1>
        %19 = memref.load %10[] : memref<i1>
        scf.if %19 {
          %20 = memref.load %3[] : memref<i32>
          %21 = arith.subi %20, %c1_i32 : i32
          memref.store %21, %3[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  func.return


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%1 = llvm.mlir.undef : i32
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %8 = memref.load %6[] : memref<i1>
  scf.if %8 {
    scf.execute_region {
      %9 = memref.load %6[] : memref<i1>
      scf.if %9 {
        %20 = memref.get_global @kbm3 : memref<1xi32>
        %21 = memref.load %20[%c0] : memref<1xi32>
        memref.store %21, %3[] : memref<i32>
      }
      %10 = memref.alloca() : memref<i1>
      %11 = memref.alloca() : memref<i1>
      memref.store %true, %11[] : memref<i1>
      cf.br ^bb1
    ^bb1:  // 2 preds: ^bb0, ^bb2
      %12 = memref.load %3[] : memref<i32>
      %13 = arith.cmpi sgt, %12, %c0_i32 : i32
      %14 = memref.load %11[] : memref<i1>
      %15 = arith.andi %13, %14 : i1
      cf.cond_br %15, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %16 = memref.load %11[] : memref<i1>
      memref.store %16, %10[] : memref<i1>
      %17 = memref.load %10[] : memref<i1>
      scf.if %17 {
        %20 = memref.load %10[] : memref<i1>
        scf.if %20 {
          scf.execute_region {
            %21 = memref.load %10[] : memref<i1>
            scf.if %21 {
              memref.store %c0_i32, %2[] : memref<i32>
            }
            %22 = memref.alloca() : memref<i1>
            %23 = memref.alloca() : memref<i1>
            memref.store %true, %23[] : memref<i1>
            cf.br ^bb1
          ^bb1:  // 2 preds: ^bb0, ^bb2
            %24 = memref.load %2[] : memref<i32>
            %25 = memref.get_global @jm : memref<1xi32>
            %26 = memref.load %25[%c0] : memref<1xi32>
            %27 = arith.cmpi slt, %24, %26 : i32
            %28 = memref.load %23[] : memref<i1>
            %29 = arith.andi %27, %28 : i1
            cf.cond_br %29, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %30 = memref.load %23[] : memref<i1>
            memref.store %30, %22[] : memref<i1>
            %31 = memref.load %22[] : memref<i1>
            scf.if %31 {
              %34 = memref.load %22[] : memref<i1>
              scf.if %34 {
                scf.execute_region {
                  %35 = memref.load %22[] : memref<i1>
                  scf.if %35 {
                    memref.store %c0_i32, %0[] : memref<i32>
                  }
                  %36 = memref.alloca() : memref<i1>
                  %37 = memref.alloca() : memref<i1>
                  memref.store %true, %37[] : memref<i1>
                  cf.br ^bb1
                ^bb1:  // 2 preds: ^bb0, ^bb2
                  %38 = memref.load %0[] : memref<i32>
                  %39 = memref.get_global @im : memref<1xi32>
                  %40 = memref.load %39[%c0] : memref<1xi32>
                  %41 = arith.cmpi slt, %38, %40 : i32
                  %42 = memref.load %37[] : memref<i1>
                  %43 = arith.andi %41, %42 : i1
                  cf.cond_br %43, ^bb2, ^bb3
                ^bb2:  // pred: ^bb1
                  %44 = memref.load %37[] : memref<i1>
                  memref.store %44, %36[] : memref<i1>
                  %45 = memref.load %36[] : memref<i1>
                  scf.if %45 {
                    %48 = memref.load %4[] : memref<memref<?xf32>>
                    %49 = memref.load %0[] : memref<i32>
                    %50 = memref.load %2[] : memref<i32>
                    %51 = memref.load %39[%c0] : memref<1xi32>
                    %52 = arith.muli %50, %51 : i32
                    %53 = arith.addi %49, %52 : i32
                    %54 = memref.load %3[] : memref<i32>
                    %55 = arith.muli %54, %51 : i32
                    %56 = memref.load %25[%c0] : memref<1xi32>
                    %57 = arith.muli %55, %56 : i32
                    %58 = arith.addi %53, %57 : i32
                    %59 = arith.index_cast %58 : i32 to index
                    %60 = memref.load %5[] : memref<memref<?xf32>>
                    %61 = arith.subi %54, %c1_i32 : i32
                    %62 = arith.muli %61, %51 : i32
                    %63 = arith.muli %62, %56 : i32
                    %64 = arith.addi %53, %63 : i32
                    %65 = arith.index_cast %64 : i32 to index
                    %66 = arith.addi %65, %c0 : index
                    %67 = memref.load %60[%66] : memref<?xf32>
                    %68 = arith.addi %59, %c0 : index
                    memref.store %67, %48[%68] : memref<?xf32>
                  }
                  %46 = memref.load %37[] : memref<i1>
                  memref.store %46, %36[] : memref<i1>
                  %47 = memref.load %36[] : memref<i1>
                  scf.if %47 {
                    %48 = memref.load %0[] : memref<i32>
                    %49 = arith.addi %48, %c1_i32 : i32
                    memref.store %49, %0[] : memref<i32>
                  }
                  cf.br ^bb1
                ^bb3:  // pred: ^bb1
                  scf.yield
                }
              }
            }
            %32 = memref.load %23[] : memref<i1>
            memref.store %32, %22[] : memref<i1>
            %33 = memref.load %22[] : memref<i1>
            scf.if %33 {
              %34 = memref.load %2[] : memref<i32>
              %35 = arith.addi %34, %c1_i32 : i32
              memref.store %35, %2[] : memref<i32>
            }
            cf.br ^bb1
          ^bb3:  // pred: ^bb1
            scf.yield
          }
        }
      }
      %18 = memref.load %11[] : memref<i1>
      memref.store %18, %10[] : memref<i1>
      %19 = memref.load %10[] : memref<i1>
      scf.if %19 {
        %20 = memref.load %3[] : memref<i32>
        %21 = arith.subi %20, %c1_i32 : i32
        memref.store %21, %3[] : memref<i32>
      }
      cf.br ^bb1
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
  scf.yield


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%1 = llvm.mlir.undef : i32
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.execute_region {
    %9 = memref.load %6[] : memref<i1>
    scf.if %9 {
      %20 = memref.get_global @kbm3 : memref<1xi32>
      %21 = memref.load %20[%c0] : memref<1xi32>
      memref.store %21, %3[] : memref<i32>
    }
    %10 = memref.alloca() : memref<i1>
    %11 = memref.alloca() : memref<i1>
    memref.store %true, %11[] : memref<i1>
    cf.br ^bb1
  ^bb1:  // 2 preds: ^bb0, ^bb2
    %12 = memref.load %3[] : memref<i32>
    %13 = arith.cmpi sgt, %12, %c0_i32 : i32
    %14 = memref.load %11[] : memref<i1>
    %15 = arith.andi %13, %14 : i1
    cf.cond_br %15, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %16 = memref.load %11[] : memref<i1>
    memref.store %16, %10[] : memref<i1>
    %17 = memref.load %10[] : memref<i1>
    scf.if %17 {
      %20 = memref.load %10[] : memref<i1>
      scf.if %20 {
        scf.execute_region {
          %21 = memref.load %10[] : memref<i1>
          scf.if %21 {
            memref.store %c0_i32, %2[] : memref<i32>
          }
          %22 = memref.alloca() : memref<i1>
          %23 = memref.alloca() : memref<i1>
          memref.store %true, %23[] : memref<i1>
          cf.br ^bb1
        ^bb1:  // 2 preds: ^bb0, ^bb2
          %24 = memref.load %2[] : memref<i32>
          %25 = memref.get_global @jm : memref<1xi32>
          %26 = memref.load %25[%c0] : memref<1xi32>
          %27 = arith.cmpi slt, %24, %26 : i32
          %28 = memref.load %23[] : memref<i1>
          %29 = arith.andi %27, %28 : i1
          cf.cond_br %29, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %30 = memref.load %23[] : memref<i1>
          memref.store %30, %22[] : memref<i1>
          %31 = memref.load %22[] : memref<i1>
          scf.if %31 {
            %34 = memref.load %22[] : memref<i1>
            scf.if %34 {
              scf.execute_region {
                %35 = memref.load %22[] : memref<i1>
                scf.if %35 {
                  memref.store %c0_i32, %0[] : memref<i32>
                }
                %36 = memref.alloca() : memref<i1>
                %37 = memref.alloca() : memref<i1>
                memref.store %true, %37[] : memref<i1>
                cf.br ^bb1
              ^bb1:  // 2 preds: ^bb0, ^bb2
                %38 = memref.load %0[] : memref<i32>
                %39 = memref.get_global @im : memref<1xi32>
                %40 = memref.load %39[%c0] : memref<1xi32>
                %41 = arith.cmpi slt, %38, %40 : i32
                %42 = memref.load %37[] : memref<i1>
                %43 = arith.andi %41, %42 : i1
                cf.cond_br %43, ^bb2, ^bb3
              ^bb2:  // pred: ^bb1
                %44 = memref.load %37[] : memref<i1>
                memref.store %44, %36[] : memref<i1>
                %45 = memref.load %36[] : memref<i1>
                scf.if %45 {
                  %48 = memref.load %4[] : memref<memref<?xf32>>
                  %49 = memref.load %0[] : memref<i32>
                  %50 = memref.load %2[] : memref<i32>
                  %51 = memref.load %39[%c0] : memref<1xi32>
                  %52 = arith.muli %50, %51 : i32
                  %53 = arith.addi %49, %52 : i32
                  %54 = memref.load %3[] : memref<i32>
                  %55 = arith.muli %54, %51 : i32
                  %56 = memref.load %25[%c0] : memref<1xi32>
                  %57 = arith.muli %55, %56 : i32
                  %58 = arith.addi %53, %57 : i32
                  %59 = arith.index_cast %58 : i32 to index
                  %60 = memref.load %5[] : memref<memref<?xf32>>
                  %61 = arith.subi %54, %c1_i32 : i32
                  %62 = arith.muli %61, %51 : i32
                  %63 = arith.muli %62, %56 : i32
                  %64 = arith.addi %53, %63 : i32
                  %65 = arith.index_cast %64 : i32 to index
                  %66 = arith.addi %65, %c0 : index
                  %67 = memref.load %60[%66] : memref<?xf32>
                  %68 = arith.addi %59, %c0 : index
                  memref.store %67, %48[%68] : memref<?xf32>
                }
                %46 = memref.load %37[] : memref<i1>
                memref.store %46, %36[] : memref<i1>
                %47 = memref.load %36[] : memref<i1>
                scf.if %47 {
                  %48 = memref.load %0[] : memref<i32>
                  %49 = arith.addi %48, %c1_i32 : i32
                  memref.store %49, %0[] : memref<i32>
                }
                cf.br ^bb1
              ^bb3:  // pred: ^bb1
                scf.yield
              }
            }
          }
          %32 = memref.load %23[] : memref<i1>
          memref.store %32, %22[] : memref<i1>
          %33 = memref.load %22[] : memref<i1>
          scf.if %33 {
            %34 = memref.load %2[] : memref<i32>
            %35 = arith.addi %34, %c1_i32 : i32
            memref.store %35, %2[] : memref<i32>
          }
          cf.br ^bb1
        ^bb3:  // pred: ^bb1
          scf.yield
        }
      }
    }
    %18 = memref.load %11[] : memref<i1>
    memref.store %18, %10[] : memref<i1>
    %19 = memref.load %10[] : memref<i1>
    scf.if %19 {
      %20 = memref.load %3[] : memref<i32>
      %21 = arith.subi %20, %c1_i32 : i32
      memref.store %21, %3[] : memref<i32>
    }
    cf.br ^bb1
  ^bb3:  // pred: ^bb1
    scf.yield
  }
  scf.yield


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%1 = llvm.mlir.undef : i32
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %9 = memref.load %6[] : memref<i1>
  scf.if %9 {
    %20 = memref.get_global @kbm3 : memref<1xi32>
    %21 = memref.load %20[%c0] : memref<1xi32>
    memref.store %21, %3[] : memref<i32>
  }
  %10 = memref.alloca() : memref<i1>
  %11 = memref.alloca() : memref<i1>
  memref.store %true, %11[] : memref<i1>
  cf.br ^bb1


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%1 = llvm.mlir.undef : i32
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %20 = memref.get_global @kbm3 : memref<1xi32>
  %21 = memref.load %20[%c0] : memref<1xi32>
  memref.store %21, %3[] : memref<i32>
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %20 = memref.get_global @kbm3 : memref<1xi32>
  %21 = memref.load %20[%c0] : memref<1xi32>
  memref.store %21, %3[] : memref<i32>
  scf.yield
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%1 = llvm.mlir.undef : i32
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %9 = memref.load %6[] : memref<i1>
  scf.if %9 {
    %20 = memref.get_global @kbm3 : memref<1xi32>
    %21 = memref.load %20[%c0] : memref<1xi32>
    memref.store %21, %3[] : memref<i32>
  }
  %10 = memref.alloca() : memref<i1>
  %11 = memref.alloca() : memref<i1>
  memref.store %true, %11[] : memref<i1>
  cf.br ^bb1
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%1 = llvm.mlir.undef : i32

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb1:  // 2 preds: ^bb0, ^bb2
  %12 = memref.load %3[] : memref<i32>
  %13 = arith.cmpi sgt, %12, %c0_i32 : i32
  %14 = memref.load %11[] : memref<i1>
  %15 = arith.andi %13, %14 : i1
  cf.cond_br %15, ^bb2, ^bb3

mlir-asm-printer: Verifying operation: builtin.module
^bb1:  // 2 preds: ^bb0, ^bb2
  %12 = memref.load %3[] : memref<i32>
  %13 = arith.cmpi sgt, %12, %c0_i32 : i32
  %14 = memref.load %11[] : memref<i1>
  %15 = arith.andi %13, %14 : i1
  cf.cond_br %15, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1:  // 2 preds: ^bb0, ^bb2
  %12 = memref.load %3[] : memref<i32>
  %13 = arith.cmpi sgt, %12, %c0_i32 : i32
  %14 = memref.load %11[] : memref<i1>
  %15 = arith.andi %13, %14 : i1
  cf.cond_br %15, ^bb2, ^bb3
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb1:  // 2 preds: ^bb0, ^bb2
  %12 = memref.load %3[] : memref<i32>
  %13 = arith.cmpi sgt, %12, %c0_i32 : i32
  %14 = memref.load %11[] : memref<i1>
  %15 = arith.andi %13, %14 : i1
  cf.cond_br %15, ^bb2, ^bb3


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %16 = memref.load %11[] : memref<i1>
  memref.store %16, %10[] : memref<i1>
  %17 = memref.load %10[] : memref<i1>
  scf.if %17 {
    %20 = memref.load %10[] : memref<i1>
    scf.if %20 {
      scf.execute_region {
        %21 = memref.load %10[] : memref<i1>
        scf.if %21 {
          memref.store %c0_i32, %2[] : memref<i32>
        }
        %22 = memref.alloca() : memref<i1>
        %23 = memref.alloca() : memref<i1>
        memref.store %true, %23[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %24 = memref.load %2[] : memref<i32>
        %25 = memref.get_global @jm : memref<1xi32>
        %26 = memref.load %25[%c0] : memref<1xi32>
        %27 = arith.cmpi slt, %24, %26 : i32
        %28 = memref.load %23[] : memref<i1>
        %29 = arith.andi %27, %28 : i1
        cf.cond_br %29, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %30 = memref.load %23[] : memref<i1>
        memref.store %30, %22[] : memref<i1>
        %31 = memref.load %22[] : memref<i1>
        scf.if %31 {
          %34 = memref.load %22[] : memref<i1>
          scf.if %34 {
            scf.execute_region {
              %35 = memref.load %22[] : memref<i1>
              scf.if %35 {
                memref.store %c0_i32, %0[] : memref<i32>
              }
              %36 = memref.alloca() : memref<i1>
              %37 = memref.alloca() : memref<i1>
              memref.store %true, %37[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %38 = memref.load %0[] : memref<i32>
              %39 = memref.get_global @im : memref<1xi32>
              %40 = memref.load %39[%c0] : memref<1xi32>
              %41 = arith.cmpi slt, %38, %40 : i32
              %42 = memref.load %37[] : memref<i1>
              %43 = arith.andi %41, %42 : i1
              cf.cond_br %43, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %44 = memref.load %37[] : memref<i1>
              memref.store %44, %36[] : memref<i1>
              %45 = memref.load %36[] : memref<i1>
              scf.if %45 {
                %48 = memref.load %4[] : memref<memref<?xf32>>
                %49 = memref.load %0[] : memref<i32>
                %50 = memref.load %2[] : memref<i32>
                %51 = memref.load %39[%c0] : memref<1xi32>
                %52 = arith.muli %50, %51 : i32
                %53 = arith.addi %49, %52 : i32
                %54 = memref.load %3[] : memref<i32>
                %55 = arith.muli %54, %51 : i32
                %56 = memref.load %25[%c0] : memref<1xi32>
                %57 = arith.muli %55, %56 : i32
                %58 = arith.addi %53, %57 : i32
                %59 = arith.index_cast %58 : i32 to index
                %60 = memref.load %5[] : memref<memref<?xf32>>
                %61 = arith.subi %54, %c1_i32 : i32
                %62 = arith.muli %61, %51 : i32
                %63 = arith.muli %62, %56 : i32
                %64 = arith.addi %53, %63 : i32
                %65 = arith.index_cast %64 : i32 to index
                %66 = arith.addi %65, %c0 : index
                %67 = memref.load %60[%66] : memref<?xf32>
                %68 = arith.addi %59, %c0 : index
                memref.store %67, %48[%68] : memref<?xf32>
              }
              %46 = memref.load %37[] : memref<i1>
              memref.store %46, %36[] : memref<i1>
              %47 = memref.load %36[] : memref<i1>
              scf.if %47 {
                %48 = memref.load %0[] : memref<i32>
                %49 = arith.addi %48, %c1_i32 : i32
                memref.store %49, %0[] : memref<i32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %32 = memref.load %23[] : memref<i1>
        memref.store %32, %22[] : memref<i1>
        %33 = memref.load %22[] : memref<i1>
        scf.if %33 {
          %34 = memref.load %2[] : memref<i32>
          %35 = arith.addi %34, %c1_i32 : i32
          memref.store %35, %2[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  scf.if %19 {
    %20 = memref.load %3[] : memref<i32>
    %21 = arith.subi %20, %c1_i32 : i32
    memref.store %21, %3[] : memref<i32>
  }
  cf.br ^bb1

mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %16 = memref.load %11[] : memref<i1>
  memref.store %16, %10[] : memref<i1>
  %17 = memref.load %10[] : memref<i1>
  scf.if %17 {
    %20 = memref.load %10[] : memref<i1>
    scf.if %20 {
      scf.execute_region {
        %21 = memref.load %10[] : memref<i1>
        scf.if %21 {
          memref.store %c0_i32, %2[] : memref<i32>
        }
        %22 = memref.alloca() : memref<i1>
        %23 = memref.alloca() : memref<i1>
        memref.store %true, %23[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %24 = memref.load %2[] : memref<i32>
        %25 = memref.get_global @jm : memref<1xi32>
        %26 = memref.load %25[%c0] : memref<1xi32>
        %27 = arith.cmpi slt, %24, %26 : i32
        %28 = memref.load %23[] : memref<i1>
        %29 = arith.andi %27, %28 : i1
        cf.cond_br %29, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %30 = memref.load %23[] : memref<i1>
        memref.store %30, %22[] : memref<i1>
        %31 = memref.load %22[] : memref<i1>
        scf.if %31 {
          %34 = memref.load %22[] : memref<i1>
          scf.if %34 {
            scf.execute_region {
              %35 = memref.load %22[] : memref<i1>
              scf.if %35 {
                memref.store %c0_i32, %0[] : memref<i32>
              }
              %36 = memref.alloca() : memref<i1>
              %37 = memref.alloca() : memref<i1>
              memref.store %true, %37[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %38 = memref.load %0[] : memref<i32>
              %39 = memref.get_global @im : memref<1xi32>
              %40 = memref.load %39[%c0] : memref<1xi32>
              %41 = arith.cmpi slt, %38, %40 : i32
              %42 = memref.load %37[] : memref<i1>
              %43 = arith.andi %41, %42 : i1
              cf.cond_br %43, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %44 = memref.load %37[] : memref<i1>
              memref.store %44, %36[] : memref<i1>
              %45 = memref.load %36[] : memref<i1>
              scf.if %45 {
                %48 = memref.load %4[] : memref<memref<?xf32>>
                %49 = memref.load %0[] : memref<i32>
                %50 = memref.load %2[] : memref<i32>
                %51 = memref.load %39[%c0] : memref<1xi32>
                %52 = arith.muli %50, %51 : i32
                %53 = arith.addi %49, %52 : i32
                %54 = memref.load %3[] : memref<i32>
                %55 = arith.muli %54, %51 : i32
                %56 = memref.load %25[%c0] : memref<1xi32>
                %57 = arith.muli %55, %56 : i32
                %58 = arith.addi %53, %57 : i32
                %59 = arith.index_cast %58 : i32 to index
                %60 = memref.load %5[] : memref<memref<?xf32>>
                %61 = arith.subi %54, %c1_i32 : i32
                %62 = arith.muli %61, %51 : i32
                %63 = arith.muli %62, %56 : i32
                %64 = arith.addi %53, %63 : i32
                %65 = arith.index_cast %64 : i32 to index
                %66 = arith.addi %65, %c0 : index
                %67 = memref.load %60[%66] : memref<?xf32>
                %68 = arith.addi %59, %c0 : index
                memref.store %67, %48[%68] : memref<?xf32>
              }
              %46 = memref.load %37[] : memref<i1>
              memref.store %46, %36[] : memref<i1>
              %47 = memref.load %36[] : memref<i1>
              scf.if %47 {
                %48 = memref.load %0[] : memref<i32>
                %49 = arith.addi %48, %c1_i32 : i32
                memref.store %49, %0[] : memref<i32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %32 = memref.load %23[] : memref<i1>
        memref.store %32, %22[] : memref<i1>
        %33 = memref.load %22[] : memref<i1>
        scf.if %33 {
          %34 = memref.load %2[] : memref<i32>
          %35 = arith.addi %34, %c1_i32 : i32
          memref.store %35, %2[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  scf.if %19 {
    %20 = memref.load %3[] : memref<i32>
    %21 = arith.subi %20, %c1_i32 : i32
    memref.store %21, %3[] : memref<i32>
  }
  cf.br ^bb1


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %16 = memref.load %11[] : memref<i1>
  memref.store %16, %10[] : memref<i1>
  %17 = memref.load %10[] : memref<i1>
  scf.if %17 {
    %20 = memref.load %10[] : memref<i1>
    scf.if %20 {
      scf.execute_region {
        %21 = memref.load %10[] : memref<i1>
        scf.if %21 {
          memref.store %c0_i32, %2[] : memref<i32>
        }
        %22 = memref.alloca() : memref<i1>
        %23 = memref.alloca() : memref<i1>
        memref.store %true, %23[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %24 = memref.load %2[] : memref<i32>
        %25 = memref.get_global @jm : memref<1xi32>
        %26 = memref.load %25[%c0] : memref<1xi32>
        %27 = arith.cmpi slt, %24, %26 : i32
        %28 = memref.load %23[] : memref<i1>
        %29 = arith.andi %27, %28 : i1
        cf.cond_br %29, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %30 = memref.load %23[] : memref<i1>
        memref.store %30, %22[] : memref<i1>
        %31 = memref.load %22[] : memref<i1>
        scf.if %31 {
          %34 = memref.load %22[] : memref<i1>
          scf.if %34 {
            scf.execute_region {
              %35 = memref.load %22[] : memref<i1>
              scf.if %35 {
                memref.store %c0_i32, %0[] : memref<i32>
              }
              %36 = memref.alloca() : memref<i1>
              %37 = memref.alloca() : memref<i1>
              memref.store %true, %37[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %38 = memref.load %0[] : memref<i32>
              %39 = memref.get_global @im : memref<1xi32>
              %40 = memref.load %39[%c0] : memref<1xi32>
              %41 = arith.cmpi slt, %38, %40 : i32
              %42 = memref.load %37[] : memref<i1>
              %43 = arith.andi %41, %42 : i1
              cf.cond_br %43, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %44 = memref.load %37[] : memref<i1>
              memref.store %44, %36[] : memref<i1>
              %45 = memref.load %36[] : memref<i1>
              scf.if %45 {
                %48 = memref.load %4[] : memref<memref<?xf32>>
                %49 = memref.load %0[] : memref<i32>
                %50 = memref.load %2[] : memref<i32>
                %51 = memref.load %39[%c0] : memref<1xi32>
                %52 = arith.muli %50, %51 : i32
                %53 = arith.addi %49, %52 : i32
                %54 = memref.load %3[] : memref<i32>
                %55 = arith.muli %54, %51 : i32
                %56 = memref.load %25[%c0] : memref<1xi32>
                %57 = arith.muli %55, %56 : i32
                %58 = arith.addi %53, %57 : i32
                %59 = arith.index_cast %58 : i32 to index
                %60 = memref.load %5[] : memref<memref<?xf32>>
                %61 = arith.subi %54, %c1_i32 : i32
                %62 = arith.muli %61, %51 : i32
                %63 = arith.muli %62, %56 : i32
                %64 = arith.addi %53, %63 : i32
                %65 = arith.index_cast %64 : i32 to index
                %66 = arith.addi %65, %c0 : index
                %67 = memref.load %60[%66] : memref<?xf32>
                %68 = arith.addi %59, %c0 : index
                memref.store %67, %48[%68] : memref<?xf32>
              }
              %46 = memref.load %37[] : memref<i1>
              memref.store %46, %36[] : memref<i1>
              %47 = memref.load %36[] : memref<i1>
              scf.if %47 {
                %48 = memref.load %0[] : memref<i32>
                %49 = arith.addi %48, %c1_i32 : i32
                memref.store %49, %0[] : memref<i32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %32 = memref.load %23[] : memref<i1>
        memref.store %32, %22[] : memref<i1>
        %33 = memref.load %22[] : memref<i1>
        scf.if %33 {
          %34 = memref.load %2[] : memref<i32>
          %35 = arith.addi %34, %c1_i32 : i32
          memref.store %35, %2[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  scf.if %19 {
    %20 = memref.load %3[] : memref<i32>
    %21 = arith.subi %20, %c1_i32 : i32
    memref.store %21, %3[] : memref<i32>
  }
  cf.br ^bb1

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %20 = memref.load %10[] : memref<i1>
  scf.if %20 {
    scf.execute_region {
      %21 = memref.load %10[] : memref<i1>
      scf.if %21 {
        memref.store %c0_i32, %2[] : memref<i32>
      }
      %22 = memref.alloca() : memref<i1>
      %23 = memref.alloca() : memref<i1>
      memref.store %true, %23[] : memref<i1>
      cf.br ^bb1
    ^bb1:  // 2 preds: ^bb0, ^bb2
      %24 = memref.load %2[] : memref<i32>
      %25 = memref.get_global @jm : memref<1xi32>
      %26 = memref.load %25[%c0] : memref<1xi32>
      %27 = arith.cmpi slt, %24, %26 : i32
      %28 = memref.load %23[] : memref<i1>
      %29 = arith.andi %27, %28 : i1
      cf.cond_br %29, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %30 = memref.load %23[] : memref<i1>
      memref.store %30, %22[] : memref<i1>
      %31 = memref.load %22[] : memref<i1>
      scf.if %31 {
        %34 = memref.load %22[] : memref<i1>
        scf.if %34 {
          scf.execute_region {
            %35 = memref.load %22[] : memref<i1>
            scf.if %35 {
              memref.store %c0_i32, %0[] : memref<i32>
            }
            %36 = memref.alloca() : memref<i1>
            %37 = memref.alloca() : memref<i1>
            memref.store %true, %37[] : memref<i1>
            cf.br ^bb1
          ^bb1:  // 2 preds: ^bb0, ^bb2
            %38 = memref.load %0[] : memref<i32>
            %39 = memref.get_global @im : memref<1xi32>
            %40 = memref.load %39[%c0] : memref<1xi32>
            %41 = arith.cmpi slt, %38, %40 : i32
            %42 = memref.load %37[] : memref<i1>
            %43 = arith.andi %41, %42 : i1
            cf.cond_br %43, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %44 = memref.load %37[] : memref<i1>
            memref.store %44, %36[] : memref<i1>
            %45 = memref.load %36[] : memref<i1>
            scf.if %45 {
              %48 = memref.load %4[] : memref<memref<?xf32>>
              %49 = memref.load %0[] : memref<i32>
              %50 = memref.load %2[] : memref<i32>
              %51 = memref.load %39[%c0] : memref<1xi32>
              %52 = arith.muli %50, %51 : i32
              %53 = arith.addi %49, %52 : i32
              %54 = memref.load %3[] : memref<i32>
              %55 = arith.muli %54, %51 : i32
              %56 = memref.load %25[%c0] : memref<1xi32>
              %57 = arith.muli %55, %56 : i32
              %58 = arith.addi %53, %57 : i32
              %59 = arith.index_cast %58 : i32 to index
              %60 = memref.load %5[] : memref<memref<?xf32>>
              %61 = arith.subi %54, %c1_i32 : i32
              %62 = arith.muli %61, %51 : i32
              %63 = arith.muli %62, %56 : i32
              %64 = arith.addi %53, %63 : i32
              %65 = arith.index_cast %64 : i32 to index
              %66 = arith.addi %65, %c0 : index
              %67 = memref.load %60[%66] : memref<?xf32>
              %68 = arith.addi %59, %c0 : index
              memref.store %67, %48[%68] : memref<?xf32>
            }
            %46 = memref.load %37[] : memref<i1>
            memref.store %46, %36[] : memref<i1>
            %47 = memref.load %36[] : memref<i1>
            scf.if %47 {
              %48 = memref.load %0[] : memref<i32>
              %49 = arith.addi %48, %c1_i32 : i32
              memref.store %49, %0[] : memref<i32>
            }
            cf.br ^bb1
          ^bb3:  // pred: ^bb1
            scf.yield
          }
        }
      }
      %32 = memref.load %23[] : memref<i1>
      memref.store %32, %22[] : memref<i1>
      %33 = memref.load %22[] : memref<i1>
      scf.if %33 {
        %34 = memref.load %2[] : memref<i32>
        %35 = arith.addi %34, %c1_i32 : i32
        memref.store %35, %2[] : memref<i32>
      }
      cf.br ^bb1
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
  scf.yield


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %16 = memref.load %11[] : memref<i1>
  memref.store %16, %10[] : memref<i1>
  %17 = memref.load %10[] : memref<i1>
  scf.if %17 {
    %20 = memref.load %10[] : memref<i1>
    scf.if %20 {
      scf.execute_region {
        %21 = memref.load %10[] : memref<i1>
        scf.if %21 {
          memref.store %c0_i32, %2[] : memref<i32>
        }
        %22 = memref.alloca() : memref<i1>
        %23 = memref.alloca() : memref<i1>
        memref.store %true, %23[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %24 = memref.load %2[] : memref<i32>
        %25 = memref.get_global @jm : memref<1xi32>
        %26 = memref.load %25[%c0] : memref<1xi32>
        %27 = arith.cmpi slt, %24, %26 : i32
        %28 = memref.load %23[] : memref<i1>
        %29 = arith.andi %27, %28 : i1
        cf.cond_br %29, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %30 = memref.load %23[] : memref<i1>
        memref.store %30, %22[] : memref<i1>
        %31 = memref.load %22[] : memref<i1>
        scf.if %31 {
          %34 = memref.load %22[] : memref<i1>
          scf.if %34 {
            scf.execute_region {
              %35 = memref.load %22[] : memref<i1>
              scf.if %35 {
                memref.store %c0_i32, %0[] : memref<i32>
              }
              %36 = memref.alloca() : memref<i1>
              %37 = memref.alloca() : memref<i1>
              memref.store %true, %37[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %38 = memref.load %0[] : memref<i32>
              %39 = memref.get_global @im : memref<1xi32>
              %40 = memref.load %39[%c0] : memref<1xi32>
              %41 = arith.cmpi slt, %38, %40 : i32
              %42 = memref.load %37[] : memref<i1>
              %43 = arith.andi %41, %42 : i1
              cf.cond_br %43, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %44 = memref.load %37[] : memref<i1>
              memref.store %44, %36[] : memref<i1>
              %45 = memref.load %36[] : memref<i1>
              scf.if %45 {
                %48 = memref.load %4[] : memref<memref<?xf32>>
                %49 = memref.load %0[] : memref<i32>
                %50 = memref.load %2[] : memref<i32>
                %51 = memref.load %39[%c0] : memref<1xi32>
                %52 = arith.muli %50, %51 : i32
                %53 = arith.addi %49, %52 : i32
                %54 = memref.load %3[] : memref<i32>
                %55 = arith.muli %54, %51 : i32
                %56 = memref.load %25[%c0] : memref<1xi32>
                %57 = arith.muli %55, %56 : i32
                %58 = arith.addi %53, %57 : i32
                %59 = arith.index_cast %58 : i32 to index
                %60 = memref.load %5[] : memref<memref<?xf32>>
                %61 = arith.subi %54, %c1_i32 : i32
                %62 = arith.muli %61, %51 : i32
                %63 = arith.muli %62, %56 : i32
                %64 = arith.addi %53, %63 : i32
                %65 = arith.index_cast %64 : i32 to index
                %66 = arith.addi %65, %c0 : index
                %67 = memref.load %60[%66] : memref<?xf32>
                %68 = arith.addi %59, %c0 : index
                memref.store %67, %48[%68] : memref<?xf32>
              }
              %46 = memref.load %37[] : memref<i1>
              memref.store %46, %36[] : memref<i1>
              %47 = memref.load %36[] : memref<i1>
              scf.if %47 {
                %48 = memref.load %0[] : memref<i32>
                %49 = arith.addi %48, %c1_i32 : i32
                memref.store %49, %0[] : memref<i32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %32 = memref.load %23[] : memref<i1>
        memref.store %32, %22[] : memref<i1>
        %33 = memref.load %22[] : memref<i1>
        scf.if %33 {
          %34 = memref.load %2[] : memref<i32>
          %35 = arith.addi %34, %c1_i32 : i32
          memref.store %35, %2[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  scf.if %19 {
    %20 = memref.load %3[] : memref<i32>
    %21 = arith.subi %20, %c1_i32 : i32
    memref.store %21, %3[] : memref<i32>
  }
  cf.br ^bb1

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.execute_region {
    %21 = memref.load %10[] : memref<i1>
    scf.if %21 {
      memref.store %c0_i32, %2[] : memref<i32>
    }
    %22 = memref.alloca() : memref<i1>
    %23 = memref.alloca() : memref<i1>
    memref.store %true, %23[] : memref<i1>
    cf.br ^bb1
  ^bb1:  // 2 preds: ^bb0, ^bb2
    %24 = memref.load %2[] : memref<i32>
    %25 = memref.get_global @jm : memref<1xi32>
    %26 = memref.load %25[%c0] : memref<1xi32>
    %27 = arith.cmpi slt, %24, %26 : i32
    %28 = memref.load %23[] : memref<i1>
    %29 = arith.andi %27, %28 : i1
    cf.cond_br %29, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %30 = memref.load %23[] : memref<i1>
    memref.store %30, %22[] : memref<i1>
    %31 = memref.load %22[] : memref<i1>
    scf.if %31 {
      %34 = memref.load %22[] : memref<i1>
      scf.if %34 {
        scf.execute_region {
          %35 = memref.load %22[] : memref<i1>
          scf.if %35 {
            memref.store %c0_i32, %0[] : memref<i32>
          }
          %36 = memref.alloca() : memref<i1>
          %37 = memref.alloca() : memref<i1>
          memref.store %true, %37[] : memref<i1>
          cf.br ^bb1
        ^bb1:  // 2 preds: ^bb0, ^bb2
          %38 = memref.load %0[] : memref<i32>
          %39 = memref.get_global @im : memref<1xi32>
          %40 = memref.load %39[%c0] : memref<1xi32>
          %41 = arith.cmpi slt, %38, %40 : i32
          %42 = memref.load %37[] : memref<i1>
          %43 = arith.andi %41, %42 : i1
          cf.cond_br %43, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %44 = memref.load %37[] : memref<i1>
          memref.store %44, %36[] : memref<i1>
          %45 = memref.load %36[] : memref<i1>
          scf.if %45 {
            %48 = memref.load %4[] : memref<memref<?xf32>>
            %49 = memref.load %0[] : memref<i32>
            %50 = memref.load %2[] : memref<i32>
            %51 = memref.load %39[%c0] : memref<1xi32>
            %52 = arith.muli %50, %51 : i32
            %53 = arith.addi %49, %52 : i32
            %54 = memref.load %3[] : memref<i32>
            %55 = arith.muli %54, %51 : i32
            %56 = memref.load %25[%c0] : memref<1xi32>
            %57 = arith.muli %55, %56 : i32
            %58 = arith.addi %53, %57 : i32
            %59 = arith.index_cast %58 : i32 to index
            %60 = memref.load %5[] : memref<memref<?xf32>>
            %61 = arith.subi %54, %c1_i32 : i32
            %62 = arith.muli %61, %51 : i32
            %63 = arith.muli %62, %56 : i32
            %64 = arith.addi %53, %63 : i32
            %65 = arith.index_cast %64 : i32 to index
            %66 = arith.addi %65, %c0 : index
            %67 = memref.load %60[%66] : memref<?xf32>
            %68 = arith.addi %59, %c0 : index
            memref.store %67, %48[%68] : memref<?xf32>
          }
          %46 = memref.load %37[] : memref<i1>
          memref.store %46, %36[] : memref<i1>
          %47 = memref.load %36[] : memref<i1>
          scf.if %47 {
            %48 = memref.load %0[] : memref<i32>
            %49 = arith.addi %48, %c1_i32 : i32
            memref.store %49, %0[] : memref<i32>
          }
          cf.br ^bb1
        ^bb3:  // pred: ^bb1
          scf.yield
        }
      }
    }
    %32 = memref.load %23[] : memref<i1>
    memref.store %32, %22[] : memref<i1>
    %33 = memref.load %22[] : memref<i1>
    scf.if %33 {
      %34 = memref.load %2[] : memref<i32>
      %35 = arith.addi %34, %c1_i32 : i32
      memref.store %35, %2[] : memref<i32>
    }
    cf.br ^bb1
  ^bb3:  // pred: ^bb1
    scf.yield
  }
  scf.yield


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %16 = memref.load %11[] : memref<i1>
  memref.store %16, %10[] : memref<i1>
  %17 = memref.load %10[] : memref<i1>
  scf.if %17 {
    %20 = memref.load %10[] : memref<i1>
    scf.if %20 {
      scf.execute_region {
        %21 = memref.load %10[] : memref<i1>
        scf.if %21 {
          memref.store %c0_i32, %2[] : memref<i32>
        }
        %22 = memref.alloca() : memref<i1>
        %23 = memref.alloca() : memref<i1>
        memref.store %true, %23[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %24 = memref.load %2[] : memref<i32>
        %25 = memref.get_global @jm : memref<1xi32>
        %26 = memref.load %25[%c0] : memref<1xi32>
        %27 = arith.cmpi slt, %24, %26 : i32
        %28 = memref.load %23[] : memref<i1>
        %29 = arith.andi %27, %28 : i1
        cf.cond_br %29, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %30 = memref.load %23[] : memref<i1>
        memref.store %30, %22[] : memref<i1>
        %31 = memref.load %22[] : memref<i1>
        scf.if %31 {
          %34 = memref.load %22[] : memref<i1>
          scf.if %34 {
            scf.execute_region {
              %35 = memref.load %22[] : memref<i1>
              scf.if %35 {
                memref.store %c0_i32, %0[] : memref<i32>
              }
              %36 = memref.alloca() : memref<i1>
              %37 = memref.alloca() : memref<i1>
              memref.store %true, %37[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %38 = memref.load %0[] : memref<i32>
              %39 = memref.get_global @im : memref<1xi32>
              %40 = memref.load %39[%c0] : memref<1xi32>
              %41 = arith.cmpi slt, %38, %40 : i32
              %42 = memref.load %37[] : memref<i1>
              %43 = arith.andi %41, %42 : i1
              cf.cond_br %43, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %44 = memref.load %37[] : memref<i1>
              memref.store %44, %36[] : memref<i1>
              %45 = memref.load %36[] : memref<i1>
              scf.if %45 {
                %48 = memref.load %4[] : memref<memref<?xf32>>
                %49 = memref.load %0[] : memref<i32>
                %50 = memref.load %2[] : memref<i32>
                %51 = memref.load %39[%c0] : memref<1xi32>
                %52 = arith.muli %50, %51 : i32
                %53 = arith.addi %49, %52 : i32
                %54 = memref.load %3[] : memref<i32>
                %55 = arith.muli %54, %51 : i32
                %56 = memref.load %25[%c0] : memref<1xi32>
                %57 = arith.muli %55, %56 : i32
                %58 = arith.addi %53, %57 : i32
                %59 = arith.index_cast %58 : i32 to index
                %60 = memref.load %5[] : memref<memref<?xf32>>
                %61 = arith.subi %54, %c1_i32 : i32
                %62 = arith.muli %61, %51 : i32
                %63 = arith.muli %62, %56 : i32
                %64 = arith.addi %53, %63 : i32
                %65 = arith.index_cast %64 : i32 to index
                %66 = arith.addi %65, %c0 : index
                %67 = memref.load %60[%66] : memref<?xf32>
                %68 = arith.addi %59, %c0 : index
                memref.store %67, %48[%68] : memref<?xf32>
              }
              %46 = memref.load %37[] : memref<i1>
              memref.store %46, %36[] : memref<i1>
              %47 = memref.load %36[] : memref<i1>
              scf.if %47 {
                %48 = memref.load %0[] : memref<i32>
                %49 = arith.addi %48, %c1_i32 : i32
                memref.store %49, %0[] : memref<i32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %32 = memref.load %23[] : memref<i1>
        memref.store %32, %22[] : memref<i1>
        %33 = memref.load %22[] : memref<i1>
        scf.if %33 {
          %34 = memref.load %2[] : memref<i32>
          %35 = arith.addi %34, %c1_i32 : i32
          memref.store %35, %2[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  scf.if %19 {
    %20 = memref.load %3[] : memref<i32>
    %21 = arith.subi %20, %c1_i32 : i32
    memref.store %21, %3[] : memref<i32>
  }
  cf.br ^bb1

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %21 = memref.load %10[] : memref<i1>
  scf.if %21 {
    memref.store %c0_i32, %2[] : memref<i32>
  }
  %22 = memref.alloca() : memref<i1>
  %23 = memref.alloca() : memref<i1>
  memref.store %true, %23[] : memref<i1>
  cf.br ^bb1


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %16 = memref.load %11[] : memref<i1>
  memref.store %16, %10[] : memref<i1>
  %17 = memref.load %10[] : memref<i1>
  scf.if %17 {
    %20 = memref.load %10[] : memref<i1>
    scf.if %20 {
      scf.execute_region {
        %21 = memref.load %10[] : memref<i1>
        scf.if %21 {
          memref.store %c0_i32, %2[] : memref<i32>
        }
        %22 = memref.alloca() : memref<i1>
        %23 = memref.alloca() : memref<i1>
        memref.store %true, %23[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %24 = memref.load %2[] : memref<i32>
        %25 = memref.get_global @jm : memref<1xi32>
        %26 = memref.load %25[%c0] : memref<1xi32>
        %27 = arith.cmpi slt, %24, %26 : i32
        %28 = memref.load %23[] : memref<i1>
        %29 = arith.andi %27, %28 : i1
        cf.cond_br %29, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %30 = memref.load %23[] : memref<i1>
        memref.store %30, %22[] : memref<i1>
        %31 = memref.load %22[] : memref<i1>
        scf.if %31 {
          %34 = memref.load %22[] : memref<i1>
          scf.if %34 {
            scf.execute_region {
              %35 = memref.load %22[] : memref<i1>
              scf.if %35 {
                memref.store %c0_i32, %0[] : memref<i32>
              }
              %36 = memref.alloca() : memref<i1>
              %37 = memref.alloca() : memref<i1>
              memref.store %true, %37[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %38 = memref.load %0[] : memref<i32>
              %39 = memref.get_global @im : memref<1xi32>
              %40 = memref.load %39[%c0] : memref<1xi32>
              %41 = arith.cmpi slt, %38, %40 : i32
              %42 = memref.load %37[] : memref<i1>
              %43 = arith.andi %41, %42 : i1
              cf.cond_br %43, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %44 = memref.load %37[] : memref<i1>
              memref.store %44, %36[] : memref<i1>
              %45 = memref.load %36[] : memref<i1>
              scf.if %45 {
                %48 = memref.load %4[] : memref<memref<?xf32>>
                %49 = memref.load %0[] : memref<i32>
                %50 = memref.load %2[] : memref<i32>
                %51 = memref.load %39[%c0] : memref<1xi32>
                %52 = arith.muli %50, %51 : i32
                %53 = arith.addi %49, %52 : i32
                %54 = memref.load %3[] : memref<i32>
                %55 = arith.muli %54, %51 : i32
                %56 = memref.load %25[%c0] : memref<1xi32>
                %57 = arith.muli %55, %56 : i32
                %58 = arith.addi %53, %57 : i32
                %59 = arith.index_cast %58 : i32 to index
                %60 = memref.load %5[] : memref<memref<?xf32>>
                %61 = arith.subi %54, %c1_i32 : i32
                %62 = arith.muli %61, %51 : i32
                %63 = arith.muli %62, %56 : i32
                %64 = arith.addi %53, %63 : i32
                %65 = arith.index_cast %64 : i32 to index
                %66 = arith.addi %65, %c0 : index
                %67 = memref.load %60[%66] : memref<?xf32>
                %68 = arith.addi %59, %c0 : index
                memref.store %67, %48[%68] : memref<?xf32>
              }
              %46 = memref.load %37[] : memref<i1>
              memref.store %46, %36[] : memref<i1>
              %47 = memref.load %36[] : memref<i1>
              scf.if %47 {
                %48 = memref.load %0[] : memref<i32>
                %49 = arith.addi %48, %c1_i32 : i32
                memref.store %49, %0[] : memref<i32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %32 = memref.load %23[] : memref<i1>
        memref.store %32, %22[] : memref<i1>
        %33 = memref.load %22[] : memref<i1>
        scf.if %33 {
          %34 = memref.load %2[] : memref<i32>
          %35 = arith.addi %34, %c1_i32 : i32
          memref.store %35, %2[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  scf.if %19 {
    %20 = memref.load %3[] : memref<i32>
    %21 = arith.subi %20, %c1_i32 : i32
    memref.store %21, %3[] : memref<i32>
  }
  cf.br ^bb1

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %2[] : memref<i32>
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %2[] : memref<i32>
  scf.yield
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %16 = memref.load %11[] : memref<i1>
  memref.store %16, %10[] : memref<i1>
  %17 = memref.load %10[] : memref<i1>
  scf.if %17 {
    %20 = memref.load %10[] : memref<i1>
    scf.if %20 {
      scf.execute_region {
        %21 = memref.load %10[] : memref<i1>
        scf.if %21 {
          memref.store %c0_i32, %2[] : memref<i32>
        }
        %22 = memref.alloca() : memref<i1>
        %23 = memref.alloca() : memref<i1>
        memref.store %true, %23[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %24 = memref.load %2[] : memref<i32>
        %25 = memref.get_global @jm : memref<1xi32>
        %26 = memref.load %25[%c0] : memref<1xi32>
        %27 = arith.cmpi slt, %24, %26 : i32
        %28 = memref.load %23[] : memref<i1>
        %29 = arith.andi %27, %28 : i1
        cf.cond_br %29, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %30 = memref.load %23[] : memref<i1>
        memref.store %30, %22[] : memref<i1>
        %31 = memref.load %22[] : memref<i1>
        scf.if %31 {
          %34 = memref.load %22[] : memref<i1>
          scf.if %34 {
            scf.execute_region {
              %35 = memref.load %22[] : memref<i1>
              scf.if %35 {
                memref.store %c0_i32, %0[] : memref<i32>
              }
              %36 = memref.alloca() : memref<i1>
              %37 = memref.alloca() : memref<i1>
              memref.store %true, %37[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %38 = memref.load %0[] : memref<i32>
              %39 = memref.get_global @im : memref<1xi32>
              %40 = memref.load %39[%c0] : memref<1xi32>
              %41 = arith.cmpi slt, %38, %40 : i32
              %42 = memref.load %37[] : memref<i1>
              %43 = arith.andi %41, %42 : i1
              cf.cond_br %43, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %44 = memref.load %37[] : memref<i1>
              memref.store %44, %36[] : memref<i1>
              %45 = memref.load %36[] : memref<i1>
              scf.if %45 {
                %48 = memref.load %4[] : memref<memref<?xf32>>
                %49 = memref.load %0[] : memref<i32>
                %50 = memref.load %2[] : memref<i32>
                %51 = memref.load %39[%c0] : memref<1xi32>
                %52 = arith.muli %50, %51 : i32
                %53 = arith.addi %49, %52 : i32
                %54 = memref.load %3[] : memref<i32>
                %55 = arith.muli %54, %51 : i32
                %56 = memref.load %25[%c0] : memref<1xi32>
                %57 = arith.muli %55, %56 : i32
                %58 = arith.addi %53, %57 : i32
                %59 = arith.index_cast %58 : i32 to index
                %60 = memref.load %5[] : memref<memref<?xf32>>
                %61 = arith.subi %54, %c1_i32 : i32
                %62 = arith.muli %61, %51 : i32
                %63 = arith.muli %62, %56 : i32
                %64 = arith.addi %53, %63 : i32
                %65 = arith.index_cast %64 : i32 to index
                %66 = arith.addi %65, %c0 : index
                %67 = memref.load %60[%66] : memref<?xf32>
                %68 = arith.addi %59, %c0 : index
                memref.store %67, %48[%68] : memref<?xf32>
              }
              %46 = memref.load %37[] : memref<i1>
              memref.store %46, %36[] : memref<i1>
              %47 = memref.load %36[] : memref<i1>
              scf.if %47 {
                %48 = memref.load %0[] : memref<i32>
                %49 = arith.addi %48, %c1_i32 : i32
                memref.store %49, %0[] : memref<i32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %32 = memref.load %23[] : memref<i1>
        memref.store %32, %22[] : memref<i1>
        %33 = memref.load %22[] : memref<i1>
        scf.if %33 {
          %34 = memref.load %2[] : memref<i32>
          %35 = arith.addi %34, %c1_i32 : i32
          memref.store %35, %2[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  scf.if %19 {
    %20 = memref.load %3[] : memref<i32>
    %21 = arith.subi %20, %c1_i32 : i32
    memref.store %21, %3[] : memref<i32>
  }
  cf.br ^bb1

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %21 = memref.load %10[] : memref<i1>
  scf.if %21 {
    memref.store %c0_i32, %2[] : memref<i32>
  }
  %22 = memref.alloca() : memref<i1>
  %23 = memref.alloca() : memref<i1>
  memref.store %true, %23[] : memref<i1>
  cf.br ^bb1
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %16 = memref.load %11[] : memref<i1>
  memref.store %16, %10[] : memref<i1>
  %17 = memref.load %10[] : memref<i1>
  scf.if %17 {
    %20 = memref.load %10[] : memref<i1>
    scf.if %20 {
      scf.execute_region {
        %21 = memref.load %10[] : memref<i1>
        scf.if %21 {
          memref.store %c0_i32, %2[] : memref<i32>
        }
        %22 = memref.alloca() : memref<i1>
        %23 = memref.alloca() : memref<i1>
        memref.store %true, %23[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %24 = memref.load %2[] : memref<i32>
        %25 = memref.get_global @jm : memref<1xi32>
        %26 = memref.load %25[%c0] : memref<1xi32>
        %27 = arith.cmpi slt, %24, %26 : i32
        %28 = memref.load %23[] : memref<i1>
        %29 = arith.andi %27, %28 : i1
        cf.cond_br %29, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %30 = memref.load %23[] : memref<i1>
        memref.store %30, %22[] : memref<i1>
        %31 = memref.load %22[] : memref<i1>
        scf.if %31 {
          %34 = memref.load %22[] : memref<i1>
          scf.if %34 {
            scf.execute_region {
              %35 = memref.load %22[] : memref<i1>
              scf.if %35 {
                memref.store %c0_i32, %0[] : memref<i32>
              }
              %36 = memref.alloca() : memref<i1>
              %37 = memref.alloca() : memref<i1>
              memref.store %true, %37[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %38 = memref.load %0[] : memref<i32>
              %39 = memref.get_global @im : memref<1xi32>
              %40 = memref.load %39[%c0] : memref<1xi32>
              %41 = arith.cmpi slt, %38, %40 : i32
              %42 = memref.load %37[] : memref<i1>
              %43 = arith.andi %41, %42 : i1
              cf.cond_br %43, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %44 = memref.load %37[] : memref<i1>
              memref.store %44, %36[] : memref<i1>
              %45 = memref.load %36[] : memref<i1>
              scf.if %45 {
                %48 = memref.load %4[] : memref<memref<?xf32>>
                %49 = memref.load %0[] : memref<i32>
                %50 = memref.load %2[] : memref<i32>
                %51 = memref.load %39[%c0] : memref<1xi32>
                %52 = arith.muli %50, %51 : i32
                %53 = arith.addi %49, %52 : i32
                %54 = memref.load %3[] : memref<i32>
                %55 = arith.muli %54, %51 : i32
                %56 = memref.load %25[%c0] : memref<1xi32>
                %57 = arith.muli %55, %56 : i32
                %58 = arith.addi %53, %57 : i32
                %59 = arith.index_cast %58 : i32 to index
                %60 = memref.load %5[] : memref<memref<?xf32>>
                %61 = arith.subi %54, %c1_i32 : i32
                %62 = arith.muli %61, %51 : i32
                %63 = arith.muli %62, %56 : i32
                %64 = arith.addi %53, %63 : i32
                %65 = arith.index_cast %64 : i32 to index
                %66 = arith.addi %65, %c0 : index
                %67 = memref.load %60[%66] : memref<?xf32>
                %68 = arith.addi %59, %c0 : index
                memref.store %67, %48[%68] : memref<?xf32>
              }
              %46 = memref.load %37[] : memref<i1>
              memref.store %46, %36[] : memref<i1>
              %47 = memref.load %36[] : memref<i1>
              scf.if %47 {
                %48 = memref.load %0[] : memref<i32>
                %49 = arith.addi %48, %c1_i32 : i32
                memref.store %49, %0[] : memref<i32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %32 = memref.load %23[] : memref<i1>
        memref.store %32, %22[] : memref<i1>
        %33 = memref.load %22[] : memref<i1>
        scf.if %33 {
          %34 = memref.load %2[] : memref<i32>
          %35 = arith.addi %34, %c1_i32 : i32
          memref.store %35, %2[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  scf.if %19 {
    %20 = memref.load %3[] : memref<i32>
    %21 = arith.subi %20, %c1_i32 : i32
    memref.store %21, %3[] : memref<i32>
  }
  cf.br ^bb1


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb1:  // 2 preds: ^bb0, ^bb2
  %24 = memref.load %2[] : memref<i32>
  %25 = memref.get_global @jm : memref<1xi32>
  %26 = memref.load %25[%c0] : memref<1xi32>
  %27 = arith.cmpi slt, %24, %26 : i32
  %28 = memref.load %23[] : memref<i1>
  %29 = arith.andi %27, %28 : i1
  cf.cond_br %29, ^bb2, ^bb3

mlir-asm-printer: Verifying operation: builtin.module
^bb1:  // 2 preds: ^bb0, ^bb2
  %24 = memref.load %2[] : memref<i32>
  %25 = memref.get_global @jm : memref<1xi32>
  %26 = memref.load %25[%c0] : memref<1xi32>
  %27 = arith.cmpi slt, %24, %26 : i32
  %28 = memref.load %23[] : memref<i1>
  %29 = arith.andi %27, %28 : i1
  cf.cond_br %29, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1:  // 2 preds: ^bb0, ^bb2
  %24 = memref.load %2[] : memref<i32>
  %25 = memref.get_global @jm : memref<1xi32>
  %26 = memref.load %25[%c0] : memref<1xi32>
  %27 = arith.cmpi slt, %24, %26 : i32
  %28 = memref.load %23[] : memref<i1>
  %29 = arith.andi %27, %28 : i1
  cf.cond_br %29, ^bb2, ^bb3
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb1:  // 2 preds: ^bb0, ^bb2
  %24 = memref.load %2[] : memref<i32>
  %25 = memref.get_global @jm : memref<1xi32>
  %26 = memref.load %25[%c0] : memref<1xi32>
  %27 = arith.cmpi slt, %24, %26 : i32
  %28 = memref.load %23[] : memref<i1>
  %29 = arith.andi %27, %28 : i1
  cf.cond_br %29, ^bb2, ^bb3


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %30 = memref.load %23[] : memref<i1>
  memref.store %30, %22[] : memref<i1>
  %31 = memref.load %22[] : memref<i1>
  scf.if %31 {
    %34 = memref.load %22[] : memref<i1>
    scf.if %34 {
      scf.execute_region {
        %35 = memref.load %22[] : memref<i1>
        scf.if %35 {
          memref.store %c0_i32, %0[] : memref<i32>
        }
        %36 = memref.alloca() : memref<i1>
        %37 = memref.alloca() : memref<i1>
        memref.store %true, %37[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %38 = memref.load %0[] : memref<i32>
        %39 = memref.get_global @im : memref<1xi32>
        %40 = memref.load %39[%c0] : memref<1xi32>
        %41 = arith.cmpi slt, %38, %40 : i32
        %42 = memref.load %37[] : memref<i1>
        %43 = arith.andi %41, %42 : i1
        cf.cond_br %43, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %44 = memref.load %37[] : memref<i1>
        memref.store %44, %36[] : memref<i1>
        %45 = memref.load %36[] : memref<i1>
        scf.if %45 {
          %48 = memref.load %4[] : memref<memref<?xf32>>
          %49 = memref.load %0[] : memref<i32>
          %50 = memref.load %2[] : memref<i32>
          %51 = memref.load %39[%c0] : memref<1xi32>
          %52 = arith.muli %50, %51 : i32
          %53 = arith.addi %49, %52 : i32
          %54 = memref.load %3[] : memref<i32>
          %55 = arith.muli %54, %51 : i32
          %56 = memref.load %25[%c0] : memref<1xi32>
          %57 = arith.muli %55, %56 : i32
          %58 = arith.addi %53, %57 : i32
          %59 = arith.index_cast %58 : i32 to index
          %60 = memref.load %5[] : memref<memref<?xf32>>
          %61 = arith.subi %54, %c1_i32 : i32
          %62 = arith.muli %61, %51 : i32
          %63 = arith.muli %62, %56 : i32
          %64 = arith.addi %53, %63 : i32
          %65 = arith.index_cast %64 : i32 to index
          %66 = arith.addi %65, %c0 : index
          %67 = memref.load %60[%66] : memref<?xf32>
          %68 = arith.addi %59, %c0 : index
          memref.store %67, %48[%68] : memref<?xf32>
        }
        %46 = memref.load %37[] : memref<i1>
        memref.store %46, %36[] : memref<i1>
        %47 = memref.load %36[] : memref<i1>
        scf.if %47 {
          %48 = memref.load %0[] : memref<i32>
          %49 = arith.addi %48, %c1_i32 : i32
          memref.store %49, %0[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  %32 = memref.load %23[] : memref<i1>
  memref.store %32, %22[] : memref<i1>
  %33 = memref.load %22[] : memref<i1>
  scf.if %33 {
    %34 = memref.load %2[] : memref<i32>
    %35 = arith.addi %34, %c1_i32 : i32
    memref.store %35, %2[] : memref<i32>
  }
  cf.br ^bb1

mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %30 = memref.load %23[] : memref<i1>
  memref.store %30, %22[] : memref<i1>
  %31 = memref.load %22[] : memref<i1>
  scf.if %31 {
    %34 = memref.load %22[] : memref<i1>
    scf.if %34 {
      scf.execute_region {
        %35 = memref.load %22[] : memref<i1>
        scf.if %35 {
          memref.store %c0_i32, %0[] : memref<i32>
        }
        %36 = memref.alloca() : memref<i1>
        %37 = memref.alloca() : memref<i1>
        memref.store %true, %37[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %38 = memref.load %0[] : memref<i32>
        %39 = memref.get_global @im : memref<1xi32>
        %40 = memref.load %39[%c0] : memref<1xi32>
        %41 = arith.cmpi slt, %38, %40 : i32
        %42 = memref.load %37[] : memref<i1>
        %43 = arith.andi %41, %42 : i1
        cf.cond_br %43, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %44 = memref.load %37[] : memref<i1>
        memref.store %44, %36[] : memref<i1>
        %45 = memref.load %36[] : memref<i1>
        scf.if %45 {
          %48 = memref.load %4[] : memref<memref<?xf32>>
          %49 = memref.load %0[] : memref<i32>
          %50 = memref.load %2[] : memref<i32>
          %51 = memref.load %39[%c0] : memref<1xi32>
          %52 = arith.muli %50, %51 : i32
          %53 = arith.addi %49, %52 : i32
          %54 = memref.load %3[] : memref<i32>
          %55 = arith.muli %54, %51 : i32
          %56 = memref.load %25[%c0] : memref<1xi32>
          %57 = arith.muli %55, %56 : i32
          %58 = arith.addi %53, %57 : i32
          %59 = arith.index_cast %58 : i32 to index
          %60 = memref.load %5[] : memref<memref<?xf32>>
          %61 = arith.subi %54, %c1_i32 : i32
          %62 = arith.muli %61, %51 : i32
          %63 = arith.muli %62, %56 : i32
          %64 = arith.addi %53, %63 : i32
          %65 = arith.index_cast %64 : i32 to index
          %66 = arith.addi %65, %c0 : index
          %67 = memref.load %60[%66] : memref<?xf32>
          %68 = arith.addi %59, %c0 : index
          memref.store %67, %48[%68] : memref<?xf32>
        }
        %46 = memref.load %37[] : memref<i1>
        memref.store %46, %36[] : memref<i1>
        %47 = memref.load %36[] : memref<i1>
        scf.if %47 {
          %48 = memref.load %0[] : memref<i32>
          %49 = arith.addi %48, %c1_i32 : i32
          memref.store %49, %0[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  %32 = memref.load %23[] : memref<i1>
  memref.store %32, %22[] : memref<i1>
  %33 = memref.load %22[] : memref<i1>
  scf.if %33 {
    %34 = memref.load %2[] : memref<i32>
    %35 = arith.addi %34, %c1_i32 : i32
    memref.store %35, %2[] : memref<i32>
  }
  cf.br ^bb1


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %30 = memref.load %23[] : memref<i1>
  memref.store %30, %22[] : memref<i1>
  %31 = memref.load %22[] : memref<i1>
  scf.if %31 {
    %34 = memref.load %22[] : memref<i1>
    scf.if %34 {
      scf.execute_region {
        %35 = memref.load %22[] : memref<i1>
        scf.if %35 {
          memref.store %c0_i32, %0[] : memref<i32>
        }
        %36 = memref.alloca() : memref<i1>
        %37 = memref.alloca() : memref<i1>
        memref.store %true, %37[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %38 = memref.load %0[] : memref<i32>
        %39 = memref.get_global @im : memref<1xi32>
        %40 = memref.load %39[%c0] : memref<1xi32>
        %41 = arith.cmpi slt, %38, %40 : i32
        %42 = memref.load %37[] : memref<i1>
        %43 = arith.andi %41, %42 : i1
        cf.cond_br %43, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %44 = memref.load %37[] : memref<i1>
        memref.store %44, %36[] : memref<i1>
        %45 = memref.load %36[] : memref<i1>
        scf.if %45 {
          %48 = memref.load %4[] : memref<memref<?xf32>>
          %49 = memref.load %0[] : memref<i32>
          %50 = memref.load %2[] : memref<i32>
          %51 = memref.load %39[%c0] : memref<1xi32>
          %52 = arith.muli %50, %51 : i32
          %53 = arith.addi %49, %52 : i32
          %54 = memref.load %3[] : memref<i32>
          %55 = arith.muli %54, %51 : i32
          %56 = memref.load %25[%c0] : memref<1xi32>
          %57 = arith.muli %55, %56 : i32
          %58 = arith.addi %53, %57 : i32
          %59 = arith.index_cast %58 : i32 to index
          %60 = memref.load %5[] : memref<memref<?xf32>>
          %61 = arith.subi %54, %c1_i32 : i32
          %62 = arith.muli %61, %51 : i32
          %63 = arith.muli %62, %56 : i32
          %64 = arith.addi %53, %63 : i32
          %65 = arith.index_cast %64 : i32 to index
          %66 = arith.addi %65, %c0 : index
          %67 = memref.load %60[%66] : memref<?xf32>
          %68 = arith.addi %59, %c0 : index
          memref.store %67, %48[%68] : memref<?xf32>
        }
        %46 = memref.load %37[] : memref<i1>
        memref.store %46, %36[] : memref<i1>
        %47 = memref.load %36[] : memref<i1>
        scf.if %47 {
          %48 = memref.load %0[] : memref<i32>
          %49 = arith.addi %48, %c1_i32 : i32
          memref.store %49, %0[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  %32 = memref.load %23[] : memref<i1>
  memref.store %32, %22[] : memref<i1>
  %33 = memref.load %22[] : memref<i1>
  scf.if %33 {
    %34 = memref.load %2[] : memref<i32>
    %35 = arith.addi %34, %c1_i32 : i32
    memref.store %35, %2[] : memref<i32>
  }
  cf.br ^bb1

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %34 = memref.load %22[] : memref<i1>
  scf.if %34 {
    scf.execute_region {
      %35 = memref.load %22[] : memref<i1>
      scf.if %35 {
        memref.store %c0_i32, %0[] : memref<i32>
      }
      %36 = memref.alloca() : memref<i1>
      %37 = memref.alloca() : memref<i1>
      memref.store %true, %37[] : memref<i1>
      cf.br ^bb1
    ^bb1:  // 2 preds: ^bb0, ^bb2
      %38 = memref.load %0[] : memref<i32>
      %39 = memref.get_global @im : memref<1xi32>
      %40 = memref.load %39[%c0] : memref<1xi32>
      %41 = arith.cmpi slt, %38, %40 : i32
      %42 = memref.load %37[] : memref<i1>
      %43 = arith.andi %41, %42 : i1
      cf.cond_br %43, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %44 = memref.load %37[] : memref<i1>
      memref.store %44, %36[] : memref<i1>
      %45 = memref.load %36[] : memref<i1>
      scf.if %45 {
        %48 = memref.load %4[] : memref<memref<?xf32>>
        %49 = memref.load %0[] : memref<i32>
        %50 = memref.load %2[] : memref<i32>
        %51 = memref.load %39[%c0] : memref<1xi32>
        %52 = arith.muli %50, %51 : i32
        %53 = arith.addi %49, %52 : i32
        %54 = memref.load %3[] : memref<i32>
        %55 = arith.muli %54, %51 : i32
        %56 = memref.load %25[%c0] : memref<1xi32>
        %57 = arith.muli %55, %56 : i32
        %58 = arith.addi %53, %57 : i32
        %59 = arith.index_cast %58 : i32 to index
        %60 = memref.load %5[] : memref<memref<?xf32>>
        %61 = arith.subi %54, %c1_i32 : i32
        %62 = arith.muli %61, %51 : i32
        %63 = arith.muli %62, %56 : i32
        %64 = arith.addi %53, %63 : i32
        %65 = arith.index_cast %64 : i32 to index
        %66 = arith.addi %65, %c0 : index
        %67 = memref.load %60[%66] : memref<?xf32>
        %68 = arith.addi %59, %c0 : index
        memref.store %67, %48[%68] : memref<?xf32>
      }
      %46 = memref.load %37[] : memref<i1>
      memref.store %46, %36[] : memref<i1>
      %47 = memref.load %36[] : memref<i1>
      scf.if %47 {
        %48 = memref.load %0[] : memref<i32>
        %49 = arith.addi %48, %c1_i32 : i32
        memref.store %49, %0[] : memref<i32>
      }
      cf.br ^bb1
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
  scf.yield


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %30 = memref.load %23[] : memref<i1>
  memref.store %30, %22[] : memref<i1>
  %31 = memref.load %22[] : memref<i1>
  scf.if %31 {
    %34 = memref.load %22[] : memref<i1>
    scf.if %34 {
      scf.execute_region {
        %35 = memref.load %22[] : memref<i1>
        scf.if %35 {
          memref.store %c0_i32, %0[] : memref<i32>
        }
        %36 = memref.alloca() : memref<i1>
        %37 = memref.alloca() : memref<i1>
        memref.store %true, %37[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %38 = memref.load %0[] : memref<i32>
        %39 = memref.get_global @im : memref<1xi32>
        %40 = memref.load %39[%c0] : memref<1xi32>
        %41 = arith.cmpi slt, %38, %40 : i32
        %42 = memref.load %37[] : memref<i1>
        %43 = arith.andi %41, %42 : i1
        cf.cond_br %43, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %44 = memref.load %37[] : memref<i1>
        memref.store %44, %36[] : memref<i1>
        %45 = memref.load %36[] : memref<i1>
        scf.if %45 {
          %48 = memref.load %4[] : memref<memref<?xf32>>
          %49 = memref.load %0[] : memref<i32>
          %50 = memref.load %2[] : memref<i32>
          %51 = memref.load %39[%c0] : memref<1xi32>
          %52 = arith.muli %50, %51 : i32
          %53 = arith.addi %49, %52 : i32
          %54 = memref.load %3[] : memref<i32>
          %55 = arith.muli %54, %51 : i32
          %56 = memref.load %25[%c0] : memref<1xi32>
          %57 = arith.muli %55, %56 : i32
          %58 = arith.addi %53, %57 : i32
          %59 = arith.index_cast %58 : i32 to index
          %60 = memref.load %5[] : memref<memref<?xf32>>
          %61 = arith.subi %54, %c1_i32 : i32
          %62 = arith.muli %61, %51 : i32
          %63 = arith.muli %62, %56 : i32
          %64 = arith.addi %53, %63 : i32
          %65 = arith.index_cast %64 : i32 to index
          %66 = arith.addi %65, %c0 : index
          %67 = memref.load %60[%66] : memref<?xf32>
          %68 = arith.addi %59, %c0 : index
          memref.store %67, %48[%68] : memref<?xf32>
        }
        %46 = memref.load %37[] : memref<i1>
        memref.store %46, %36[] : memref<i1>
        %47 = memref.load %36[] : memref<i1>
        scf.if %47 {
          %48 = memref.load %0[] : memref<i32>
          %49 = arith.addi %48, %c1_i32 : i32
          memref.store %49, %0[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  %32 = memref.load %23[] : memref<i1>
  memref.store %32, %22[] : memref<i1>
  %33 = memref.load %22[] : memref<i1>
  scf.if %33 {
    %34 = memref.load %2[] : memref<i32>
    %35 = arith.addi %34, %c1_i32 : i32
    memref.store %35, %2[] : memref<i32>
  }
  cf.br ^bb1

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.execute_region {
    %35 = memref.load %22[] : memref<i1>
    scf.if %35 {
      memref.store %c0_i32, %0[] : memref<i32>
    }
    %36 = memref.alloca() : memref<i1>
    %37 = memref.alloca() : memref<i1>
    memref.store %true, %37[] : memref<i1>
    cf.br ^bb1
  ^bb1:  // 2 preds: ^bb0, ^bb2
    %38 = memref.load %0[] : memref<i32>
    %39 = memref.get_global @im : memref<1xi32>
    %40 = memref.load %39[%c0] : memref<1xi32>
    %41 = arith.cmpi slt, %38, %40 : i32
    %42 = memref.load %37[] : memref<i1>
    %43 = arith.andi %41, %42 : i1
    cf.cond_br %43, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %44 = memref.load %37[] : memref<i1>
    memref.store %44, %36[] : memref<i1>
    %45 = memref.load %36[] : memref<i1>
    scf.if %45 {
      %48 = memref.load %4[] : memref<memref<?xf32>>
      %49 = memref.load %0[] : memref<i32>
      %50 = memref.load %2[] : memref<i32>
      %51 = memref.load %39[%c0] : memref<1xi32>
      %52 = arith.muli %50, %51 : i32
      %53 = arith.addi %49, %52 : i32
      %54 = memref.load %3[] : memref<i32>
      %55 = arith.muli %54, %51 : i32
      %56 = memref.load %25[%c0] : memref<1xi32>
      %57 = arith.muli %55, %56 : i32
      %58 = arith.addi %53, %57 : i32
      %59 = arith.index_cast %58 : i32 to index
      %60 = memref.load %5[] : memref<memref<?xf32>>
      %61 = arith.subi %54, %c1_i32 : i32
      %62 = arith.muli %61, %51 : i32
      %63 = arith.muli %62, %56 : i32
      %64 = arith.addi %53, %63 : i32
      %65 = arith.index_cast %64 : i32 to index
      %66 = arith.addi %65, %c0 : index
      %67 = memref.load %60[%66] : memref<?xf32>
      %68 = arith.addi %59, %c0 : index
      memref.store %67, %48[%68] : memref<?xf32>
    }
    %46 = memref.load %37[] : memref<i1>
    memref.store %46, %36[] : memref<i1>
    %47 = memref.load %36[] : memref<i1>
    scf.if %47 {
      %48 = memref.load %0[] : memref<i32>
      %49 = arith.addi %48, %c1_i32 : i32
      memref.store %49, %0[] : memref<i32>
    }
    cf.br ^bb1
  ^bb3:  // pred: ^bb1
    scf.yield
  }
  scf.yield


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %30 = memref.load %23[] : memref<i1>
  memref.store %30, %22[] : memref<i1>
  %31 = memref.load %22[] : memref<i1>
  scf.if %31 {
    %34 = memref.load %22[] : memref<i1>
    scf.if %34 {
      scf.execute_region {
        %35 = memref.load %22[] : memref<i1>
        scf.if %35 {
          memref.store %c0_i32, %0[] : memref<i32>
        }
        %36 = memref.alloca() : memref<i1>
        %37 = memref.alloca() : memref<i1>
        memref.store %true, %37[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %38 = memref.load %0[] : memref<i32>
        %39 = memref.get_global @im : memref<1xi32>
        %40 = memref.load %39[%c0] : memref<1xi32>
        %41 = arith.cmpi slt, %38, %40 : i32
        %42 = memref.load %37[] : memref<i1>
        %43 = arith.andi %41, %42 : i1
        cf.cond_br %43, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %44 = memref.load %37[] : memref<i1>
        memref.store %44, %36[] : memref<i1>
        %45 = memref.load %36[] : memref<i1>
        scf.if %45 {
          %48 = memref.load %4[] : memref<memref<?xf32>>
          %49 = memref.load %0[] : memref<i32>
          %50 = memref.load %2[] : memref<i32>
          %51 = memref.load %39[%c0] : memref<1xi32>
          %52 = arith.muli %50, %51 : i32
          %53 = arith.addi %49, %52 : i32
          %54 = memref.load %3[] : memref<i32>
          %55 = arith.muli %54, %51 : i32
          %56 = memref.load %25[%c0] : memref<1xi32>
          %57 = arith.muli %55, %56 : i32
          %58 = arith.addi %53, %57 : i32
          %59 = arith.index_cast %58 : i32 to index
          %60 = memref.load %5[] : memref<memref<?xf32>>
          %61 = arith.subi %54, %c1_i32 : i32
          %62 = arith.muli %61, %51 : i32
          %63 = arith.muli %62, %56 : i32
          %64 = arith.addi %53, %63 : i32
          %65 = arith.index_cast %64 : i32 to index
          %66 = arith.addi %65, %c0 : index
          %67 = memref.load %60[%66] : memref<?xf32>
          %68 = arith.addi %59, %c0 : index
          memref.store %67, %48[%68] : memref<?xf32>
        }
        %46 = memref.load %37[] : memref<i1>
        memref.store %46, %36[] : memref<i1>
        %47 = memref.load %36[] : memref<i1>
        scf.if %47 {
          %48 = memref.load %0[] : memref<i32>
          %49 = arith.addi %48, %c1_i32 : i32
          memref.store %49, %0[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  %32 = memref.load %23[] : memref<i1>
  memref.store %32, %22[] : memref<i1>
  %33 = memref.load %22[] : memref<i1>
  scf.if %33 {
    %34 = memref.load %2[] : memref<i32>
    %35 = arith.addi %34, %c1_i32 : i32
    memref.store %35, %2[] : memref<i32>
  }
  cf.br ^bb1

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %35 = memref.load %22[] : memref<i1>
  scf.if %35 {
    memref.store %c0_i32, %0[] : memref<i32>
  }
  %36 = memref.alloca() : memref<i1>
  %37 = memref.alloca() : memref<i1>
  memref.store %true, %37[] : memref<i1>
  cf.br ^bb1


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %30 = memref.load %23[] : memref<i1>
  memref.store %30, %22[] : memref<i1>
  %31 = memref.load %22[] : memref<i1>
  scf.if %31 {
    %34 = memref.load %22[] : memref<i1>
    scf.if %34 {
      scf.execute_region {
        %35 = memref.load %22[] : memref<i1>
        scf.if %35 {
          memref.store %c0_i32, %0[] : memref<i32>
        }
        %36 = memref.alloca() : memref<i1>
        %37 = memref.alloca() : memref<i1>
        memref.store %true, %37[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %38 = memref.load %0[] : memref<i32>
        %39 = memref.get_global @im : memref<1xi32>
        %40 = memref.load %39[%c0] : memref<1xi32>
        %41 = arith.cmpi slt, %38, %40 : i32
        %42 = memref.load %37[] : memref<i1>
        %43 = arith.andi %41, %42 : i1
        cf.cond_br %43, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %44 = memref.load %37[] : memref<i1>
        memref.store %44, %36[] : memref<i1>
        %45 = memref.load %36[] : memref<i1>
        scf.if %45 {
          %48 = memref.load %4[] : memref<memref<?xf32>>
          %49 = memref.load %0[] : memref<i32>
          %50 = memref.load %2[] : memref<i32>
          %51 = memref.load %39[%c0] : memref<1xi32>
          %52 = arith.muli %50, %51 : i32
          %53 = arith.addi %49, %52 : i32
          %54 = memref.load %3[] : memref<i32>
          %55 = arith.muli %54, %51 : i32
          %56 = memref.load %25[%c0] : memref<1xi32>
          %57 = arith.muli %55, %56 : i32
          %58 = arith.addi %53, %57 : i32
          %59 = arith.index_cast %58 : i32 to index
          %60 = memref.load %5[] : memref<memref<?xf32>>
          %61 = arith.subi %54, %c1_i32 : i32
          %62 = arith.muli %61, %51 : i32
          %63 = arith.muli %62, %56 : i32
          %64 = arith.addi %53, %63 : i32
          %65 = arith.index_cast %64 : i32 to index
          %66 = arith.addi %65, %c0 : index
          %67 = memref.load %60[%66] : memref<?xf32>
          %68 = arith.addi %59, %c0 : index
          memref.store %67, %48[%68] : memref<?xf32>
        }
        %46 = memref.load %37[] : memref<i1>
        memref.store %46, %36[] : memref<i1>
        %47 = memref.load %36[] : memref<i1>
        scf.if %47 {
          %48 = memref.load %0[] : memref<i32>
          %49 = arith.addi %48, %c1_i32 : i32
          memref.store %49, %0[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  %32 = memref.load %23[] : memref<i1>
  memref.store %32, %22[] : memref<i1>
  %33 = memref.load %22[] : memref<i1>
  scf.if %33 {
    %34 = memref.load %2[] : memref<i32>
    %35 = arith.addi %34, %c1_i32 : i32
    memref.store %35, %2[] : memref<i32>
  }
  cf.br ^bb1

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%c0_i32 = arith.constant 0 : i32
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %35 = memref.load %22[] : memref<i1>
  scf.if %35 {
    memref.store %c0_i32, %0[] : memref<i32>
  }
  %36 = memref.alloca() : memref<i1>
  %37 = memref.alloca() : memref<i1>
  memref.store %true, %37[] : memref<i1>
  cf.br ^bb1
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %35 {
  memref.store %c0_i32, %0[] : memref<i32>
}

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb1:  // 2 preds: ^bb0, ^bb2
  %38 = memref.load %0[] : memref<i32>
  %39 = memref.get_global @im : memref<1xi32>
  %40 = memref.load %39[%c0] : memref<1xi32>
  %41 = arith.cmpi slt, %38, %40 : i32
  %42 = memref.load %37[] : memref<i1>
  %43 = arith.andi %41, %42 : i1
  cf.cond_br %43, ^bb2, ^bb3

mlir-asm-printer: Verifying operation: builtin.module
^bb1:  // 2 preds: ^bb0, ^bb2
  %38 = memref.load %0[] : memref<i32>
  %39 = memref.get_global @im : memref<1xi32>
  %40 = memref.load %39[%c0] : memref<1xi32>
  %41 = arith.cmpi slt, %38, %40 : i32
  %42 = memref.load %37[] : memref<i1>
  %43 = arith.andi %41, %42 : i1
  cf.cond_br %43, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1:  // 2 preds: ^bb0, ^bb2
  %38 = memref.load %0[] : memref<i32>
  %39 = memref.get_global @im : memref<1xi32>
  %40 = memref.load %39[%c0] : memref<1xi32>
  %41 = arith.cmpi slt, %38, %40 : i32
  %42 = memref.load %37[] : memref<i1>
  %43 = arith.andi %41, %42 : i1
  cf.cond_br %43, ^bb2, ^bb3
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%38 = memref.load %0[] : memref<i32>

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %44 = memref.load %37[] : memref<i1>
  memref.store %44, %36[] : memref<i1>
  %45 = memref.load %36[] : memref<i1>
  scf.if %45 {
    %48 = memref.load %4[] : memref<memref<?xf32>>
    %49 = memref.load %0[] : memref<i32>
    %50 = memref.load %2[] : memref<i32>
    %51 = memref.load %39[%c0] : memref<1xi32>
    %52 = arith.muli %50, %51 : i32
    %53 = arith.addi %49, %52 : i32
    %54 = memref.load %3[] : memref<i32>
    %55 = arith.muli %54, %51 : i32
    %56 = memref.load %25[%c0] : memref<1xi32>
    %57 = arith.muli %55, %56 : i32
    %58 = arith.addi %53, %57 : i32
    %59 = arith.index_cast %58 : i32 to index
    %60 = memref.load %5[] : memref<memref<?xf32>>
    %61 = arith.subi %54, %c1_i32 : i32
    %62 = arith.muli %61, %51 : i32
    %63 = arith.muli %62, %56 : i32
    %64 = arith.addi %53, %63 : i32
    %65 = arith.index_cast %64 : i32 to index
    %66 = arith.addi %65, %c0 : index
    %67 = memref.load %60[%66] : memref<?xf32>
    %68 = arith.addi %59, %c0 : index
    memref.store %67, %48[%68] : memref<?xf32>
  }
  %46 = memref.load %37[] : memref<i1>
  memref.store %46, %36[] : memref<i1>
  %47 = memref.load %36[] : memref<i1>
  scf.if %47 {
    %48 = memref.load %0[] : memref<i32>
    %49 = arith.addi %48, %c1_i32 : i32
    memref.store %49, %0[] : memref<i32>
  }
  cf.br ^bb1

mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %44 = memref.load %37[] : memref<i1>
  memref.store %44, %36[] : memref<i1>
  %45 = memref.load %36[] : memref<i1>
  scf.if %45 {
    %48 = memref.load %4[] : memref<memref<?xf32>>
    %49 = memref.load %0[] : memref<i32>
    %50 = memref.load %2[] : memref<i32>
    %51 = memref.load %39[%c0] : memref<1xi32>
    %52 = arith.muli %50, %51 : i32
    %53 = arith.addi %49, %52 : i32
    %54 = memref.load %3[] : memref<i32>
    %55 = arith.muli %54, %51 : i32
    %56 = memref.load %25[%c0] : memref<1xi32>
    %57 = arith.muli %55, %56 : i32
    %58 = arith.addi %53, %57 : i32
    %59 = arith.index_cast %58 : i32 to index
    %60 = memref.load %5[] : memref<memref<?xf32>>
    %61 = arith.subi %54, %c1_i32 : i32
    %62 = arith.muli %61, %51 : i32
    %63 = arith.muli %62, %56 : i32
    %64 = arith.addi %53, %63 : i32
    %65 = arith.index_cast %64 : i32 to index
    %66 = arith.addi %65, %c0 : index
    %67 = memref.load %60[%66] : memref<?xf32>
    %68 = arith.addi %59, %c0 : index
    memref.store %67, %48[%68] : memref<?xf32>
  }
  %46 = memref.load %37[] : memref<i1>
  memref.store %46, %36[] : memref<i1>
  %47 = memref.load %36[] : memref<i1>
  scf.if %47 {
    %48 = memref.load %0[] : memref<i32>
    %49 = arith.addi %48, %c1_i32 : i32
    memref.store %49, %0[] : memref<i32>
  }
  cf.br ^bb1


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %44 = memref.load %37[] : memref<i1>
  memref.store %44, %36[] : memref<i1>
  %45 = memref.load %36[] : memref<i1>
  scf.if %45 {
    %48 = memref.load %4[] : memref<memref<?xf32>>
    %49 = memref.load %0[] : memref<i32>
    %50 = memref.load %2[] : memref<i32>
    %51 = memref.load %39[%c0] : memref<1xi32>
    %52 = arith.muli %50, %51 : i32
    %53 = arith.addi %49, %52 : i32
    %54 = memref.load %3[] : memref<i32>
    %55 = arith.muli %54, %51 : i32
    %56 = memref.load %25[%c0] : memref<1xi32>
    %57 = arith.muli %55, %56 : i32
    %58 = arith.addi %53, %57 : i32
    %59 = arith.index_cast %58 : i32 to index
    %60 = memref.load %5[] : memref<memref<?xf32>>
    %61 = arith.subi %54, %c1_i32 : i32
    %62 = arith.muli %61, %51 : i32
    %63 = arith.muli %62, %56 : i32
    %64 = arith.addi %53, %63 : i32
    %65 = arith.index_cast %64 : i32 to index
    %66 = arith.addi %65, %c0 : index
    %67 = memref.load %60[%66] : memref<?xf32>
    %68 = arith.addi %59, %c0 : index
    memref.store %67, %48[%68] : memref<?xf32>
  }
  %46 = memref.load %37[] : memref<i1>
  memref.store %46, %36[] : memref<i1>
  %47 = memref.load %36[] : memref<i1>
  scf.if %47 {
    %48 = memref.load %0[] : memref<i32>
    %49 = arith.addi %48, %c1_i32 : i32
    memref.store %49, %0[] : memref<i32>
  }
  cf.br ^bb1

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %48 = memref.load %4[] : memref<memref<?xf32>>
  %49 = memref.load %0[] : memref<i32>
  %50 = memref.load %2[] : memref<i32>
  %51 = memref.load %39[%c0] : memref<1xi32>
  %52 = arith.muli %50, %51 : i32
  %53 = arith.addi %49, %52 : i32
  %54 = memref.load %3[] : memref<i32>
  %55 = arith.muli %54, %51 : i32
  %56 = memref.load %25[%c0] : memref<1xi32>
  %57 = arith.muli %55, %56 : i32
  %58 = arith.addi %53, %57 : i32
  %59 = arith.index_cast %58 : i32 to index
  %60 = memref.load %5[] : memref<memref<?xf32>>
  %61 = arith.subi %54, %c1_i32 : i32
  %62 = arith.muli %61, %51 : i32
  %63 = arith.muli %62, %56 : i32
  %64 = arith.addi %53, %63 : i32
  %65 = arith.index_cast %64 : i32 to index
  %66 = arith.addi %65, %c0 : index
  %67 = memref.load %60[%66] : memref<?xf32>
  %68 = arith.addi %59, %c0 : index
  memref.store %67, %48[%68] : memref<?xf32>
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %48 = memref.load %4[] : memref<memref<?xf32>>
  %49 = memref.load %0[] : memref<i32>
  %50 = memref.load %2[] : memref<i32>
  %51 = memref.load %39[%c0] : memref<1xi32>
  %52 = arith.muli %50, %51 : i32
  %53 = arith.addi %49, %52 : i32
  %54 = memref.load %3[] : memref<i32>
  %55 = arith.muli %54, %51 : i32
  %56 = memref.load %25[%c0] : memref<1xi32>
  %57 = arith.muli %55, %56 : i32
  %58 = arith.addi %53, %57 : i32
  %59 = arith.index_cast %58 : i32 to index
  %60 = memref.load %5[] : memref<memref<?xf32>>
  %61 = arith.subi %54, %c1_i32 : i32
  %62 = arith.muli %61, %51 : i32
  %63 = arith.muli %62, %56 : i32
  %64 = arith.addi %53, %63 : i32
  %65 = arith.index_cast %64 : i32 to index
  %66 = arith.addi %65, %c0 : index
  %67 = memref.load %60[%66] : memref<?xf32>
  %68 = arith.addi %59, %c0 : index
  memref.store %67, %48[%68] : memref<?xf32>
  scf.yield
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%49 = memref.load %0[] : memref<i32>

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %44 = memref.load %37[] : memref<i1>
  memref.store %44, %36[] : memref<i1>
  %45 = memref.load %36[] : memref<i1>
  scf.if %45 {
    %48 = memref.load %4[] : memref<memref<?xf32>>
    %49 = memref.load %0[] : memref<i32>
    %50 = memref.load %2[] : memref<i32>
    %51 = memref.load %39[%c0] : memref<1xi32>
    %52 = arith.muli %50, %51 : i32
    %53 = arith.addi %49, %52 : i32
    %54 = memref.load %3[] : memref<i32>
    %55 = arith.muli %54, %51 : i32
    %56 = memref.load %25[%c0] : memref<1xi32>
    %57 = arith.muli %55, %56 : i32
    %58 = arith.addi %53, %57 : i32
    %59 = arith.index_cast %58 : i32 to index
    %60 = memref.load %5[] : memref<memref<?xf32>>
    %61 = arith.subi %54, %c1_i32 : i32
    %62 = arith.muli %61, %51 : i32
    %63 = arith.muli %62, %56 : i32
    %64 = arith.addi %53, %63 : i32
    %65 = arith.index_cast %64 : i32 to index
    %66 = arith.addi %65, %c0 : index
    %67 = memref.load %60[%66] : memref<?xf32>
    %68 = arith.addi %59, %c0 : index
    memref.store %67, %48[%68] : memref<?xf32>
  }
  %46 = memref.load %37[] : memref<i1>
  memref.store %46, %36[] : memref<i1>
  %47 = memref.load %36[] : memref<i1>
  scf.if %47 {
    %48 = memref.load %0[] : memref<i32>
    %49 = arith.addi %48, %c1_i32 : i32
    memref.store %49, %0[] : memref<i32>
  }
  cf.br ^bb1

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %48 = memref.load %0[] : memref<i32>
  %49 = arith.addi %48, %c1_i32 : i32
  memref.store %49, %0[] : memref<i32>
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %48 = memref.load %0[] : memref<i32>
  %49 = arith.addi %48, %c1_i32 : i32
  memref.store %49, %0[] : memref<i32>
  scf.yield
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%49 = arith.addi %48, %c1_i32 : i32
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %44 = memref.load %37[] : memref<i1>
  memref.store %44, %36[] : memref<i1>
  %45 = memref.load %36[] : memref<i1>
  scf.if %45 {
    %48 = memref.load %4[] : memref<memref<?xf32>>
    %49 = memref.load %0[] : memref<i32>
    %50 = memref.load %2[] : memref<i32>
    %51 = memref.load %39[%c0] : memref<1xi32>
    %52 = arith.muli %50, %51 : i32
    %53 = arith.addi %49, %52 : i32
    %54 = memref.load %3[] : memref<i32>
    %55 = arith.muli %54, %51 : i32
    %56 = memref.load %25[%c0] : memref<1xi32>
    %57 = arith.muli %55, %56 : i32
    %58 = arith.addi %53, %57 : i32
    %59 = arith.index_cast %58 : i32 to index
    %60 = memref.load %5[] : memref<memref<?xf32>>
    %61 = arith.subi %54, %c1_i32 : i32
    %62 = arith.muli %61, %51 : i32
    %63 = arith.muli %62, %56 : i32
    %64 = arith.addi %53, %63 : i32
    %65 = arith.index_cast %64 : i32 to index
    %66 = arith.addi %65, %c0 : index
    %67 = memref.load %60[%66] : memref<?xf32>
    %68 = arith.addi %59, %c0 : index
    memref.store %67, %48[%68] : memref<?xf32>
  }
  %46 = memref.load %37[] : memref<i1>
  memref.store %46, %36[] : memref<i1>
  %47 = memref.load %36[] : memref<i1>
  scf.if %47 {
    %48 = memref.load %0[] : memref<i32>
    %49 = arith.addi %48, %c1_i32 : i32
    memref.store %49, %0[] : memref<i32>
  }
  cf.br ^bb1
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %47 {
  %48 = memref.load %0[] : memref<i32>
  %49 = arith.addi %48, %c1_i32 : i32
  memref.store %49, %0[] : memref<i32>
}

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield

mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.execute_region {
    %35 = memref.load %22[] : memref<i1>
    scf.if %35 {
      memref.store %c0_i32, %0[] : memref<i32>
    }
    %36 = memref.alloca() : memref<i1>
    %37 = memref.alloca() : memref<i1>
    memref.store %true, %37[] : memref<i1>
    cf.br ^bb1
  ^bb1:  // 2 preds: ^bb0, ^bb2
    %38 = memref.load %0[] : memref<i32>
    %39 = memref.get_global @im : memref<1xi32>
    %40 = memref.load %39[%c0] : memref<1xi32>
    %41 = arith.cmpi slt, %38, %40 : i32
    %42 = memref.load %37[] : memref<i1>
    %43 = arith.andi %41, %42 : i1
    cf.cond_br %43, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %44 = memref.load %37[] : memref<i1>
    memref.store %44, %36[] : memref<i1>
    %45 = memref.load %36[] : memref<i1>
    scf.if %45 {
      %48 = memref.load %4[] : memref<memref<?xf32>>
      %49 = memref.load %0[] : memref<i32>
      %50 = memref.load %2[] : memref<i32>
      %51 = memref.load %39[%c0] : memref<1xi32>
      %52 = arith.muli %50, %51 : i32
      %53 = arith.addi %49, %52 : i32
      %54 = memref.load %3[] : memref<i32>
      %55 = arith.muli %54, %51 : i32
      %56 = memref.load %25[%c0] : memref<1xi32>
      %57 = arith.muli %55, %56 : i32
      %58 = arith.addi %53, %57 : i32
      %59 = arith.index_cast %58 : i32 to index
      %60 = memref.load %5[] : memref<memref<?xf32>>
      %61 = arith.subi %54, %c1_i32 : i32
      %62 = arith.muli %61, %51 : i32
      %63 = arith.muli %62, %56 : i32
      %64 = arith.addi %53, %63 : i32
      %65 = arith.index_cast %64 : i32 to index
      %66 = arith.addi %65, %c0 : index
      %67 = memref.load %60[%66] : memref<?xf32>
      %68 = arith.addi %59, %c0 : index
      memref.store %67, %48[%68] : memref<?xf32>
    }
    %46 = memref.load %37[] : memref<i1>
    memref.store %46, %36[] : memref<i1>
    %47 = memref.load %36[] : memref<i1>
    scf.if %47 {
      %48 = memref.load %0[] : memref<i32>
      %49 = arith.addi %48, %c1_i32 : i32
      memref.store %49, %0[] : memref<i32>
    }
    cf.br ^bb1
  ^bb3:  // pred: ^bb1
    scf.yield
  }
  scf.yield
 with val:exOp:mlir-asm-printer: Verifying operation: func.func
scf.execute_region {
  %35 = memref.load %22[] : memref<i1>
  scf.if %35 {
    memref.store %c0_i32, %0[] : memref<i32>
  }
  %36 = memref.alloca() : memref<i1>
  %37 = memref.alloca() : memref<i1>
  memref.store %true, %37[] : memref<i1>
  cf.br ^bb1
^bb1:  // 2 preds: ^bb0, ^bb2
  %38 = memref.load %0[] : memref<i32>
  %39 = memref.get_global @im : memref<1xi32>
  %40 = memref.load %39[%c0] : memref<1xi32>
  %41 = arith.cmpi slt, %38, %40 : i32
  %42 = memref.load %37[] : memref<i1>
  %43 = arith.andi %41, %42 : i1
  cf.cond_br %43, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %44 = memref.load %37[] : memref<i1>
  memref.store %44, %36[] : memref<i1>
  %45 = memref.load %36[] : memref<i1>
  scf.if %45 {
    %48 = memref.load %4[] : memref<memref<?xf32>>
    %49 = memref.load %0[] : memref<i32>
    %50 = memref.load %2[] : memref<i32>
    %51 = memref.load %39[%c0] : memref<1xi32>
    %52 = arith.muli %50, %51 : i32
    %53 = arith.addi %49, %52 : i32
    %54 = memref.load %3[] : memref<i32>
    %55 = arith.muli %54, %51 : i32
    %56 = memref.load %25[%c0] : memref<1xi32>
    %57 = arith.muli %55, %56 : i32
    %58 = arith.addi %53, %57 : i32
    %59 = arith.index_cast %58 : i32 to index
    %60 = memref.load %5[] : memref<memref<?xf32>>
    %61 = arith.subi %54, %c1_i32 : i32
    %62 = arith.muli %61, %51 : i32
    %63 = arith.muli %62, %56 : i32
    %64 = arith.addi %53, %63 : i32
    %65 = arith.index_cast %64 : i32 to index
    %66 = arith.addi %65, %c0 : index
    %67 = memref.load %60[%66] : memref<?xf32>
    %68 = arith.addi %59, %c0 : index
    memref.store %67, %48[%68] : memref<?xf32>
  }
  %46 = memref.load %37[] : memref<i1>
  memref.store %46, %36[] : memref<i1>
  %47 = memref.load %36[] : memref<i1>
  scf.if %47 {
    %48 = memref.load %0[] : memref<i32>
    %49 = arith.addi %48, %c1_i32 : i32
    memref.store %49, %0[] : memref<i32>
  }
  cf.br ^bb1
^bb3:  // pred: ^bb1
  scf.yield
}
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %34 = memref.load %22[] : memref<i1>
  scf.if %34 {
    scf.execute_region {
      %35 = memref.load %22[] : memref<i1>
      scf.if %35 {
        memref.store %c0_i32, %0[] : memref<i32>
      }
      %36 = memref.alloca() : memref<i1>
      %37 = memref.alloca() : memref<i1>
      memref.store %true, %37[] : memref<i1>
      cf.br ^bb1
    ^bb1:  // 2 preds: ^bb0, ^bb2
      %38 = memref.load %0[] : memref<i32>
      %39 = memref.get_global @im : memref<1xi32>
      %40 = memref.load %39[%c0] : memref<1xi32>
      %41 = arith.cmpi slt, %38, %40 : i32
      %42 = memref.load %37[] : memref<i1>
      %43 = arith.andi %41, %42 : i1
      cf.cond_br %43, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %44 = memref.load %37[] : memref<i1>
      memref.store %44, %36[] : memref<i1>
      %45 = memref.load %36[] : memref<i1>
      scf.if %45 {
        %48 = memref.load %4[] : memref<memref<?xf32>>
        %49 = memref.load %0[] : memref<i32>
        %50 = memref.load %2[] : memref<i32>
        %51 = memref.load %39[%c0] : memref<1xi32>
        %52 = arith.muli %50, %51 : i32
        %53 = arith.addi %49, %52 : i32
        %54 = memref.load %3[] : memref<i32>
        %55 = arith.muli %54, %51 : i32
        %56 = memref.load %25[%c0] : memref<1xi32>
        %57 = arith.muli %55, %56 : i32
        %58 = arith.addi %53, %57 : i32
        %59 = arith.index_cast %58 : i32 to index
        %60 = memref.load %5[] : memref<memref<?xf32>>
        %61 = arith.subi %54, %c1_i32 : i32
        %62 = arith.muli %61, %51 : i32
        %63 = arith.muli %62, %56 : i32
        %64 = arith.addi %53, %63 : i32
        %65 = arith.index_cast %64 : i32 to index
        %66 = arith.addi %65, %c0 : index
        %67 = memref.load %60[%66] : memref<?xf32>
        %68 = arith.addi %59, %c0 : index
        memref.store %67, %48[%68] : memref<?xf32>
      }
      %46 = memref.load %37[] : memref<i1>
      memref.store %46, %36[] : memref<i1>
      %47 = memref.load %36[] : memref<i1>
      scf.if %47 {
        %48 = memref.load %0[] : memref<i32>
        %49 = arith.addi %48, %c1_i32 : i32
        memref.store %49, %0[] : memref<i32>
      }
      cf.br ^bb1
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
  scf.yield
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %34 {
  scf.execute_region {
    %35 = memref.load %22[] : memref<i1>
    scf.if %35 {
      memref.store %c0_i32, %0[] : memref<i32>
    }
    %36 = memref.alloca() : memref<i1>
    %37 = memref.alloca() : memref<i1>
    memref.store %true, %37[] : memref<i1>
    cf.br ^bb1
  ^bb1:  // 2 preds: ^bb0, ^bb2
    %38 = memref.load %0[] : memref<i32>
    %39 = memref.get_global @im : memref<1xi32>
    %40 = memref.load %39[%c0] : memref<1xi32>
    %41 = arith.cmpi slt, %38, %40 : i32
    %42 = memref.load %37[] : memref<i1>
    %43 = arith.andi %41, %42 : i1
    cf.cond_br %43, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %44 = memref.load %37[] : memref<i1>
    memref.store %44, %36[] : memref<i1>
    %45 = memref.load %36[] : memref<i1>
    scf.if %45 {
      %48 = memref.load %4[] : memref<memref<?xf32>>
      %49 = memref.load %0[] : memref<i32>
      %50 = memref.load %2[] : memref<i32>
      %51 = memref.load %39[%c0] : memref<1xi32>
      %52 = arith.muli %50, %51 : i32
      %53 = arith.addi %49, %52 : i32
      %54 = memref.load %3[] : memref<i32>
      %55 = arith.muli %54, %51 : i32
      %56 = memref.load %25[%c0] : memref<1xi32>
      %57 = arith.muli %55, %56 : i32
      %58 = arith.addi %53, %57 : i32
      %59 = arith.index_cast %58 : i32 to index
      %60 = memref.load %5[] : memref<memref<?xf32>>
      %61 = arith.subi %54, %c1_i32 : i32
      %62 = arith.muli %61, %51 : i32
      %63 = arith.muli %62, %56 : i32
      %64 = arith.addi %53, %63 : i32
      %65 = arith.index_cast %64 : i32 to index
      %66 = arith.addi %65, %c0 : index
      %67 = memref.load %60[%66] : memref<?xf32>
      %68 = arith.addi %59, %c0 : index
      memref.store %67, %48[%68] : memref<?xf32>
    }
    %46 = memref.load %37[] : memref<i1>
    memref.store %46, %36[] : memref<i1>
    %47 = memref.load %36[] : memref<i1>
    scf.if %47 {
      %48 = memref.load %0[] : memref<i32>
      %49 = arith.addi %48, %c1_i32 : i32
      memref.store %49, %0[] : memref<i32>
    }
    cf.br ^bb1
  ^bb3:  // pred: ^bb1
    scf.yield
  }
}

starting block: lastVal=ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %31 {
  %34 = memref.load %22[] : memref<i1>
  scf.if %34 {
    scf.execute_region {
      %35 = memref.load %22[] : memref<i1>
      scf.if %35 {
        memref.store %c0_i32, %0[] : memref<i32>
      }
      %36 = memref.alloca() : memref<i1>
      %37 = memref.alloca() : memref<i1>
      memref.store %true, %37[] : memref<i1>
      cf.br ^bb1
    ^bb1:  // 2 preds: ^bb0, ^bb2
      %38 = memref.load %0[] : memref<i32>
      %39 = memref.get_global @im : memref<1xi32>
      %40 = memref.load %39[%c0] : memref<1xi32>
      %41 = arith.cmpi slt, %38, %40 : i32
      %42 = memref.load %37[] : memref<i1>
      %43 = arith.andi %41, %42 : i1
      cf.cond_br %43, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %44 = memref.load %37[] : memref<i1>
      memref.store %44, %36[] : memref<i1>
      %45 = memref.load %36[] : memref<i1>
      scf.if %45 {
        %48 = memref.load %4[] : memref<memref<?xf32>>
        %49 = memref.load %0[] : memref<i32>
        %50 = memref.load %2[] : memref<i32>
        %51 = memref.load %39[%c0] : memref<1xi32>
        %52 = arith.muli %50, %51 : i32
        %53 = arith.addi %49, %52 : i32
        %54 = memref.load %3[] : memref<i32>
        %55 = arith.muli %54, %51 : i32
        %56 = memref.load %25[%c0] : memref<1xi32>
        %57 = arith.muli %55, %56 : i32
        %58 = arith.addi %53, %57 : i32
        %59 = arith.index_cast %58 : i32 to index
        %60 = memref.load %5[] : memref<memref<?xf32>>
        %61 = arith.subi %54, %c1_i32 : i32
        %62 = arith.muli %61, %51 : i32
        %63 = arith.muli %62, %56 : i32
        %64 = arith.addi %53, %63 : i32
        %65 = arith.index_cast %64 : i32 to index
        %66 = arith.addi %65, %c0 : index
        %67 = memref.load %60[%66] : memref<?xf32>
        %68 = arith.addi %59, %c0 : index
        memref.store %67, %48[%68] : memref<?xf32>
      }
      %46 = memref.load %37[] : memref<i1>
      memref.store %46, %36[] : memref<i1>
      %47 = memref.load %36[] : memref<i1>
      scf.if %47 {
        %48 = memref.load %0[] : memref<i32>
        %49 = arith.addi %48, %c1_i32 : i32
        memref.store %49, %0[] : memref<i32>
      }
      cf.br ^bb1
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
}
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %34 = memref.load %2[] : memref<i32>
  %35 = arith.addi %34, %c1_i32 : i32
  memref.store %35, %2[] : memref<i32>
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %34 = memref.load %2[] : memref<i32>
  %35 = arith.addi %34, %c1_i32 : i32
  memref.store %35, %2[] : memref<i32>
  scf.yield
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %31 {
  %34 = memref.load %22[] : memref<i1>
  scf.if %34 {
    scf.execute_region {
      %35 = memref.load %22[] : memref<i1>
      scf.if %35 {
        memref.store %c0_i32, %0[] : memref<i32>
      }
      %36 = memref.alloca() : memref<i1>
      %37 = memref.alloca() : memref<i1>
      memref.store %true, %37[] : memref<i1>
      cf.br ^bb1
    ^bb1:  // 2 preds: ^bb0, ^bb2
      %38 = memref.load %0[] : memref<i32>
      %39 = memref.get_global @im : memref<1xi32>
      %40 = memref.load %39[%c0] : memref<1xi32>
      %41 = arith.cmpi slt, %38, %40 : i32
      %42 = memref.load %37[] : memref<i1>
      %43 = arith.andi %41, %42 : i1
      cf.cond_br %43, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %44 = memref.load %37[] : memref<i1>
      memref.store %44, %36[] : memref<i1>
      %45 = memref.load %36[] : memref<i1>
      scf.if %45 {
        %48 = memref.load %4[] : memref<memref<?xf32>>
        %49 = memref.load %0[] : memref<i32>
        %50 = memref.load %2[] : memref<i32>
        %51 = memref.load %39[%c0] : memref<1xi32>
        %52 = arith.muli %50, %51 : i32
        %53 = arith.addi %49, %52 : i32
        %54 = memref.load %3[] : memref<i32>
        %55 = arith.muli %54, %51 : i32
        %56 = memref.load %25[%c0] : memref<1xi32>
        %57 = arith.muli %55, %56 : i32
        %58 = arith.addi %53, %57 : i32
        %59 = arith.index_cast %58 : i32 to index
        %60 = memref.load %5[] : memref<memref<?xf32>>
        %61 = arith.subi %54, %c1_i32 : i32
        %62 = arith.muli %61, %51 : i32
        %63 = arith.muli %62, %56 : i32
        %64 = arith.addi %53, %63 : i32
        %65 = arith.index_cast %64 : i32 to index
        %66 = arith.addi %65, %c0 : index
        %67 = memref.load %60[%66] : memref<?xf32>
        %68 = arith.addi %59, %c0 : index
        memref.store %67, %48[%68] : memref<?xf32>
      }
      %46 = memref.load %37[] : memref<i1>
      memref.store %46, %36[] : memref<i1>
      %47 = memref.load %36[] : memref<i1>
      scf.if %47 {
        %48 = memref.load %0[] : memref<i32>
        %49 = arith.addi %48, %c1_i32 : i32
        memref.store %49, %0[] : memref<i32>
      }
      cf.br ^bb1
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
}
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %30 = memref.load %23[] : memref<i1>
  memref.store %30, %22[] : memref<i1>
  %31 = memref.load %22[] : memref<i1>
  scf.if %31 {
    %34 = memref.load %22[] : memref<i1>
    scf.if %34 {
      scf.execute_region {
        %35 = memref.load %22[] : memref<i1>
        scf.if %35 {
          memref.store %c0_i32, %0[] : memref<i32>
        }
        %36 = memref.alloca() : memref<i1>
        %37 = memref.alloca() : memref<i1>
        memref.store %true, %37[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %38 = memref.load %0[] : memref<i32>
        %39 = memref.get_global @im : memref<1xi32>
        %40 = memref.load %39[%c0] : memref<1xi32>
        %41 = arith.cmpi slt, %38, %40 : i32
        %42 = memref.load %37[] : memref<i1>
        %43 = arith.andi %41, %42 : i1
        cf.cond_br %43, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %44 = memref.load %37[] : memref<i1>
        memref.store %44, %36[] : memref<i1>
        %45 = memref.load %36[] : memref<i1>
        scf.if %45 {
          %48 = memref.load %4[] : memref<memref<?xf32>>
          %49 = memref.load %0[] : memref<i32>
          %50 = memref.load %2[] : memref<i32>
          %51 = memref.load %39[%c0] : memref<1xi32>
          %52 = arith.muli %50, %51 : i32
          %53 = arith.addi %49, %52 : i32
          %54 = memref.load %3[] : memref<i32>
          %55 = arith.muli %54, %51 : i32
          %56 = memref.load %25[%c0] : memref<1xi32>
          %57 = arith.muli %55, %56 : i32
          %58 = arith.addi %53, %57 : i32
          %59 = arith.index_cast %58 : i32 to index
          %60 = memref.load %5[] : memref<memref<?xf32>>
          %61 = arith.subi %54, %c1_i32 : i32
          %62 = arith.muli %61, %51 : i32
          %63 = arith.muli %62, %56 : i32
          %64 = arith.addi %53, %63 : i32
          %65 = arith.index_cast %64 : i32 to index
          %66 = arith.addi %65, %c0 : index
          %67 = memref.load %60[%66] : memref<?xf32>
          %68 = arith.addi %59, %c0 : index
          memref.store %67, %48[%68] : memref<?xf32>
        }
        %46 = memref.load %37[] : memref<i1>
        memref.store %46, %36[] : memref<i1>
        %47 = memref.load %36[] : memref<i1>
        scf.if %47 {
          %48 = memref.load %0[] : memref<i32>
          %49 = arith.addi %48, %c1_i32 : i32
          memref.store %49, %0[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  %32 = memref.load %23[] : memref<i1>
  memref.store %32, %22[] : memref<i1>
  %33 = memref.load %22[] : memref<i1>
  scf.if %33 {
    %34 = memref.load %2[] : memref<i32>
    %35 = arith.addi %34, %c1_i32 : i32
    memref.store %35, %2[] : memref<i32>
  }
  cf.br ^bb1
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %31 {
  %34 = memref.load %22[] : memref<i1>
  scf.if %34 {
    scf.execute_region {
      %35 = memref.load %22[] : memref<i1>
      scf.if %35 {
        memref.store %c0_i32, %0[] : memref<i32>
      }
      %36 = memref.alloca() : memref<i1>
      %37 = memref.alloca() : memref<i1>
      memref.store %true, %37[] : memref<i1>
      cf.br ^bb1
    ^bb1:  // 2 preds: ^bb0, ^bb2
      %38 = memref.load %0[] : memref<i32>
      %39 = memref.get_global @im : memref<1xi32>
      %40 = memref.load %39[%c0] : memref<1xi32>
      %41 = arith.cmpi slt, %38, %40 : i32
      %42 = memref.load %37[] : memref<i1>
      %43 = arith.andi %41, %42 : i1
      cf.cond_br %43, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %44 = memref.load %37[] : memref<i1>
      memref.store %44, %36[] : memref<i1>
      %45 = memref.load %36[] : memref<i1>
      scf.if %45 {
        %48 = memref.load %4[] : memref<memref<?xf32>>
        %49 = memref.load %0[] : memref<i32>
        %50 = memref.load %2[] : memref<i32>
        %51 = memref.load %39[%c0] : memref<1xi32>
        %52 = arith.muli %50, %51 : i32
        %53 = arith.addi %49, %52 : i32
        %54 = memref.load %3[] : memref<i32>
        %55 = arith.muli %54, %51 : i32
        %56 = memref.load %25[%c0] : memref<1xi32>
        %57 = arith.muli %55, %56 : i32
        %58 = arith.addi %53, %57 : i32
        %59 = arith.index_cast %58 : i32 to index
        %60 = memref.load %5[] : memref<memref<?xf32>>
        %61 = arith.subi %54, %c1_i32 : i32
        %62 = arith.muli %61, %51 : i32
        %63 = arith.muli %62, %56 : i32
        %64 = arith.addi %53, %63 : i32
        %65 = arith.index_cast %64 : i32 to index
        %66 = arith.addi %65, %c0 : index
        %67 = memref.load %60[%66] : memref<?xf32>
        %68 = arith.addi %59, %c0 : index
        memref.store %67, %48[%68] : memref<?xf32>
      }
      %46 = memref.load %37[] : memref<i1>
      memref.store %46, %36[] : memref<i1>
      %47 = memref.load %36[] : memref<i1>
      scf.if %47 {
        %48 = memref.load %0[] : memref<i32>
        %49 = arith.addi %48, %c1_i32 : i32
        memref.store %49, %0[] : memref<i32>
      }
      cf.br ^bb1
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
}

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield

mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.execute_region {
    %21 = memref.load %10[] : memref<i1>
    scf.if %21 {
      memref.store %c0_i32, %2[] : memref<i32>
    }
    %22 = memref.alloca() : memref<i1>
    %23 = memref.alloca() : memref<i1>
    memref.store %true, %23[] : memref<i1>
    cf.br ^bb1
  ^bb1:  // 2 preds: ^bb0, ^bb2
    %24 = memref.load %2[] : memref<i32>
    %25 = memref.get_global @jm : memref<1xi32>
    %26 = memref.load %25[%c0] : memref<1xi32>
    %27 = arith.cmpi slt, %24, %26 : i32
    %28 = memref.load %23[] : memref<i1>
    %29 = arith.andi %27, %28 : i1
    cf.cond_br %29, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %30 = memref.load %23[] : memref<i1>
    memref.store %30, %22[] : memref<i1>
    %31 = memref.load %22[] : memref<i1>
    scf.if %31 {
      %34 = memref.load %22[] : memref<i1>
      scf.if %34 {
        scf.execute_region {
          %35 = memref.load %22[] : memref<i1>
          scf.if %35 {
            memref.store %c0_i32, %0[] : memref<i32>
          }
          %36 = memref.alloca() : memref<i1>
          %37 = memref.alloca() : memref<i1>
          memref.store %true, %37[] : memref<i1>
          cf.br ^bb1
        ^bb1:  // 2 preds: ^bb0, ^bb2
          %38 = memref.load %0[] : memref<i32>
          %39 = memref.get_global @im : memref<1xi32>
          %40 = memref.load %39[%c0] : memref<1xi32>
          %41 = arith.cmpi slt, %38, %40 : i32
          %42 = memref.load %37[] : memref<i1>
          %43 = arith.andi %41, %42 : i1
          cf.cond_br %43, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %44 = memref.load %37[] : memref<i1>
          memref.store %44, %36[] : memref<i1>
          %45 = memref.load %36[] : memref<i1>
          scf.if %45 {
            %48 = memref.load %4[] : memref<memref<?xf32>>
            %49 = memref.load %0[] : memref<i32>
            %50 = memref.load %2[] : memref<i32>
            %51 = memref.load %39[%c0] : memref<1xi32>
            %52 = arith.muli %50, %51 : i32
            %53 = arith.addi %49, %52 : i32
            %54 = memref.load %3[] : memref<i32>
            %55 = arith.muli %54, %51 : i32
            %56 = memref.load %25[%c0] : memref<1xi32>
            %57 = arith.muli %55, %56 : i32
            %58 = arith.addi %53, %57 : i32
            %59 = arith.index_cast %58 : i32 to index
            %60 = memref.load %5[] : memref<memref<?xf32>>
            %61 = arith.subi %54, %c1_i32 : i32
            %62 = arith.muli %61, %51 : i32
            %63 = arith.muli %62, %56 : i32
            %64 = arith.addi %53, %63 : i32
            %65 = arith.index_cast %64 : i32 to index
            %66 = arith.addi %65, %c0 : index
            %67 = memref.load %60[%66] : memref<?xf32>
            %68 = arith.addi %59, %c0 : index
            memref.store %67, %48[%68] : memref<?xf32>
          }
          %46 = memref.load %37[] : memref<i1>
          memref.store %46, %36[] : memref<i1>
          %47 = memref.load %36[] : memref<i1>
          scf.if %47 {
            %48 = memref.load %0[] : memref<i32>
            %49 = arith.addi %48, %c1_i32 : i32
            memref.store %49, %0[] : memref<i32>
          }
          cf.br ^bb1
        ^bb3:  // pred: ^bb1
          scf.yield
        }
      }
    }
    %32 = memref.load %23[] : memref<i1>
    memref.store %32, %22[] : memref<i1>
    %33 = memref.load %22[] : memref<i1>
    scf.if %33 {
      %34 = memref.load %2[] : memref<i32>
      %35 = arith.addi %34, %c1_i32 : i32
      memref.store %35, %2[] : memref<i32>
    }
    cf.br ^bb1
  ^bb3:  // pred: ^bb1
    scf.yield
  }
  scf.yield
 with val:exOp:mlir-asm-printer: Verifying operation: func.func
scf.execute_region {
  %21 = memref.load %10[] : memref<i1>
  scf.if %21 {
    memref.store %c0_i32, %2[] : memref<i32>
  }
  %22 = memref.alloca() : memref<i1>
  %23 = memref.alloca() : memref<i1>
  memref.store %true, %23[] : memref<i1>
  cf.br ^bb1
^bb1:  // 2 preds: ^bb0, ^bb2
  %24 = memref.load %2[] : memref<i32>
  %25 = memref.get_global @jm : memref<1xi32>
  %26 = memref.load %25[%c0] : memref<1xi32>
  %27 = arith.cmpi slt, %24, %26 : i32
  %28 = memref.load %23[] : memref<i1>
  %29 = arith.andi %27, %28 : i1
  cf.cond_br %29, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %30 = memref.load %23[] : memref<i1>
  memref.store %30, %22[] : memref<i1>
  %31 = memref.load %22[] : memref<i1>
  scf.if %31 {
    %34 = memref.load %22[] : memref<i1>
    scf.if %34 {
      scf.execute_region {
        %35 = memref.load %22[] : memref<i1>
        scf.if %35 {
          memref.store %c0_i32, %0[] : memref<i32>
        }
        %36 = memref.alloca() : memref<i1>
        %37 = memref.alloca() : memref<i1>
        memref.store %true, %37[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %38 = memref.load %0[] : memref<i32>
        %39 = memref.get_global @im : memref<1xi32>
        %40 = memref.load %39[%c0] : memref<1xi32>
        %41 = arith.cmpi slt, %38, %40 : i32
        %42 = memref.load %37[] : memref<i1>
        %43 = arith.andi %41, %42 : i1
        cf.cond_br %43, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %44 = memref.load %37[] : memref<i1>
        memref.store %44, %36[] : memref<i1>
        %45 = memref.load %36[] : memref<i1>
        scf.if %45 {
          %48 = memref.load %4[] : memref<memref<?xf32>>
          %49 = memref.load %0[] : memref<i32>
          %50 = memref.load %2[] : memref<i32>
          %51 = memref.load %39[%c0] : memref<1xi32>
          %52 = arith.muli %50, %51 : i32
          %53 = arith.addi %49, %52 : i32
          %54 = memref.load %3[] : memref<i32>
          %55 = arith.muli %54, %51 : i32
          %56 = memref.load %25[%c0] : memref<1xi32>
          %57 = arith.muli %55, %56 : i32
          %58 = arith.addi %53, %57 : i32
          %59 = arith.index_cast %58 : i32 to index
          %60 = memref.load %5[] : memref<memref<?xf32>>
          %61 = arith.subi %54, %c1_i32 : i32
          %62 = arith.muli %61, %51 : i32
          %63 = arith.muli %62, %56 : i32
          %64 = arith.addi %53, %63 : i32
          %65 = arith.index_cast %64 : i32 to index
          %66 = arith.addi %65, %c0 : index
          %67 = memref.load %60[%66] : memref<?xf32>
          %68 = arith.addi %59, %c0 : index
          memref.store %67, %48[%68] : memref<?xf32>
        }
        %46 = memref.load %37[] : memref<i1>
        memref.store %46, %36[] : memref<i1>
        %47 = memref.load %36[] : memref<i1>
        scf.if %47 {
          %48 = memref.load %0[] : memref<i32>
          %49 = arith.addi %48, %c1_i32 : i32
          memref.store %49, %0[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  %32 = memref.load %23[] : memref<i1>
  memref.store %32, %22[] : memref<i1>
  %33 = memref.load %22[] : memref<i1>
  scf.if %33 {
    %34 = memref.load %2[] : memref<i32>
    %35 = arith.addi %34, %c1_i32 : i32
    memref.store %35, %2[] : memref<i32>
  }
  cf.br ^bb1
^bb3:  // pred: ^bb1
  scf.yield
}
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %20 = memref.load %10[] : memref<i1>
  scf.if %20 {
    scf.execute_region {
      %21 = memref.load %10[] : memref<i1>
      scf.if %21 {
        memref.store %c0_i32, %2[] : memref<i32>
      }
      %22 = memref.alloca() : memref<i1>
      %23 = memref.alloca() : memref<i1>
      memref.store %true, %23[] : memref<i1>
      cf.br ^bb1
    ^bb1:  // 2 preds: ^bb0, ^bb2
      %24 = memref.load %2[] : memref<i32>
      %25 = memref.get_global @jm : memref<1xi32>
      %26 = memref.load %25[%c0] : memref<1xi32>
      %27 = arith.cmpi slt, %24, %26 : i32
      %28 = memref.load %23[] : memref<i1>
      %29 = arith.andi %27, %28 : i1
      cf.cond_br %29, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %30 = memref.load %23[] : memref<i1>
      memref.store %30, %22[] : memref<i1>
      %31 = memref.load %22[] : memref<i1>
      scf.if %31 {
        %34 = memref.load %22[] : memref<i1>
        scf.if %34 {
          scf.execute_region {
            %35 = memref.load %22[] : memref<i1>
            scf.if %35 {
              memref.store %c0_i32, %0[] : memref<i32>
            }
            %36 = memref.alloca() : memref<i1>
            %37 = memref.alloca() : memref<i1>
            memref.store %true, %37[] : memref<i1>
            cf.br ^bb1
          ^bb1:  // 2 preds: ^bb0, ^bb2
            %38 = memref.load %0[] : memref<i32>
            %39 = memref.get_global @im : memref<1xi32>
            %40 = memref.load %39[%c0] : memref<1xi32>
            %41 = arith.cmpi slt, %38, %40 : i32
            %42 = memref.load %37[] : memref<i1>
            %43 = arith.andi %41, %42 : i1
            cf.cond_br %43, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %44 = memref.load %37[] : memref<i1>
            memref.store %44, %36[] : memref<i1>
            %45 = memref.load %36[] : memref<i1>
            scf.if %45 {
              %48 = memref.load %4[] : memref<memref<?xf32>>
              %49 = memref.load %0[] : memref<i32>
              %50 = memref.load %2[] : memref<i32>
              %51 = memref.load %39[%c0] : memref<1xi32>
              %52 = arith.muli %50, %51 : i32
              %53 = arith.addi %49, %52 : i32
              %54 = memref.load %3[] : memref<i32>
              %55 = arith.muli %54, %51 : i32
              %56 = memref.load %25[%c0] : memref<1xi32>
              %57 = arith.muli %55, %56 : i32
              %58 = arith.addi %53, %57 : i32
              %59 = arith.index_cast %58 : i32 to index
              %60 = memref.load %5[] : memref<memref<?xf32>>
              %61 = arith.subi %54, %c1_i32 : i32
              %62 = arith.muli %61, %51 : i32
              %63 = arith.muli %62, %56 : i32
              %64 = arith.addi %53, %63 : i32
              %65 = arith.index_cast %64 : i32 to index
              %66 = arith.addi %65, %c0 : index
              %67 = memref.load %60[%66] : memref<?xf32>
              %68 = arith.addi %59, %c0 : index
              memref.store %67, %48[%68] : memref<?xf32>
            }
            %46 = memref.load %37[] : memref<i1>
            memref.store %46, %36[] : memref<i1>
            %47 = memref.load %36[] : memref<i1>
            scf.if %47 {
              %48 = memref.load %0[] : memref<i32>
              %49 = arith.addi %48, %c1_i32 : i32
              memref.store %49, %0[] : memref<i32>
            }
            cf.br ^bb1
          ^bb3:  // pred: ^bb1
            scf.yield
          }
        }
      }
      %32 = memref.load %23[] : memref<i1>
      memref.store %32, %22[] : memref<i1>
      %33 = memref.load %22[] : memref<i1>
      scf.if %33 {
        %34 = memref.load %2[] : memref<i32>
        %35 = arith.addi %34, %c1_i32 : i32
        memref.store %35, %2[] : memref<i32>
      }
      cf.br ^bb1
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
  scf.yield
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %20 {
  scf.execute_region {
    %21 = memref.load %10[] : memref<i1>
    scf.if %21 {
      memref.store %c0_i32, %2[] : memref<i32>
    }
    %22 = memref.alloca() : memref<i1>
    %23 = memref.alloca() : memref<i1>
    memref.store %true, %23[] : memref<i1>
    cf.br ^bb1
  ^bb1:  // 2 preds: ^bb0, ^bb2
    %24 = memref.load %2[] : memref<i32>
    %25 = memref.get_global @jm : memref<1xi32>
    %26 = memref.load %25[%c0] : memref<1xi32>
    %27 = arith.cmpi slt, %24, %26 : i32
    %28 = memref.load %23[] : memref<i1>
    %29 = arith.andi %27, %28 : i1
    cf.cond_br %29, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %30 = memref.load %23[] : memref<i1>
    memref.store %30, %22[] : memref<i1>
    %31 = memref.load %22[] : memref<i1>
    scf.if %31 {
      %34 = memref.load %22[] : memref<i1>
      scf.if %34 {
        scf.execute_region {
          %35 = memref.load %22[] : memref<i1>
          scf.if %35 {
            memref.store %c0_i32, %0[] : memref<i32>
          }
          %36 = memref.alloca() : memref<i1>
          %37 = memref.alloca() : memref<i1>
          memref.store %true, %37[] : memref<i1>
          cf.br ^bb1
        ^bb1:  // 2 preds: ^bb0, ^bb2
          %38 = memref.load %0[] : memref<i32>
          %39 = memref.get_global @im : memref<1xi32>
          %40 = memref.load %39[%c0] : memref<1xi32>
          %41 = arith.cmpi slt, %38, %40 : i32
          %42 = memref.load %37[] : memref<i1>
          %43 = arith.andi %41, %42 : i1
          cf.cond_br %43, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %44 = memref.load %37[] : memref<i1>
          memref.store %44, %36[] : memref<i1>
          %45 = memref.load %36[] : memref<i1>
          scf.if %45 {
            %48 = memref.load %4[] : memref<memref<?xf32>>
            %49 = memref.load %0[] : memref<i32>
            %50 = memref.load %2[] : memref<i32>
            %51 = memref.load %39[%c0] : memref<1xi32>
            %52 = arith.muli %50, %51 : i32
            %53 = arith.addi %49, %52 : i32
            %54 = memref.load %3[] : memref<i32>
            %55 = arith.muli %54, %51 : i32
            %56 = memref.load %25[%c0] : memref<1xi32>
            %57 = arith.muli %55, %56 : i32
            %58 = arith.addi %53, %57 : i32
            %59 = arith.index_cast %58 : i32 to index
            %60 = memref.load %5[] : memref<memref<?xf32>>
            %61 = arith.subi %54, %c1_i32 : i32
            %62 = arith.muli %61, %51 : i32
            %63 = arith.muli %62, %56 : i32
            %64 = arith.addi %53, %63 : i32
            %65 = arith.index_cast %64 : i32 to index
            %66 = arith.addi %65, %c0 : index
            %67 = memref.load %60[%66] : memref<?xf32>
            %68 = arith.addi %59, %c0 : index
            memref.store %67, %48[%68] : memref<?xf32>
          }
          %46 = memref.load %37[] : memref<i1>
          memref.store %46, %36[] : memref<i1>
          %47 = memref.load %36[] : memref<i1>
          scf.if %47 {
            %48 = memref.load %0[] : memref<i32>
            %49 = arith.addi %48, %c1_i32 : i32
            memref.store %49, %0[] : memref<i32>
          }
          cf.br ^bb1
        ^bb3:  // pred: ^bb1
          scf.yield
        }
      }
    }
    %32 = memref.load %23[] : memref<i1>
    memref.store %32, %22[] : memref<i1>
    %33 = memref.load %22[] : memref<i1>
    scf.if %33 {
      %34 = memref.load %2[] : memref<i32>
      %35 = arith.addi %34, %c1_i32 : i32
      memref.store %35, %2[] : memref<i32>
    }
    cf.br ^bb1
  ^bb3:  // pred: ^bb1
    scf.yield
  }
}

starting block: lastVal=ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %17 {
  %20 = memref.load %10[] : memref<i1>
  scf.if %20 {
    scf.execute_region {
      %21 = memref.load %10[] : memref<i1>
      scf.if %21 {
        memref.store %c0_i32, %2[] : memref<i32>
      }
      %22 = memref.alloca() : memref<i1>
      %23 = memref.alloca() : memref<i1>
      memref.store %true, %23[] : memref<i1>
      cf.br ^bb1
    ^bb1:  // 2 preds: ^bb0, ^bb2
      %24 = memref.load %2[] : memref<i32>
      %25 = memref.get_global @jm : memref<1xi32>
      %26 = memref.load %25[%c0] : memref<1xi32>
      %27 = arith.cmpi slt, %24, %26 : i32
      %28 = memref.load %23[] : memref<i1>
      %29 = arith.andi %27, %28 : i1
      cf.cond_br %29, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %30 = memref.load %23[] : memref<i1>
      memref.store %30, %22[] : memref<i1>
      %31 = memref.load %22[] : memref<i1>
      scf.if %31 {
        %34 = memref.load %22[] : memref<i1>
        scf.if %34 {
          scf.execute_region {
            %35 = memref.load %22[] : memref<i1>
            scf.if %35 {
              memref.store %c0_i32, %0[] : memref<i32>
            }
            %36 = memref.alloca() : memref<i1>
            %37 = memref.alloca() : memref<i1>
            memref.store %true, %37[] : memref<i1>
            cf.br ^bb1
          ^bb1:  // 2 preds: ^bb0, ^bb2
            %38 = memref.load %0[] : memref<i32>
            %39 = memref.get_global @im : memref<1xi32>
            %40 = memref.load %39[%c0] : memref<1xi32>
            %41 = arith.cmpi slt, %38, %40 : i32
            %42 = memref.load %37[] : memref<i1>
            %43 = arith.andi %41, %42 : i1
            cf.cond_br %43, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %44 = memref.load %37[] : memref<i1>
            memref.store %44, %36[] : memref<i1>
            %45 = memref.load %36[] : memref<i1>
            scf.if %45 {
              %48 = memref.load %4[] : memref<memref<?xf32>>
              %49 = memref.load %0[] : memref<i32>
              %50 = memref.load %2[] : memref<i32>
              %51 = memref.load %39[%c0] : memref<1xi32>
              %52 = arith.muli %50, %51 : i32
              %53 = arith.addi %49, %52 : i32
              %54 = memref.load %3[] : memref<i32>
              %55 = arith.muli %54, %51 : i32
              %56 = memref.load %25[%c0] : memref<1xi32>
              %57 = arith.muli %55, %56 : i32
              %58 = arith.addi %53, %57 : i32
              %59 = arith.index_cast %58 : i32 to index
              %60 = memref.load %5[] : memref<memref<?xf32>>
              %61 = arith.subi %54, %c1_i32 : i32
              %62 = arith.muli %61, %51 : i32
              %63 = arith.muli %62, %56 : i32
              %64 = arith.addi %53, %63 : i32
              %65 = arith.index_cast %64 : i32 to index
              %66 = arith.addi %65, %c0 : index
              %67 = memref.load %60[%66] : memref<?xf32>
              %68 = arith.addi %59, %c0 : index
              memref.store %67, %48[%68] : memref<?xf32>
            }
            %46 = memref.load %37[] : memref<i1>
            memref.store %46, %36[] : memref<i1>
            %47 = memref.load %36[] : memref<i1>
            scf.if %47 {
              %48 = memref.load %0[] : memref<i32>
              %49 = arith.addi %48, %c1_i32 : i32
              memref.store %49, %0[] : memref<i32>
            }
            cf.br ^bb1
          ^bb3:  // pred: ^bb1
            scf.yield
          }
        }
      }
      %32 = memref.load %23[] : memref<i1>
      memref.store %32, %22[] : memref<i1>
      %33 = memref.load %22[] : memref<i1>
      scf.if %33 {
        %34 = memref.load %2[] : memref<i32>
        %35 = arith.addi %34, %c1_i32 : i32
        memref.store %35, %2[] : memref<i32>
      }
      cf.br ^bb1
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
}
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %20 = memref.load %3[] : memref<i32>
  %21 = arith.subi %20, %c1_i32 : i32
  memref.store %21, %3[] : memref<i32>
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %20 = memref.load %3[] : memref<i32>
  %21 = arith.subi %20, %c1_i32 : i32
  memref.store %21, %3[] : memref<i32>
  scf.yield
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %17 {
  %20 = memref.load %10[] : memref<i1>
  scf.if %20 {
    scf.execute_region {
      %21 = memref.load %10[] : memref<i1>
      scf.if %21 {
        memref.store %c0_i32, %2[] : memref<i32>
      }
      %22 = memref.alloca() : memref<i1>
      %23 = memref.alloca() : memref<i1>
      memref.store %true, %23[] : memref<i1>
      cf.br ^bb1
    ^bb1:  // 2 preds: ^bb0, ^bb2
      %24 = memref.load %2[] : memref<i32>
      %25 = memref.get_global @jm : memref<1xi32>
      %26 = memref.load %25[%c0] : memref<1xi32>
      %27 = arith.cmpi slt, %24, %26 : i32
      %28 = memref.load %23[] : memref<i1>
      %29 = arith.andi %27, %28 : i1
      cf.cond_br %29, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %30 = memref.load %23[] : memref<i1>
      memref.store %30, %22[] : memref<i1>
      %31 = memref.load %22[] : memref<i1>
      scf.if %31 {
        %34 = memref.load %22[] : memref<i1>
        scf.if %34 {
          scf.execute_region {
            %35 = memref.load %22[] : memref<i1>
            scf.if %35 {
              memref.store %c0_i32, %0[] : memref<i32>
            }
            %36 = memref.alloca() : memref<i1>
            %37 = memref.alloca() : memref<i1>
            memref.store %true, %37[] : memref<i1>
            cf.br ^bb1
          ^bb1:  // 2 preds: ^bb0, ^bb2
            %38 = memref.load %0[] : memref<i32>
            %39 = memref.get_global @im : memref<1xi32>
            %40 = memref.load %39[%c0] : memref<1xi32>
            %41 = arith.cmpi slt, %38, %40 : i32
            %42 = memref.load %37[] : memref<i1>
            %43 = arith.andi %41, %42 : i1
            cf.cond_br %43, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %44 = memref.load %37[] : memref<i1>
            memref.store %44, %36[] : memref<i1>
            %45 = memref.load %36[] : memref<i1>
            scf.if %45 {
              %48 = memref.load %4[] : memref<memref<?xf32>>
              %49 = memref.load %0[] : memref<i32>
              %50 = memref.load %2[] : memref<i32>
              %51 = memref.load %39[%c0] : memref<1xi32>
              %52 = arith.muli %50, %51 : i32
              %53 = arith.addi %49, %52 : i32
              %54 = memref.load %3[] : memref<i32>
              %55 = arith.muli %54, %51 : i32
              %56 = memref.load %25[%c0] : memref<1xi32>
              %57 = arith.muli %55, %56 : i32
              %58 = arith.addi %53, %57 : i32
              %59 = arith.index_cast %58 : i32 to index
              %60 = memref.load %5[] : memref<memref<?xf32>>
              %61 = arith.subi %54, %c1_i32 : i32
              %62 = arith.muli %61, %51 : i32
              %63 = arith.muli %62, %56 : i32
              %64 = arith.addi %53, %63 : i32
              %65 = arith.index_cast %64 : i32 to index
              %66 = arith.addi %65, %c0 : index
              %67 = memref.load %60[%66] : memref<?xf32>
              %68 = arith.addi %59, %c0 : index
              memref.store %67, %48[%68] : memref<?xf32>
            }
            %46 = memref.load %37[] : memref<i1>
            memref.store %46, %36[] : memref<i1>
            %47 = memref.load %36[] : memref<i1>
            scf.if %47 {
              %48 = memref.load %0[] : memref<i32>
              %49 = arith.addi %48, %c1_i32 : i32
              memref.store %49, %0[] : memref<i32>
            }
            cf.br ^bb1
          ^bb3:  // pred: ^bb1
            scf.yield
          }
        }
      }
      %32 = memref.load %23[] : memref<i1>
      memref.store %32, %22[] : memref<i1>
      %33 = memref.load %22[] : memref<i1>
      scf.if %33 {
        %34 = memref.load %2[] : memref<i32>
        %35 = arith.addi %34, %c1_i32 : i32
        memref.store %35, %2[] : memref<i32>
      }
      cf.br ^bb1
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
}
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %16 = memref.load %11[] : memref<i1>
  memref.store %16, %10[] : memref<i1>
  %17 = memref.load %10[] : memref<i1>
  scf.if %17 {
    %20 = memref.load %10[] : memref<i1>
    scf.if %20 {
      scf.execute_region {
        %21 = memref.load %10[] : memref<i1>
        scf.if %21 {
          memref.store %c0_i32, %2[] : memref<i32>
        }
        %22 = memref.alloca() : memref<i1>
        %23 = memref.alloca() : memref<i1>
        memref.store %true, %23[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %24 = memref.load %2[] : memref<i32>
        %25 = memref.get_global @jm : memref<1xi32>
        %26 = memref.load %25[%c0] : memref<1xi32>
        %27 = arith.cmpi slt, %24, %26 : i32
        %28 = memref.load %23[] : memref<i1>
        %29 = arith.andi %27, %28 : i1
        cf.cond_br %29, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %30 = memref.load %23[] : memref<i1>
        memref.store %30, %22[] : memref<i1>
        %31 = memref.load %22[] : memref<i1>
        scf.if %31 {
          %34 = memref.load %22[] : memref<i1>
          scf.if %34 {
            scf.execute_region {
              %35 = memref.load %22[] : memref<i1>
              scf.if %35 {
                memref.store %c0_i32, %0[] : memref<i32>
              }
              %36 = memref.alloca() : memref<i1>
              %37 = memref.alloca() : memref<i1>
              memref.store %true, %37[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %38 = memref.load %0[] : memref<i32>
              %39 = memref.get_global @im : memref<1xi32>
              %40 = memref.load %39[%c0] : memref<1xi32>
              %41 = arith.cmpi slt, %38, %40 : i32
              %42 = memref.load %37[] : memref<i1>
              %43 = arith.andi %41, %42 : i1
              cf.cond_br %43, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %44 = memref.load %37[] : memref<i1>
              memref.store %44, %36[] : memref<i1>
              %45 = memref.load %36[] : memref<i1>
              scf.if %45 {
                %48 = memref.load %4[] : memref<memref<?xf32>>
                %49 = memref.load %0[] : memref<i32>
                %50 = memref.load %2[] : memref<i32>
                %51 = memref.load %39[%c0] : memref<1xi32>
                %52 = arith.muli %50, %51 : i32
                %53 = arith.addi %49, %52 : i32
                %54 = memref.load %3[] : memref<i32>
                %55 = arith.muli %54, %51 : i32
                %56 = memref.load %25[%c0] : memref<1xi32>
                %57 = arith.muli %55, %56 : i32
                %58 = arith.addi %53, %57 : i32
                %59 = arith.index_cast %58 : i32 to index
                %60 = memref.load %5[] : memref<memref<?xf32>>
                %61 = arith.subi %54, %c1_i32 : i32
                %62 = arith.muli %61, %51 : i32
                %63 = arith.muli %62, %56 : i32
                %64 = arith.addi %53, %63 : i32
                %65 = arith.index_cast %64 : i32 to index
                %66 = arith.addi %65, %c0 : index
                %67 = memref.load %60[%66] : memref<?xf32>
                %68 = arith.addi %59, %c0 : index
                memref.store %67, %48[%68] : memref<?xf32>
              }
              %46 = memref.load %37[] : memref<i1>
              memref.store %46, %36[] : memref<i1>
              %47 = memref.load %36[] : memref<i1>
              scf.if %47 {
                %48 = memref.load %0[] : memref<i32>
                %49 = arith.addi %48, %c1_i32 : i32
                memref.store %49, %0[] : memref<i32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %32 = memref.load %23[] : memref<i1>
        memref.store %32, %22[] : memref<i1>
        %33 = memref.load %22[] : memref<i1>
        scf.if %33 {
          %34 = memref.load %2[] : memref<i32>
          %35 = arith.addi %34, %c1_i32 : i32
          memref.store %35, %2[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  scf.if %19 {
    %20 = memref.load %3[] : memref<i32>
    %21 = arith.subi %20, %c1_i32 : i32
    memref.store %21, %3[] : memref<i32>
  }
  cf.br ^bb1
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %17 {
  %20 = memref.load %10[] : memref<i1>
  scf.if %20 {
    scf.execute_region {
      %21 = memref.load %10[] : memref<i1>
      scf.if %21 {
        memref.store %c0_i32, %2[] : memref<i32>
      }
      %22 = memref.alloca() : memref<i1>
      %23 = memref.alloca() : memref<i1>
      memref.store %true, %23[] : memref<i1>
      cf.br ^bb1
    ^bb1:  // 2 preds: ^bb0, ^bb2
      %24 = memref.load %2[] : memref<i32>
      %25 = memref.get_global @jm : memref<1xi32>
      %26 = memref.load %25[%c0] : memref<1xi32>
      %27 = arith.cmpi slt, %24, %26 : i32
      %28 = memref.load %23[] : memref<i1>
      %29 = arith.andi %27, %28 : i1
      cf.cond_br %29, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %30 = memref.load %23[] : memref<i1>
      memref.store %30, %22[] : memref<i1>
      %31 = memref.load %22[] : memref<i1>
      scf.if %31 {
        %34 = memref.load %22[] : memref<i1>
        scf.if %34 {
          scf.execute_region {
            %35 = memref.load %22[] : memref<i1>
            scf.if %35 {
              memref.store %c0_i32, %0[] : memref<i32>
            }
            %36 = memref.alloca() : memref<i1>
            %37 = memref.alloca() : memref<i1>
            memref.store %true, %37[] : memref<i1>
            cf.br ^bb1
          ^bb1:  // 2 preds: ^bb0, ^bb2
            %38 = memref.load %0[] : memref<i32>
            %39 = memref.get_global @im : memref<1xi32>
            %40 = memref.load %39[%c0] : memref<1xi32>
            %41 = arith.cmpi slt, %38, %40 : i32
            %42 = memref.load %37[] : memref<i1>
            %43 = arith.andi %41, %42 : i1
            cf.cond_br %43, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %44 = memref.load %37[] : memref<i1>
            memref.store %44, %36[] : memref<i1>
            %45 = memref.load %36[] : memref<i1>
            scf.if %45 {
              %48 = memref.load %4[] : memref<memref<?xf32>>
              %49 = memref.load %0[] : memref<i32>
              %50 = memref.load %2[] : memref<i32>
              %51 = memref.load %39[%c0] : memref<1xi32>
              %52 = arith.muli %50, %51 : i32
              %53 = arith.addi %49, %52 : i32
              %54 = memref.load %3[] : memref<i32>
              %55 = arith.muli %54, %51 : i32
              %56 = memref.load %25[%c0] : memref<1xi32>
              %57 = arith.muli %55, %56 : i32
              %58 = arith.addi %53, %57 : i32
              %59 = arith.index_cast %58 : i32 to index
              %60 = memref.load %5[] : memref<memref<?xf32>>
              %61 = arith.subi %54, %c1_i32 : i32
              %62 = arith.muli %61, %51 : i32
              %63 = arith.muli %62, %56 : i32
              %64 = arith.addi %53, %63 : i32
              %65 = arith.index_cast %64 : i32 to index
              %66 = arith.addi %65, %c0 : index
              %67 = memref.load %60[%66] : memref<?xf32>
              %68 = arith.addi %59, %c0 : index
              memref.store %67, %48[%68] : memref<?xf32>
            }
            %46 = memref.load %37[] : memref<i1>
            memref.store %46, %36[] : memref<i1>
            %47 = memref.load %36[] : memref<i1>
            scf.if %47 {
              %48 = memref.load %0[] : memref<i32>
              %49 = arith.addi %48, %c1_i32 : i32
              memref.store %49, %0[] : memref<i32>
            }
            cf.br ^bb1
          ^bb3:  // pred: ^bb1
            scf.yield
          }
        }
      }
      %32 = memref.load %23[] : memref<i1>
      memref.store %32, %22[] : memref<i1>
      %33 = memref.load %22[] : memref<i1>
      scf.if %33 {
        %34 = memref.load %2[] : memref<i32>
        %35 = arith.addi %34, %c1_i32 : i32
        memref.store %35, %2[] : memref<i32>
      }
      cf.br ^bb1
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
}

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield

mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.execute_region {
    %9 = memref.load %6[] : memref<i1>
    scf.if %9 {
      %20 = memref.get_global @kbm3 : memref<1xi32>
      %21 = memref.load %20[%c0] : memref<1xi32>
      memref.store %21, %3[] : memref<i32>
    }
    %10 = memref.alloca() : memref<i1>
    %11 = memref.alloca() : memref<i1>
    memref.store %true, %11[] : memref<i1>
    cf.br ^bb1
  ^bb1:  // 2 preds: ^bb0, ^bb2
    %12 = memref.load %3[] : memref<i32>
    %13 = arith.cmpi sgt, %12, %c0_i32 : i32
    %14 = memref.load %11[] : memref<i1>
    %15 = arith.andi %13, %14 : i1
    cf.cond_br %15, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %16 = memref.load %11[] : memref<i1>
    memref.store %16, %10[] : memref<i1>
    %17 = memref.load %10[] : memref<i1>
    scf.if %17 {
      %20 = memref.load %10[] : memref<i1>
      scf.if %20 {
        scf.execute_region {
          %21 = memref.load %10[] : memref<i1>
          scf.if %21 {
            memref.store %c0_i32, %2[] : memref<i32>
          }
          %22 = memref.alloca() : memref<i1>
          %23 = memref.alloca() : memref<i1>
          memref.store %true, %23[] : memref<i1>
          cf.br ^bb1
        ^bb1:  // 2 preds: ^bb0, ^bb2
          %24 = memref.load %2[] : memref<i32>
          %25 = memref.get_global @jm : memref<1xi32>
          %26 = memref.load %25[%c0] : memref<1xi32>
          %27 = arith.cmpi slt, %24, %26 : i32
          %28 = memref.load %23[] : memref<i1>
          %29 = arith.andi %27, %28 : i1
          cf.cond_br %29, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %30 = memref.load %23[] : memref<i1>
          memref.store %30, %22[] : memref<i1>
          %31 = memref.load %22[] : memref<i1>
          scf.if %31 {
            %34 = memref.load %22[] : memref<i1>
            scf.if %34 {
              scf.execute_region {
                %35 = memref.load %22[] : memref<i1>
                scf.if %35 {
                  memref.store %c0_i32, %0[] : memref<i32>
                }
                %36 = memref.alloca() : memref<i1>
                %37 = memref.alloca() : memref<i1>
                memref.store %true, %37[] : memref<i1>
                cf.br ^bb1
              ^bb1:  // 2 preds: ^bb0, ^bb2
                %38 = memref.load %0[] : memref<i32>
                %39 = memref.get_global @im : memref<1xi32>
                %40 = memref.load %39[%c0] : memref<1xi32>
                %41 = arith.cmpi slt, %38, %40 : i32
                %42 = memref.load %37[] : memref<i1>
                %43 = arith.andi %41, %42 : i1
                cf.cond_br %43, ^bb2, ^bb3
              ^bb2:  // pred: ^bb1
                %44 = memref.load %37[] : memref<i1>
                memref.store %44, %36[] : memref<i1>
                %45 = memref.load %36[] : memref<i1>
                scf.if %45 {
                  %48 = memref.load %4[] : memref<memref<?xf32>>
                  %49 = memref.load %0[] : memref<i32>
                  %50 = memref.load %2[] : memref<i32>
                  %51 = memref.load %39[%c0] : memref<1xi32>
                  %52 = arith.muli %50, %51 : i32
                  %53 = arith.addi %49, %52 : i32
                  %54 = memref.load %3[] : memref<i32>
                  %55 = arith.muli %54, %51 : i32
                  %56 = memref.load %25[%c0] : memref<1xi32>
                  %57 = arith.muli %55, %56 : i32
                  %58 = arith.addi %53, %57 : i32
                  %59 = arith.index_cast %58 : i32 to index
                  %60 = memref.load %5[] : memref<memref<?xf32>>
                  %61 = arith.subi %54, %c1_i32 : i32
                  %62 = arith.muli %61, %51 : i32
                  %63 = arith.muli %62, %56 : i32
                  %64 = arith.addi %53, %63 : i32
                  %65 = arith.index_cast %64 : i32 to index
                  %66 = arith.addi %65, %c0 : index
                  %67 = memref.load %60[%66] : memref<?xf32>
                  %68 = arith.addi %59, %c0 : index
                  memref.store %67, %48[%68] : memref<?xf32>
                }
                %46 = memref.load %37[] : memref<i1>
                memref.store %46, %36[] : memref<i1>
                %47 = memref.load %36[] : memref<i1>
                scf.if %47 {
                  %48 = memref.load %0[] : memref<i32>
                  %49 = arith.addi %48, %c1_i32 : i32
                  memref.store %49, %0[] : memref<i32>
                }
                cf.br ^bb1
              ^bb3:  // pred: ^bb1
                scf.yield
              }
            }
          }
          %32 = memref.load %23[] : memref<i1>
          memref.store %32, %22[] : memref<i1>
          %33 = memref.load %22[] : memref<i1>
          scf.if %33 {
            %34 = memref.load %2[] : memref<i32>
            %35 = arith.addi %34, %c1_i32 : i32
            memref.store %35, %2[] : memref<i32>
          }
          cf.br ^bb1
        ^bb3:  // pred: ^bb1
          scf.yield
        }
      }
    }
    %18 = memref.load %11[] : memref<i1>
    memref.store %18, %10[] : memref<i1>
    %19 = memref.load %10[] : memref<i1>
    scf.if %19 {
      %20 = memref.load %3[] : memref<i32>
      %21 = arith.subi %20, %c1_i32 : i32
      memref.store %21, %3[] : memref<i32>
    }
    cf.br ^bb1
  ^bb3:  // pred: ^bb1
    scf.yield
  }
  scf.yield
 with val:exOp:mlir-asm-printer: Verifying operation: func.func
scf.execute_region {
  %9 = memref.load %6[] : memref<i1>
  scf.if %9 {
    %20 = memref.get_global @kbm3 : memref<1xi32>
    %21 = memref.load %20[%c0] : memref<1xi32>
    memref.store %21, %3[] : memref<i32>
  }
  %10 = memref.alloca() : memref<i1>
  %11 = memref.alloca() : memref<i1>
  memref.store %true, %11[] : memref<i1>
  cf.br ^bb1
^bb1:  // 2 preds: ^bb0, ^bb2
  %12 = memref.load %3[] : memref<i32>
  %13 = arith.cmpi sgt, %12, %c0_i32 : i32
  %14 = memref.load %11[] : memref<i1>
  %15 = arith.andi %13, %14 : i1
  cf.cond_br %15, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %16 = memref.load %11[] : memref<i1>
  memref.store %16, %10[] : memref<i1>
  %17 = memref.load %10[] : memref<i1>
  scf.if %17 {
    %20 = memref.load %10[] : memref<i1>
    scf.if %20 {
      scf.execute_region {
        %21 = memref.load %10[] : memref<i1>
        scf.if %21 {
          memref.store %c0_i32, %2[] : memref<i32>
        }
        %22 = memref.alloca() : memref<i1>
        %23 = memref.alloca() : memref<i1>
        memref.store %true, %23[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %24 = memref.load %2[] : memref<i32>
        %25 = memref.get_global @jm : memref<1xi32>
        %26 = memref.load %25[%c0] : memref<1xi32>
        %27 = arith.cmpi slt, %24, %26 : i32
        %28 = memref.load %23[] : memref<i1>
        %29 = arith.andi %27, %28 : i1
        cf.cond_br %29, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %30 = memref.load %23[] : memref<i1>
        memref.store %30, %22[] : memref<i1>
        %31 = memref.load %22[] : memref<i1>
        scf.if %31 {
          %34 = memref.load %22[] : memref<i1>
          scf.if %34 {
            scf.execute_region {
              %35 = memref.load %22[] : memref<i1>
              scf.if %35 {
                memref.store %c0_i32, %0[] : memref<i32>
              }
              %36 = memref.alloca() : memref<i1>
              %37 = memref.alloca() : memref<i1>
              memref.store %true, %37[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %38 = memref.load %0[] : memref<i32>
              %39 = memref.get_global @im : memref<1xi32>
              %40 = memref.load %39[%c0] : memref<1xi32>
              %41 = arith.cmpi slt, %38, %40 : i32
              %42 = memref.load %37[] : memref<i1>
              %43 = arith.andi %41, %42 : i1
              cf.cond_br %43, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %44 = memref.load %37[] : memref<i1>
              memref.store %44, %36[] : memref<i1>
              %45 = memref.load %36[] : memref<i1>
              scf.if %45 {
                %48 = memref.load %4[] : memref<memref<?xf32>>
                %49 = memref.load %0[] : memref<i32>
                %50 = memref.load %2[] : memref<i32>
                %51 = memref.load %39[%c0] : memref<1xi32>
                %52 = arith.muli %50, %51 : i32
                %53 = arith.addi %49, %52 : i32
                %54 = memref.load %3[] : memref<i32>
                %55 = arith.muli %54, %51 : i32
                %56 = memref.load %25[%c0] : memref<1xi32>
                %57 = arith.muli %55, %56 : i32
                %58 = arith.addi %53, %57 : i32
                %59 = arith.index_cast %58 : i32 to index
                %60 = memref.load %5[] : memref<memref<?xf32>>
                %61 = arith.subi %54, %c1_i32 : i32
                %62 = arith.muli %61, %51 : i32
                %63 = arith.muli %62, %56 : i32
                %64 = arith.addi %53, %63 : i32
                %65 = arith.index_cast %64 : i32 to index
                %66 = arith.addi %65, %c0 : index
                %67 = memref.load %60[%66] : memref<?xf32>
                %68 = arith.addi %59, %c0 : index
                memref.store %67, %48[%68] : memref<?xf32>
              }
              %46 = memref.load %37[] : memref<i1>
              memref.store %46, %36[] : memref<i1>
              %47 = memref.load %36[] : memref<i1>
              scf.if %47 {
                %48 = memref.load %0[] : memref<i32>
                %49 = arith.addi %48, %c1_i32 : i32
                memref.store %49, %0[] : memref<i32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %32 = memref.load %23[] : memref<i1>
        memref.store %32, %22[] : memref<i1>
        %33 = memref.load %22[] : memref<i1>
        scf.if %33 {
          %34 = memref.load %2[] : memref<i32>
          %35 = arith.addi %34, %c1_i32 : i32
          memref.store %35, %2[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  scf.if %19 {
    %20 = memref.load %3[] : memref<i32>
    %21 = arith.subi %20, %c1_i32 : i32
    memref.store %21, %3[] : memref<i32>
  }
  cf.br ^bb1
^bb3:  // pred: ^bb1
  scf.yield
}
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %8 = memref.load %6[] : memref<i1>
  scf.if %8 {
    scf.execute_region {
      %9 = memref.load %6[] : memref<i1>
      scf.if %9 {
        %20 = memref.get_global @kbm3 : memref<1xi32>
        %21 = memref.load %20[%c0] : memref<1xi32>
        memref.store %21, %3[] : memref<i32>
      }
      %10 = memref.alloca() : memref<i1>
      %11 = memref.alloca() : memref<i1>
      memref.store %true, %11[] : memref<i1>
      cf.br ^bb1
    ^bb1:  // 2 preds: ^bb0, ^bb2
      %12 = memref.load %3[] : memref<i32>
      %13 = arith.cmpi sgt, %12, %c0_i32 : i32
      %14 = memref.load %11[] : memref<i1>
      %15 = arith.andi %13, %14 : i1
      cf.cond_br %15, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %16 = memref.load %11[] : memref<i1>
      memref.store %16, %10[] : memref<i1>
      %17 = memref.load %10[] : memref<i1>
      scf.if %17 {
        %20 = memref.load %10[] : memref<i1>
        scf.if %20 {
          scf.execute_region {
            %21 = memref.load %10[] : memref<i1>
            scf.if %21 {
              memref.store %c0_i32, %2[] : memref<i32>
            }
            %22 = memref.alloca() : memref<i1>
            %23 = memref.alloca() : memref<i1>
            memref.store %true, %23[] : memref<i1>
            cf.br ^bb1
          ^bb1:  // 2 preds: ^bb0, ^bb2
            %24 = memref.load %2[] : memref<i32>
            %25 = memref.get_global @jm : memref<1xi32>
            %26 = memref.load %25[%c0] : memref<1xi32>
            %27 = arith.cmpi slt, %24, %26 : i32
            %28 = memref.load %23[] : memref<i1>
            %29 = arith.andi %27, %28 : i1
            cf.cond_br %29, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %30 = memref.load %23[] : memref<i1>
            memref.store %30, %22[] : memref<i1>
            %31 = memref.load %22[] : memref<i1>
            scf.if %31 {
              %34 = memref.load %22[] : memref<i1>
              scf.if %34 {
                scf.execute_region {
                  %35 = memref.load %22[] : memref<i1>
                  scf.if %35 {
                    memref.store %c0_i32, %0[] : memref<i32>
                  }
                  %36 = memref.alloca() : memref<i1>
                  %37 = memref.alloca() : memref<i1>
                  memref.store %true, %37[] : memref<i1>
                  cf.br ^bb1
                ^bb1:  // 2 preds: ^bb0, ^bb2
                  %38 = memref.load %0[] : memref<i32>
                  %39 = memref.get_global @im : memref<1xi32>
                  %40 = memref.load %39[%c0] : memref<1xi32>
                  %41 = arith.cmpi slt, %38, %40 : i32
                  %42 = memref.load %37[] : memref<i1>
                  %43 = arith.andi %41, %42 : i1
                  cf.cond_br %43, ^bb2, ^bb3
                ^bb2:  // pred: ^bb1
                  %44 = memref.load %37[] : memref<i1>
                  memref.store %44, %36[] : memref<i1>
                  %45 = memref.load %36[] : memref<i1>
                  scf.if %45 {
                    %48 = memref.load %4[] : memref<memref<?xf32>>
                    %49 = memref.load %0[] : memref<i32>
                    %50 = memref.load %2[] : memref<i32>
                    %51 = memref.load %39[%c0] : memref<1xi32>
                    %52 = arith.muli %50, %51 : i32
                    %53 = arith.addi %49, %52 : i32
                    %54 = memref.load %3[] : memref<i32>
                    %55 = arith.muli %54, %51 : i32
                    %56 = memref.load %25[%c0] : memref<1xi32>
                    %57 = arith.muli %55, %56 : i32
                    %58 = arith.addi %53, %57 : i32
                    %59 = arith.index_cast %58 : i32 to index
                    %60 = memref.load %5[] : memref<memref<?xf32>>
                    %61 = arith.subi %54, %c1_i32 : i32
                    %62 = arith.muli %61, %51 : i32
                    %63 = arith.muli %62, %56 : i32
                    %64 = arith.addi %53, %63 : i32
                    %65 = arith.index_cast %64 : i32 to index
                    %66 = arith.addi %65, %c0 : index
                    %67 = memref.load %60[%66] : memref<?xf32>
                    %68 = arith.addi %59, %c0 : index
                    memref.store %67, %48[%68] : memref<?xf32>
                  }
                  %46 = memref.load %37[] : memref<i1>
                  memref.store %46, %36[] : memref<i1>
                  %47 = memref.load %36[] : memref<i1>
                  scf.if %47 {
                    %48 = memref.load %0[] : memref<i32>
                    %49 = arith.addi %48, %c1_i32 : i32
                    memref.store %49, %0[] : memref<i32>
                  }
                  cf.br ^bb1
                ^bb3:  // pred: ^bb1
                  scf.yield
                }
              }
            }
            %32 = memref.load %23[] : memref<i1>
            memref.store %32, %22[] : memref<i1>
            %33 = memref.load %22[] : memref<i1>
            scf.if %33 {
              %34 = memref.load %2[] : memref<i32>
              %35 = arith.addi %34, %c1_i32 : i32
              memref.store %35, %2[] : memref<i32>
            }
            cf.br ^bb1
          ^bb3:  // pred: ^bb1
            scf.yield
          }
        }
      }
      %18 = memref.load %11[] : memref<i1>
      memref.store %18, %10[] : memref<i1>
      %19 = memref.load %10[] : memref<i1>
      scf.if %19 {
        %20 = memref.load %3[] : memref<i32>
        %21 = arith.subi %20, %c1_i32 : i32
        memref.store %21, %3[] : memref<i32>
      }
      cf.br ^bb1
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
  scf.yield
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %8 {
  scf.execute_region {
    %9 = memref.load %6[] : memref<i1>
    scf.if %9 {
      %20 = memref.get_global @kbm3 : memref<1xi32>
      %21 = memref.load %20[%c0] : memref<1xi32>
      memref.store %21, %3[] : memref<i32>
    }
    %10 = memref.alloca() : memref<i1>
    %11 = memref.alloca() : memref<i1>
    memref.store %true, %11[] : memref<i1>
    cf.br ^bb1
  ^bb1:  // 2 preds: ^bb0, ^bb2
    %12 = memref.load %3[] : memref<i32>
    %13 = arith.cmpi sgt, %12, %c0_i32 : i32
    %14 = memref.load %11[] : memref<i1>
    %15 = arith.andi %13, %14 : i1
    cf.cond_br %15, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %16 = memref.load %11[] : memref<i1>
    memref.store %16, %10[] : memref<i1>
    %17 = memref.load %10[] : memref<i1>
    scf.if %17 {
      %20 = memref.load %10[] : memref<i1>
      scf.if %20 {
        scf.execute_region {
          %21 = memref.load %10[] : memref<i1>
          scf.if %21 {
            memref.store %c0_i32, %2[] : memref<i32>
          }
          %22 = memref.alloca() : memref<i1>
          %23 = memref.alloca() : memref<i1>
          memref.store %true, %23[] : memref<i1>
          cf.br ^bb1
        ^bb1:  // 2 preds: ^bb0, ^bb2
          %24 = memref.load %2[] : memref<i32>
          %25 = memref.get_global @jm : memref<1xi32>
          %26 = memref.load %25[%c0] : memref<1xi32>
          %27 = arith.cmpi slt, %24, %26 : i32
          %28 = memref.load %23[] : memref<i1>
          %29 = arith.andi %27, %28 : i1
          cf.cond_br %29, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %30 = memref.load %23[] : memref<i1>
          memref.store %30, %22[] : memref<i1>
          %31 = memref.load %22[] : memref<i1>
          scf.if %31 {
            %34 = memref.load %22[] : memref<i1>
            scf.if %34 {
              scf.execute_region {
                %35 = memref.load %22[] : memref<i1>
                scf.if %35 {
                  memref.store %c0_i32, %0[] : memref<i32>
                }
                %36 = memref.alloca() : memref<i1>
                %37 = memref.alloca() : memref<i1>
                memref.store %true, %37[] : memref<i1>
                cf.br ^bb1
              ^bb1:  // 2 preds: ^bb0, ^bb2
                %38 = memref.load %0[] : memref<i32>
                %39 = memref.get_global @im : memref<1xi32>
                %40 = memref.load %39[%c0] : memref<1xi32>
                %41 = arith.cmpi slt, %38, %40 : i32
                %42 = memref.load %37[] : memref<i1>
                %43 = arith.andi %41, %42 : i1
                cf.cond_br %43, ^bb2, ^bb3
              ^bb2:  // pred: ^bb1
                %44 = memref.load %37[] : memref<i1>
                memref.store %44, %36[] : memref<i1>
                %45 = memref.load %36[] : memref<i1>
                scf.if %45 {
                  %48 = memref.load %4[] : memref<memref<?xf32>>
                  %49 = memref.load %0[] : memref<i32>
                  %50 = memref.load %2[] : memref<i32>
                  %51 = memref.load %39[%c0] : memref<1xi32>
                  %52 = arith.muli %50, %51 : i32
                  %53 = arith.addi %49, %52 : i32
                  %54 = memref.load %3[] : memref<i32>
                  %55 = arith.muli %54, %51 : i32
                  %56 = memref.load %25[%c0] : memref<1xi32>
                  %57 = arith.muli %55, %56 : i32
                  %58 = arith.addi %53, %57 : i32
                  %59 = arith.index_cast %58 : i32 to index
                  %60 = memref.load %5[] : memref<memref<?xf32>>
                  %61 = arith.subi %54, %c1_i32 : i32
                  %62 = arith.muli %61, %51 : i32
                  %63 = arith.muli %62, %56 : i32
                  %64 = arith.addi %53, %63 : i32
                  %65 = arith.index_cast %64 : i32 to index
                  %66 = arith.addi %65, %c0 : index
                  %67 = memref.load %60[%66] : memref<?xf32>
                  %68 = arith.addi %59, %c0 : index
                  memref.store %67, %48[%68] : memref<?xf32>
                }
                %46 = memref.load %37[] : memref<i1>
                memref.store %46, %36[] : memref<i1>
                %47 = memref.load %36[] : memref<i1>
                scf.if %47 {
                  %48 = memref.load %0[] : memref<i32>
                  %49 = arith.addi %48, %c1_i32 : i32
                  memref.store %49, %0[] : memref<i32>
                }
                cf.br ^bb1
              ^bb3:  // pred: ^bb1
                scf.yield
              }
            }
          }
          %32 = memref.load %23[] : memref<i1>
          memref.store %32, %22[] : memref<i1>
          %33 = memref.load %22[] : memref<i1>
          scf.if %33 {
            %34 = memref.load %2[] : memref<i32>
            %35 = arith.addi %34, %c1_i32 : i32
            memref.store %35, %2[] : memref<i32>
          }
          cf.br ^bb1
        ^bb3:  // pred: ^bb1
          scf.yield
        }
      }
    }
    %18 = memref.load %11[] : memref<i1>
    memref.store %18, %10[] : memref<i1>
    %19 = memref.load %10[] : memref<i1>
    scf.if %19 {
      %20 = memref.load %3[] : memref<i32>
      %21 = arith.subi %20, %c1_i32 : i32
      memref.store %21, %3[] : memref<i32>
    }
    cf.br ^bb1
  ^bb3:  // pred: ^bb1
    scf.yield
  }
}
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32):
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %7 {
    %8 = memref.load %6[] : memref<i1>
    scf.if %8 {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        scf.if %9 {
          %20 = memref.get_global @kbm3 : memref<1xi32>
          %21 = memref.load %20[%c0] : memref<1xi32>
          memref.store %21, %3[] : memref<i32>
        }
        %10 = memref.alloca() : memref<i1>
        %11 = memref.alloca() : memref<i1>
        memref.store %true, %11[] : memref<i1>
        cf.br ^bb1
      ^bb1:  // 2 preds: ^bb0, ^bb2
        %12 = memref.load %3[] : memref<i32>
        %13 = arith.cmpi sgt, %12, %c0_i32 : i32
        %14 = memref.load %11[] : memref<i1>
        %15 = arith.andi %13, %14 : i1
        cf.cond_br %15, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %16 = memref.load %11[] : memref<i1>
        memref.store %16, %10[] : memref<i1>
        %17 = memref.load %10[] : memref<i1>
        scf.if %17 {
          %20 = memref.load %10[] : memref<i1>
          scf.if %20 {
            scf.execute_region {
              %21 = memref.load %10[] : memref<i1>
              scf.if %21 {
                memref.store %c0_i32, %2[] : memref<i32>
              }
              %22 = memref.alloca() : memref<i1>
              %23 = memref.alloca() : memref<i1>
              memref.store %true, %23[] : memref<i1>
              cf.br ^bb1
            ^bb1:  // 2 preds: ^bb0, ^bb2
              %24 = memref.load %2[] : memref<i32>
              %25 = memref.get_global @jm : memref<1xi32>
              %26 = memref.load %25[%c0] : memref<1xi32>
              %27 = arith.cmpi slt, %24, %26 : i32
              %28 = memref.load %23[] : memref<i1>
              %29 = arith.andi %27, %28 : i1
              cf.cond_br %29, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %30 = memref.load %23[] : memref<i1>
              memref.store %30, %22[] : memref<i1>
              %31 = memref.load %22[] : memref<i1>
              scf.if %31 {
                %34 = memref.load %22[] : memref<i1>
                scf.if %34 {
                  scf.execute_region {
                    %35 = memref.load %22[] : memref<i1>
                    scf.if %35 {
                      memref.store %c0_i32, %0[] : memref<i32>
                    }
                    %36 = memref.alloca() : memref<i1>
                    %37 = memref.alloca() : memref<i1>
                    memref.store %true, %37[] : memref<i1>
                    cf.br ^bb1
                  ^bb1:  // 2 preds: ^bb0, ^bb2
                    %38 = memref.load %0[] : memref<i32>
                    %39 = memref.get_global @im : memref<1xi32>
                    %40 = memref.load %39[%c0] : memref<1xi32>
                    %41 = arith.cmpi slt, %38, %40 : i32
                    %42 = memref.load %37[] : memref<i1>
                    %43 = arith.andi %41, %42 : i1
                    cf.cond_br %43, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %44 = memref.load %37[] : memref<i1>
                    memref.store %44, %36[] : memref<i1>
                    %45 = memref.load %36[] : memref<i1>
                    scf.if %45 {
                      %48 = memref.load %4[] : memref<memref<?xf32>>
                      %49 = memref.load %0[] : memref<i32>
                      %50 = memref.load %2[] : memref<i32>
                      %51 = memref.load %39[%c0] : memref<1xi32>
                      %52 = arith.muli %50, %51 : i32
                      %53 = arith.addi %49, %52 : i32
                      %54 = memref.load %3[] : memref<i32>
                      %55 = arith.muli %54, %51 : i32
                      %56 = memref.load %25[%c0] : memref<1xi32>
                      %57 = arith.muli %55, %56 : i32
                      %58 = arith.addi %53, %57 : i32
                      %59 = arith.index_cast %58 : i32 to index
                      %60 = memref.load %5[] : memref<memref<?xf32>>
                      %61 = arith.subi %54, %c1_i32 : i32
                      %62 = arith.muli %61, %51 : i32
                      %63 = arith.muli %62, %56 : i32
                      %64 = arith.addi %53, %63 : i32
                      %65 = arith.index_cast %64 : i32 to index
                      %66 = arith.addi %65, %c0 : index
                      %67 = memref.load %60[%66] : memref<?xf32>
                      %68 = arith.addi %59, %c0 : index
                      memref.store %67, %48[%68] : memref<?xf32>
                    }
                    %46 = memref.load %37[] : memref<i1>
                    memref.store %46, %36[] : memref<i1>
                    %47 = memref.load %36[] : memref<i1>
                    scf.if %47 {
                      %48 = memref.load %0[] : memref<i32>
                      %49 = arith.addi %48, %c1_i32 : i32
                      memref.store %49, %0[] : memref<i32>
                    }
                    cf.br ^bb1
                  ^bb3:  // pred: ^bb1
                    scf.yield
                  }
                }
              }
              %32 = memref.load %23[] : memref<i1>
              memref.store %32, %22[] : memref<i1>
              %33 = memref.load %22[] : memref<i1>
              scf.if %33 {
                %34 = memref.load %2[] : memref<i32>
                %35 = arith.addi %34, %c1_i32 : i32
                memref.store %35, %2[] : memref<i32>
              }
              cf.br ^bb1
            ^bb3:  // pred: ^bb1
              scf.yield
            }
          }
        }
        %18 = memref.load %11[] : memref<i1>
        memref.store %18, %10[] : memref<i1>
        %19 = memref.load %10[] : memref<i1>
        scf.if %19 {
          %20 = memref.load %3[] : memref<i32>
          %21 = arith.subi %20, %c1_i32 : i32
          memref.store %21, %3[] : memref<i32>
        }
        cf.br ^bb1
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  func.return
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %7 {
  %8 = memref.load %6[] : memref<i1>
  scf.if %8 {
    scf.execute_region {
      %9 = memref.load %6[] : memref<i1>
      scf.if %9 {
        %20 = memref.get_global @kbm3 : memref<1xi32>
        %21 = memref.load %20[%c0] : memref<1xi32>
        memref.store %21, %3[] : memref<i32>
      }
      %10 = memref.alloca() : memref<i1>
      %11 = memref.alloca() : memref<i1>
      memref.store %true, %11[] : memref<i1>
      cf.br ^bb1
    ^bb1:  // 2 preds: ^bb0, ^bb2
      %12 = memref.load %3[] : memref<i32>
      %13 = arith.cmpi sgt, %12, %c0_i32 : i32
      %14 = memref.load %11[] : memref<i1>
      %15 = arith.andi %13, %14 : i1
      cf.cond_br %15, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %16 = memref.load %11[] : memref<i1>
      memref.store %16, %10[] : memref<i1>
      %17 = memref.load %10[] : memref<i1>
      scf.if %17 {
        %20 = memref.load %10[] : memref<i1>
        scf.if %20 {
          scf.execute_region {
            %21 = memref.load %10[] : memref<i1>
            scf.if %21 {
              memref.store %c0_i32, %2[] : memref<i32>
            }
            %22 = memref.alloca() : memref<i1>
            %23 = memref.alloca() : memref<i1>
            memref.store %true, %23[] : memref<i1>
            cf.br ^bb1
          ^bb1:  // 2 preds: ^bb0, ^bb2
            %24 = memref.load %2[] : memref<i32>
            %25 = memref.get_global @jm : memref<1xi32>
            %26 = memref.load %25[%c0] : memref<1xi32>
            %27 = arith.cmpi slt, %24, %26 : i32
            %28 = memref.load %23[] : memref<i1>
            %29 = arith.andi %27, %28 : i1
            cf.cond_br %29, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %30 = memref.load %23[] : memref<i1>
            memref.store %30, %22[] : memref<i1>
            %31 = memref.load %22[] : memref<i1>
            scf.if %31 {
              %34 = memref.load %22[] : memref<i1>
              scf.if %34 {
                scf.execute_region {
                  %35 = memref.load %22[] : memref<i1>
                  scf.if %35 {
                    memref.store %c0_i32, %0[] : memref<i32>
                  }
                  %36 = memref.alloca() : memref<i1>
                  %37 = memref.alloca() : memref<i1>
                  memref.store %true, %37[] : memref<i1>
                  cf.br ^bb1
                ^bb1:  // 2 preds: ^bb0, ^bb2
                  %38 = memref.load %0[] : memref<i32>
                  %39 = memref.get_global @im : memref<1xi32>
                  %40 = memref.load %39[%c0] : memref<1xi32>
                  %41 = arith.cmpi slt, %38, %40 : i32
                  %42 = memref.load %37[] : memref<i1>
                  %43 = arith.andi %41, %42 : i1
                  cf.cond_br %43, ^bb2, ^bb3
                ^bb2:  // pred: ^bb1
                  %44 = memref.load %37[] : memref<i1>
                  memref.store %44, %36[] : memref<i1>
                  %45 = memref.load %36[] : memref<i1>
                  scf.if %45 {
                    %48 = memref.load %4[] : memref<memref<?xf32>>
                    %49 = memref.load %0[] : memref<i32>
                    %50 = memref.load %2[] : memref<i32>
                    %51 = memref.load %39[%c0] : memref<1xi32>
                    %52 = arith.muli %50, %51 : i32
                    %53 = arith.addi %49, %52 : i32
                    %54 = memref.load %3[] : memref<i32>
                    %55 = arith.muli %54, %51 : i32
                    %56 = memref.load %25[%c0] : memref<1xi32>
                    %57 = arith.muli %55, %56 : i32
                    %58 = arith.addi %53, %57 : i32
                    %59 = arith.index_cast %58 : i32 to index
                    %60 = memref.load %5[] : memref<memref<?xf32>>
                    %61 = arith.subi %54, %c1_i32 : i32
                    %62 = arith.muli %61, %51 : i32
                    %63 = arith.muli %62, %56 : i32
                    %64 = arith.addi %53, %63 : i32
                    %65 = arith.index_cast %64 : i32 to index
                    %66 = arith.addi %65, %c0 : index
                    %67 = memref.load %60[%66] : memref<?xf32>
                    %68 = arith.addi %59, %c0 : index
                    memref.store %67, %48[%68] : memref<?xf32>
                  }
                  %46 = memref.load %37[] : memref<i1>
                  memref.store %46, %36[] : memref<i1>
                  %47 = memref.load %36[] : memref<i1>
                  scf.if %47 {
                    %48 = memref.load %0[] : memref<i32>
                    %49 = arith.addi %48, %c1_i32 : i32
                    memref.store %49, %0[] : memref<i32>
                  }
                  cf.br ^bb1
                ^bb3:  // pred: ^bb1
                  scf.yield
                }
              }
            }
            %32 = memref.load %23[] : memref<i1>
            memref.store %32, %22[] : memref<i1>
            %33 = memref.load %22[] : memref<i1>
            scf.if %33 {
              %34 = memref.load %2[] : memref<i32>
              %35 = arith.addi %34, %c1_i32 : i32
              memref.store %35, %2[] : memref<i32>
            }
            cf.br ^bb1
          ^bb3:  // pred: ^bb1
            scf.yield
          }
        }
      }
      %18 = memref.load %11[] : memref<i1>
      memref.store %18, %10[] : memref<i1>
      %19 = memref.load %10[] : memref<i1>
      scf.if %19 {
        %20 = memref.load %3[] : memref<i32>
        %21 = arith.subi %20, %c1_i32 : i32
        memref.store %21, %3[] : memref<i32>
      }
      cf.br ^bb1
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
}
 replaced mlir-asm-printer: Verifying operation: builtin.module
branch has 0 operands for successor #0, but target block has 1
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%48 = "memref.load"(%4) : (memref<i32>) -> i32 with <block argument> of type 'i32' at index: 0
 replaced mlir-asm-printer: Verifying operation: builtin.module
branch has 0 operands for successor #0, but target block has 1
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%61 = "memref.load"(%4) : (memref<i32>) -> i32 with <block argument> of type 'i32' at index: 0
 replaced mlir-asm-printer: Verifying operation: builtin.module
branch has 0 operands for successor #0, but target block has 1
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%60 = "memref.load"(%4) : (memref<i32>) -> i32 with <block argument> of type 'i32' at index: 0
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%2 = memref.alloca() : memref<i32>
 + forwarding vec to promote {} of mlir-asm-printer: Verifying operation: builtin.module
%2 = memref.alloca() : memref<i32>
Begin forwarding store of mlir-asm-printer: Verifying operation: builtin.module
%2 = memref.alloca() : memref<i32> to load
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %7 {
    %8 = memref.load %6[] : memref<i1>
    scf.if %8 {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        scf.if %9 {
          %22 = memref.get_global @kbm3 : memref<1xi32>
          %23 = memref.load %22[%c0] : memref<1xi32>
          memref.store %23, %3[] : memref<i32>
        }
        %10 = memref.alloca() : memref<i1>
        %11 = memref.alloca() : memref<i1>
        memref.store %true, %11[] : memref<i1>
        cf.br ^bb1(%1 : i32)
      ^bb1(%12: i32):  // 2 preds: ^bb0, ^bb2
        %13 = memref.load %3[] : memref<i32>
        %14 = arith.cmpi sgt, %13, %c0_i32 : i32
        %15 = memref.load %11[] : memref<i1>
        %16 = arith.andi %14, %15 : i1
        cf.cond_br %16, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %17 = memref.load %11[] : memref<i1>
        memref.store %17, %10[] : memref<i1>
        %18 = memref.load %10[] : memref<i1>
        %19 = scf.if %18 -> (i32) {
          %22 = memref.load %10[] : memref<i1>
          %23 = scf.if %22 -> (i32) {
            %24 = scf.execute_region -> i32 {
              %25 = memref.load %10[] : memref<i1>
              scf.if %25 {
                memref.store %c0_i32, %2[] : memref<i32>
              }
              %26 = memref.alloca() : memref<i1>
              %27 = memref.alloca() : memref<i1>
              memref.store %true, %27[] : memref<i1>
              cf.br ^bb1(%12 : i32)
            ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
              %29 = memref.load %2[] : memref<i32>
              %30 = memref.get_global @jm : memref<1xi32>
              %31 = memref.load %30[%c0] : memref<1xi32>
              %32 = arith.cmpi slt, %29, %31 : i32
              %33 = memref.load %27[] : memref<i1>
              %34 = arith.andi %32, %33 : i1
              cf.cond_br %34, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %35 = memref.load %27[] : memref<i1>
              memref.store %35, %26[] : memref<i1>
              %36 = memref.load %26[] : memref<i1>
              %37 = scf.if %36 -> (i32) {
                %40 = memref.load %26[] : memref<i1>
                %41 = scf.if %40 -> (i32) {
                  %42 = scf.execute_region -> i32 {
                    %43 = memref.load %26[] : memref<i1>
                    %44 = scf.if %43 -> (i32) {
                      memref.store %c0_i32, %0[] : memref<i32>
                      scf.yield %c0_i32 : i32
                    } else {
                      scf.yield %28 : i32
                    }
                    %45 = memref.alloca() : memref<i1>
                    %46 = memref.alloca() : memref<i1>
                    memref.store %true, %46[] : memref<i1>
                    cf.br ^bb1(%44 : i32)
                  ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
                    %48 = memref.load %0[] : memref<i32>
                    %49 = memref.get_global @im : memref<1xi32>
                    %50 = memref.load %49[%c0] : memref<1xi32>
                    %51 = arith.cmpi slt, %47, %50 : i32
                    %52 = memref.load %46[] : memref<i1>
                    %53 = arith.andi %51, %52 : i1
                    cf.cond_br %53, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %54 = memref.load %46[] : memref<i1>
                    memref.store %54, %45[] : memref<i1>
                    %55 = memref.load %45[] : memref<i1>
                    scf.if %55 {
                      %59 = memref.load %4[] : memref<memref<?xf32>>
                      %60 = memref.load %0[] : memref<i32>
                      %61 = memref.load %2[] : memref<i32>
                      %62 = memref.load %49[%c0] : memref<1xi32>
                      %63 = arith.muli %61, %62 : i32
                      %64 = arith.addi %47, %63 : i32
                      %65 = memref.load %3[] : memref<i32>
                      %66 = arith.muli %65, %62 : i32
                      %67 = memref.load %30[%c0] : memref<1xi32>
                      %68 = arith.muli %66, %67 : i32
                      %69 = arith.addi %64, %68 : i32
                      %70 = arith.index_cast %69 : i32 to index
                      %71 = memref.load %5[] : memref<memref<?xf32>>
                      %72 = arith.subi %65, %c1_i32 : i32
                      %73 = arith.muli %72, %62 : i32
                      %74 = arith.muli %73, %67 : i32
                      %75 = arith.addi %64, %74 : i32
                      %76 = arith.index_cast %75 : i32 to index
                      %77 = arith.addi %76, %c0 : index
                      %78 = memref.load %71[%77] : memref<?xf32>
                      %79 = arith.addi %70, %c0 : index
                      memref.store %78, %59[%79] : memref<?xf32>
                    }
                    %56 = memref.load %46[] : memref<i1>
                    memref.store %56, %45[] : memref<i1>
                    %57 = memref.load %45[] : memref<i1>
                    %58 = scf.if %57 -> (i32) {
                      %59 = memref.load %0[] : memref<i32>
                      %60 = arith.addi %47, %c1_i32 : i32
                      memref.store %60, %0[] : memref<i32>
                      scf.yield %60 : i32
                    } else {
                      scf.yield %47 : i32
                    }
                    cf.br ^bb1(%58 : i32)
                  ^bb3:  // pred: ^bb1
                    scf.yield %47 : i32
                  }
                  scf.yield %42 : i32
                } else {
                  scf.yield %28 : i32
                }
                scf.yield %41 : i32
              } else {
                scf.yield %28 : i32
              }
              %38 = memref.load %27[] : memref<i1>
              memref.store %38, %26[] : memref<i1>
              %39 = memref.load %26[] : memref<i1>
              scf.if %39 {
                %40 = memref.load %2[] : memref<i32>
                %41 = arith.addi %40, %c1_i32 : i32
                memref.store %41, %2[] : memref<i32>
              }
              cf.br ^bb1(%37 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %28 : i32
            }
            scf.yield %24 : i32
          } else {
            scf.yield %12 : i32
          }
          scf.yield %23 : i32
        } else {
          scf.yield %12 : i32
        }
        %20 = memref.load %11[] : memref<i1>
        memref.store %20, %10[] : memref<i1>
        %21 = memref.load %10[] : memref<i1>
        scf.if %21 {
          %22 = memref.load %3[] : memref<i32>
          %23 = arith.subi %22, %c1_i32 : i32
          memref.store %23, %3[] : memref<i32>
        }
        cf.br ^bb1(%19 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}
Matching Store: mlir-asm-printer: Verifying operation: func.func
memref.store %41, %2[] : memref<i32>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%40 = memref.load %2[] : memref<i32>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%61 = memref.load %2[] : memref<i32>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%29 = memref.load %2[] : memref<i32>
Matching Store: mlir-asm-printer: Verifying operation: func.func
memref.store %c0_i32, %2[] : memref<i32>
Matching Store: mlir-asm-printer: Verifying operation: func.func
memref.store %1, %2[] : memref<i32>
 storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %41, %2[] : memref<i32>
 storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %1, %2[] : memref<i32>
 storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %c0_i32, %2[] : memref<i32>
 initial storing block: 0x7fbd9800a040
 derived storing block: 0x7fbd98169610
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd98168e20
 derived storing block: 0x7fbd98168c20
 initial storing block: 0x7fbd98169610
 derived storing block: 0x7fbd98168a80
 initial storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd98168c20
 derived storing block: 0x7fbd98168a80
 initial storing block: 0x7fbd98168a80
 derived storing block: 0x7fbd981687d0
 initial storing block: 0x7fbd98168a80
 derived storing block: 0x7fbd981687d0
 initial storing block: 0x7fbd981687d0
 derived storing block: 0x7fbd98167b50
 initial storing block: 0x7fbd981687d0
 derived storing block: 0x7fbd98167b50
 initial storing block: 0x7fbd98167b50
 derived storing block: 0x7fbd981669f0
 initial storing block: 0x7fbd98167b50
 derived storing block: 0x7fbd981669f0
 initial storing block: 0x7fbd981669f0
 derived storing block: 0x7fbd98166740
 initial storing block: 0x7fbd981669f0
 derived storing block: 0x7fbd98166740
 initial storing block: 0x7fbd98166740
 derived storing block: 0x7fbd98164100
 initial storing block: 0x7fbd98166740
 derived storing block: 0x7fbd98164100
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32):
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %7 {
    %8 = memref.load %6[] : memref<i1>
    scf.if %8 {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        scf.if %9 {
          %22 = memref.get_global @kbm3 : memref<1xi32>
          %23 = memref.load %22[%c0] : memref<1xi32>
          memref.store %23, %3[] : memref<i32>
        }
        %10 = memref.alloca() : memref<i1>
        %11 = memref.alloca() : memref<i1>
        memref.store %true, %11[] : memref<i1>
        cf.br ^bb1(%1 : i32)
      ^bb1(%12: i32):  // 2 preds: ^bb0, ^bb2
        %13 = memref.load %3[] : memref<i32>
        %14 = arith.cmpi sgt, %13, %c0_i32 : i32
        %15 = memref.load %11[] : memref<i1>
        %16 = arith.andi %14, %15 : i1
        cf.cond_br %16, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %17 = memref.load %11[] : memref<i1>
        memref.store %17, %10[] : memref<i1>
        %18 = memref.load %10[] : memref<i1>
        %19 = scf.if %18 -> (i32) {
          %22 = memref.load %10[] : memref<i1>
          %23 = scf.if %22 -> (i32) {
            %24 = scf.execute_region -> i32 {
              %25 = memref.load %10[] : memref<i1>
              scf.if %25 {
                memref.store %c0_i32, %2[] : memref<i32>
              }
              %26 = memref.alloca() : memref<i1>
              %27 = memref.alloca() : memref<i1>
              memref.store %true, %27[] : memref<i1>
              cf.br ^bb1(%12 : i32)
            ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
              %29 = memref.load %2[] : memref<i32>
              %30 = memref.get_global @jm : memref<1xi32>
              %31 = memref.load %30[%c0] : memref<1xi32>
              %32 = arith.cmpi slt, %29, %31 : i32
              %33 = memref.load %27[] : memref<i1>
              %34 = arith.andi %32, %33 : i1
              cf.cond_br %34, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %35 = memref.load %27[] : memref<i1>
              memref.store %35, %26[] : memref<i1>
              %36 = memref.load %26[] : memref<i1>
              %37 = scf.if %36 -> (i32) {
                %40 = memref.load %26[] : memref<i1>
                %41 = scf.if %40 -> (i32) {
                  %42 = scf.execute_region -> i32 {
                    %43 = memref.load %26[] : memref<i1>
                    %44 = scf.if %43 -> (i32) {
                      memref.store %c0_i32, %0[] : memref<i32>
                      scf.yield %c0_i32 : i32
                    } else {
                      scf.yield %28 : i32
                    }
                    %45 = memref.alloca() : memref<i1>
                    %46 = memref.alloca() : memref<i1>
                    memref.store %true, %46[] : memref<i1>
                    cf.br ^bb1(%44 : i32)
                  ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
                    %48 = memref.load %0[] : memref<i32>
                    %49 = memref.get_global @im : memref<1xi32>
                    %50 = memref.load %49[%c0] : memref<1xi32>
                    %51 = arith.cmpi slt, %47, %50 : i32
                    %52 = memref.load %46[] : memref<i1>
                    %53 = arith.andi %51, %52 : i1
                    cf.cond_br %53, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %54 = memref.load %46[] : memref<i1>
                    memref.store %54, %45[] : memref<i1>
                    %55 = memref.load %45[] : memref<i1>
                    scf.if %55 {
                      %59 = memref.load %4[] : memref<memref<?xf32>>
                      %60 = memref.load %0[] : memref<i32>
                      %61 = memref.load %2[] : memref<i32>
                      %62 = memref.load %49[%c0] : memref<1xi32>
                      %63 = arith.muli %61, %62 : i32
                      %64 = arith.addi %47, %63 : i32
                      %65 = memref.load %3[] : memref<i32>
                      %66 = arith.muli %65, %62 : i32
                      %67 = memref.load %30[%c0] : memref<1xi32>
                      %68 = arith.muli %66, %67 : i32
                      %69 = arith.addi %64, %68 : i32
                      %70 = arith.index_cast %69 : i32 to index
                      %71 = memref.load %5[] : memref<memref<?xf32>>
                      %72 = arith.subi %65, %c1_i32 : i32
                      %73 = arith.muli %72, %62 : i32
                      %74 = arith.muli %73, %67 : i32
                      %75 = arith.addi %64, %74 : i32
                      %76 = arith.index_cast %75 : i32 to index
                      %77 = arith.addi %76, %c0 : index
                      %78 = memref.load %71[%77] : memref<?xf32>
                      %79 = arith.addi %70, %c0 : index
                      memref.store %78, %59[%79] : memref<?xf32>
                    }
                    %56 = memref.load %46[] : memref<i1>
                    memref.store %56, %45[] : memref<i1>
                    %57 = memref.load %45[] : memref<i1>
                    %58 = scf.if %57 -> (i32) {
                      %59 = memref.load %0[] : memref<i32>
                      %60 = arith.addi %47, %c1_i32 : i32
                      memref.store %60, %0[] : memref<i32>
                      scf.yield %60 : i32
                    } else {
                      scf.yield %47 : i32
                    }
                    cf.br ^bb1(%58 : i32)
                  ^bb3:  // pred: ^bb1
                    scf.yield %47 : i32
                  }
                  scf.yield %42 : i32
                } else {
                  scf.yield %28 : i32
                }
                scf.yield %41 : i32
              } else {
                scf.yield %28 : i32
              }
              %38 = memref.load %27[] : memref<i1>
              memref.store %38, %26[] : memref<i1>
              %39 = memref.load %26[] : memref<i1>
              scf.if %39 {
                %40 = memref.load %2[] : memref<i32>
                %41 = arith.addi %40, %c1_i32 : i32
                memref.store %41, %2[] : memref<i32>
              }
              cf.br ^bb1(%37 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %28 : i32
            }
            scf.yield %24 : i32
          } else {
            scf.yield %12 : i32
          }
          scf.yield %23 : i32
        } else {
          scf.yield %12 : i32
        }
        %20 = memref.load %11[] : memref<i1>
        memref.store %20, %10[] : memref<i1>
        %21 = memref.load %10[] : memref<i1>
        scf.if %21 {
          %22 = memref.load %3[] : memref<i32>
          %23 = arith.subi %22, %c1_i32 : i32
          memref.store %23, %3[] : memref<i32>
        }
        cf.br ^bb1(%19 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  func.return


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%1 = llvm.mlir.undef : i32
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %8 = memref.load %6[] : memref<i1>
  scf.if %8 {
    scf.execute_region {
      %9 = memref.load %6[] : memref<i1>
      scf.if %9 {
        %22 = memref.get_global @kbm3 : memref<1xi32>
        %23 = memref.load %22[%c0] : memref<1xi32>
        memref.store %23, %3[] : memref<i32>
      }
      %10 = memref.alloca() : memref<i1>
      %11 = memref.alloca() : memref<i1>
      memref.store %true, %11[] : memref<i1>
      cf.br ^bb1(%1 : i32)
    ^bb1(%12: i32):  // 2 preds: ^bb0, ^bb2
      %13 = memref.load %3[] : memref<i32>
      %14 = arith.cmpi sgt, %13, %c0_i32 : i32
      %15 = memref.load %11[] : memref<i1>
      %16 = arith.andi %14, %15 : i1
      cf.cond_br %16, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %17 = memref.load %11[] : memref<i1>
      memref.store %17, %10[] : memref<i1>
      %18 = memref.load %10[] : memref<i1>
      %19 = scf.if %18 -> (i32) {
        %22 = memref.load %10[] : memref<i1>
        %23 = scf.if %22 -> (i32) {
          %24 = scf.execute_region -> i32 {
            %25 = memref.load %10[] : memref<i1>
            scf.if %25 {
              memref.store %c0_i32, %2[] : memref<i32>
            }
            %26 = memref.alloca() : memref<i1>
            %27 = memref.alloca() : memref<i1>
            memref.store %true, %27[] : memref<i1>
            cf.br ^bb1(%12 : i32)
          ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
            %29 = memref.load %2[] : memref<i32>
            %30 = memref.get_global @jm : memref<1xi32>
            %31 = memref.load %30[%c0] : memref<1xi32>
            %32 = arith.cmpi slt, %29, %31 : i32
            %33 = memref.load %27[] : memref<i1>
            %34 = arith.andi %32, %33 : i1
            cf.cond_br %34, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %35 = memref.load %27[] : memref<i1>
            memref.store %35, %26[] : memref<i1>
            %36 = memref.load %26[] : memref<i1>
            %37 = scf.if %36 -> (i32) {
              %40 = memref.load %26[] : memref<i1>
              %41 = scf.if %40 -> (i32) {
                %42 = scf.execute_region -> i32 {
                  %43 = memref.load %26[] : memref<i1>
                  %44 = scf.if %43 -> (i32) {
                    memref.store %c0_i32, %0[] : memref<i32>
                    scf.yield %c0_i32 : i32
                  } else {
                    scf.yield %28 : i32
                  }
                  %45 = memref.alloca() : memref<i1>
                  %46 = memref.alloca() : memref<i1>
                  memref.store %true, %46[] : memref<i1>
                  cf.br ^bb1(%44 : i32)
                ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
                  %48 = memref.load %0[] : memref<i32>
                  %49 = memref.get_global @im : memref<1xi32>
                  %50 = memref.load %49[%c0] : memref<1xi32>
                  %51 = arith.cmpi slt, %47, %50 : i32
                  %52 = memref.load %46[] : memref<i1>
                  %53 = arith.andi %51, %52 : i1
                  cf.cond_br %53, ^bb2, ^bb3
                ^bb2:  // pred: ^bb1
                  %54 = memref.load %46[] : memref<i1>
                  memref.store %54, %45[] : memref<i1>
                  %55 = memref.load %45[] : memref<i1>
                  scf.if %55 {
                    %59 = memref.load %4[] : memref<memref<?xf32>>
                    %60 = memref.load %0[] : memref<i32>
                    %61 = memref.load %2[] : memref<i32>
                    %62 = memref.load %49[%c0] : memref<1xi32>
                    %63 = arith.muli %61, %62 : i32
                    %64 = arith.addi %47, %63 : i32
                    %65 = memref.load %3[] : memref<i32>
                    %66 = arith.muli %65, %62 : i32
                    %67 = memref.load %30[%c0] : memref<1xi32>
                    %68 = arith.muli %66, %67 : i32
                    %69 = arith.addi %64, %68 : i32
                    %70 = arith.index_cast %69 : i32 to index
                    %71 = memref.load %5[] : memref<memref<?xf32>>
                    %72 = arith.subi %65, %c1_i32 : i32
                    %73 = arith.muli %72, %62 : i32
                    %74 = arith.muli %73, %67 : i32
                    %75 = arith.addi %64, %74 : i32
                    %76 = arith.index_cast %75 : i32 to index
                    %77 = arith.addi %76, %c0 : index
                    %78 = memref.load %71[%77] : memref<?xf32>
                    %79 = arith.addi %70, %c0 : index
                    memref.store %78, %59[%79] : memref<?xf32>
                  }
                  %56 = memref.load %46[] : memref<i1>
                  memref.store %56, %45[] : memref<i1>
                  %57 = memref.load %45[] : memref<i1>
                  %58 = scf.if %57 -> (i32) {
                    %59 = memref.load %0[] : memref<i32>
                    %60 = arith.addi %47, %c1_i32 : i32
                    memref.store %60, %0[] : memref<i32>
                    scf.yield %60 : i32
                  } else {
                    scf.yield %47 : i32
                  }
                  cf.br ^bb1(%58 : i32)
                ^bb3:  // pred: ^bb1
                  scf.yield %47 : i32
                }
                scf.yield %42 : i32
              } else {
                scf.yield %28 : i32
              }
              scf.yield %41 : i32
            } else {
              scf.yield %28 : i32
            }
            %38 = memref.load %27[] : memref<i1>
            memref.store %38, %26[] : memref<i1>
            %39 = memref.load %26[] : memref<i1>
            scf.if %39 {
              %40 = memref.load %2[] : memref<i32>
              %41 = arith.addi %40, %c1_i32 : i32
              memref.store %41, %2[] : memref<i32>
            }
            cf.br ^bb1(%37 : i32)
          ^bb3:  // pred: ^bb1
            scf.yield %28 : i32
          }
          scf.yield %24 : i32
        } else {
          scf.yield %12 : i32
        }
        scf.yield %23 : i32
      } else {
        scf.yield %12 : i32
      }
      %20 = memref.load %11[] : memref<i1>
      memref.store %20, %10[] : memref<i1>
      %21 = memref.load %10[] : memref<i1>
      scf.if %21 {
        %22 = memref.load %3[] : memref<i32>
        %23 = arith.subi %22, %c1_i32 : i32
        memref.store %23, %3[] : memref<i32>
      }
      cf.br ^bb1(%19 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
  scf.yield


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%1 = llvm.mlir.undef : i32
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.execute_region {
    %9 = memref.load %6[] : memref<i1>
    scf.if %9 {
      %22 = memref.get_global @kbm3 : memref<1xi32>
      %23 = memref.load %22[%c0] : memref<1xi32>
      memref.store %23, %3[] : memref<i32>
    }
    %10 = memref.alloca() : memref<i1>
    %11 = memref.alloca() : memref<i1>
    memref.store %true, %11[] : memref<i1>
    cf.br ^bb1(%1 : i32)
  ^bb1(%12: i32):  // 2 preds: ^bb0, ^bb2
    %13 = memref.load %3[] : memref<i32>
    %14 = arith.cmpi sgt, %13, %c0_i32 : i32
    %15 = memref.load %11[] : memref<i1>
    %16 = arith.andi %14, %15 : i1
    cf.cond_br %16, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %17 = memref.load %11[] : memref<i1>
    memref.store %17, %10[] : memref<i1>
    %18 = memref.load %10[] : memref<i1>
    %19 = scf.if %18 -> (i32) {
      %22 = memref.load %10[] : memref<i1>
      %23 = scf.if %22 -> (i32) {
        %24 = scf.execute_region -> i32 {
          %25 = memref.load %10[] : memref<i1>
          scf.if %25 {
            memref.store %c0_i32, %2[] : memref<i32>
          }
          %26 = memref.alloca() : memref<i1>
          %27 = memref.alloca() : memref<i1>
          memref.store %true, %27[] : memref<i1>
          cf.br ^bb1(%12 : i32)
        ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
          %29 = memref.load %2[] : memref<i32>
          %30 = memref.get_global @jm : memref<1xi32>
          %31 = memref.load %30[%c0] : memref<1xi32>
          %32 = arith.cmpi slt, %29, %31 : i32
          %33 = memref.load %27[] : memref<i1>
          %34 = arith.andi %32, %33 : i1
          cf.cond_br %34, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %35 = memref.load %27[] : memref<i1>
          memref.store %35, %26[] : memref<i1>
          %36 = memref.load %26[] : memref<i1>
          %37 = scf.if %36 -> (i32) {
            %40 = memref.load %26[] : memref<i1>
            %41 = scf.if %40 -> (i32) {
              %42 = scf.execute_region -> i32 {
                %43 = memref.load %26[] : memref<i1>
                %44 = scf.if %43 -> (i32) {
                  memref.store %c0_i32, %0[] : memref<i32>
                  scf.yield %c0_i32 : i32
                } else {
                  scf.yield %28 : i32
                }
                %45 = memref.alloca() : memref<i1>
                %46 = memref.alloca() : memref<i1>
                memref.store %true, %46[] : memref<i1>
                cf.br ^bb1(%44 : i32)
              ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
                %48 = memref.load %0[] : memref<i32>
                %49 = memref.get_global @im : memref<1xi32>
                %50 = memref.load %49[%c0] : memref<1xi32>
                %51 = arith.cmpi slt, %47, %50 : i32
                %52 = memref.load %46[] : memref<i1>
                %53 = arith.andi %51, %52 : i1
                cf.cond_br %53, ^bb2, ^bb3
              ^bb2:  // pred: ^bb1
                %54 = memref.load %46[] : memref<i1>
                memref.store %54, %45[] : memref<i1>
                %55 = memref.load %45[] : memref<i1>
                scf.if %55 {
                  %59 = memref.load %4[] : memref<memref<?xf32>>
                  %60 = memref.load %0[] : memref<i32>
                  %61 = memref.load %2[] : memref<i32>
                  %62 = memref.load %49[%c0] : memref<1xi32>
                  %63 = arith.muli %61, %62 : i32
                  %64 = arith.addi %47, %63 : i32
                  %65 = memref.load %3[] : memref<i32>
                  %66 = arith.muli %65, %62 : i32
                  %67 = memref.load %30[%c0] : memref<1xi32>
                  %68 = arith.muli %66, %67 : i32
                  %69 = arith.addi %64, %68 : i32
                  %70 = arith.index_cast %69 : i32 to index
                  %71 = memref.load %5[] : memref<memref<?xf32>>
                  %72 = arith.subi %65, %c1_i32 : i32
                  %73 = arith.muli %72, %62 : i32
                  %74 = arith.muli %73, %67 : i32
                  %75 = arith.addi %64, %74 : i32
                  %76 = arith.index_cast %75 : i32 to index
                  %77 = arith.addi %76, %c0 : index
                  %78 = memref.load %71[%77] : memref<?xf32>
                  %79 = arith.addi %70, %c0 : index
                  memref.store %78, %59[%79] : memref<?xf32>
                }
                %56 = memref.load %46[] : memref<i1>
                memref.store %56, %45[] : memref<i1>
                %57 = memref.load %45[] : memref<i1>
                %58 = scf.if %57 -> (i32) {
                  %59 = memref.load %0[] : memref<i32>
                  %60 = arith.addi %47, %c1_i32 : i32
                  memref.store %60, %0[] : memref<i32>
                  scf.yield %60 : i32
                } else {
                  scf.yield %47 : i32
                }
                cf.br ^bb1(%58 : i32)
              ^bb3:  // pred: ^bb1
                scf.yield %47 : i32
              }
              scf.yield %42 : i32
            } else {
              scf.yield %28 : i32
            }
            scf.yield %41 : i32
          } else {
            scf.yield %28 : i32
          }
          %38 = memref.load %27[] : memref<i1>
          memref.store %38, %26[] : memref<i1>
          %39 = memref.load %26[] : memref<i1>
          scf.if %39 {
            %40 = memref.load %2[] : memref<i32>
            %41 = arith.addi %40, %c1_i32 : i32
            memref.store %41, %2[] : memref<i32>
          }
          cf.br ^bb1(%37 : i32)
        ^bb3:  // pred: ^bb1
          scf.yield %28 : i32
        }
        scf.yield %24 : i32
      } else {
        scf.yield %12 : i32
      }
      scf.yield %23 : i32
    } else {
      scf.yield %12 : i32
    }
    %20 = memref.load %11[] : memref<i1>
    memref.store %20, %10[] : memref<i1>
    %21 = memref.load %10[] : memref<i1>
    scf.if %21 {
      %22 = memref.load %3[] : memref<i32>
      %23 = arith.subi %22, %c1_i32 : i32
      memref.store %23, %3[] : memref<i32>
    }
    cf.br ^bb1(%19 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield
  }
  scf.yield


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%1 = llvm.mlir.undef : i32
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %9 = memref.load %6[] : memref<i1>
  scf.if %9 {
    %22 = memref.get_global @kbm3 : memref<1xi32>
    %23 = memref.load %22[%c0] : memref<1xi32>
    memref.store %23, %3[] : memref<i32>
  }
  %10 = memref.alloca() : memref<i1>
  %11 = memref.alloca() : memref<i1>
  memref.store %true, %11[] : memref<i1>
  cf.br ^bb1(%1 : i32)


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%1 = llvm.mlir.undef : i32
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %22 = memref.get_global @kbm3 : memref<1xi32>
  %23 = memref.load %22[%c0] : memref<1xi32>
  memref.store %23, %3[] : memref<i32>
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %22 = memref.get_global @kbm3 : memref<1xi32>
  %23 = memref.load %22[%c0] : memref<1xi32>
  memref.store %23, %3[] : memref<i32>
  scf.yield
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%1 = llvm.mlir.undef : i32
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %9 = memref.load %6[] : memref<i1>
  scf.if %9 {
    %22 = memref.get_global @kbm3 : memref<1xi32>
    %23 = memref.load %22[%c0] : memref<1xi32>
    memref.store %23, %3[] : memref<i32>
  }
  %10 = memref.alloca() : memref<i1>
  %11 = memref.alloca() : memref<i1>
  memref.store %true, %11[] : memref<i1>
  cf.br ^bb1(%1 : i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%1 = llvm.mlir.undef : i32

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb1(%12: i32):  // 2 preds: ^bb0, ^bb2
  %13 = memref.load %3[] : memref<i32>
  %14 = arith.cmpi sgt, %13, %c0_i32 : i32
  %15 = memref.load %11[] : memref<i1>
  %16 = arith.andi %14, %15 : i1
  cf.cond_br %16, ^bb2, ^bb3

mlir-asm-printer: Verifying operation: builtin.module
^bb1(%12: i32):  // 2 preds: ^bb0, ^bb2
  %13 = memref.load %3[] : memref<i32>
  %14 = arith.cmpi sgt, %13, %c0_i32 : i32
  %15 = memref.load %11[] : memref<i1>
  %16 = arith.andi %14, %15 : i1
  cf.cond_br %16, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%12: i32):  // 2 preds: ^bb0, ^bb2
  %13 = memref.load %3[] : memref<i32>
  %14 = arith.cmpi sgt, %13, %c0_i32 : i32
  %15 = memref.load %11[] : memref<i1>
  %16 = arith.andi %14, %15 : i1
  cf.cond_br %16, ^bb2, ^bb3
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb1(%12: i32):  // 2 preds: ^bb0, ^bb2
  %13 = memref.load %3[] : memref<i32>
  %14 = arith.cmpi sgt, %13, %c0_i32 : i32
  %15 = memref.load %11[] : memref<i1>
  %16 = arith.andi %14, %15 : i1
  cf.cond_br %16, ^bb2, ^bb3


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %17 = memref.load %11[] : memref<i1>
  memref.store %17, %10[] : memref<i1>
  %18 = memref.load %10[] : memref<i1>
  %19 = scf.if %18 -> (i32) {
    %22 = memref.load %10[] : memref<i1>
    %23 = scf.if %22 -> (i32) {
      %24 = scf.execute_region -> i32 {
        %25 = memref.load %10[] : memref<i1>
        scf.if %25 {
          memref.store %c0_i32, %2[] : memref<i32>
        }
        %26 = memref.alloca() : memref<i1>
        %27 = memref.alloca() : memref<i1>
        memref.store %true, %27[] : memref<i1>
        cf.br ^bb1(%12 : i32)
      ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
        %29 = memref.load %2[] : memref<i32>
        %30 = memref.get_global @jm : memref<1xi32>
        %31 = memref.load %30[%c0] : memref<1xi32>
        %32 = arith.cmpi slt, %29, %31 : i32
        %33 = memref.load %27[] : memref<i1>
        %34 = arith.andi %32, %33 : i1
        cf.cond_br %34, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %35 = memref.load %27[] : memref<i1>
        memref.store %35, %26[] : memref<i1>
        %36 = memref.load %26[] : memref<i1>
        %37 = scf.if %36 -> (i32) {
          %40 = memref.load %26[] : memref<i1>
          %41 = scf.if %40 -> (i32) {
            %42 = scf.execute_region -> i32 {
              %43 = memref.load %26[] : memref<i1>
              %44 = scf.if %43 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %28 : i32
              }
              %45 = memref.alloca() : memref<i1>
              %46 = memref.alloca() : memref<i1>
              memref.store %true, %46[] : memref<i1>
              cf.br ^bb1(%44 : i32)
            ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
              %48 = memref.load %0[] : memref<i32>
              %49 = memref.get_global @im : memref<1xi32>
              %50 = memref.load %49[%c0] : memref<1xi32>
              %51 = arith.cmpi slt, %47, %50 : i32
              %52 = memref.load %46[] : memref<i1>
              %53 = arith.andi %51, %52 : i1
              cf.cond_br %53, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %54 = memref.load %46[] : memref<i1>
              memref.store %54, %45[] : memref<i1>
              %55 = memref.load %45[] : memref<i1>
              scf.if %55 {
                %59 = memref.load %4[] : memref<memref<?xf32>>
                %60 = memref.load %0[] : memref<i32>
                %61 = memref.load %2[] : memref<i32>
                %62 = memref.load %49[%c0] : memref<1xi32>
                %63 = arith.muli %61, %62 : i32
                %64 = arith.addi %47, %63 : i32
                %65 = memref.load %3[] : memref<i32>
                %66 = arith.muli %65, %62 : i32
                %67 = memref.load %30[%c0] : memref<1xi32>
                %68 = arith.muli %66, %67 : i32
                %69 = arith.addi %64, %68 : i32
                %70 = arith.index_cast %69 : i32 to index
                %71 = memref.load %5[] : memref<memref<?xf32>>
                %72 = arith.subi %65, %c1_i32 : i32
                %73 = arith.muli %72, %62 : i32
                %74 = arith.muli %73, %67 : i32
                %75 = arith.addi %64, %74 : i32
                %76 = arith.index_cast %75 : i32 to index
                %77 = arith.addi %76, %c0 : index
                %78 = memref.load %71[%77] : memref<?xf32>
                %79 = arith.addi %70, %c0 : index
                memref.store %78, %59[%79] : memref<?xf32>
              }
              %56 = memref.load %46[] : memref<i1>
              memref.store %56, %45[] : memref<i1>
              %57 = memref.load %45[] : memref<i1>
              %58 = scf.if %57 -> (i32) {
                %59 = memref.load %0[] : memref<i32>
                %60 = arith.addi %47, %c1_i32 : i32
                memref.store %60, %0[] : memref<i32>
                scf.yield %60 : i32
              } else {
                scf.yield %47 : i32
              }
              cf.br ^bb1(%58 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %47 : i32
            }
            scf.yield %42 : i32
          } else {
            scf.yield %28 : i32
          }
          scf.yield %41 : i32
        } else {
          scf.yield %28 : i32
        }
        %38 = memref.load %27[] : memref<i1>
        memref.store %38, %26[] : memref<i1>
        %39 = memref.load %26[] : memref<i1>
        scf.if %39 {
          %40 = memref.load %2[] : memref<i32>
          %41 = arith.addi %40, %c1_i32 : i32
          memref.store %41, %2[] : memref<i32>
        }
        cf.br ^bb1(%37 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %28 : i32
      }
      scf.yield %24 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %23 : i32
  } else {
    scf.yield %12 : i32
  }
  %20 = memref.load %11[] : memref<i1>
  memref.store %20, %10[] : memref<i1>
  %21 = memref.load %10[] : memref<i1>
  scf.if %21 {
    %22 = memref.load %3[] : memref<i32>
    %23 = arith.subi %22, %c1_i32 : i32
    memref.store %23, %3[] : memref<i32>
  }
  cf.br ^bb1(%19 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %17 = memref.load %11[] : memref<i1>
  memref.store %17, %10[] : memref<i1>
  %18 = memref.load %10[] : memref<i1>
  %19 = scf.if %18 -> (i32) {
    %22 = memref.load %10[] : memref<i1>
    %23 = scf.if %22 -> (i32) {
      %24 = scf.execute_region -> i32 {
        %25 = memref.load %10[] : memref<i1>
        scf.if %25 {
          memref.store %c0_i32, %2[] : memref<i32>
        }
        %26 = memref.alloca() : memref<i1>
        %27 = memref.alloca() : memref<i1>
        memref.store %true, %27[] : memref<i1>
        cf.br ^bb1(%12 : i32)
      ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
        %29 = memref.load %2[] : memref<i32>
        %30 = memref.get_global @jm : memref<1xi32>
        %31 = memref.load %30[%c0] : memref<1xi32>
        %32 = arith.cmpi slt, %29, %31 : i32
        %33 = memref.load %27[] : memref<i1>
        %34 = arith.andi %32, %33 : i1
        cf.cond_br %34, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %35 = memref.load %27[] : memref<i1>
        memref.store %35, %26[] : memref<i1>
        %36 = memref.load %26[] : memref<i1>
        %37 = scf.if %36 -> (i32) {
          %40 = memref.load %26[] : memref<i1>
          %41 = scf.if %40 -> (i32) {
            %42 = scf.execute_region -> i32 {
              %43 = memref.load %26[] : memref<i1>
              %44 = scf.if %43 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %28 : i32
              }
              %45 = memref.alloca() : memref<i1>
              %46 = memref.alloca() : memref<i1>
              memref.store %true, %46[] : memref<i1>
              cf.br ^bb1(%44 : i32)
            ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
              %48 = memref.load %0[] : memref<i32>
              %49 = memref.get_global @im : memref<1xi32>
              %50 = memref.load %49[%c0] : memref<1xi32>
              %51 = arith.cmpi slt, %47, %50 : i32
              %52 = memref.load %46[] : memref<i1>
              %53 = arith.andi %51, %52 : i1
              cf.cond_br %53, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %54 = memref.load %46[] : memref<i1>
              memref.store %54, %45[] : memref<i1>
              %55 = memref.load %45[] : memref<i1>
              scf.if %55 {
                %59 = memref.load %4[] : memref<memref<?xf32>>
                %60 = memref.load %0[] : memref<i32>
                %61 = memref.load %2[] : memref<i32>
                %62 = memref.load %49[%c0] : memref<1xi32>
                %63 = arith.muli %61, %62 : i32
                %64 = arith.addi %47, %63 : i32
                %65 = memref.load %3[] : memref<i32>
                %66 = arith.muli %65, %62 : i32
                %67 = memref.load %30[%c0] : memref<1xi32>
                %68 = arith.muli %66, %67 : i32
                %69 = arith.addi %64, %68 : i32
                %70 = arith.index_cast %69 : i32 to index
                %71 = memref.load %5[] : memref<memref<?xf32>>
                %72 = arith.subi %65, %c1_i32 : i32
                %73 = arith.muli %72, %62 : i32
                %74 = arith.muli %73, %67 : i32
                %75 = arith.addi %64, %74 : i32
                %76 = arith.index_cast %75 : i32 to index
                %77 = arith.addi %76, %c0 : index
                %78 = memref.load %71[%77] : memref<?xf32>
                %79 = arith.addi %70, %c0 : index
                memref.store %78, %59[%79] : memref<?xf32>
              }
              %56 = memref.load %46[] : memref<i1>
              memref.store %56, %45[] : memref<i1>
              %57 = memref.load %45[] : memref<i1>
              %58 = scf.if %57 -> (i32) {
                %59 = memref.load %0[] : memref<i32>
                %60 = arith.addi %47, %c1_i32 : i32
                memref.store %60, %0[] : memref<i32>
                scf.yield %60 : i32
              } else {
                scf.yield %47 : i32
              }
              cf.br ^bb1(%58 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %47 : i32
            }
            scf.yield %42 : i32
          } else {
            scf.yield %28 : i32
          }
          scf.yield %41 : i32
        } else {
          scf.yield %28 : i32
        }
        %38 = memref.load %27[] : memref<i1>
        memref.store %38, %26[] : memref<i1>
        %39 = memref.load %26[] : memref<i1>
        scf.if %39 {
          %40 = memref.load %2[] : memref<i32>
          %41 = arith.addi %40, %c1_i32 : i32
          memref.store %41, %2[] : memref<i32>
        }
        cf.br ^bb1(%37 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %28 : i32
      }
      scf.yield %24 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %23 : i32
  } else {
    scf.yield %12 : i32
  }
  %20 = memref.load %11[] : memref<i1>
  memref.store %20, %10[] : memref<i1>
  %21 = memref.load %10[] : memref<i1>
  scf.if %21 {
    %22 = memref.load %3[] : memref<i32>
    %23 = arith.subi %22, %c1_i32 : i32
    memref.store %23, %3[] : memref<i32>
  }
  cf.br ^bb1(%19 : i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %17 = memref.load %11[] : memref<i1>
  memref.store %17, %10[] : memref<i1>
  %18 = memref.load %10[] : memref<i1>
  %19 = scf.if %18 -> (i32) {
    %22 = memref.load %10[] : memref<i1>
    %23 = scf.if %22 -> (i32) {
      %24 = scf.execute_region -> i32 {
        %25 = memref.load %10[] : memref<i1>
        scf.if %25 {
          memref.store %c0_i32, %2[] : memref<i32>
        }
        %26 = memref.alloca() : memref<i1>
        %27 = memref.alloca() : memref<i1>
        memref.store %true, %27[] : memref<i1>
        cf.br ^bb1(%12 : i32)
      ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
        %29 = memref.load %2[] : memref<i32>
        %30 = memref.get_global @jm : memref<1xi32>
        %31 = memref.load %30[%c0] : memref<1xi32>
        %32 = arith.cmpi slt, %29, %31 : i32
        %33 = memref.load %27[] : memref<i1>
        %34 = arith.andi %32, %33 : i1
        cf.cond_br %34, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %35 = memref.load %27[] : memref<i1>
        memref.store %35, %26[] : memref<i1>
        %36 = memref.load %26[] : memref<i1>
        %37 = scf.if %36 -> (i32) {
          %40 = memref.load %26[] : memref<i1>
          %41 = scf.if %40 -> (i32) {
            %42 = scf.execute_region -> i32 {
              %43 = memref.load %26[] : memref<i1>
              %44 = scf.if %43 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %28 : i32
              }
              %45 = memref.alloca() : memref<i1>
              %46 = memref.alloca() : memref<i1>
              memref.store %true, %46[] : memref<i1>
              cf.br ^bb1(%44 : i32)
            ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
              %48 = memref.load %0[] : memref<i32>
              %49 = memref.get_global @im : memref<1xi32>
              %50 = memref.load %49[%c0] : memref<1xi32>
              %51 = arith.cmpi slt, %47, %50 : i32
              %52 = memref.load %46[] : memref<i1>
              %53 = arith.andi %51, %52 : i1
              cf.cond_br %53, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %54 = memref.load %46[] : memref<i1>
              memref.store %54, %45[] : memref<i1>
              %55 = memref.load %45[] : memref<i1>
              scf.if %55 {
                %59 = memref.load %4[] : memref<memref<?xf32>>
                %60 = memref.load %0[] : memref<i32>
                %61 = memref.load %2[] : memref<i32>
                %62 = memref.load %49[%c0] : memref<1xi32>
                %63 = arith.muli %61, %62 : i32
                %64 = arith.addi %47, %63 : i32
                %65 = memref.load %3[] : memref<i32>
                %66 = arith.muli %65, %62 : i32
                %67 = memref.load %30[%c0] : memref<1xi32>
                %68 = arith.muli %66, %67 : i32
                %69 = arith.addi %64, %68 : i32
                %70 = arith.index_cast %69 : i32 to index
                %71 = memref.load %5[] : memref<memref<?xf32>>
                %72 = arith.subi %65, %c1_i32 : i32
                %73 = arith.muli %72, %62 : i32
                %74 = arith.muli %73, %67 : i32
                %75 = arith.addi %64, %74 : i32
                %76 = arith.index_cast %75 : i32 to index
                %77 = arith.addi %76, %c0 : index
                %78 = memref.load %71[%77] : memref<?xf32>
                %79 = arith.addi %70, %c0 : index
                memref.store %78, %59[%79] : memref<?xf32>
              }
              %56 = memref.load %46[] : memref<i1>
              memref.store %56, %45[] : memref<i1>
              %57 = memref.load %45[] : memref<i1>
              %58 = scf.if %57 -> (i32) {
                %59 = memref.load %0[] : memref<i32>
                %60 = arith.addi %47, %c1_i32 : i32
                memref.store %60, %0[] : memref<i32>
                scf.yield %60 : i32
              } else {
                scf.yield %47 : i32
              }
              cf.br ^bb1(%58 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %47 : i32
            }
            scf.yield %42 : i32
          } else {
            scf.yield %28 : i32
          }
          scf.yield %41 : i32
        } else {
          scf.yield %28 : i32
        }
        %38 = memref.load %27[] : memref<i1>
        memref.store %38, %26[] : memref<i1>
        %39 = memref.load %26[] : memref<i1>
        scf.if %39 {
          %40 = memref.load %2[] : memref<i32>
          %41 = arith.addi %40, %c1_i32 : i32
          memref.store %41, %2[] : memref<i32>
        }
        cf.br ^bb1(%37 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %28 : i32
      }
      scf.yield %24 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %23 : i32
  } else {
    scf.yield %12 : i32
  }
  %20 = memref.load %11[] : memref<i1>
  memref.store %20, %10[] : memref<i1>
  %21 = memref.load %10[] : memref<i1>
  scf.if %21 {
    %22 = memref.load %3[] : memref<i32>
    %23 = arith.subi %22, %c1_i32 : i32
    memref.store %23, %3[] : memref<i32>
  }
  cf.br ^bb1(%19 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %22 = memref.load %10[] : memref<i1>
  %23 = scf.if %22 -> (i32) {
    %24 = scf.execute_region -> i32 {
      %25 = memref.load %10[] : memref<i1>
      scf.if %25 {
        memref.store %c0_i32, %2[] : memref<i32>
      }
      %26 = memref.alloca() : memref<i1>
      %27 = memref.alloca() : memref<i1>
      memref.store %true, %27[] : memref<i1>
      cf.br ^bb1(%12 : i32)
    ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
      %29 = memref.load %2[] : memref<i32>
      %30 = memref.get_global @jm : memref<1xi32>
      %31 = memref.load %30[%c0] : memref<1xi32>
      %32 = arith.cmpi slt, %29, %31 : i32
      %33 = memref.load %27[] : memref<i1>
      %34 = arith.andi %32, %33 : i1
      cf.cond_br %34, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %35 = memref.load %27[] : memref<i1>
      memref.store %35, %26[] : memref<i1>
      %36 = memref.load %26[] : memref<i1>
      %37 = scf.if %36 -> (i32) {
        %40 = memref.load %26[] : memref<i1>
        %41 = scf.if %40 -> (i32) {
          %42 = scf.execute_region -> i32 {
            %43 = memref.load %26[] : memref<i1>
            %44 = scf.if %43 -> (i32) {
              memref.store %c0_i32, %0[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %28 : i32
            }
            %45 = memref.alloca() : memref<i1>
            %46 = memref.alloca() : memref<i1>
            memref.store %true, %46[] : memref<i1>
            cf.br ^bb1(%44 : i32)
          ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
            %48 = memref.load %0[] : memref<i32>
            %49 = memref.get_global @im : memref<1xi32>
            %50 = memref.load %49[%c0] : memref<1xi32>
            %51 = arith.cmpi slt, %47, %50 : i32
            %52 = memref.load %46[] : memref<i1>
            %53 = arith.andi %51, %52 : i1
            cf.cond_br %53, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %54 = memref.load %46[] : memref<i1>
            memref.store %54, %45[] : memref<i1>
            %55 = memref.load %45[] : memref<i1>
            scf.if %55 {
              %59 = memref.load %4[] : memref<memref<?xf32>>
              %60 = memref.load %0[] : memref<i32>
              %61 = memref.load %2[] : memref<i32>
              %62 = memref.load %49[%c0] : memref<1xi32>
              %63 = arith.muli %61, %62 : i32
              %64 = arith.addi %47, %63 : i32
              %65 = memref.load %3[] : memref<i32>
              %66 = arith.muli %65, %62 : i32
              %67 = memref.load %30[%c0] : memref<1xi32>
              %68 = arith.muli %66, %67 : i32
              %69 = arith.addi %64, %68 : i32
              %70 = arith.index_cast %69 : i32 to index
              %71 = memref.load %5[] : memref<memref<?xf32>>
              %72 = arith.subi %65, %c1_i32 : i32
              %73 = arith.muli %72, %62 : i32
              %74 = arith.muli %73, %67 : i32
              %75 = arith.addi %64, %74 : i32
              %76 = arith.index_cast %75 : i32 to index
              %77 = arith.addi %76, %c0 : index
              %78 = memref.load %71[%77] : memref<?xf32>
              %79 = arith.addi %70, %c0 : index
              memref.store %78, %59[%79] : memref<?xf32>
            }
            %56 = memref.load %46[] : memref<i1>
            memref.store %56, %45[] : memref<i1>
            %57 = memref.load %45[] : memref<i1>
            %58 = scf.if %57 -> (i32) {
              %59 = memref.load %0[] : memref<i32>
              %60 = arith.addi %47, %c1_i32 : i32
              memref.store %60, %0[] : memref<i32>
              scf.yield %60 : i32
            } else {
              scf.yield %47 : i32
            }
            cf.br ^bb1(%58 : i32)
          ^bb3:  // pred: ^bb1
            scf.yield %47 : i32
          }
          scf.yield %42 : i32
        } else {
          scf.yield %28 : i32
        }
        scf.yield %41 : i32
      } else {
        scf.yield %28 : i32
      }
      %38 = memref.load %27[] : memref<i1>
      memref.store %38, %26[] : memref<i1>
      %39 = memref.load %26[] : memref<i1>
      scf.if %39 {
        %40 = memref.load %2[] : memref<i32>
        %41 = arith.addi %40, %c1_i32 : i32
        memref.store %41, %2[] : memref<i32>
      }
      cf.br ^bb1(%37 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %28 : i32
    }
    scf.yield %24 : i32
  } else {
    scf.yield %12 : i32
  }
  scf.yield %23 : i32


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %17 = memref.load %11[] : memref<i1>
  memref.store %17, %10[] : memref<i1>
  %18 = memref.load %10[] : memref<i1>
  %19 = scf.if %18 -> (i32) {
    %22 = memref.load %10[] : memref<i1>
    %23 = scf.if %22 -> (i32) {
      %24 = scf.execute_region -> i32 {
        %25 = memref.load %10[] : memref<i1>
        scf.if %25 {
          memref.store %c0_i32, %2[] : memref<i32>
        }
        %26 = memref.alloca() : memref<i1>
        %27 = memref.alloca() : memref<i1>
        memref.store %true, %27[] : memref<i1>
        cf.br ^bb1(%12 : i32)
      ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
        %29 = memref.load %2[] : memref<i32>
        %30 = memref.get_global @jm : memref<1xi32>
        %31 = memref.load %30[%c0] : memref<1xi32>
        %32 = arith.cmpi slt, %29, %31 : i32
        %33 = memref.load %27[] : memref<i1>
        %34 = arith.andi %32, %33 : i1
        cf.cond_br %34, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %35 = memref.load %27[] : memref<i1>
        memref.store %35, %26[] : memref<i1>
        %36 = memref.load %26[] : memref<i1>
        %37 = scf.if %36 -> (i32) {
          %40 = memref.load %26[] : memref<i1>
          %41 = scf.if %40 -> (i32) {
            %42 = scf.execute_region -> i32 {
              %43 = memref.load %26[] : memref<i1>
              %44 = scf.if %43 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %28 : i32
              }
              %45 = memref.alloca() : memref<i1>
              %46 = memref.alloca() : memref<i1>
              memref.store %true, %46[] : memref<i1>
              cf.br ^bb1(%44 : i32)
            ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
              %48 = memref.load %0[] : memref<i32>
              %49 = memref.get_global @im : memref<1xi32>
              %50 = memref.load %49[%c0] : memref<1xi32>
              %51 = arith.cmpi slt, %47, %50 : i32
              %52 = memref.load %46[] : memref<i1>
              %53 = arith.andi %51, %52 : i1
              cf.cond_br %53, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %54 = memref.load %46[] : memref<i1>
              memref.store %54, %45[] : memref<i1>
              %55 = memref.load %45[] : memref<i1>
              scf.if %55 {
                %59 = memref.load %4[] : memref<memref<?xf32>>
                %60 = memref.load %0[] : memref<i32>
                %61 = memref.load %2[] : memref<i32>
                %62 = memref.load %49[%c0] : memref<1xi32>
                %63 = arith.muli %61, %62 : i32
                %64 = arith.addi %47, %63 : i32
                %65 = memref.load %3[] : memref<i32>
                %66 = arith.muli %65, %62 : i32
                %67 = memref.load %30[%c0] : memref<1xi32>
                %68 = arith.muli %66, %67 : i32
                %69 = arith.addi %64, %68 : i32
                %70 = arith.index_cast %69 : i32 to index
                %71 = memref.load %5[] : memref<memref<?xf32>>
                %72 = arith.subi %65, %c1_i32 : i32
                %73 = arith.muli %72, %62 : i32
                %74 = arith.muli %73, %67 : i32
                %75 = arith.addi %64, %74 : i32
                %76 = arith.index_cast %75 : i32 to index
                %77 = arith.addi %76, %c0 : index
                %78 = memref.load %71[%77] : memref<?xf32>
                %79 = arith.addi %70, %c0 : index
                memref.store %78, %59[%79] : memref<?xf32>
              }
              %56 = memref.load %46[] : memref<i1>
              memref.store %56, %45[] : memref<i1>
              %57 = memref.load %45[] : memref<i1>
              %58 = scf.if %57 -> (i32) {
                %59 = memref.load %0[] : memref<i32>
                %60 = arith.addi %47, %c1_i32 : i32
                memref.store %60, %0[] : memref<i32>
                scf.yield %60 : i32
              } else {
                scf.yield %47 : i32
              }
              cf.br ^bb1(%58 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %47 : i32
            }
            scf.yield %42 : i32
          } else {
            scf.yield %28 : i32
          }
          scf.yield %41 : i32
        } else {
          scf.yield %28 : i32
        }
        %38 = memref.load %27[] : memref<i1>
        memref.store %38, %26[] : memref<i1>
        %39 = memref.load %26[] : memref<i1>
        scf.if %39 {
          %40 = memref.load %2[] : memref<i32>
          %41 = arith.addi %40, %c1_i32 : i32
          memref.store %41, %2[] : memref<i32>
        }
        cf.br ^bb1(%37 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %28 : i32
      }
      scf.yield %24 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %23 : i32
  } else {
    scf.yield %12 : i32
  }
  %20 = memref.load %11[] : memref<i1>
  memref.store %20, %10[] : memref<i1>
  %21 = memref.load %10[] : memref<i1>
  scf.if %21 {
    %22 = memref.load %3[] : memref<i32>
    %23 = arith.subi %22, %c1_i32 : i32
    memref.store %23, %3[] : memref<i32>
  }
  cf.br ^bb1(%19 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %24 = scf.execute_region -> i32 {
    %25 = memref.load %10[] : memref<i1>
    scf.if %25 {
      memref.store %c0_i32, %2[] : memref<i32>
    }
    %26 = memref.alloca() : memref<i1>
    %27 = memref.alloca() : memref<i1>
    memref.store %true, %27[] : memref<i1>
    cf.br ^bb1(%12 : i32)
  ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
    %29 = memref.load %2[] : memref<i32>
    %30 = memref.get_global @jm : memref<1xi32>
    %31 = memref.load %30[%c0] : memref<1xi32>
    %32 = arith.cmpi slt, %29, %31 : i32
    %33 = memref.load %27[] : memref<i1>
    %34 = arith.andi %32, %33 : i1
    cf.cond_br %34, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %35 = memref.load %27[] : memref<i1>
    memref.store %35, %26[] : memref<i1>
    %36 = memref.load %26[] : memref<i1>
    %37 = scf.if %36 -> (i32) {
      %40 = memref.load %26[] : memref<i1>
      %41 = scf.if %40 -> (i32) {
        %42 = scf.execute_region -> i32 {
          %43 = memref.load %26[] : memref<i1>
          %44 = scf.if %43 -> (i32) {
            memref.store %c0_i32, %0[] : memref<i32>
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %28 : i32
          }
          %45 = memref.alloca() : memref<i1>
          %46 = memref.alloca() : memref<i1>
          memref.store %true, %46[] : memref<i1>
          cf.br ^bb1(%44 : i32)
        ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
          %48 = memref.load %0[] : memref<i32>
          %49 = memref.get_global @im : memref<1xi32>
          %50 = memref.load %49[%c0] : memref<1xi32>
          %51 = arith.cmpi slt, %47, %50 : i32
          %52 = memref.load %46[] : memref<i1>
          %53 = arith.andi %51, %52 : i1
          cf.cond_br %53, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %54 = memref.load %46[] : memref<i1>
          memref.store %54, %45[] : memref<i1>
          %55 = memref.load %45[] : memref<i1>
          scf.if %55 {
            %59 = memref.load %4[] : memref<memref<?xf32>>
            %60 = memref.load %0[] : memref<i32>
            %61 = memref.load %2[] : memref<i32>
            %62 = memref.load %49[%c0] : memref<1xi32>
            %63 = arith.muli %61, %62 : i32
            %64 = arith.addi %47, %63 : i32
            %65 = memref.load %3[] : memref<i32>
            %66 = arith.muli %65, %62 : i32
            %67 = memref.load %30[%c0] : memref<1xi32>
            %68 = arith.muli %66, %67 : i32
            %69 = arith.addi %64, %68 : i32
            %70 = arith.index_cast %69 : i32 to index
            %71 = memref.load %5[] : memref<memref<?xf32>>
            %72 = arith.subi %65, %c1_i32 : i32
            %73 = arith.muli %72, %62 : i32
            %74 = arith.muli %73, %67 : i32
            %75 = arith.addi %64, %74 : i32
            %76 = arith.index_cast %75 : i32 to index
            %77 = arith.addi %76, %c0 : index
            %78 = memref.load %71[%77] : memref<?xf32>
            %79 = arith.addi %70, %c0 : index
            memref.store %78, %59[%79] : memref<?xf32>
          }
          %56 = memref.load %46[] : memref<i1>
          memref.store %56, %45[] : memref<i1>
          %57 = memref.load %45[] : memref<i1>
          %58 = scf.if %57 -> (i32) {
            %59 = memref.load %0[] : memref<i32>
            %60 = arith.addi %47, %c1_i32 : i32
            memref.store %60, %0[] : memref<i32>
            scf.yield %60 : i32
          } else {
            scf.yield %47 : i32
          }
          cf.br ^bb1(%58 : i32)
        ^bb3:  // pred: ^bb1
          scf.yield %47 : i32
        }
        scf.yield %42 : i32
      } else {
        scf.yield %28 : i32
      }
      scf.yield %41 : i32
    } else {
      scf.yield %28 : i32
    }
    %38 = memref.load %27[] : memref<i1>
    memref.store %38, %26[] : memref<i1>
    %39 = memref.load %26[] : memref<i1>
    scf.if %39 {
      %40 = memref.load %2[] : memref<i32>
      %41 = arith.addi %40, %c1_i32 : i32
      memref.store %41, %2[] : memref<i32>
    }
    cf.br ^bb1(%37 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %28 : i32
  }
  scf.yield %24 : i32


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %17 = memref.load %11[] : memref<i1>
  memref.store %17, %10[] : memref<i1>
  %18 = memref.load %10[] : memref<i1>
  %19 = scf.if %18 -> (i32) {
    %22 = memref.load %10[] : memref<i1>
    %23 = scf.if %22 -> (i32) {
      %24 = scf.execute_region -> i32 {
        %25 = memref.load %10[] : memref<i1>
        scf.if %25 {
          memref.store %c0_i32, %2[] : memref<i32>
        }
        %26 = memref.alloca() : memref<i1>
        %27 = memref.alloca() : memref<i1>
        memref.store %true, %27[] : memref<i1>
        cf.br ^bb1(%12 : i32)
      ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
        %29 = memref.load %2[] : memref<i32>
        %30 = memref.get_global @jm : memref<1xi32>
        %31 = memref.load %30[%c0] : memref<1xi32>
        %32 = arith.cmpi slt, %29, %31 : i32
        %33 = memref.load %27[] : memref<i1>
        %34 = arith.andi %32, %33 : i1
        cf.cond_br %34, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %35 = memref.load %27[] : memref<i1>
        memref.store %35, %26[] : memref<i1>
        %36 = memref.load %26[] : memref<i1>
        %37 = scf.if %36 -> (i32) {
          %40 = memref.load %26[] : memref<i1>
          %41 = scf.if %40 -> (i32) {
            %42 = scf.execute_region -> i32 {
              %43 = memref.load %26[] : memref<i1>
              %44 = scf.if %43 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %28 : i32
              }
              %45 = memref.alloca() : memref<i1>
              %46 = memref.alloca() : memref<i1>
              memref.store %true, %46[] : memref<i1>
              cf.br ^bb1(%44 : i32)
            ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
              %48 = memref.load %0[] : memref<i32>
              %49 = memref.get_global @im : memref<1xi32>
              %50 = memref.load %49[%c0] : memref<1xi32>
              %51 = arith.cmpi slt, %47, %50 : i32
              %52 = memref.load %46[] : memref<i1>
              %53 = arith.andi %51, %52 : i1
              cf.cond_br %53, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %54 = memref.load %46[] : memref<i1>
              memref.store %54, %45[] : memref<i1>
              %55 = memref.load %45[] : memref<i1>
              scf.if %55 {
                %59 = memref.load %4[] : memref<memref<?xf32>>
                %60 = memref.load %0[] : memref<i32>
                %61 = memref.load %2[] : memref<i32>
                %62 = memref.load %49[%c0] : memref<1xi32>
                %63 = arith.muli %61, %62 : i32
                %64 = arith.addi %47, %63 : i32
                %65 = memref.load %3[] : memref<i32>
                %66 = arith.muli %65, %62 : i32
                %67 = memref.load %30[%c0] : memref<1xi32>
                %68 = arith.muli %66, %67 : i32
                %69 = arith.addi %64, %68 : i32
                %70 = arith.index_cast %69 : i32 to index
                %71 = memref.load %5[] : memref<memref<?xf32>>
                %72 = arith.subi %65, %c1_i32 : i32
                %73 = arith.muli %72, %62 : i32
                %74 = arith.muli %73, %67 : i32
                %75 = arith.addi %64, %74 : i32
                %76 = arith.index_cast %75 : i32 to index
                %77 = arith.addi %76, %c0 : index
                %78 = memref.load %71[%77] : memref<?xf32>
                %79 = arith.addi %70, %c0 : index
                memref.store %78, %59[%79] : memref<?xf32>
              }
              %56 = memref.load %46[] : memref<i1>
              memref.store %56, %45[] : memref<i1>
              %57 = memref.load %45[] : memref<i1>
              %58 = scf.if %57 -> (i32) {
                %59 = memref.load %0[] : memref<i32>
                %60 = arith.addi %47, %c1_i32 : i32
                memref.store %60, %0[] : memref<i32>
                scf.yield %60 : i32
              } else {
                scf.yield %47 : i32
              }
              cf.br ^bb1(%58 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %47 : i32
            }
            scf.yield %42 : i32
          } else {
            scf.yield %28 : i32
          }
          scf.yield %41 : i32
        } else {
          scf.yield %28 : i32
        }
        %38 = memref.load %27[] : memref<i1>
        memref.store %38, %26[] : memref<i1>
        %39 = memref.load %26[] : memref<i1>
        scf.if %39 {
          %40 = memref.load %2[] : memref<i32>
          %41 = arith.addi %40, %c1_i32 : i32
          memref.store %41, %2[] : memref<i32>
        }
        cf.br ^bb1(%37 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %28 : i32
      }
      scf.yield %24 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %23 : i32
  } else {
    scf.yield %12 : i32
  }
  %20 = memref.load %11[] : memref<i1>
  memref.store %20, %10[] : memref<i1>
  %21 = memref.load %10[] : memref<i1>
  scf.if %21 {
    %22 = memref.load %3[] : memref<i32>
    %23 = arith.subi %22, %c1_i32 : i32
    memref.store %23, %3[] : memref<i32>
  }
  cf.br ^bb1(%19 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %25 = memref.load %10[] : memref<i1>
  scf.if %25 {
    memref.store %c0_i32, %2[] : memref<i32>
  }
  %26 = memref.alloca() : memref<i1>
  %27 = memref.alloca() : memref<i1>
  memref.store %true, %27[] : memref<i1>
  cf.br ^bb1(%12 : i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %17 = memref.load %11[] : memref<i1>
  memref.store %17, %10[] : memref<i1>
  %18 = memref.load %10[] : memref<i1>
  %19 = scf.if %18 -> (i32) {
    %22 = memref.load %10[] : memref<i1>
    %23 = scf.if %22 -> (i32) {
      %24 = scf.execute_region -> i32 {
        %25 = memref.load %10[] : memref<i1>
        scf.if %25 {
          memref.store %c0_i32, %2[] : memref<i32>
        }
        %26 = memref.alloca() : memref<i1>
        %27 = memref.alloca() : memref<i1>
        memref.store %true, %27[] : memref<i1>
        cf.br ^bb1(%12 : i32)
      ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
        %29 = memref.load %2[] : memref<i32>
        %30 = memref.get_global @jm : memref<1xi32>
        %31 = memref.load %30[%c0] : memref<1xi32>
        %32 = arith.cmpi slt, %29, %31 : i32
        %33 = memref.load %27[] : memref<i1>
        %34 = arith.andi %32, %33 : i1
        cf.cond_br %34, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %35 = memref.load %27[] : memref<i1>
        memref.store %35, %26[] : memref<i1>
        %36 = memref.load %26[] : memref<i1>
        %37 = scf.if %36 -> (i32) {
          %40 = memref.load %26[] : memref<i1>
          %41 = scf.if %40 -> (i32) {
            %42 = scf.execute_region -> i32 {
              %43 = memref.load %26[] : memref<i1>
              %44 = scf.if %43 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %28 : i32
              }
              %45 = memref.alloca() : memref<i1>
              %46 = memref.alloca() : memref<i1>
              memref.store %true, %46[] : memref<i1>
              cf.br ^bb1(%44 : i32)
            ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
              %48 = memref.load %0[] : memref<i32>
              %49 = memref.get_global @im : memref<1xi32>
              %50 = memref.load %49[%c0] : memref<1xi32>
              %51 = arith.cmpi slt, %47, %50 : i32
              %52 = memref.load %46[] : memref<i1>
              %53 = arith.andi %51, %52 : i1
              cf.cond_br %53, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %54 = memref.load %46[] : memref<i1>
              memref.store %54, %45[] : memref<i1>
              %55 = memref.load %45[] : memref<i1>
              scf.if %55 {
                %59 = memref.load %4[] : memref<memref<?xf32>>
                %60 = memref.load %0[] : memref<i32>
                %61 = memref.load %2[] : memref<i32>
                %62 = memref.load %49[%c0] : memref<1xi32>
                %63 = arith.muli %61, %62 : i32
                %64 = arith.addi %47, %63 : i32
                %65 = memref.load %3[] : memref<i32>
                %66 = arith.muli %65, %62 : i32
                %67 = memref.load %30[%c0] : memref<1xi32>
                %68 = arith.muli %66, %67 : i32
                %69 = arith.addi %64, %68 : i32
                %70 = arith.index_cast %69 : i32 to index
                %71 = memref.load %5[] : memref<memref<?xf32>>
                %72 = arith.subi %65, %c1_i32 : i32
                %73 = arith.muli %72, %62 : i32
                %74 = arith.muli %73, %67 : i32
                %75 = arith.addi %64, %74 : i32
                %76 = arith.index_cast %75 : i32 to index
                %77 = arith.addi %76, %c0 : index
                %78 = memref.load %71[%77] : memref<?xf32>
                %79 = arith.addi %70, %c0 : index
                memref.store %78, %59[%79] : memref<?xf32>
              }
              %56 = memref.load %46[] : memref<i1>
              memref.store %56, %45[] : memref<i1>
              %57 = memref.load %45[] : memref<i1>
              %58 = scf.if %57 -> (i32) {
                %59 = memref.load %0[] : memref<i32>
                %60 = arith.addi %47, %c1_i32 : i32
                memref.store %60, %0[] : memref<i32>
                scf.yield %60 : i32
              } else {
                scf.yield %47 : i32
              }
              cf.br ^bb1(%58 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %47 : i32
            }
            scf.yield %42 : i32
          } else {
            scf.yield %28 : i32
          }
          scf.yield %41 : i32
        } else {
          scf.yield %28 : i32
        }
        %38 = memref.load %27[] : memref<i1>
        memref.store %38, %26[] : memref<i1>
        %39 = memref.load %26[] : memref<i1>
        scf.if %39 {
          %40 = memref.load %2[] : memref<i32>
          %41 = arith.addi %40, %c1_i32 : i32
          memref.store %41, %2[] : memref<i32>
        }
        cf.br ^bb1(%37 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %28 : i32
      }
      scf.yield %24 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %23 : i32
  } else {
    scf.yield %12 : i32
  }
  %20 = memref.load %11[] : memref<i1>
  memref.store %20, %10[] : memref<i1>
  %21 = memref.load %10[] : memref<i1>
  scf.if %21 {
    %22 = memref.load %3[] : memref<i32>
    %23 = arith.subi %22, %c1_i32 : i32
    memref.store %23, %3[] : memref<i32>
  }
  cf.br ^bb1(%19 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %2[] : memref<i32>
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %2[] : memref<i32>
  scf.yield
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%c0_i32 = arith.constant 0 : i32
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %25 = memref.load %10[] : memref<i1>
  scf.if %25 {
    memref.store %c0_i32, %2[] : memref<i32>
  }
  %26 = memref.alloca() : memref<i1>
  %27 = memref.alloca() : memref<i1>
  memref.store %true, %27[] : memref<i1>
  cf.br ^bb1(%12 : i32)
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %25 {
  memref.store %c0_i32, %2[] : memref<i32>
}

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
  %29 = memref.load %2[] : memref<i32>
  %30 = memref.get_global @jm : memref<1xi32>
  %31 = memref.load %30[%c0] : memref<1xi32>
  %32 = arith.cmpi slt, %29, %31 : i32
  %33 = memref.load %27[] : memref<i1>
  %34 = arith.andi %32, %33 : i1
  cf.cond_br %34, ^bb2, ^bb3

mlir-asm-printer: Verifying operation: builtin.module
^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
  %29 = memref.load %2[] : memref<i32>
  %30 = memref.get_global @jm : memref<1xi32>
  %31 = memref.load %30[%c0] : memref<1xi32>
  %32 = arith.cmpi slt, %29, %31 : i32
  %33 = memref.load %27[] : memref<i1>
  %34 = arith.andi %32, %33 : i1
  cf.cond_br %34, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
  %29 = memref.load %2[] : memref<i32>
  %30 = memref.get_global @jm : memref<1xi32>
  %31 = memref.load %30[%c0] : memref<1xi32>
  %32 = arith.cmpi slt, %29, %31 : i32
  %33 = memref.load %27[] : memref<i1>
  %34 = arith.andi %32, %33 : i1
  cf.cond_br %34, ^bb2, ^bb3
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%29 = memref.load %2[] : memref<i32>

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %40 = memref.load %26[] : memref<i1>
  %41 = scf.if %40 -> (i32) {
    %42 = scf.execute_region -> i32 {
      %43 = memref.load %26[] : memref<i1>
      %44 = scf.if %43 -> (i32) {
        memref.store %c0_i32, %0[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %28 : i32
      }
      %45 = memref.alloca() : memref<i1>
      %46 = memref.alloca() : memref<i1>
      memref.store %true, %46[] : memref<i1>
      cf.br ^bb1(%44 : i32)
    ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
      %48 = memref.load %0[] : memref<i32>
      %49 = memref.get_global @im : memref<1xi32>
      %50 = memref.load %49[%c0] : memref<1xi32>
      %51 = arith.cmpi slt, %47, %50 : i32
      %52 = memref.load %46[] : memref<i1>
      %53 = arith.andi %51, %52 : i1
      cf.cond_br %53, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %54 = memref.load %46[] : memref<i1>
      memref.store %54, %45[] : memref<i1>
      %55 = memref.load %45[] : memref<i1>
      scf.if %55 {
        %59 = memref.load %4[] : memref<memref<?xf32>>
        %60 = memref.load %0[] : memref<i32>
        %61 = memref.load %2[] : memref<i32>
        %62 = memref.load %49[%c0] : memref<1xi32>
        %63 = arith.muli %61, %62 : i32
        %64 = arith.addi %47, %63 : i32
        %65 = memref.load %3[] : memref<i32>
        %66 = arith.muli %65, %62 : i32
        %67 = memref.load %30[%c0] : memref<1xi32>
        %68 = arith.muli %66, %67 : i32
        %69 = arith.addi %64, %68 : i32
        %70 = arith.index_cast %69 : i32 to index
        %71 = memref.load %5[] : memref<memref<?xf32>>
        %72 = arith.subi %65, %c1_i32 : i32
        %73 = arith.muli %72, %62 : i32
        %74 = arith.muli %73, %67 : i32
        %75 = arith.addi %64, %74 : i32
        %76 = arith.index_cast %75 : i32 to index
        %77 = arith.addi %76, %c0 : index
        %78 = memref.load %71[%77] : memref<?xf32>
        %79 = arith.addi %70, %c0 : index
        memref.store %78, %59[%79] : memref<?xf32>
      }
      %56 = memref.load %46[] : memref<i1>
      memref.store %56, %45[] : memref<i1>
      %57 = memref.load %45[] : memref<i1>
      %58 = scf.if %57 -> (i32) {
        %59 = memref.load %0[] : memref<i32>
        %60 = arith.addi %47, %c1_i32 : i32
        memref.store %60, %0[] : memref<i32>
        scf.yield %60 : i32
      } else {
        scf.yield %47 : i32
      }
      cf.br ^bb1(%58 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %47 : i32
    }
    scf.yield %42 : i32
  } else {
    scf.yield %28 : i32
  }
  scf.yield %41 : i32


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %42 = scf.execute_region -> i32 {
    %43 = memref.load %26[] : memref<i1>
    %44 = scf.if %43 -> (i32) {
      memref.store %c0_i32, %0[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %28 : i32
    }
    %45 = memref.alloca() : memref<i1>
    %46 = memref.alloca() : memref<i1>
    memref.store %true, %46[] : memref<i1>
    cf.br ^bb1(%44 : i32)
  ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
    %48 = memref.load %0[] : memref<i32>
    %49 = memref.get_global @im : memref<1xi32>
    %50 = memref.load %49[%c0] : memref<1xi32>
    %51 = arith.cmpi slt, %47, %50 : i32
    %52 = memref.load %46[] : memref<i1>
    %53 = arith.andi %51, %52 : i1
    cf.cond_br %53, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %54 = memref.load %46[] : memref<i1>
    memref.store %54, %45[] : memref<i1>
    %55 = memref.load %45[] : memref<i1>
    scf.if %55 {
      %59 = memref.load %4[] : memref<memref<?xf32>>
      %60 = memref.load %0[] : memref<i32>
      %61 = memref.load %2[] : memref<i32>
      %62 = memref.load %49[%c0] : memref<1xi32>
      %63 = arith.muli %61, %62 : i32
      %64 = arith.addi %47, %63 : i32
      %65 = memref.load %3[] : memref<i32>
      %66 = arith.muli %65, %62 : i32
      %67 = memref.load %30[%c0] : memref<1xi32>
      %68 = arith.muli %66, %67 : i32
      %69 = arith.addi %64, %68 : i32
      %70 = arith.index_cast %69 : i32 to index
      %71 = memref.load %5[] : memref<memref<?xf32>>
      %72 = arith.subi %65, %c1_i32 : i32
      %73 = arith.muli %72, %62 : i32
      %74 = arith.muli %73, %67 : i32
      %75 = arith.addi %64, %74 : i32
      %76 = arith.index_cast %75 : i32 to index
      %77 = arith.addi %76, %c0 : index
      %78 = memref.load %71[%77] : memref<?xf32>
      %79 = arith.addi %70, %c0 : index
      memref.store %78, %59[%79] : memref<?xf32>
    }
    %56 = memref.load %46[] : memref<i1>
    memref.store %56, %45[] : memref<i1>
    %57 = memref.load %45[] : memref<i1>
    %58 = scf.if %57 -> (i32) {
      %59 = memref.load %0[] : memref<i32>
      %60 = arith.addi %47, %c1_i32 : i32
      memref.store %60, %0[] : memref<i32>
      scf.yield %60 : i32
    } else {
      scf.yield %47 : i32
    }
    cf.br ^bb1(%58 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %47 : i32
  }
  scf.yield %42 : i32


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %43 = memref.load %26[] : memref<i1>
  %44 = scf.if %43 -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %28 : i32
  }
  %45 = memref.alloca() : memref<i1>
  %46 = memref.alloca() : memref<i1>
  memref.store %true, %46[] : memref<i1>
  cf.br ^bb1(%44 : i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield %c0_i32 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield %c0_i32 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %28 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %28 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %43 = memref.load %26[] : memref<i1>
  %44 = scf.if %43 -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %28 : i32
  }
  %45 = memref.alloca() : memref<i1>
  %46 = memref.alloca() : memref<i1>
  memref.store %true, %46[] : memref<i1>
  cf.br ^bb1(%44 : i32)
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
  %48 = memref.load %0[] : memref<i32>
  %49 = memref.get_global @im : memref<1xi32>
  %50 = memref.load %49[%c0] : memref<1xi32>
  %51 = arith.cmpi slt, %47, %50 : i32
  %52 = memref.load %46[] : memref<i1>
  %53 = arith.andi %51, %52 : i1
  cf.cond_br %53, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
  %48 = memref.load %0[] : memref<i32>
  %49 = memref.get_global @im : memref<1xi32>
  %50 = memref.load %49[%c0] : memref<1xi32>
  %51 = arith.cmpi slt, %47, %50 : i32
  %52 = memref.load %46[] : memref<i1>
  %53 = arith.andi %51, %52 : i1
  cf.cond_br %53, ^bb2, ^bb3
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %54 = memref.load %46[] : memref<i1>
  memref.store %54, %45[] : memref<i1>
  %55 = memref.load %45[] : memref<i1>
  scf.if %55 {
    %59 = memref.load %4[] : memref<memref<?xf32>>
    %60 = memref.load %0[] : memref<i32>
    %61 = memref.load %2[] : memref<i32>
    %62 = memref.load %49[%c0] : memref<1xi32>
    %63 = arith.muli %61, %62 : i32
    %64 = arith.addi %47, %63 : i32
    %65 = memref.load %3[] : memref<i32>
    %66 = arith.muli %65, %62 : i32
    %67 = memref.load %30[%c0] : memref<1xi32>
    %68 = arith.muli %66, %67 : i32
    %69 = arith.addi %64, %68 : i32
    %70 = arith.index_cast %69 : i32 to index
    %71 = memref.load %5[] : memref<memref<?xf32>>
    %72 = arith.subi %65, %c1_i32 : i32
    %73 = arith.muli %72, %62 : i32
    %74 = arith.muli %73, %67 : i32
    %75 = arith.addi %64, %74 : i32
    %76 = arith.index_cast %75 : i32 to index
    %77 = arith.addi %76, %c0 : index
    %78 = memref.load %71[%77] : memref<?xf32>
    %79 = arith.addi %70, %c0 : index
    memref.store %78, %59[%79] : memref<?xf32>
  }
  %56 = memref.load %46[] : memref<i1>
  memref.store %56, %45[] : memref<i1>
  %57 = memref.load %45[] : memref<i1>
  %58 = scf.if %57 -> (i32) {
    %59 = memref.load %0[] : memref<i32>
    %60 = arith.addi %47, %c1_i32 : i32
    memref.store %60, %0[] : memref<i32>
    scf.yield %60 : i32
  } else {
    scf.yield %47 : i32
  }
  cf.br ^bb1(%58 : i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %59 = memref.load %4[] : memref<memref<?xf32>>
  %60 = memref.load %0[] : memref<i32>
  %61 = memref.load %2[] : memref<i32>
  %62 = memref.load %49[%c0] : memref<1xi32>
  %63 = arith.muli %61, %62 : i32
  %64 = arith.addi %47, %63 : i32
  %65 = memref.load %3[] : memref<i32>
  %66 = arith.muli %65, %62 : i32
  %67 = memref.load %30[%c0] : memref<1xi32>
  %68 = arith.muli %66, %67 : i32
  %69 = arith.addi %64, %68 : i32
  %70 = arith.index_cast %69 : i32 to index
  %71 = memref.load %5[] : memref<memref<?xf32>>
  %72 = arith.subi %65, %c1_i32 : i32
  %73 = arith.muli %72, %62 : i32
  %74 = arith.muli %73, %67 : i32
  %75 = arith.addi %64, %74 : i32
  %76 = arith.index_cast %75 : i32 to index
  %77 = arith.addi %76, %c0 : index
  %78 = memref.load %71[%77] : memref<?xf32>
  %79 = arith.addi %70, %c0 : index
  memref.store %78, %59[%79] : memref<?xf32>
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %59 = memref.load %4[] : memref<memref<?xf32>>
  %60 = memref.load %0[] : memref<i32>
  %61 = memref.load %2[] : memref<i32>
  %62 = memref.load %49[%c0] : memref<1xi32>
  %63 = arith.muli %61, %62 : i32
  %64 = arith.addi %47, %63 : i32
  %65 = memref.load %3[] : memref<i32>
  %66 = arith.muli %65, %62 : i32
  %67 = memref.load %30[%c0] : memref<1xi32>
  %68 = arith.muli %66, %67 : i32
  %69 = arith.addi %64, %68 : i32
  %70 = arith.index_cast %69 : i32 to index
  %71 = memref.load %5[] : memref<memref<?xf32>>
  %72 = arith.subi %65, %c1_i32 : i32
  %73 = arith.muli %72, %62 : i32
  %74 = arith.muli %73, %67 : i32
  %75 = arith.addi %64, %74 : i32
  %76 = arith.index_cast %75 : i32 to index
  %77 = arith.addi %76, %c0 : index
  %78 = memref.load %71[%77] : memref<?xf32>
  %79 = arith.addi %70, %c0 : index
  memref.store %78, %59[%79] : memref<?xf32>
  scf.yield
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%61 = memref.load %2[] : memref<i32>

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %59 = memref.load %0[] : memref<i32>
  %60 = arith.addi %47, %c1_i32 : i32
  memref.store %60, %0[] : memref<i32>
  scf.yield %60 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %59 = memref.load %0[] : memref<i32>
  %60 = arith.addi %47, %c1_i32 : i32
  memref.store %60, %0[] : memref<i32>
  scf.yield %60 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %47 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %47 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %54 = memref.load %46[] : memref<i1>
  memref.store %54, %45[] : memref<i1>
  %55 = memref.load %45[] : memref<i1>
  scf.if %55 {
    %59 = memref.load %4[] : memref<memref<?xf32>>
    %60 = memref.load %0[] : memref<i32>
    %61 = memref.load %2[] : memref<i32>
    %62 = memref.load %49[%c0] : memref<1xi32>
    %63 = arith.muli %61, %62 : i32
    %64 = arith.addi %47, %63 : i32
    %65 = memref.load %3[] : memref<i32>
    %66 = arith.muli %65, %62 : i32
    %67 = memref.load %30[%c0] : memref<1xi32>
    %68 = arith.muli %66, %67 : i32
    %69 = arith.addi %64, %68 : i32
    %70 = arith.index_cast %69 : i32 to index
    %71 = memref.load %5[] : memref<memref<?xf32>>
    %72 = arith.subi %65, %c1_i32 : i32
    %73 = arith.muli %72, %62 : i32
    %74 = arith.muli %73, %67 : i32
    %75 = arith.addi %64, %74 : i32
    %76 = arith.index_cast %75 : i32 to index
    %77 = arith.addi %76, %c0 : index
    %78 = memref.load %71[%77] : memref<?xf32>
    %79 = arith.addi %70, %c0 : index
    memref.store %78, %59[%79] : memref<?xf32>
  }
  %56 = memref.load %46[] : memref<i1>
  memref.store %56, %45[] : memref<i1>
  %57 = memref.load %45[] : memref<i1>
  %58 = scf.if %57 -> (i32) {
    %59 = memref.load %0[] : memref<i32>
    %60 = arith.addi %47, %c1_i32 : i32
    memref.store %60, %0[] : memref<i32>
    scf.yield %60 : i32
  } else {
    scf.yield %47 : i32
  }
  cf.br ^bb1(%58 : i32)
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %47 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %47 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %42 = scf.execute_region -> i32 {
    %43 = memref.load %26[] : memref<i1>
    %44 = scf.if %43 -> (i32) {
      memref.store %c0_i32, %0[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %28 : i32
    }
    %45 = memref.alloca() : memref<i1>
    %46 = memref.alloca() : memref<i1>
    memref.store %true, %46[] : memref<i1>
    cf.br ^bb1(%44 : i32)
  ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
    %48 = memref.load %0[] : memref<i32>
    %49 = memref.get_global @im : memref<1xi32>
    %50 = memref.load %49[%c0] : memref<1xi32>
    %51 = arith.cmpi slt, %47, %50 : i32
    %52 = memref.load %46[] : memref<i1>
    %53 = arith.andi %51, %52 : i1
    cf.cond_br %53, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %54 = memref.load %46[] : memref<i1>
    memref.store %54, %45[] : memref<i1>
    %55 = memref.load %45[] : memref<i1>
    scf.if %55 {
      %59 = memref.load %4[] : memref<memref<?xf32>>
      %60 = memref.load %0[] : memref<i32>
      %61 = memref.load %2[] : memref<i32>
      %62 = memref.load %49[%c0] : memref<1xi32>
      %63 = arith.muli %61, %62 : i32
      %64 = arith.addi %47, %63 : i32
      %65 = memref.load %3[] : memref<i32>
      %66 = arith.muli %65, %62 : i32
      %67 = memref.load %30[%c0] : memref<1xi32>
      %68 = arith.muli %66, %67 : i32
      %69 = arith.addi %64, %68 : i32
      %70 = arith.index_cast %69 : i32 to index
      %71 = memref.load %5[] : memref<memref<?xf32>>
      %72 = arith.subi %65, %c1_i32 : i32
      %73 = arith.muli %72, %62 : i32
      %74 = arith.muli %73, %67 : i32
      %75 = arith.addi %64, %74 : i32
      %76 = arith.index_cast %75 : i32 to index
      %77 = arith.addi %76, %c0 : index
      %78 = memref.load %71[%77] : memref<?xf32>
      %79 = arith.addi %70, %c0 : index
      memref.store %78, %59[%79] : memref<?xf32>
    }
    %56 = memref.load %46[] : memref<i1>
    memref.store %56, %45[] : memref<i1>
    %57 = memref.load %45[] : memref<i1>
    %58 = scf.if %57 -> (i32) {
      %59 = memref.load %0[] : memref<i32>
      %60 = arith.addi %47, %c1_i32 : i32
      memref.store %60, %0[] : memref<i32>
      scf.yield %60 : i32
    } else {
      scf.yield %47 : i32
    }
    cf.br ^bb1(%58 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %47 : i32
  }
  scf.yield %42 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %28 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %28 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %40 = memref.load %26[] : memref<i1>
  %41 = scf.if %40 -> (i32) {
    %42 = scf.execute_region -> i32 {
      %43 = memref.load %26[] : memref<i1>
      %44 = scf.if %43 -> (i32) {
        memref.store %c0_i32, %0[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %28 : i32
      }
      %45 = memref.alloca() : memref<i1>
      %46 = memref.alloca() : memref<i1>
      memref.store %true, %46[] : memref<i1>
      cf.br ^bb1(%44 : i32)
    ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
      %48 = memref.load %0[] : memref<i32>
      %49 = memref.get_global @im : memref<1xi32>
      %50 = memref.load %49[%c0] : memref<1xi32>
      %51 = arith.cmpi slt, %47, %50 : i32
      %52 = memref.load %46[] : memref<i1>
      %53 = arith.andi %51, %52 : i1
      cf.cond_br %53, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %54 = memref.load %46[] : memref<i1>
      memref.store %54, %45[] : memref<i1>
      %55 = memref.load %45[] : memref<i1>
      scf.if %55 {
        %59 = memref.load %4[] : memref<memref<?xf32>>
        %60 = memref.load %0[] : memref<i32>
        %61 = memref.load %2[] : memref<i32>
        %62 = memref.load %49[%c0] : memref<1xi32>
        %63 = arith.muli %61, %62 : i32
        %64 = arith.addi %47, %63 : i32
        %65 = memref.load %3[] : memref<i32>
        %66 = arith.muli %65, %62 : i32
        %67 = memref.load %30[%c0] : memref<1xi32>
        %68 = arith.muli %66, %67 : i32
        %69 = arith.addi %64, %68 : i32
        %70 = arith.index_cast %69 : i32 to index
        %71 = memref.load %5[] : memref<memref<?xf32>>
        %72 = arith.subi %65, %c1_i32 : i32
        %73 = arith.muli %72, %62 : i32
        %74 = arith.muli %73, %67 : i32
        %75 = arith.addi %64, %74 : i32
        %76 = arith.index_cast %75 : i32 to index
        %77 = arith.addi %76, %c0 : index
        %78 = memref.load %71[%77] : memref<?xf32>
        %79 = arith.addi %70, %c0 : index
        memref.store %78, %59[%79] : memref<?xf32>
      }
      %56 = memref.load %46[] : memref<i1>
      memref.store %56, %45[] : memref<i1>
      %57 = memref.load %45[] : memref<i1>
      %58 = scf.if %57 -> (i32) {
        %59 = memref.load %0[] : memref<i32>
        %60 = arith.addi %47, %c1_i32 : i32
        memref.store %60, %0[] : memref<i32>
        scf.yield %60 : i32
      } else {
        scf.yield %47 : i32
      }
      cf.br ^bb1(%58 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %47 : i32
    }
    scf.yield %42 : i32
  } else {
    scf.yield %28 : i32
  }
  scf.yield %41 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %28 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %28 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %40 = memref.load %2[] : memref<i32>
  %41 = arith.addi %40, %c1_i32 : i32
  memref.store %41, %2[] : memref<i32>
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %40 = memref.load %2[] : memref<i32>
  %41 = arith.addi %40, %c1_i32 : i32
  memref.store %41, %2[] : memref<i32>
  scf.yield
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = arith.addi %40, %c1_i32 : i32
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %39 {
  %40 = memref.load %2[] : memref<i32>
  %41 = arith.addi %40, %c1_i32 : i32
  memref.store %41, %2[] : memref<i32>
}

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %28 : i32

mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %28 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %28 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %28 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %24 = scf.execute_region -> i32 {
    %25 = memref.load %10[] : memref<i1>
    scf.if %25 {
      memref.store %c0_i32, %2[] : memref<i32>
    }
    %26 = memref.alloca() : memref<i1>
    %27 = memref.alloca() : memref<i1>
    memref.store %true, %27[] : memref<i1>
    cf.br ^bb1(%12 : i32)
  ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
    %29 = memref.load %2[] : memref<i32>
    %30 = memref.get_global @jm : memref<1xi32>
    %31 = memref.load %30[%c0] : memref<1xi32>
    %32 = arith.cmpi slt, %29, %31 : i32
    %33 = memref.load %27[] : memref<i1>
    %34 = arith.andi %32, %33 : i1
    cf.cond_br %34, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %35 = memref.load %27[] : memref<i1>
    memref.store %35, %26[] : memref<i1>
    %36 = memref.load %26[] : memref<i1>
    %37 = scf.if %36 -> (i32) {
      %40 = memref.load %26[] : memref<i1>
      %41 = scf.if %40 -> (i32) {
        %42 = scf.execute_region -> i32 {
          %43 = memref.load %26[] : memref<i1>
          %44 = scf.if %43 -> (i32) {
            memref.store %c0_i32, %0[] : memref<i32>
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %28 : i32
          }
          %45 = memref.alloca() : memref<i1>
          %46 = memref.alloca() : memref<i1>
          memref.store %true, %46[] : memref<i1>
          cf.br ^bb1(%44 : i32)
        ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
          %48 = memref.load %0[] : memref<i32>
          %49 = memref.get_global @im : memref<1xi32>
          %50 = memref.load %49[%c0] : memref<1xi32>
          %51 = arith.cmpi slt, %47, %50 : i32
          %52 = memref.load %46[] : memref<i1>
          %53 = arith.andi %51, %52 : i1
          cf.cond_br %53, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %54 = memref.load %46[] : memref<i1>
          memref.store %54, %45[] : memref<i1>
          %55 = memref.load %45[] : memref<i1>
          scf.if %55 {
            %59 = memref.load %4[] : memref<memref<?xf32>>
            %60 = memref.load %0[] : memref<i32>
            %61 = memref.load %2[] : memref<i32>
            %62 = memref.load %49[%c0] : memref<1xi32>
            %63 = arith.muli %61, %62 : i32
            %64 = arith.addi %47, %63 : i32
            %65 = memref.load %3[] : memref<i32>
            %66 = arith.muli %65, %62 : i32
            %67 = memref.load %30[%c0] : memref<1xi32>
            %68 = arith.muli %66, %67 : i32
            %69 = arith.addi %64, %68 : i32
            %70 = arith.index_cast %69 : i32 to index
            %71 = memref.load %5[] : memref<memref<?xf32>>
            %72 = arith.subi %65, %c1_i32 : i32
            %73 = arith.muli %72, %62 : i32
            %74 = arith.muli %73, %67 : i32
            %75 = arith.addi %64, %74 : i32
            %76 = arith.index_cast %75 : i32 to index
            %77 = arith.addi %76, %c0 : index
            %78 = memref.load %71[%77] : memref<?xf32>
            %79 = arith.addi %70, %c0 : index
            memref.store %78, %59[%79] : memref<?xf32>
          }
          %56 = memref.load %46[] : memref<i1>
          memref.store %56, %45[] : memref<i1>
          %57 = memref.load %45[] : memref<i1>
          %58 = scf.if %57 -> (i32) {
            %59 = memref.load %0[] : memref<i32>
            %60 = arith.addi %47, %c1_i32 : i32
            memref.store %60, %0[] : memref<i32>
            scf.yield %60 : i32
          } else {
            scf.yield %47 : i32
          }
          cf.br ^bb1(%58 : i32)
        ^bb3:  // pred: ^bb1
          scf.yield %47 : i32
        }
        scf.yield %42 : i32
      } else {
        scf.yield %28 : i32
      }
      scf.yield %41 : i32
    } else {
      scf.yield %28 : i32
    }
    %38 = memref.load %27[] : memref<i1>
    memref.store %38, %26[] : memref<i1>
    %39 = memref.load %26[] : memref<i1>
    scf.if %39 {
      %40 = memref.load %2[] : memref<i32>
      %41 = arith.addi %40, %c1_i32 : i32
      memref.store %41, %2[] : memref<i32>
    }
    cf.br ^bb1(%37 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %28 : i32
  }
  scf.yield %24 : i32
 with val:exOp:mlir-asm-printer: Verifying operation: func.func
%24 = scf.execute_region -> i32 {
  %25 = memref.load %10[] : memref<i1>
  scf.if %25 {
    memref.store %c0_i32, %2[] : memref<i32>
  }
  %26 = memref.alloca() : memref<i1>
  %27 = memref.alloca() : memref<i1>
  memref.store %true, %27[] : memref<i1>
  cf.br ^bb1(%12 : i32)
^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
  %29 = memref.load %2[] : memref<i32>
  %30 = memref.get_global @jm : memref<1xi32>
  %31 = memref.load %30[%c0] : memref<1xi32>
  %32 = arith.cmpi slt, %29, %31 : i32
  %33 = memref.load %27[] : memref<i1>
  %34 = arith.andi %32, %33 : i1
  cf.cond_br %34, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %35 = memref.load %27[] : memref<i1>
  memref.store %35, %26[] : memref<i1>
  %36 = memref.load %26[] : memref<i1>
  %37 = scf.if %36 -> (i32) {
    %40 = memref.load %26[] : memref<i1>
    %41 = scf.if %40 -> (i32) {
      %42 = scf.execute_region -> i32 {
        %43 = memref.load %26[] : memref<i1>
        %44 = scf.if %43 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %28 : i32
        }
        %45 = memref.alloca() : memref<i1>
        %46 = memref.alloca() : memref<i1>
        memref.store %true, %46[] : memref<i1>
        cf.br ^bb1(%44 : i32)
      ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
        %48 = memref.load %0[] : memref<i32>
        %49 = memref.get_global @im : memref<1xi32>
        %50 = memref.load %49[%c0] : memref<1xi32>
        %51 = arith.cmpi slt, %47, %50 : i32
        %52 = memref.load %46[] : memref<i1>
        %53 = arith.andi %51, %52 : i1
        cf.cond_br %53, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %54 = memref.load %46[] : memref<i1>
        memref.store %54, %45[] : memref<i1>
        %55 = memref.load %45[] : memref<i1>
        scf.if %55 {
          %59 = memref.load %4[] : memref<memref<?xf32>>
          %60 = memref.load %0[] : memref<i32>
          %61 = memref.load %2[] : memref<i32>
          %62 = memref.load %49[%c0] : memref<1xi32>
          %63 = arith.muli %61, %62 : i32
          %64 = arith.addi %47, %63 : i32
          %65 = memref.load %3[] : memref<i32>
          %66 = arith.muli %65, %62 : i32
          %67 = memref.load %30[%c0] : memref<1xi32>
          %68 = arith.muli %66, %67 : i32
          %69 = arith.addi %64, %68 : i32
          %70 = arith.index_cast %69 : i32 to index
          %71 = memref.load %5[] : memref<memref<?xf32>>
          %72 = arith.subi %65, %c1_i32 : i32
          %73 = arith.muli %72, %62 : i32
          %74 = arith.muli %73, %67 : i32
          %75 = arith.addi %64, %74 : i32
          %76 = arith.index_cast %75 : i32 to index
          %77 = arith.addi %76, %c0 : index
          %78 = memref.load %71[%77] : memref<?xf32>
          %79 = arith.addi %70, %c0 : index
          memref.store %78, %59[%79] : memref<?xf32>
        }
        %56 = memref.load %46[] : memref<i1>
        memref.store %56, %45[] : memref<i1>
        %57 = memref.load %45[] : memref<i1>
        %58 = scf.if %57 -> (i32) {
          %59 = memref.load %0[] : memref<i32>
          %60 = arith.addi %47, %c1_i32 : i32
          memref.store %60, %0[] : memref<i32>
          scf.yield %60 : i32
        } else {
          scf.yield %47 : i32
        }
        cf.br ^bb1(%58 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %47 : i32
      }
      scf.yield %42 : i32
    } else {
      scf.yield %28 : i32
    }
    scf.yield %41 : i32
  } else {
    scf.yield %28 : i32
  }
  %38 = memref.load %27[] : memref<i1>
  memref.store %38, %26[] : memref<i1>
  %39 = memref.load %26[] : memref<i1>
  scf.if %39 {
    %40 = memref.load %2[] : memref<i32>
    %41 = arith.addi %40, %c1_i32 : i32
    memref.store %41, %2[] : memref<i32>
  }
  cf.br ^bb1(%37 : i32)
^bb3:  // pred: ^bb1
  scf.yield %28 : i32
}

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %17 = memref.load %11[] : memref<i1>
  memref.store %17, %10[] : memref<i1>
  %18 = memref.load %10[] : memref<i1>
  %19 = scf.if %18 -> (i32) {
    %22 = memref.load %10[] : memref<i1>
    %23 = scf.if %22 -> (i32) {
      %24 = scf.execute_region -> i32 {
        %25 = memref.load %10[] : memref<i1>
        scf.if %25 {
          memref.store %c0_i32, %2[] : memref<i32>
        }
        %26 = memref.alloca() : memref<i1>
        %27 = memref.alloca() : memref<i1>
        memref.store %true, %27[] : memref<i1>
        cf.br ^bb1(%12 : i32)
      ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
        %29 = memref.load %2[] : memref<i32>
        %30 = memref.get_global @jm : memref<1xi32>
        %31 = memref.load %30[%c0] : memref<1xi32>
        %32 = arith.cmpi slt, %29, %31 : i32
        %33 = memref.load %27[] : memref<i1>
        %34 = arith.andi %32, %33 : i1
        cf.cond_br %34, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %35 = memref.load %27[] : memref<i1>
        memref.store %35, %26[] : memref<i1>
        %36 = memref.load %26[] : memref<i1>
        %37 = scf.if %36 -> (i32) {
          %40 = memref.load %26[] : memref<i1>
          %41 = scf.if %40 -> (i32) {
            %42 = scf.execute_region -> i32 {
              %43 = memref.load %26[] : memref<i1>
              %44 = scf.if %43 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %28 : i32
              }
              %45 = memref.alloca() : memref<i1>
              %46 = memref.alloca() : memref<i1>
              memref.store %true, %46[] : memref<i1>
              cf.br ^bb1(%44 : i32)
            ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
              %48 = memref.load %0[] : memref<i32>
              %49 = memref.get_global @im : memref<1xi32>
              %50 = memref.load %49[%c0] : memref<1xi32>
              %51 = arith.cmpi slt, %47, %50 : i32
              %52 = memref.load %46[] : memref<i1>
              %53 = arith.andi %51, %52 : i1
              cf.cond_br %53, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %54 = memref.load %46[] : memref<i1>
              memref.store %54, %45[] : memref<i1>
              %55 = memref.load %45[] : memref<i1>
              scf.if %55 {
                %59 = memref.load %4[] : memref<memref<?xf32>>
                %60 = memref.load %0[] : memref<i32>
                %61 = memref.load %2[] : memref<i32>
                %62 = memref.load %49[%c0] : memref<1xi32>
                %63 = arith.muli %61, %62 : i32
                %64 = arith.addi %47, %63 : i32
                %65 = memref.load %3[] : memref<i32>
                %66 = arith.muli %65, %62 : i32
                %67 = memref.load %30[%c0] : memref<1xi32>
                %68 = arith.muli %66, %67 : i32
                %69 = arith.addi %64, %68 : i32
                %70 = arith.index_cast %69 : i32 to index
                %71 = memref.load %5[] : memref<memref<?xf32>>
                %72 = arith.subi %65, %c1_i32 : i32
                %73 = arith.muli %72, %62 : i32
                %74 = arith.muli %73, %67 : i32
                %75 = arith.addi %64, %74 : i32
                %76 = arith.index_cast %75 : i32 to index
                %77 = arith.addi %76, %c0 : index
                %78 = memref.load %71[%77] : memref<?xf32>
                %79 = arith.addi %70, %c0 : index
                memref.store %78, %59[%79] : memref<?xf32>
              }
              %56 = memref.load %46[] : memref<i1>
              memref.store %56, %45[] : memref<i1>
              %57 = memref.load %45[] : memref<i1>
              %58 = scf.if %57 -> (i32) {
                %59 = memref.load %0[] : memref<i32>
                %60 = arith.addi %47, %c1_i32 : i32
                memref.store %60, %0[] : memref<i32>
                scf.yield %60 : i32
              } else {
                scf.yield %47 : i32
              }
              cf.br ^bb1(%58 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %47 : i32
            }
            scf.yield %42 : i32
          } else {
            scf.yield %28 : i32
          }
          scf.yield %41 : i32
        } else {
          scf.yield %28 : i32
        }
        %38 = memref.load %27[] : memref<i1>
        memref.store %38, %26[] : memref<i1>
        %39 = memref.load %26[] : memref<i1>
        scf.if %39 {
          %40 = memref.load %2[] : memref<i32>
          %41 = arith.addi %40, %c1_i32 : i32
          memref.store %41, %2[] : memref<i32>
        }
        cf.br ^bb1(%37 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %28 : i32
      }
      scf.yield %24 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %23 : i32
  } else {
    scf.yield %12 : i32
  }
  %20 = memref.load %11[] : memref<i1>
  memref.store %20, %10[] : memref<i1>
  %21 = memref.load %10[] : memref<i1>
  scf.if %21 {
    %22 = memref.load %3[] : memref<i32>
    %23 = arith.subi %22, %c1_i32 : i32
    memref.store %23, %3[] : memref<i32>
  }
  cf.br ^bb1(%19 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %12 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %12 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %17 = memref.load %11[] : memref<i1>
  memref.store %17, %10[] : memref<i1>
  %18 = memref.load %10[] : memref<i1>
  %19 = scf.if %18 -> (i32) {
    %22 = memref.load %10[] : memref<i1>
    %23 = scf.if %22 -> (i32) {
      %24 = scf.execute_region -> i32 {
        %25 = memref.load %10[] : memref<i1>
        scf.if %25 {
          memref.store %c0_i32, %2[] : memref<i32>
        }
        %26 = memref.alloca() : memref<i1>
        %27 = memref.alloca() : memref<i1>
        memref.store %true, %27[] : memref<i1>
        cf.br ^bb1(%12 : i32)
      ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
        %29 = memref.load %2[] : memref<i32>
        %30 = memref.get_global @jm : memref<1xi32>
        %31 = memref.load %30[%c0] : memref<1xi32>
        %32 = arith.cmpi slt, %29, %31 : i32
        %33 = memref.load %27[] : memref<i1>
        %34 = arith.andi %32, %33 : i1
        cf.cond_br %34, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %35 = memref.load %27[] : memref<i1>
        memref.store %35, %26[] : memref<i1>
        %36 = memref.load %26[] : memref<i1>
        %37 = scf.if %36 -> (i32) {
          %40 = memref.load %26[] : memref<i1>
          %41 = scf.if %40 -> (i32) {
            %42 = scf.execute_region -> i32 {
              %43 = memref.load %26[] : memref<i1>
              %44 = scf.if %43 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %28 : i32
              }
              %45 = memref.alloca() : memref<i1>
              %46 = memref.alloca() : memref<i1>
              memref.store %true, %46[] : memref<i1>
              cf.br ^bb1(%44 : i32)
            ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
              %48 = memref.load %0[] : memref<i32>
              %49 = memref.get_global @im : memref<1xi32>
              %50 = memref.load %49[%c0] : memref<1xi32>
              %51 = arith.cmpi slt, %47, %50 : i32
              %52 = memref.load %46[] : memref<i1>
              %53 = arith.andi %51, %52 : i1
              cf.cond_br %53, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %54 = memref.load %46[] : memref<i1>
              memref.store %54, %45[] : memref<i1>
              %55 = memref.load %45[] : memref<i1>
              scf.if %55 {
                %59 = memref.load %4[] : memref<memref<?xf32>>
                %60 = memref.load %0[] : memref<i32>
                %61 = memref.load %2[] : memref<i32>
                %62 = memref.load %49[%c0] : memref<1xi32>
                %63 = arith.muli %61, %62 : i32
                %64 = arith.addi %47, %63 : i32
                %65 = memref.load %3[] : memref<i32>
                %66 = arith.muli %65, %62 : i32
                %67 = memref.load %30[%c0] : memref<1xi32>
                %68 = arith.muli %66, %67 : i32
                %69 = arith.addi %64, %68 : i32
                %70 = arith.index_cast %69 : i32 to index
                %71 = memref.load %5[] : memref<memref<?xf32>>
                %72 = arith.subi %65, %c1_i32 : i32
                %73 = arith.muli %72, %62 : i32
                %74 = arith.muli %73, %67 : i32
                %75 = arith.addi %64, %74 : i32
                %76 = arith.index_cast %75 : i32 to index
                %77 = arith.addi %76, %c0 : index
                %78 = memref.load %71[%77] : memref<?xf32>
                %79 = arith.addi %70, %c0 : index
                memref.store %78, %59[%79] : memref<?xf32>
              }
              %56 = memref.load %46[] : memref<i1>
              memref.store %56, %45[] : memref<i1>
              %57 = memref.load %45[] : memref<i1>
              %58 = scf.if %57 -> (i32) {
                %59 = memref.load %0[] : memref<i32>
                %60 = arith.addi %47, %c1_i32 : i32
                memref.store %60, %0[] : memref<i32>
                scf.yield %60 : i32
              } else {
                scf.yield %47 : i32
              }
              cf.br ^bb1(%58 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %47 : i32
            }
            scf.yield %42 : i32
          } else {
            scf.yield %28 : i32
          }
          scf.yield %41 : i32
        } else {
          scf.yield %28 : i32
        }
        %38 = memref.load %27[] : memref<i1>
        memref.store %38, %26[] : memref<i1>
        %39 = memref.load %26[] : memref<i1>
        scf.if %39 {
          %40 = memref.load %2[] : memref<i32>
          %41 = arith.addi %40, %c1_i32 : i32
          memref.store %41, %2[] : memref<i32>
        }
        cf.br ^bb1(%37 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %28 : i32
      }
      scf.yield %24 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %23 : i32
  } else {
    scf.yield %12 : i32
  }
  %20 = memref.load %11[] : memref<i1>
  memref.store %20, %10[] : memref<i1>
  %21 = memref.load %10[] : memref<i1>
  scf.if %21 {
    %22 = memref.load %3[] : memref<i32>
    %23 = arith.subi %22, %c1_i32 : i32
    memref.store %23, %3[] : memref<i32>
  }
  cf.br ^bb1(%19 : i32)

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %22 = memref.load %10[] : memref<i1>
  %23 = scf.if %22 -> (i32) {
    %24 = scf.execute_region -> i32 {
      %25 = memref.load %10[] : memref<i1>
      scf.if %25 {
        memref.store %c0_i32, %2[] : memref<i32>
      }
      %26 = memref.alloca() : memref<i1>
      %27 = memref.alloca() : memref<i1>
      memref.store %true, %27[] : memref<i1>
      cf.br ^bb1(%12 : i32)
    ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
      %29 = memref.load %2[] : memref<i32>
      %30 = memref.get_global @jm : memref<1xi32>
      %31 = memref.load %30[%c0] : memref<1xi32>
      %32 = arith.cmpi slt, %29, %31 : i32
      %33 = memref.load %27[] : memref<i1>
      %34 = arith.andi %32, %33 : i1
      cf.cond_br %34, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %35 = memref.load %27[] : memref<i1>
      memref.store %35, %26[] : memref<i1>
      %36 = memref.load %26[] : memref<i1>
      %37 = scf.if %36 -> (i32) {
        %40 = memref.load %26[] : memref<i1>
        %41 = scf.if %40 -> (i32) {
          %42 = scf.execute_region -> i32 {
            %43 = memref.load %26[] : memref<i1>
            %44 = scf.if %43 -> (i32) {
              memref.store %c0_i32, %0[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %28 : i32
            }
            %45 = memref.alloca() : memref<i1>
            %46 = memref.alloca() : memref<i1>
            memref.store %true, %46[] : memref<i1>
            cf.br ^bb1(%44 : i32)
          ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
            %48 = memref.load %0[] : memref<i32>
            %49 = memref.get_global @im : memref<1xi32>
            %50 = memref.load %49[%c0] : memref<1xi32>
            %51 = arith.cmpi slt, %47, %50 : i32
            %52 = memref.load %46[] : memref<i1>
            %53 = arith.andi %51, %52 : i1
            cf.cond_br %53, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %54 = memref.load %46[] : memref<i1>
            memref.store %54, %45[] : memref<i1>
            %55 = memref.load %45[] : memref<i1>
            scf.if %55 {
              %59 = memref.load %4[] : memref<memref<?xf32>>
              %60 = memref.load %0[] : memref<i32>
              %61 = memref.load %2[] : memref<i32>
              %62 = memref.load %49[%c0] : memref<1xi32>
              %63 = arith.muli %61, %62 : i32
              %64 = arith.addi %47, %63 : i32
              %65 = memref.load %3[] : memref<i32>
              %66 = arith.muli %65, %62 : i32
              %67 = memref.load %30[%c0] : memref<1xi32>
              %68 = arith.muli %66, %67 : i32
              %69 = arith.addi %64, %68 : i32
              %70 = arith.index_cast %69 : i32 to index
              %71 = memref.load %5[] : memref<memref<?xf32>>
              %72 = arith.subi %65, %c1_i32 : i32
              %73 = arith.muli %72, %62 : i32
              %74 = arith.muli %73, %67 : i32
              %75 = arith.addi %64, %74 : i32
              %76 = arith.index_cast %75 : i32 to index
              %77 = arith.addi %76, %c0 : index
              %78 = memref.load %71[%77] : memref<?xf32>
              %79 = arith.addi %70, %c0 : index
              memref.store %78, %59[%79] : memref<?xf32>
            }
            %56 = memref.load %46[] : memref<i1>
            memref.store %56, %45[] : memref<i1>
            %57 = memref.load %45[] : memref<i1>
            %58 = scf.if %57 -> (i32) {
              %59 = memref.load %0[] : memref<i32>
              %60 = arith.addi %47, %c1_i32 : i32
              memref.store %60, %0[] : memref<i32>
              scf.yield %60 : i32
            } else {
              scf.yield %47 : i32
            }
            cf.br ^bb1(%58 : i32)
          ^bb3:  // pred: ^bb1
            scf.yield %47 : i32
          }
          scf.yield %42 : i32
        } else {
          scf.yield %28 : i32
        }
        scf.yield %41 : i32
      } else {
        scf.yield %28 : i32
      }
      %38 = memref.load %27[] : memref<i1>
      memref.store %38, %26[] : memref<i1>
      %39 = memref.load %26[] : memref<i1>
      scf.if %39 {
        %40 = memref.load %2[] : memref<i32>
        %41 = arith.addi %40, %c1_i32 : i32
        memref.store %41, %2[] : memref<i32>
      }
      cf.br ^bb1(%37 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %28 : i32
    }
    scf.yield %24 : i32
  } else {
    scf.yield %12 : i32
  }
  scf.yield %23 : i32
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
%23 = scf.if %22 -> (i32) {
  %24 = scf.execute_region -> i32 {
    %25 = memref.load %10[] : memref<i1>
    scf.if %25 {
      memref.store %c0_i32, %2[] : memref<i32>
    }
    %26 = memref.alloca() : memref<i1>
    %27 = memref.alloca() : memref<i1>
    memref.store %true, %27[] : memref<i1>
    cf.br ^bb1(%12 : i32)
  ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
    %29 = memref.load %2[] : memref<i32>
    %30 = memref.get_global @jm : memref<1xi32>
    %31 = memref.load %30[%c0] : memref<1xi32>
    %32 = arith.cmpi slt, %29, %31 : i32
    %33 = memref.load %27[] : memref<i1>
    %34 = arith.andi %32, %33 : i1
    cf.cond_br %34, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %35 = memref.load %27[] : memref<i1>
    memref.store %35, %26[] : memref<i1>
    %36 = memref.load %26[] : memref<i1>
    %37 = scf.if %36 -> (i32) {
      %40 = memref.load %26[] : memref<i1>
      %41 = scf.if %40 -> (i32) {
        %42 = scf.execute_region -> i32 {
          %43 = memref.load %26[] : memref<i1>
          %44 = scf.if %43 -> (i32) {
            memref.store %c0_i32, %0[] : memref<i32>
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %28 : i32
          }
          %45 = memref.alloca() : memref<i1>
          %46 = memref.alloca() : memref<i1>
          memref.store %true, %46[] : memref<i1>
          cf.br ^bb1(%44 : i32)
        ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
          %48 = memref.load %0[] : memref<i32>
          %49 = memref.get_global @im : memref<1xi32>
          %50 = memref.load %49[%c0] : memref<1xi32>
          %51 = arith.cmpi slt, %47, %50 : i32
          %52 = memref.load %46[] : memref<i1>
          %53 = arith.andi %51, %52 : i1
          cf.cond_br %53, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %54 = memref.load %46[] : memref<i1>
          memref.store %54, %45[] : memref<i1>
          %55 = memref.load %45[] : memref<i1>
          scf.if %55 {
            %59 = memref.load %4[] : memref<memref<?xf32>>
            %60 = memref.load %0[] : memref<i32>
            %61 = memref.load %2[] : memref<i32>
            %62 = memref.load %49[%c0] : memref<1xi32>
            %63 = arith.muli %61, %62 : i32
            %64 = arith.addi %47, %63 : i32
            %65 = memref.load %3[] : memref<i32>
            %66 = arith.muli %65, %62 : i32
            %67 = memref.load %30[%c0] : memref<1xi32>
            %68 = arith.muli %66, %67 : i32
            %69 = arith.addi %64, %68 : i32
            %70 = arith.index_cast %69 : i32 to index
            %71 = memref.load %5[] : memref<memref<?xf32>>
            %72 = arith.subi %65, %c1_i32 : i32
            %73 = arith.muli %72, %62 : i32
            %74 = arith.muli %73, %67 : i32
            %75 = arith.addi %64, %74 : i32
            %76 = arith.index_cast %75 : i32 to index
            %77 = arith.addi %76, %c0 : index
            %78 = memref.load %71[%77] : memref<?xf32>
            %79 = arith.addi %70, %c0 : index
            memref.store %78, %59[%79] : memref<?xf32>
          }
          %56 = memref.load %46[] : memref<i1>
          memref.store %56, %45[] : memref<i1>
          %57 = memref.load %45[] : memref<i1>
          %58 = scf.if %57 -> (i32) {
            %59 = memref.load %0[] : memref<i32>
            %60 = arith.addi %47, %c1_i32 : i32
            memref.store %60, %0[] : memref<i32>
            scf.yield %60 : i32
          } else {
            scf.yield %47 : i32
          }
          cf.br ^bb1(%58 : i32)
        ^bb3:  // pred: ^bb1
          scf.yield %47 : i32
        }
        scf.yield %42 : i32
      } else {
        scf.yield %28 : i32
      }
      scf.yield %41 : i32
    } else {
      scf.yield %28 : i32
    }
    %38 = memref.load %27[] : memref<i1>
    memref.store %38, %26[] : memref<i1>
    %39 = memref.load %26[] : memref<i1>
    scf.if %39 {
      %40 = memref.load %2[] : memref<i32>
      %41 = arith.addi %40, %c1_i32 : i32
      memref.store %41, %2[] : memref<i32>
    }
    cf.br ^bb1(%37 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %28 : i32
  }
  scf.yield %24 : i32
} else {
  scf.yield %12 : i32
}

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %17 = memref.load %11[] : memref<i1>
  memref.store %17, %10[] : memref<i1>
  %18 = memref.load %10[] : memref<i1>
  %19 = scf.if %18 -> (i32) {
    %22 = memref.load %10[] : memref<i1>
    %23 = scf.if %22 -> (i32) {
      %24 = scf.execute_region -> i32 {
        %25 = memref.load %10[] : memref<i1>
        scf.if %25 {
          memref.store %c0_i32, %2[] : memref<i32>
        }
        %26 = memref.alloca() : memref<i1>
        %27 = memref.alloca() : memref<i1>
        memref.store %true, %27[] : memref<i1>
        cf.br ^bb1(%12 : i32)
      ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
        %29 = memref.load %2[] : memref<i32>
        %30 = memref.get_global @jm : memref<1xi32>
        %31 = memref.load %30[%c0] : memref<1xi32>
        %32 = arith.cmpi slt, %29, %31 : i32
        %33 = memref.load %27[] : memref<i1>
        %34 = arith.andi %32, %33 : i1
        cf.cond_br %34, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %35 = memref.load %27[] : memref<i1>
        memref.store %35, %26[] : memref<i1>
        %36 = memref.load %26[] : memref<i1>
        %37 = scf.if %36 -> (i32) {
          %40 = memref.load %26[] : memref<i1>
          %41 = scf.if %40 -> (i32) {
            %42 = scf.execute_region -> i32 {
              %43 = memref.load %26[] : memref<i1>
              %44 = scf.if %43 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %28 : i32
              }
              %45 = memref.alloca() : memref<i1>
              %46 = memref.alloca() : memref<i1>
              memref.store %true, %46[] : memref<i1>
              cf.br ^bb1(%44 : i32)
            ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
              %48 = memref.load %0[] : memref<i32>
              %49 = memref.get_global @im : memref<1xi32>
              %50 = memref.load %49[%c0] : memref<1xi32>
              %51 = arith.cmpi slt, %47, %50 : i32
              %52 = memref.load %46[] : memref<i1>
              %53 = arith.andi %51, %52 : i1
              cf.cond_br %53, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %54 = memref.load %46[] : memref<i1>
              memref.store %54, %45[] : memref<i1>
              %55 = memref.load %45[] : memref<i1>
              scf.if %55 {
                %59 = memref.load %4[] : memref<memref<?xf32>>
                %60 = memref.load %0[] : memref<i32>
                %61 = memref.load %2[] : memref<i32>
                %62 = memref.load %49[%c0] : memref<1xi32>
                %63 = arith.muli %61, %62 : i32
                %64 = arith.addi %47, %63 : i32
                %65 = memref.load %3[] : memref<i32>
                %66 = arith.muli %65, %62 : i32
                %67 = memref.load %30[%c0] : memref<1xi32>
                %68 = arith.muli %66, %67 : i32
                %69 = arith.addi %64, %68 : i32
                %70 = arith.index_cast %69 : i32 to index
                %71 = memref.load %5[] : memref<memref<?xf32>>
                %72 = arith.subi %65, %c1_i32 : i32
                %73 = arith.muli %72, %62 : i32
                %74 = arith.muli %73, %67 : i32
                %75 = arith.addi %64, %74 : i32
                %76 = arith.index_cast %75 : i32 to index
                %77 = arith.addi %76, %c0 : index
                %78 = memref.load %71[%77] : memref<?xf32>
                %79 = arith.addi %70, %c0 : index
                memref.store %78, %59[%79] : memref<?xf32>
              }
              %56 = memref.load %46[] : memref<i1>
              memref.store %56, %45[] : memref<i1>
              %57 = memref.load %45[] : memref<i1>
              %58 = scf.if %57 -> (i32) {
                %59 = memref.load %0[] : memref<i32>
                %60 = arith.addi %47, %c1_i32 : i32
                memref.store %60, %0[] : memref<i32>
                scf.yield %60 : i32
              } else {
                scf.yield %47 : i32
              }
              cf.br ^bb1(%58 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %47 : i32
            }
            scf.yield %42 : i32
          } else {
            scf.yield %28 : i32
          }
          scf.yield %41 : i32
        } else {
          scf.yield %28 : i32
        }
        %38 = memref.load %27[] : memref<i1>
        memref.store %38, %26[] : memref<i1>
        %39 = memref.load %26[] : memref<i1>
        scf.if %39 {
          %40 = memref.load %2[] : memref<i32>
          %41 = arith.addi %40, %c1_i32 : i32
          memref.store %41, %2[] : memref<i32>
        }
        cf.br ^bb1(%37 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %28 : i32
      }
      scf.yield %24 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %23 : i32
  } else {
    scf.yield %12 : i32
  }
  %20 = memref.load %11[] : memref<i1>
  memref.store %20, %10[] : memref<i1>
  %21 = memref.load %10[] : memref<i1>
  scf.if %21 {
    %22 = memref.load %3[] : memref<i32>
    %23 = arith.subi %22, %c1_i32 : i32
    memref.store %23, %3[] : memref<i32>
  }
  cf.br ^bb1(%19 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %12 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %12 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %17 = memref.load %11[] : memref<i1>
  memref.store %17, %10[] : memref<i1>
  %18 = memref.load %10[] : memref<i1>
  %19 = scf.if %18 -> (i32) {
    %22 = memref.load %10[] : memref<i1>
    %23 = scf.if %22 -> (i32) {
      %24 = scf.execute_region -> i32 {
        %25 = memref.load %10[] : memref<i1>
        scf.if %25 {
          memref.store %c0_i32, %2[] : memref<i32>
        }
        %26 = memref.alloca() : memref<i1>
        %27 = memref.alloca() : memref<i1>
        memref.store %true, %27[] : memref<i1>
        cf.br ^bb1(%12 : i32)
      ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
        %29 = memref.load %2[] : memref<i32>
        %30 = memref.get_global @jm : memref<1xi32>
        %31 = memref.load %30[%c0] : memref<1xi32>
        %32 = arith.cmpi slt, %29, %31 : i32
        %33 = memref.load %27[] : memref<i1>
        %34 = arith.andi %32, %33 : i1
        cf.cond_br %34, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %35 = memref.load %27[] : memref<i1>
        memref.store %35, %26[] : memref<i1>
        %36 = memref.load %26[] : memref<i1>
        %37 = scf.if %36 -> (i32) {
          %40 = memref.load %26[] : memref<i1>
          %41 = scf.if %40 -> (i32) {
            %42 = scf.execute_region -> i32 {
              %43 = memref.load %26[] : memref<i1>
              %44 = scf.if %43 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %28 : i32
              }
              %45 = memref.alloca() : memref<i1>
              %46 = memref.alloca() : memref<i1>
              memref.store %true, %46[] : memref<i1>
              cf.br ^bb1(%44 : i32)
            ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
              %48 = memref.load %0[] : memref<i32>
              %49 = memref.get_global @im : memref<1xi32>
              %50 = memref.load %49[%c0] : memref<1xi32>
              %51 = arith.cmpi slt, %47, %50 : i32
              %52 = memref.load %46[] : memref<i1>
              %53 = arith.andi %51, %52 : i1
              cf.cond_br %53, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %54 = memref.load %46[] : memref<i1>
              memref.store %54, %45[] : memref<i1>
              %55 = memref.load %45[] : memref<i1>
              scf.if %55 {
                %59 = memref.load %4[] : memref<memref<?xf32>>
                %60 = memref.load %0[] : memref<i32>
                %61 = memref.load %2[] : memref<i32>
                %62 = memref.load %49[%c0] : memref<1xi32>
                %63 = arith.muli %61, %62 : i32
                %64 = arith.addi %47, %63 : i32
                %65 = memref.load %3[] : memref<i32>
                %66 = arith.muli %65, %62 : i32
                %67 = memref.load %30[%c0] : memref<1xi32>
                %68 = arith.muli %66, %67 : i32
                %69 = arith.addi %64, %68 : i32
                %70 = arith.index_cast %69 : i32 to index
                %71 = memref.load %5[] : memref<memref<?xf32>>
                %72 = arith.subi %65, %c1_i32 : i32
                %73 = arith.muli %72, %62 : i32
                %74 = arith.muli %73, %67 : i32
                %75 = arith.addi %64, %74 : i32
                %76 = arith.index_cast %75 : i32 to index
                %77 = arith.addi %76, %c0 : index
                %78 = memref.load %71[%77] : memref<?xf32>
                %79 = arith.addi %70, %c0 : index
                memref.store %78, %59[%79] : memref<?xf32>
              }
              %56 = memref.load %46[] : memref<i1>
              memref.store %56, %45[] : memref<i1>
              %57 = memref.load %45[] : memref<i1>
              %58 = scf.if %57 -> (i32) {
                %59 = memref.load %0[] : memref<i32>
                %60 = arith.addi %47, %c1_i32 : i32
                memref.store %60, %0[] : memref<i32>
                scf.yield %60 : i32
              } else {
                scf.yield %47 : i32
              }
              cf.br ^bb1(%58 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %47 : i32
            }
            scf.yield %42 : i32
          } else {
            scf.yield %28 : i32
          }
          scf.yield %41 : i32
        } else {
          scf.yield %28 : i32
        }
        %38 = memref.load %27[] : memref<i1>
        memref.store %38, %26[] : memref<i1>
        %39 = memref.load %26[] : memref<i1>
        scf.if %39 {
          %40 = memref.load %2[] : memref<i32>
          %41 = arith.addi %40, %c1_i32 : i32
          memref.store %41, %2[] : memref<i32>
        }
        cf.br ^bb1(%37 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %28 : i32
      }
      scf.yield %24 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %23 : i32
  } else {
    scf.yield %12 : i32
  }
  %20 = memref.load %11[] : memref<i1>
  memref.store %20, %10[] : memref<i1>
  %21 = memref.load %10[] : memref<i1>
  scf.if %21 {
    %22 = memref.load %3[] : memref<i32>
    %23 = arith.subi %22, %c1_i32 : i32
    memref.store %23, %3[] : memref<i32>
  }
  cf.br ^bb1(%19 : i32)


starting block: lastVal=ifOp:mlir-asm-printer: Verifying operation: func.func
%19 = scf.if %18 -> (i32) {
  %22 = memref.load %10[] : memref<i1>
  %23 = scf.if %22 -> (i32) {
    %24 = scf.execute_region -> i32 {
      %25 = memref.load %10[] : memref<i1>
      scf.if %25 {
        memref.store %c0_i32, %2[] : memref<i32>
      }
      %26 = memref.alloca() : memref<i1>
      %27 = memref.alloca() : memref<i1>
      memref.store %true, %27[] : memref<i1>
      cf.br ^bb1(%12 : i32)
    ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
      %29 = memref.load %2[] : memref<i32>
      %30 = memref.get_global @jm : memref<1xi32>
      %31 = memref.load %30[%c0] : memref<1xi32>
      %32 = arith.cmpi slt, %29, %31 : i32
      %33 = memref.load %27[] : memref<i1>
      %34 = arith.andi %32, %33 : i1
      cf.cond_br %34, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %35 = memref.load %27[] : memref<i1>
      memref.store %35, %26[] : memref<i1>
      %36 = memref.load %26[] : memref<i1>
      %37 = scf.if %36 -> (i32) {
        %40 = memref.load %26[] : memref<i1>
        %41 = scf.if %40 -> (i32) {
          %42 = scf.execute_region -> i32 {
            %43 = memref.load %26[] : memref<i1>
            %44 = scf.if %43 -> (i32) {
              memref.store %c0_i32, %0[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %28 : i32
            }
            %45 = memref.alloca() : memref<i1>
            %46 = memref.alloca() : memref<i1>
            memref.store %true, %46[] : memref<i1>
            cf.br ^bb1(%44 : i32)
          ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
            %48 = memref.load %0[] : memref<i32>
            %49 = memref.get_global @im : memref<1xi32>
            %50 = memref.load %49[%c0] : memref<1xi32>
            %51 = arith.cmpi slt, %47, %50 : i32
            %52 = memref.load %46[] : memref<i1>
            %53 = arith.andi %51, %52 : i1
            cf.cond_br %53, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %54 = memref.load %46[] : memref<i1>
            memref.store %54, %45[] : memref<i1>
            %55 = memref.load %45[] : memref<i1>
            scf.if %55 {
              %59 = memref.load %4[] : memref<memref<?xf32>>
              %60 = memref.load %0[] : memref<i32>
              %61 = memref.load %2[] : memref<i32>
              %62 = memref.load %49[%c0] : memref<1xi32>
              %63 = arith.muli %61, %62 : i32
              %64 = arith.addi %47, %63 : i32
              %65 = memref.load %3[] : memref<i32>
              %66 = arith.muli %65, %62 : i32
              %67 = memref.load %30[%c0] : memref<1xi32>
              %68 = arith.muli %66, %67 : i32
              %69 = arith.addi %64, %68 : i32
              %70 = arith.index_cast %69 : i32 to index
              %71 = memref.load %5[] : memref<memref<?xf32>>
              %72 = arith.subi %65, %c1_i32 : i32
              %73 = arith.muli %72, %62 : i32
              %74 = arith.muli %73, %67 : i32
              %75 = arith.addi %64, %74 : i32
              %76 = arith.index_cast %75 : i32 to index
              %77 = arith.addi %76, %c0 : index
              %78 = memref.load %71[%77] : memref<?xf32>
              %79 = arith.addi %70, %c0 : index
              memref.store %78, %59[%79] : memref<?xf32>
            }
            %56 = memref.load %46[] : memref<i1>
            memref.store %56, %45[] : memref<i1>
            %57 = memref.load %45[] : memref<i1>
            %58 = scf.if %57 -> (i32) {
              %59 = memref.load %0[] : memref<i32>
              %60 = arith.addi %47, %c1_i32 : i32
              memref.store %60, %0[] : memref<i32>
              scf.yield %60 : i32
            } else {
              scf.yield %47 : i32
            }
            cf.br ^bb1(%58 : i32)
          ^bb3:  // pred: ^bb1
            scf.yield %47 : i32
          }
          scf.yield %42 : i32
        } else {
          scf.yield %28 : i32
        }
        scf.yield %41 : i32
      } else {
        scf.yield %28 : i32
      }
      %38 = memref.load %27[] : memref<i1>
      memref.store %38, %26[] : memref<i1>
      %39 = memref.load %26[] : memref<i1>
      scf.if %39 {
        %40 = memref.load %2[] : memref<i32>
        %41 = arith.addi %40, %c1_i32 : i32
        memref.store %41, %2[] : memref<i32>
      }
      cf.br ^bb1(%37 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %28 : i32
    }
    scf.yield %24 : i32
  } else {
    scf.yield %12 : i32
  }
  scf.yield %23 : i32
} else {
  scf.yield %12 : i32
}
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %22 = memref.load %3[] : memref<i32>
  %23 = arith.subi %22, %c1_i32 : i32
  memref.store %23, %3[] : memref<i32>
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %22 = memref.load %3[] : memref<i32>
  %23 = arith.subi %22, %c1_i32 : i32
  memref.store %23, %3[] : memref<i32>
  scf.yield
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
%19 = scf.if %18 -> (i32) {
  %22 = memref.load %10[] : memref<i1>
  %23 = scf.if %22 -> (i32) {
    %24 = scf.execute_region -> i32 {
      %25 = memref.load %10[] : memref<i1>
      scf.if %25 {
        memref.store %c0_i32, %2[] : memref<i32>
      }
      %26 = memref.alloca() : memref<i1>
      %27 = memref.alloca() : memref<i1>
      memref.store %true, %27[] : memref<i1>
      cf.br ^bb1(%12 : i32)
    ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
      %29 = memref.load %2[] : memref<i32>
      %30 = memref.get_global @jm : memref<1xi32>
      %31 = memref.load %30[%c0] : memref<1xi32>
      %32 = arith.cmpi slt, %29, %31 : i32
      %33 = memref.load %27[] : memref<i1>
      %34 = arith.andi %32, %33 : i1
      cf.cond_br %34, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %35 = memref.load %27[] : memref<i1>
      memref.store %35, %26[] : memref<i1>
      %36 = memref.load %26[] : memref<i1>
      %37 = scf.if %36 -> (i32) {
        %40 = memref.load %26[] : memref<i1>
        %41 = scf.if %40 -> (i32) {
          %42 = scf.execute_region -> i32 {
            %43 = memref.load %26[] : memref<i1>
            %44 = scf.if %43 -> (i32) {
              memref.store %c0_i32, %0[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %28 : i32
            }
            %45 = memref.alloca() : memref<i1>
            %46 = memref.alloca() : memref<i1>
            memref.store %true, %46[] : memref<i1>
            cf.br ^bb1(%44 : i32)
          ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
            %48 = memref.load %0[] : memref<i32>
            %49 = memref.get_global @im : memref<1xi32>
            %50 = memref.load %49[%c0] : memref<1xi32>
            %51 = arith.cmpi slt, %47, %50 : i32
            %52 = memref.load %46[] : memref<i1>
            %53 = arith.andi %51, %52 : i1
            cf.cond_br %53, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %54 = memref.load %46[] : memref<i1>
            memref.store %54, %45[] : memref<i1>
            %55 = memref.load %45[] : memref<i1>
            scf.if %55 {
              %59 = memref.load %4[] : memref<memref<?xf32>>
              %60 = memref.load %0[] : memref<i32>
              %61 = memref.load %2[] : memref<i32>
              %62 = memref.load %49[%c0] : memref<1xi32>
              %63 = arith.muli %61, %62 : i32
              %64 = arith.addi %47, %63 : i32
              %65 = memref.load %3[] : memref<i32>
              %66 = arith.muli %65, %62 : i32
              %67 = memref.load %30[%c0] : memref<1xi32>
              %68 = arith.muli %66, %67 : i32
              %69 = arith.addi %64, %68 : i32
              %70 = arith.index_cast %69 : i32 to index
              %71 = memref.load %5[] : memref<memref<?xf32>>
              %72 = arith.subi %65, %c1_i32 : i32
              %73 = arith.muli %72, %62 : i32
              %74 = arith.muli %73, %67 : i32
              %75 = arith.addi %64, %74 : i32
              %76 = arith.index_cast %75 : i32 to index
              %77 = arith.addi %76, %c0 : index
              %78 = memref.load %71[%77] : memref<?xf32>
              %79 = arith.addi %70, %c0 : index
              memref.store %78, %59[%79] : memref<?xf32>
            }
            %56 = memref.load %46[] : memref<i1>
            memref.store %56, %45[] : memref<i1>
            %57 = memref.load %45[] : memref<i1>
            %58 = scf.if %57 -> (i32) {
              %59 = memref.load %0[] : memref<i32>
              %60 = arith.addi %47, %c1_i32 : i32
              memref.store %60, %0[] : memref<i32>
              scf.yield %60 : i32
            } else {
              scf.yield %47 : i32
            }
            cf.br ^bb1(%58 : i32)
          ^bb3:  // pred: ^bb1
            scf.yield %47 : i32
          }
          scf.yield %42 : i32
        } else {
          scf.yield %28 : i32
        }
        scf.yield %41 : i32
      } else {
        scf.yield %28 : i32
      }
      %38 = memref.load %27[] : memref<i1>
      memref.store %38, %26[] : memref<i1>
      %39 = memref.load %26[] : memref<i1>
      scf.if %39 {
        %40 = memref.load %2[] : memref<i32>
        %41 = arith.addi %40, %c1_i32 : i32
        memref.store %41, %2[] : memref<i32>
      }
      cf.br ^bb1(%37 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %28 : i32
    }
    scf.yield %24 : i32
  } else {
    scf.yield %12 : i32
  }
  scf.yield %23 : i32
} else {
  scf.yield %12 : i32
}
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %17 = memref.load %11[] : memref<i1>
  memref.store %17, %10[] : memref<i1>
  %18 = memref.load %10[] : memref<i1>
  %19 = scf.if %18 -> (i32) {
    %22 = memref.load %10[] : memref<i1>
    %23 = scf.if %22 -> (i32) {
      %24 = scf.execute_region -> i32 {
        %25 = memref.load %10[] : memref<i1>
        scf.if %25 {
          memref.store %c0_i32, %2[] : memref<i32>
        }
        %26 = memref.alloca() : memref<i1>
        %27 = memref.alloca() : memref<i1>
        memref.store %true, %27[] : memref<i1>
        cf.br ^bb1(%12 : i32)
      ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
        %29 = memref.load %2[] : memref<i32>
        %30 = memref.get_global @jm : memref<1xi32>
        %31 = memref.load %30[%c0] : memref<1xi32>
        %32 = arith.cmpi slt, %29, %31 : i32
        %33 = memref.load %27[] : memref<i1>
        %34 = arith.andi %32, %33 : i1
        cf.cond_br %34, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %35 = memref.load %27[] : memref<i1>
        memref.store %35, %26[] : memref<i1>
        %36 = memref.load %26[] : memref<i1>
        %37 = scf.if %36 -> (i32) {
          %40 = memref.load %26[] : memref<i1>
          %41 = scf.if %40 -> (i32) {
            %42 = scf.execute_region -> i32 {
              %43 = memref.load %26[] : memref<i1>
              %44 = scf.if %43 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %28 : i32
              }
              %45 = memref.alloca() : memref<i1>
              %46 = memref.alloca() : memref<i1>
              memref.store %true, %46[] : memref<i1>
              cf.br ^bb1(%44 : i32)
            ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
              %48 = memref.load %0[] : memref<i32>
              %49 = memref.get_global @im : memref<1xi32>
              %50 = memref.load %49[%c0] : memref<1xi32>
              %51 = arith.cmpi slt, %47, %50 : i32
              %52 = memref.load %46[] : memref<i1>
              %53 = arith.andi %51, %52 : i1
              cf.cond_br %53, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %54 = memref.load %46[] : memref<i1>
              memref.store %54, %45[] : memref<i1>
              %55 = memref.load %45[] : memref<i1>
              scf.if %55 {
                %59 = memref.load %4[] : memref<memref<?xf32>>
                %60 = memref.load %0[] : memref<i32>
                %61 = memref.load %2[] : memref<i32>
                %62 = memref.load %49[%c0] : memref<1xi32>
                %63 = arith.muli %61, %62 : i32
                %64 = arith.addi %47, %63 : i32
                %65 = memref.load %3[] : memref<i32>
                %66 = arith.muli %65, %62 : i32
                %67 = memref.load %30[%c0] : memref<1xi32>
                %68 = arith.muli %66, %67 : i32
                %69 = arith.addi %64, %68 : i32
                %70 = arith.index_cast %69 : i32 to index
                %71 = memref.load %5[] : memref<memref<?xf32>>
                %72 = arith.subi %65, %c1_i32 : i32
                %73 = arith.muli %72, %62 : i32
                %74 = arith.muli %73, %67 : i32
                %75 = arith.addi %64, %74 : i32
                %76 = arith.index_cast %75 : i32 to index
                %77 = arith.addi %76, %c0 : index
                %78 = memref.load %71[%77] : memref<?xf32>
                %79 = arith.addi %70, %c0 : index
                memref.store %78, %59[%79] : memref<?xf32>
              }
              %56 = memref.load %46[] : memref<i1>
              memref.store %56, %45[] : memref<i1>
              %57 = memref.load %45[] : memref<i1>
              %58 = scf.if %57 -> (i32) {
                %59 = memref.load %0[] : memref<i32>
                %60 = arith.addi %47, %c1_i32 : i32
                memref.store %60, %0[] : memref<i32>
                scf.yield %60 : i32
              } else {
                scf.yield %47 : i32
              }
              cf.br ^bb1(%58 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %47 : i32
            }
            scf.yield %42 : i32
          } else {
            scf.yield %28 : i32
          }
          scf.yield %41 : i32
        } else {
          scf.yield %28 : i32
        }
        %38 = memref.load %27[] : memref<i1>
        memref.store %38, %26[] : memref<i1>
        %39 = memref.load %26[] : memref<i1>
        scf.if %39 {
          %40 = memref.load %2[] : memref<i32>
          %41 = arith.addi %40, %c1_i32 : i32
          memref.store %41, %2[] : memref<i32>
        }
        cf.br ^bb1(%37 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %28 : i32
      }
      scf.yield %24 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %23 : i32
  } else {
    scf.yield %12 : i32
  }
  %20 = memref.load %11[] : memref<i1>
  memref.store %20, %10[] : memref<i1>
  %21 = memref.load %10[] : memref<i1>
  scf.if %21 {
    %22 = memref.load %3[] : memref<i32>
    %23 = arith.subi %22, %c1_i32 : i32
    memref.store %23, %3[] : memref<i32>
  }
  cf.br ^bb1(%19 : i32)
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
%19 = scf.if %18 -> (i32) {
  %22 = memref.load %10[] : memref<i1>
  %23 = scf.if %22 -> (i32) {
    %24 = scf.execute_region -> i32 {
      %25 = memref.load %10[] : memref<i1>
      scf.if %25 {
        memref.store %c0_i32, %2[] : memref<i32>
      }
      %26 = memref.alloca() : memref<i1>
      %27 = memref.alloca() : memref<i1>
      memref.store %true, %27[] : memref<i1>
      cf.br ^bb1(%12 : i32)
    ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
      %29 = memref.load %2[] : memref<i32>
      %30 = memref.get_global @jm : memref<1xi32>
      %31 = memref.load %30[%c0] : memref<1xi32>
      %32 = arith.cmpi slt, %29, %31 : i32
      %33 = memref.load %27[] : memref<i1>
      %34 = arith.andi %32, %33 : i1
      cf.cond_br %34, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %35 = memref.load %27[] : memref<i1>
      memref.store %35, %26[] : memref<i1>
      %36 = memref.load %26[] : memref<i1>
      %37 = scf.if %36 -> (i32) {
        %40 = memref.load %26[] : memref<i1>
        %41 = scf.if %40 -> (i32) {
          %42 = scf.execute_region -> i32 {
            %43 = memref.load %26[] : memref<i1>
            %44 = scf.if %43 -> (i32) {
              memref.store %c0_i32, %0[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %28 : i32
            }
            %45 = memref.alloca() : memref<i1>
            %46 = memref.alloca() : memref<i1>
            memref.store %true, %46[] : memref<i1>
            cf.br ^bb1(%44 : i32)
          ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
            %48 = memref.load %0[] : memref<i32>
            %49 = memref.get_global @im : memref<1xi32>
            %50 = memref.load %49[%c0] : memref<1xi32>
            %51 = arith.cmpi slt, %47, %50 : i32
            %52 = memref.load %46[] : memref<i1>
            %53 = arith.andi %51, %52 : i1
            cf.cond_br %53, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %54 = memref.load %46[] : memref<i1>
            memref.store %54, %45[] : memref<i1>
            %55 = memref.load %45[] : memref<i1>
            scf.if %55 {
              %59 = memref.load %4[] : memref<memref<?xf32>>
              %60 = memref.load %0[] : memref<i32>
              %61 = memref.load %2[] : memref<i32>
              %62 = memref.load %49[%c0] : memref<1xi32>
              %63 = arith.muli %61, %62 : i32
              %64 = arith.addi %47, %63 : i32
              %65 = memref.load %3[] : memref<i32>
              %66 = arith.muli %65, %62 : i32
              %67 = memref.load %30[%c0] : memref<1xi32>
              %68 = arith.muli %66, %67 : i32
              %69 = arith.addi %64, %68 : i32
              %70 = arith.index_cast %69 : i32 to index
              %71 = memref.load %5[] : memref<memref<?xf32>>
              %72 = arith.subi %65, %c1_i32 : i32
              %73 = arith.muli %72, %62 : i32
              %74 = arith.muli %73, %67 : i32
              %75 = arith.addi %64, %74 : i32
              %76 = arith.index_cast %75 : i32 to index
              %77 = arith.addi %76, %c0 : index
              %78 = memref.load %71[%77] : memref<?xf32>
              %79 = arith.addi %70, %c0 : index
              memref.store %78, %59[%79] : memref<?xf32>
            }
            %56 = memref.load %46[] : memref<i1>
            memref.store %56, %45[] : memref<i1>
            %57 = memref.load %45[] : memref<i1>
            %58 = scf.if %57 -> (i32) {
              %59 = memref.load %0[] : memref<i32>
              %60 = arith.addi %47, %c1_i32 : i32
              memref.store %60, %0[] : memref<i32>
              scf.yield %60 : i32
            } else {
              scf.yield %47 : i32
            }
            cf.br ^bb1(%58 : i32)
          ^bb3:  // pred: ^bb1
            scf.yield %47 : i32
          }
          scf.yield %42 : i32
        } else {
          scf.yield %28 : i32
        }
        scf.yield %41 : i32
      } else {
        scf.yield %28 : i32
      }
      %38 = memref.load %27[] : memref<i1>
      memref.store %38, %26[] : memref<i1>
      %39 = memref.load %26[] : memref<i1>
      scf.if %39 {
        %40 = memref.load %2[] : memref<i32>
        %41 = arith.addi %40, %c1_i32 : i32
        memref.store %41, %2[] : memref<i32>
      }
      cf.br ^bb1(%37 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %28 : i32
    }
    scf.yield %24 : i32
  } else {
    scf.yield %12 : i32
  }
  scf.yield %23 : i32
} else {
  scf.yield %12 : i32
}

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield

mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.execute_region {
    %9 = memref.load %6[] : memref<i1>
    scf.if %9 {
      %22 = memref.get_global @kbm3 : memref<1xi32>
      %23 = memref.load %22[%c0] : memref<1xi32>
      memref.store %23, %3[] : memref<i32>
    }
    %10 = memref.alloca() : memref<i1>
    %11 = memref.alloca() : memref<i1>
    memref.store %true, %11[] : memref<i1>
    cf.br ^bb1(%1 : i32)
  ^bb1(%12: i32):  // 2 preds: ^bb0, ^bb2
    %13 = memref.load %3[] : memref<i32>
    %14 = arith.cmpi sgt, %13, %c0_i32 : i32
    %15 = memref.load %11[] : memref<i1>
    %16 = arith.andi %14, %15 : i1
    cf.cond_br %16, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %17 = memref.load %11[] : memref<i1>
    memref.store %17, %10[] : memref<i1>
    %18 = memref.load %10[] : memref<i1>
    %19 = scf.if %18 -> (i32) {
      %22 = memref.load %10[] : memref<i1>
      %23 = scf.if %22 -> (i32) {
        %24 = scf.execute_region -> i32 {
          %25 = memref.load %10[] : memref<i1>
          scf.if %25 {
            memref.store %c0_i32, %2[] : memref<i32>
          }
          %26 = memref.alloca() : memref<i1>
          %27 = memref.alloca() : memref<i1>
          memref.store %true, %27[] : memref<i1>
          cf.br ^bb1(%12 : i32)
        ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
          %29 = memref.load %2[] : memref<i32>
          %30 = memref.get_global @jm : memref<1xi32>
          %31 = memref.load %30[%c0] : memref<1xi32>
          %32 = arith.cmpi slt, %29, %31 : i32
          %33 = memref.load %27[] : memref<i1>
          %34 = arith.andi %32, %33 : i1
          cf.cond_br %34, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %35 = memref.load %27[] : memref<i1>
          memref.store %35, %26[] : memref<i1>
          %36 = memref.load %26[] : memref<i1>
          %37 = scf.if %36 -> (i32) {
            %40 = memref.load %26[] : memref<i1>
            %41 = scf.if %40 -> (i32) {
              %42 = scf.execute_region -> i32 {
                %43 = memref.load %26[] : memref<i1>
                %44 = scf.if %43 -> (i32) {
                  memref.store %c0_i32, %0[] : memref<i32>
                  scf.yield %c0_i32 : i32
                } else {
                  scf.yield %28 : i32
                }
                %45 = memref.alloca() : memref<i1>
                %46 = memref.alloca() : memref<i1>
                memref.store %true, %46[] : memref<i1>
                cf.br ^bb1(%44 : i32)
              ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
                %48 = memref.load %0[] : memref<i32>
                %49 = memref.get_global @im : memref<1xi32>
                %50 = memref.load %49[%c0] : memref<1xi32>
                %51 = arith.cmpi slt, %47, %50 : i32
                %52 = memref.load %46[] : memref<i1>
                %53 = arith.andi %51, %52 : i1
                cf.cond_br %53, ^bb2, ^bb3
              ^bb2:  // pred: ^bb1
                %54 = memref.load %46[] : memref<i1>
                memref.store %54, %45[] : memref<i1>
                %55 = memref.load %45[] : memref<i1>
                scf.if %55 {
                  %59 = memref.load %4[] : memref<memref<?xf32>>
                  %60 = memref.load %0[] : memref<i32>
                  %61 = memref.load %2[] : memref<i32>
                  %62 = memref.load %49[%c0] : memref<1xi32>
                  %63 = arith.muli %61, %62 : i32
                  %64 = arith.addi %47, %63 : i32
                  %65 = memref.load %3[] : memref<i32>
                  %66 = arith.muli %65, %62 : i32
                  %67 = memref.load %30[%c0] : memref<1xi32>
                  %68 = arith.muli %66, %67 : i32
                  %69 = arith.addi %64, %68 : i32
                  %70 = arith.index_cast %69 : i32 to index
                  %71 = memref.load %5[] : memref<memref<?xf32>>
                  %72 = arith.subi %65, %c1_i32 : i32
                  %73 = arith.muli %72, %62 : i32
                  %74 = arith.muli %73, %67 : i32
                  %75 = arith.addi %64, %74 : i32
                  %76 = arith.index_cast %75 : i32 to index
                  %77 = arith.addi %76, %c0 : index
                  %78 = memref.load %71[%77] : memref<?xf32>
                  %79 = arith.addi %70, %c0 : index
                  memref.store %78, %59[%79] : memref<?xf32>
                }
                %56 = memref.load %46[] : memref<i1>
                memref.store %56, %45[] : memref<i1>
                %57 = memref.load %45[] : memref<i1>
                %58 = scf.if %57 -> (i32) {
                  %59 = memref.load %0[] : memref<i32>
                  %60 = arith.addi %47, %c1_i32 : i32
                  memref.store %60, %0[] : memref<i32>
                  scf.yield %60 : i32
                } else {
                  scf.yield %47 : i32
                }
                cf.br ^bb1(%58 : i32)
              ^bb3:  // pred: ^bb1
                scf.yield %47 : i32
              }
              scf.yield %42 : i32
            } else {
              scf.yield %28 : i32
            }
            scf.yield %41 : i32
          } else {
            scf.yield %28 : i32
          }
          %38 = memref.load %27[] : memref<i1>
          memref.store %38, %26[] : memref<i1>
          %39 = memref.load %26[] : memref<i1>
          scf.if %39 {
            %40 = memref.load %2[] : memref<i32>
            %41 = arith.addi %40, %c1_i32 : i32
            memref.store %41, %2[] : memref<i32>
          }
          cf.br ^bb1(%37 : i32)
        ^bb3:  // pred: ^bb1
          scf.yield %28 : i32
        }
        scf.yield %24 : i32
      } else {
        scf.yield %12 : i32
      }
      scf.yield %23 : i32
    } else {
      scf.yield %12 : i32
    }
    %20 = memref.load %11[] : memref<i1>
    memref.store %20, %10[] : memref<i1>
    %21 = memref.load %10[] : memref<i1>
    scf.if %21 {
      %22 = memref.load %3[] : memref<i32>
      %23 = arith.subi %22, %c1_i32 : i32
      memref.store %23, %3[] : memref<i32>
    }
    cf.br ^bb1(%19 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield
  }
  scf.yield
 with val:exOp:mlir-asm-printer: Verifying operation: func.func
scf.execute_region {
  %9 = memref.load %6[] : memref<i1>
  scf.if %9 {
    %22 = memref.get_global @kbm3 : memref<1xi32>
    %23 = memref.load %22[%c0] : memref<1xi32>
    memref.store %23, %3[] : memref<i32>
  }
  %10 = memref.alloca() : memref<i1>
  %11 = memref.alloca() : memref<i1>
  memref.store %true, %11[] : memref<i1>
  cf.br ^bb1(%1 : i32)
^bb1(%12: i32):  // 2 preds: ^bb0, ^bb2
  %13 = memref.load %3[] : memref<i32>
  %14 = arith.cmpi sgt, %13, %c0_i32 : i32
  %15 = memref.load %11[] : memref<i1>
  %16 = arith.andi %14, %15 : i1
  cf.cond_br %16, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %17 = memref.load %11[] : memref<i1>
  memref.store %17, %10[] : memref<i1>
  %18 = memref.load %10[] : memref<i1>
  %19 = scf.if %18 -> (i32) {
    %22 = memref.load %10[] : memref<i1>
    %23 = scf.if %22 -> (i32) {
      %24 = scf.execute_region -> i32 {
        %25 = memref.load %10[] : memref<i1>
        scf.if %25 {
          memref.store %c0_i32, %2[] : memref<i32>
        }
        %26 = memref.alloca() : memref<i1>
        %27 = memref.alloca() : memref<i1>
        memref.store %true, %27[] : memref<i1>
        cf.br ^bb1(%12 : i32)
      ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
        %29 = memref.load %2[] : memref<i32>
        %30 = memref.get_global @jm : memref<1xi32>
        %31 = memref.load %30[%c0] : memref<1xi32>
        %32 = arith.cmpi slt, %29, %31 : i32
        %33 = memref.load %27[] : memref<i1>
        %34 = arith.andi %32, %33 : i1
        cf.cond_br %34, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %35 = memref.load %27[] : memref<i1>
        memref.store %35, %26[] : memref<i1>
        %36 = memref.load %26[] : memref<i1>
        %37 = scf.if %36 -> (i32) {
          %40 = memref.load %26[] : memref<i1>
          %41 = scf.if %40 -> (i32) {
            %42 = scf.execute_region -> i32 {
              %43 = memref.load %26[] : memref<i1>
              %44 = scf.if %43 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %28 : i32
              }
              %45 = memref.alloca() : memref<i1>
              %46 = memref.alloca() : memref<i1>
              memref.store %true, %46[] : memref<i1>
              cf.br ^bb1(%44 : i32)
            ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
              %48 = memref.load %0[] : memref<i32>
              %49 = memref.get_global @im : memref<1xi32>
              %50 = memref.load %49[%c0] : memref<1xi32>
              %51 = arith.cmpi slt, %47, %50 : i32
              %52 = memref.load %46[] : memref<i1>
              %53 = arith.andi %51, %52 : i1
              cf.cond_br %53, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %54 = memref.load %46[] : memref<i1>
              memref.store %54, %45[] : memref<i1>
              %55 = memref.load %45[] : memref<i1>
              scf.if %55 {
                %59 = memref.load %4[] : memref<memref<?xf32>>
                %60 = memref.load %0[] : memref<i32>
                %61 = memref.load %2[] : memref<i32>
                %62 = memref.load %49[%c0] : memref<1xi32>
                %63 = arith.muli %61, %62 : i32
                %64 = arith.addi %47, %63 : i32
                %65 = memref.load %3[] : memref<i32>
                %66 = arith.muli %65, %62 : i32
                %67 = memref.load %30[%c0] : memref<1xi32>
                %68 = arith.muli %66, %67 : i32
                %69 = arith.addi %64, %68 : i32
                %70 = arith.index_cast %69 : i32 to index
                %71 = memref.load %5[] : memref<memref<?xf32>>
                %72 = arith.subi %65, %c1_i32 : i32
                %73 = arith.muli %72, %62 : i32
                %74 = arith.muli %73, %67 : i32
                %75 = arith.addi %64, %74 : i32
                %76 = arith.index_cast %75 : i32 to index
                %77 = arith.addi %76, %c0 : index
                %78 = memref.load %71[%77] : memref<?xf32>
                %79 = arith.addi %70, %c0 : index
                memref.store %78, %59[%79] : memref<?xf32>
              }
              %56 = memref.load %46[] : memref<i1>
              memref.store %56, %45[] : memref<i1>
              %57 = memref.load %45[] : memref<i1>
              %58 = scf.if %57 -> (i32) {
                %59 = memref.load %0[] : memref<i32>
                %60 = arith.addi %47, %c1_i32 : i32
                memref.store %60, %0[] : memref<i32>
                scf.yield %60 : i32
              } else {
                scf.yield %47 : i32
              }
              cf.br ^bb1(%58 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %47 : i32
            }
            scf.yield %42 : i32
          } else {
            scf.yield %28 : i32
          }
          scf.yield %41 : i32
        } else {
          scf.yield %28 : i32
        }
        %38 = memref.load %27[] : memref<i1>
        memref.store %38, %26[] : memref<i1>
        %39 = memref.load %26[] : memref<i1>
        scf.if %39 {
          %40 = memref.load %2[] : memref<i32>
          %41 = arith.addi %40, %c1_i32 : i32
          memref.store %41, %2[] : memref<i32>
        }
        cf.br ^bb1(%37 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %28 : i32
      }
      scf.yield %24 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %23 : i32
  } else {
    scf.yield %12 : i32
  }
  %20 = memref.load %11[] : memref<i1>
  memref.store %20, %10[] : memref<i1>
  %21 = memref.load %10[] : memref<i1>
  scf.if %21 {
    %22 = memref.load %3[] : memref<i32>
    %23 = arith.subi %22, %c1_i32 : i32
    memref.store %23, %3[] : memref<i32>
  }
  cf.br ^bb1(%19 : i32)
^bb3:  // pred: ^bb1
  scf.yield
}
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %8 = memref.load %6[] : memref<i1>
  scf.if %8 {
    scf.execute_region {
      %9 = memref.load %6[] : memref<i1>
      scf.if %9 {
        %22 = memref.get_global @kbm3 : memref<1xi32>
        %23 = memref.load %22[%c0] : memref<1xi32>
        memref.store %23, %3[] : memref<i32>
      }
      %10 = memref.alloca() : memref<i1>
      %11 = memref.alloca() : memref<i1>
      memref.store %true, %11[] : memref<i1>
      cf.br ^bb1(%1 : i32)
    ^bb1(%12: i32):  // 2 preds: ^bb0, ^bb2
      %13 = memref.load %3[] : memref<i32>
      %14 = arith.cmpi sgt, %13, %c0_i32 : i32
      %15 = memref.load %11[] : memref<i1>
      %16 = arith.andi %14, %15 : i1
      cf.cond_br %16, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %17 = memref.load %11[] : memref<i1>
      memref.store %17, %10[] : memref<i1>
      %18 = memref.load %10[] : memref<i1>
      %19 = scf.if %18 -> (i32) {
        %22 = memref.load %10[] : memref<i1>
        %23 = scf.if %22 -> (i32) {
          %24 = scf.execute_region -> i32 {
            %25 = memref.load %10[] : memref<i1>
            scf.if %25 {
              memref.store %c0_i32, %2[] : memref<i32>
            }
            %26 = memref.alloca() : memref<i1>
            %27 = memref.alloca() : memref<i1>
            memref.store %true, %27[] : memref<i1>
            cf.br ^bb1(%12 : i32)
          ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
            %29 = memref.load %2[] : memref<i32>
            %30 = memref.get_global @jm : memref<1xi32>
            %31 = memref.load %30[%c0] : memref<1xi32>
            %32 = arith.cmpi slt, %29, %31 : i32
            %33 = memref.load %27[] : memref<i1>
            %34 = arith.andi %32, %33 : i1
            cf.cond_br %34, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %35 = memref.load %27[] : memref<i1>
            memref.store %35, %26[] : memref<i1>
            %36 = memref.load %26[] : memref<i1>
            %37 = scf.if %36 -> (i32) {
              %40 = memref.load %26[] : memref<i1>
              %41 = scf.if %40 -> (i32) {
                %42 = scf.execute_region -> i32 {
                  %43 = memref.load %26[] : memref<i1>
                  %44 = scf.if %43 -> (i32) {
                    memref.store %c0_i32, %0[] : memref<i32>
                    scf.yield %c0_i32 : i32
                  } else {
                    scf.yield %28 : i32
                  }
                  %45 = memref.alloca() : memref<i1>
                  %46 = memref.alloca() : memref<i1>
                  memref.store %true, %46[] : memref<i1>
                  cf.br ^bb1(%44 : i32)
                ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
                  %48 = memref.load %0[] : memref<i32>
                  %49 = memref.get_global @im : memref<1xi32>
                  %50 = memref.load %49[%c0] : memref<1xi32>
                  %51 = arith.cmpi slt, %47, %50 : i32
                  %52 = memref.load %46[] : memref<i1>
                  %53 = arith.andi %51, %52 : i1
                  cf.cond_br %53, ^bb2, ^bb3
                ^bb2:  // pred: ^bb1
                  %54 = memref.load %46[] : memref<i1>
                  memref.store %54, %45[] : memref<i1>
                  %55 = memref.load %45[] : memref<i1>
                  scf.if %55 {
                    %59 = memref.load %4[] : memref<memref<?xf32>>
                    %60 = memref.load %0[] : memref<i32>
                    %61 = memref.load %2[] : memref<i32>
                    %62 = memref.load %49[%c0] : memref<1xi32>
                    %63 = arith.muli %61, %62 : i32
                    %64 = arith.addi %47, %63 : i32
                    %65 = memref.load %3[] : memref<i32>
                    %66 = arith.muli %65, %62 : i32
                    %67 = memref.load %30[%c0] : memref<1xi32>
                    %68 = arith.muli %66, %67 : i32
                    %69 = arith.addi %64, %68 : i32
                    %70 = arith.index_cast %69 : i32 to index
                    %71 = memref.load %5[] : memref<memref<?xf32>>
                    %72 = arith.subi %65, %c1_i32 : i32
                    %73 = arith.muli %72, %62 : i32
                    %74 = arith.muli %73, %67 : i32
                    %75 = arith.addi %64, %74 : i32
                    %76 = arith.index_cast %75 : i32 to index
                    %77 = arith.addi %76, %c0 : index
                    %78 = memref.load %71[%77] : memref<?xf32>
                    %79 = arith.addi %70, %c0 : index
                    memref.store %78, %59[%79] : memref<?xf32>
                  }
                  %56 = memref.load %46[] : memref<i1>
                  memref.store %56, %45[] : memref<i1>
                  %57 = memref.load %45[] : memref<i1>
                  %58 = scf.if %57 -> (i32) {
                    %59 = memref.load %0[] : memref<i32>
                    %60 = arith.addi %47, %c1_i32 : i32
                    memref.store %60, %0[] : memref<i32>
                    scf.yield %60 : i32
                  } else {
                    scf.yield %47 : i32
                  }
                  cf.br ^bb1(%58 : i32)
                ^bb3:  // pred: ^bb1
                  scf.yield %47 : i32
                }
                scf.yield %42 : i32
              } else {
                scf.yield %28 : i32
              }
              scf.yield %41 : i32
            } else {
              scf.yield %28 : i32
            }
            %38 = memref.load %27[] : memref<i1>
            memref.store %38, %26[] : memref<i1>
            %39 = memref.load %26[] : memref<i1>
            scf.if %39 {
              %40 = memref.load %2[] : memref<i32>
              %41 = arith.addi %40, %c1_i32 : i32
              memref.store %41, %2[] : memref<i32>
            }
            cf.br ^bb1(%37 : i32)
          ^bb3:  // pred: ^bb1
            scf.yield %28 : i32
          }
          scf.yield %24 : i32
        } else {
          scf.yield %12 : i32
        }
        scf.yield %23 : i32
      } else {
        scf.yield %12 : i32
      }
      %20 = memref.load %11[] : memref<i1>
      memref.store %20, %10[] : memref<i1>
      %21 = memref.load %10[] : memref<i1>
      scf.if %21 {
        %22 = memref.load %3[] : memref<i32>
        %23 = arith.subi %22, %c1_i32 : i32
        memref.store %23, %3[] : memref<i32>
      }
      cf.br ^bb1(%19 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
  scf.yield
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %8 {
  scf.execute_region {
    %9 = memref.load %6[] : memref<i1>
    scf.if %9 {
      %22 = memref.get_global @kbm3 : memref<1xi32>
      %23 = memref.load %22[%c0] : memref<1xi32>
      memref.store %23, %3[] : memref<i32>
    }
    %10 = memref.alloca() : memref<i1>
    %11 = memref.alloca() : memref<i1>
    memref.store %true, %11[] : memref<i1>
    cf.br ^bb1(%1 : i32)
  ^bb1(%12: i32):  // 2 preds: ^bb0, ^bb2
    %13 = memref.load %3[] : memref<i32>
    %14 = arith.cmpi sgt, %13, %c0_i32 : i32
    %15 = memref.load %11[] : memref<i1>
    %16 = arith.andi %14, %15 : i1
    cf.cond_br %16, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %17 = memref.load %11[] : memref<i1>
    memref.store %17, %10[] : memref<i1>
    %18 = memref.load %10[] : memref<i1>
    %19 = scf.if %18 -> (i32) {
      %22 = memref.load %10[] : memref<i1>
      %23 = scf.if %22 -> (i32) {
        %24 = scf.execute_region -> i32 {
          %25 = memref.load %10[] : memref<i1>
          scf.if %25 {
            memref.store %c0_i32, %2[] : memref<i32>
          }
          %26 = memref.alloca() : memref<i1>
          %27 = memref.alloca() : memref<i1>
          memref.store %true, %27[] : memref<i1>
          cf.br ^bb1(%12 : i32)
        ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
          %29 = memref.load %2[] : memref<i32>
          %30 = memref.get_global @jm : memref<1xi32>
          %31 = memref.load %30[%c0] : memref<1xi32>
          %32 = arith.cmpi slt, %29, %31 : i32
          %33 = memref.load %27[] : memref<i1>
          %34 = arith.andi %32, %33 : i1
          cf.cond_br %34, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %35 = memref.load %27[] : memref<i1>
          memref.store %35, %26[] : memref<i1>
          %36 = memref.load %26[] : memref<i1>
          %37 = scf.if %36 -> (i32) {
            %40 = memref.load %26[] : memref<i1>
            %41 = scf.if %40 -> (i32) {
              %42 = scf.execute_region -> i32 {
                %43 = memref.load %26[] : memref<i1>
                %44 = scf.if %43 -> (i32) {
                  memref.store %c0_i32, %0[] : memref<i32>
                  scf.yield %c0_i32 : i32
                } else {
                  scf.yield %28 : i32
                }
                %45 = memref.alloca() : memref<i1>
                %46 = memref.alloca() : memref<i1>
                memref.store %true, %46[] : memref<i1>
                cf.br ^bb1(%44 : i32)
              ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
                %48 = memref.load %0[] : memref<i32>
                %49 = memref.get_global @im : memref<1xi32>
                %50 = memref.load %49[%c0] : memref<1xi32>
                %51 = arith.cmpi slt, %47, %50 : i32
                %52 = memref.load %46[] : memref<i1>
                %53 = arith.andi %51, %52 : i1
                cf.cond_br %53, ^bb2, ^bb3
              ^bb2:  // pred: ^bb1
                %54 = memref.load %46[] : memref<i1>
                memref.store %54, %45[] : memref<i1>
                %55 = memref.load %45[] : memref<i1>
                scf.if %55 {
                  %59 = memref.load %4[] : memref<memref<?xf32>>
                  %60 = memref.load %0[] : memref<i32>
                  %61 = memref.load %2[] : memref<i32>
                  %62 = memref.load %49[%c0] : memref<1xi32>
                  %63 = arith.muli %61, %62 : i32
                  %64 = arith.addi %47, %63 : i32
                  %65 = memref.load %3[] : memref<i32>
                  %66 = arith.muli %65, %62 : i32
                  %67 = memref.load %30[%c0] : memref<1xi32>
                  %68 = arith.muli %66, %67 : i32
                  %69 = arith.addi %64, %68 : i32
                  %70 = arith.index_cast %69 : i32 to index
                  %71 = memref.load %5[] : memref<memref<?xf32>>
                  %72 = arith.subi %65, %c1_i32 : i32
                  %73 = arith.muli %72, %62 : i32
                  %74 = arith.muli %73, %67 : i32
                  %75 = arith.addi %64, %74 : i32
                  %76 = arith.index_cast %75 : i32 to index
                  %77 = arith.addi %76, %c0 : index
                  %78 = memref.load %71[%77] : memref<?xf32>
                  %79 = arith.addi %70, %c0 : index
                  memref.store %78, %59[%79] : memref<?xf32>
                }
                %56 = memref.load %46[] : memref<i1>
                memref.store %56, %45[] : memref<i1>
                %57 = memref.load %45[] : memref<i1>
                %58 = scf.if %57 -> (i32) {
                  %59 = memref.load %0[] : memref<i32>
                  %60 = arith.addi %47, %c1_i32 : i32
                  memref.store %60, %0[] : memref<i32>
                  scf.yield %60 : i32
                } else {
                  scf.yield %47 : i32
                }
                cf.br ^bb1(%58 : i32)
              ^bb3:  // pred: ^bb1
                scf.yield %47 : i32
              }
              scf.yield %42 : i32
            } else {
              scf.yield %28 : i32
            }
            scf.yield %41 : i32
          } else {
            scf.yield %28 : i32
          }
          %38 = memref.load %27[] : memref<i1>
          memref.store %38, %26[] : memref<i1>
          %39 = memref.load %26[] : memref<i1>
          scf.if %39 {
            %40 = memref.load %2[] : memref<i32>
            %41 = arith.addi %40, %c1_i32 : i32
            memref.store %41, %2[] : memref<i32>
          }
          cf.br ^bb1(%37 : i32)
        ^bb3:  // pred: ^bb1
          scf.yield %28 : i32
        }
        scf.yield %24 : i32
      } else {
        scf.yield %12 : i32
      }
      scf.yield %23 : i32
    } else {
      scf.yield %12 : i32
    }
    %20 = memref.load %11[] : memref<i1>
    memref.store %20, %10[] : memref<i1>
    %21 = memref.load %10[] : memref<i1>
    scf.if %21 {
      %22 = memref.load %3[] : memref<i32>
      %23 = arith.subi %22, %c1_i32 : i32
      memref.store %23, %3[] : memref<i32>
    }
    cf.br ^bb1(%19 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield
  }
}
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32):
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %7 {
    %8 = memref.load %6[] : memref<i1>
    scf.if %8 {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        scf.if %9 {
          %22 = memref.get_global @kbm3 : memref<1xi32>
          %23 = memref.load %22[%c0] : memref<1xi32>
          memref.store %23, %3[] : memref<i32>
        }
        %10 = memref.alloca() : memref<i1>
        %11 = memref.alloca() : memref<i1>
        memref.store %true, %11[] : memref<i1>
        cf.br ^bb1(%1 : i32)
      ^bb1(%12: i32):  // 2 preds: ^bb0, ^bb2
        %13 = memref.load %3[] : memref<i32>
        %14 = arith.cmpi sgt, %13, %c0_i32 : i32
        %15 = memref.load %11[] : memref<i1>
        %16 = arith.andi %14, %15 : i1
        cf.cond_br %16, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %17 = memref.load %11[] : memref<i1>
        memref.store %17, %10[] : memref<i1>
        %18 = memref.load %10[] : memref<i1>
        %19 = scf.if %18 -> (i32) {
          %22 = memref.load %10[] : memref<i1>
          %23 = scf.if %22 -> (i32) {
            %24 = scf.execute_region -> i32 {
              %25 = memref.load %10[] : memref<i1>
              scf.if %25 {
                memref.store %c0_i32, %2[] : memref<i32>
              }
              %26 = memref.alloca() : memref<i1>
              %27 = memref.alloca() : memref<i1>
              memref.store %true, %27[] : memref<i1>
              cf.br ^bb1(%12 : i32)
            ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
              %29 = memref.load %2[] : memref<i32>
              %30 = memref.get_global @jm : memref<1xi32>
              %31 = memref.load %30[%c0] : memref<1xi32>
              %32 = arith.cmpi slt, %29, %31 : i32
              %33 = memref.load %27[] : memref<i1>
              %34 = arith.andi %32, %33 : i1
              cf.cond_br %34, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %35 = memref.load %27[] : memref<i1>
              memref.store %35, %26[] : memref<i1>
              %36 = memref.load %26[] : memref<i1>
              %37 = scf.if %36 -> (i32) {
                %40 = memref.load %26[] : memref<i1>
                %41 = scf.if %40 -> (i32) {
                  %42 = scf.execute_region -> i32 {
                    %43 = memref.load %26[] : memref<i1>
                    %44 = scf.if %43 -> (i32) {
                      memref.store %c0_i32, %0[] : memref<i32>
                      scf.yield %c0_i32 : i32
                    } else {
                      scf.yield %28 : i32
                    }
                    %45 = memref.alloca() : memref<i1>
                    %46 = memref.alloca() : memref<i1>
                    memref.store %true, %46[] : memref<i1>
                    cf.br ^bb1(%44 : i32)
                  ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
                    %48 = memref.load %0[] : memref<i32>
                    %49 = memref.get_global @im : memref<1xi32>
                    %50 = memref.load %49[%c0] : memref<1xi32>
                    %51 = arith.cmpi slt, %47, %50 : i32
                    %52 = memref.load %46[] : memref<i1>
                    %53 = arith.andi %51, %52 : i1
                    cf.cond_br %53, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %54 = memref.load %46[] : memref<i1>
                    memref.store %54, %45[] : memref<i1>
                    %55 = memref.load %45[] : memref<i1>
                    scf.if %55 {
                      %59 = memref.load %4[] : memref<memref<?xf32>>
                      %60 = memref.load %0[] : memref<i32>
                      %61 = memref.load %2[] : memref<i32>
                      %62 = memref.load %49[%c0] : memref<1xi32>
                      %63 = arith.muli %61, %62 : i32
                      %64 = arith.addi %47, %63 : i32
                      %65 = memref.load %3[] : memref<i32>
                      %66 = arith.muli %65, %62 : i32
                      %67 = memref.load %30[%c0] : memref<1xi32>
                      %68 = arith.muli %66, %67 : i32
                      %69 = arith.addi %64, %68 : i32
                      %70 = arith.index_cast %69 : i32 to index
                      %71 = memref.load %5[] : memref<memref<?xf32>>
                      %72 = arith.subi %65, %c1_i32 : i32
                      %73 = arith.muli %72, %62 : i32
                      %74 = arith.muli %73, %67 : i32
                      %75 = arith.addi %64, %74 : i32
                      %76 = arith.index_cast %75 : i32 to index
                      %77 = arith.addi %76, %c0 : index
                      %78 = memref.load %71[%77] : memref<?xf32>
                      %79 = arith.addi %70, %c0 : index
                      memref.store %78, %59[%79] : memref<?xf32>
                    }
                    %56 = memref.load %46[] : memref<i1>
                    memref.store %56, %45[] : memref<i1>
                    %57 = memref.load %45[] : memref<i1>
                    %58 = scf.if %57 -> (i32) {
                      %59 = memref.load %0[] : memref<i32>
                      %60 = arith.addi %47, %c1_i32 : i32
                      memref.store %60, %0[] : memref<i32>
                      scf.yield %60 : i32
                    } else {
                      scf.yield %47 : i32
                    }
                    cf.br ^bb1(%58 : i32)
                  ^bb3:  // pred: ^bb1
                    scf.yield %47 : i32
                  }
                  scf.yield %42 : i32
                } else {
                  scf.yield %28 : i32
                }
                scf.yield %41 : i32
              } else {
                scf.yield %28 : i32
              }
              %38 = memref.load %27[] : memref<i1>
              memref.store %38, %26[] : memref<i1>
              %39 = memref.load %26[] : memref<i1>
              scf.if %39 {
                %40 = memref.load %2[] : memref<i32>
                %41 = arith.addi %40, %c1_i32 : i32
                memref.store %41, %2[] : memref<i32>
              }
              cf.br ^bb1(%37 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %28 : i32
            }
            scf.yield %24 : i32
          } else {
            scf.yield %12 : i32
          }
          scf.yield %23 : i32
        } else {
          scf.yield %12 : i32
        }
        %20 = memref.load %11[] : memref<i1>
        memref.store %20, %10[] : memref<i1>
        %21 = memref.load %10[] : memref<i1>
        scf.if %21 {
          %22 = memref.load %3[] : memref<i32>
          %23 = arith.subi %22, %c1_i32 : i32
          memref.store %23, %3[] : memref<i32>
        }
        cf.br ^bb1(%19 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  func.return
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %7 {
  %8 = memref.load %6[] : memref<i1>
  scf.if %8 {
    scf.execute_region {
      %9 = memref.load %6[] : memref<i1>
      scf.if %9 {
        %22 = memref.get_global @kbm3 : memref<1xi32>
        %23 = memref.load %22[%c0] : memref<1xi32>
        memref.store %23, %3[] : memref<i32>
      }
      %10 = memref.alloca() : memref<i1>
      %11 = memref.alloca() : memref<i1>
      memref.store %true, %11[] : memref<i1>
      cf.br ^bb1(%1 : i32)
    ^bb1(%12: i32):  // 2 preds: ^bb0, ^bb2
      %13 = memref.load %3[] : memref<i32>
      %14 = arith.cmpi sgt, %13, %c0_i32 : i32
      %15 = memref.load %11[] : memref<i1>
      %16 = arith.andi %14, %15 : i1
      cf.cond_br %16, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %17 = memref.load %11[] : memref<i1>
      memref.store %17, %10[] : memref<i1>
      %18 = memref.load %10[] : memref<i1>
      %19 = scf.if %18 -> (i32) {
        %22 = memref.load %10[] : memref<i1>
        %23 = scf.if %22 -> (i32) {
          %24 = scf.execute_region -> i32 {
            %25 = memref.load %10[] : memref<i1>
            scf.if %25 {
              memref.store %c0_i32, %2[] : memref<i32>
            }
            %26 = memref.alloca() : memref<i1>
            %27 = memref.alloca() : memref<i1>
            memref.store %true, %27[] : memref<i1>
            cf.br ^bb1(%12 : i32)
          ^bb1(%28: i32):  // 2 preds: ^bb0, ^bb2
            %29 = memref.load %2[] : memref<i32>
            %30 = memref.get_global @jm : memref<1xi32>
            %31 = memref.load %30[%c0] : memref<1xi32>
            %32 = arith.cmpi slt, %29, %31 : i32
            %33 = memref.load %27[] : memref<i1>
            %34 = arith.andi %32, %33 : i1
            cf.cond_br %34, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %35 = memref.load %27[] : memref<i1>
            memref.store %35, %26[] : memref<i1>
            %36 = memref.load %26[] : memref<i1>
            %37 = scf.if %36 -> (i32) {
              %40 = memref.load %26[] : memref<i1>
              %41 = scf.if %40 -> (i32) {
                %42 = scf.execute_region -> i32 {
                  %43 = memref.load %26[] : memref<i1>
                  %44 = scf.if %43 -> (i32) {
                    memref.store %c0_i32, %0[] : memref<i32>
                    scf.yield %c0_i32 : i32
                  } else {
                    scf.yield %28 : i32
                  }
                  %45 = memref.alloca() : memref<i1>
                  %46 = memref.alloca() : memref<i1>
                  memref.store %true, %46[] : memref<i1>
                  cf.br ^bb1(%44 : i32)
                ^bb1(%47: i32):  // 2 preds: ^bb0, ^bb2
                  %48 = memref.load %0[] : memref<i32>
                  %49 = memref.get_global @im : memref<1xi32>
                  %50 = memref.load %49[%c0] : memref<1xi32>
                  %51 = arith.cmpi slt, %47, %50 : i32
                  %52 = memref.load %46[] : memref<i1>
                  %53 = arith.andi %51, %52 : i1
                  cf.cond_br %53, ^bb2, ^bb3
                ^bb2:  // pred: ^bb1
                  %54 = memref.load %46[] : memref<i1>
                  memref.store %54, %45[] : memref<i1>
                  %55 = memref.load %45[] : memref<i1>
                  scf.if %55 {
                    %59 = memref.load %4[] : memref<memref<?xf32>>
                    %60 = memref.load %0[] : memref<i32>
                    %61 = memref.load %2[] : memref<i32>
                    %62 = memref.load %49[%c0] : memref<1xi32>
                    %63 = arith.muli %61, %62 : i32
                    %64 = arith.addi %47, %63 : i32
                    %65 = memref.load %3[] : memref<i32>
                    %66 = arith.muli %65, %62 : i32
                    %67 = memref.load %30[%c0] : memref<1xi32>
                    %68 = arith.muli %66, %67 : i32
                    %69 = arith.addi %64, %68 : i32
                    %70 = arith.index_cast %69 : i32 to index
                    %71 = memref.load %5[] : memref<memref<?xf32>>
                    %72 = arith.subi %65, %c1_i32 : i32
                    %73 = arith.muli %72, %62 : i32
                    %74 = arith.muli %73, %67 : i32
                    %75 = arith.addi %64, %74 : i32
                    %76 = arith.index_cast %75 : i32 to index
                    %77 = arith.addi %76, %c0 : index
                    %78 = memref.load %71[%77] : memref<?xf32>
                    %79 = arith.addi %70, %c0 : index
                    memref.store %78, %59[%79] : memref<?xf32>
                  }
                  %56 = memref.load %46[] : memref<i1>
                  memref.store %56, %45[] : memref<i1>
                  %57 = memref.load %45[] : memref<i1>
                  %58 = scf.if %57 -> (i32) {
                    %59 = memref.load %0[] : memref<i32>
                    %60 = arith.addi %47, %c1_i32 : i32
                    memref.store %60, %0[] : memref<i32>
                    scf.yield %60 : i32
                  } else {
                    scf.yield %47 : i32
                  }
                  cf.br ^bb1(%58 : i32)
                ^bb3:  // pred: ^bb1
                  scf.yield %47 : i32
                }
                scf.yield %42 : i32
              } else {
                scf.yield %28 : i32
              }
              scf.yield %41 : i32
            } else {
              scf.yield %28 : i32
            }
            %38 = memref.load %27[] : memref<i1>
            memref.store %38, %26[] : memref<i1>
            %39 = memref.load %26[] : memref<i1>
            scf.if %39 {
              %40 = memref.load %2[] : memref<i32>
              %41 = arith.addi %40, %c1_i32 : i32
              memref.store %41, %2[] : memref<i32>
            }
            cf.br ^bb1(%37 : i32)
          ^bb3:  // pred: ^bb1
            scf.yield %28 : i32
          }
          scf.yield %24 : i32
        } else {
          scf.yield %12 : i32
        }
        scf.yield %23 : i32
      } else {
        scf.yield %12 : i32
      }
      %20 = memref.load %11[] : memref<i1>
      memref.store %20, %10[] : memref<i1>
      %21 = memref.load %10[] : memref<i1>
      scf.if %21 {
        %22 = memref.load %3[] : memref<i32>
        %23 = arith.subi %22, %c1_i32 : i32
        memref.store %23, %3[] : memref<i32>
      }
      cf.br ^bb1(%19 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
}
 replaced mlir-asm-printer: Verifying operation: builtin.module
branch has 1 operands for successor #0, but target block has 2
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%36 = "memref.load"(%6) : (memref<i32>) -> i32 with <block argument> of type 'i32' at index: 1
 replaced mlir-asm-printer: Verifying operation: builtin.module
branch has 1 operands for successor #0, but target block has 2
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%70 = "memref.load"(%6) : (memref<i32>) -> i32 with <block argument> of type 'i32' at index: 0
 replaced mlir-asm-printer: Verifying operation: builtin.module
branch has 1 operands for successor #0, but target block has 2
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%49 = "memref.load"(%6) : (memref<i32>) -> i32 with <block argument> of type 'i32' at index: 0
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%3 = memref.alloca() : memref<i32>
 + forwarding vec to promote {} of mlir-asm-printer: Verifying operation: builtin.module
%3 = memref.alloca() : memref<i32>
Begin forwarding store of mlir-asm-printer: Verifying operation: builtin.module
%3 = memref.alloca() : memref<i32> to load
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %7 {
    %8 = memref.load %6[] : memref<i1>
    scf.if %8 {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        scf.if %9 {
          %23 = memref.get_global @kbm3 : memref<1xi32>
          %24 = memref.load %23[%c0] : memref<1xi32>
          memref.store %24, %3[] : memref<i32>
        }
        %10 = memref.alloca() : memref<i1>
        %11 = memref.alloca() : memref<i1>
        memref.store %true, %11[] : memref<i1>
        cf.br ^bb1(%1, %1 : i32, i32)
      ^bb1(%12: i32, %13: i32):  // 2 preds: ^bb0, ^bb2
        %14 = memref.load %3[] : memref<i32>
        %15 = arith.cmpi sgt, %14, %c0_i32 : i32
        %16 = memref.load %11[] : memref<i1>
        %17 = arith.andi %15, %16 : i1
        cf.cond_br %17, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %18 = memref.load %11[] : memref<i1>
        memref.store %18, %10[] : memref<i1>
        %19 = memref.load %10[] : memref<i1>
        %20:2 = scf.if %19 -> (i32, i32) {
          %23 = memref.load %10[] : memref<i1>
          %24:2 = scf.if %23 -> (i32, i32) {
            %25:2 = scf.execute_region -> (i32, i32) {
              %26 = memref.load %10[] : memref<i1>
              %27 = scf.if %26 -> (i32) {
                memref.store %c0_i32, %2[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %13 : i32
              }
              %28 = memref.alloca() : memref<i1>
              %29 = memref.alloca() : memref<i1>
              memref.store %true, %29[] : memref<i1>
              cf.br ^bb1(%12, %27 : i32, i32)
            ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
              %32 = memref.load %2[] : memref<i32>
              %33 = memref.get_global @jm : memref<1xi32>
              %34 = memref.load %33[%c0] : memref<1xi32>
              %35 = arith.cmpi slt, %31, %34 : i32
              %36 = memref.load %29[] : memref<i1>
              %37 = arith.andi %35, %36 : i1
              cf.cond_br %37, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %38 = memref.load %29[] : memref<i1>
              memref.store %38, %28[] : memref<i1>
              %39 = memref.load %28[] : memref<i1>
              %40 = scf.if %39 -> (i32) {
                %44 = memref.load %28[] : memref<i1>
                %45 = scf.if %44 -> (i32) {
                  %46 = scf.execute_region -> i32 {
                    %47 = memref.load %28[] : memref<i1>
                    %48 = scf.if %47 -> (i32) {
                      memref.store %c0_i32, %0[] : memref<i32>
                      scf.yield %c0_i32 : i32
                    } else {
                      scf.yield %30 : i32
                    }
                    %49 = memref.alloca() : memref<i1>
                    %50 = memref.alloca() : memref<i1>
                    memref.store %true, %50[] : memref<i1>
                    cf.br ^bb1(%48 : i32)
                  ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
                    %52 = memref.load %0[] : memref<i32>
                    %53 = memref.get_global @im : memref<1xi32>
                    %54 = memref.load %53[%c0] : memref<1xi32>
                    %55 = arith.cmpi slt, %51, %54 : i32
                    %56 = memref.load %50[] : memref<i1>
                    %57 = arith.andi %55, %56 : i1
                    cf.cond_br %57, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %58 = memref.load %50[] : memref<i1>
                    memref.store %58, %49[] : memref<i1>
                    %59 = memref.load %49[] : memref<i1>
                    scf.if %59 {
                      %63 = memref.load %4[] : memref<memref<?xf32>>
                      %64 = memref.load %0[] : memref<i32>
                      %65 = memref.load %2[] : memref<i32>
                      %66 = memref.load %53[%c0] : memref<1xi32>
                      %67 = arith.muli %31, %66 : i32
                      %68 = arith.addi %51, %67 : i32
                      %69 = memref.load %3[] : memref<i32>
                      %70 = arith.muli %69, %66 : i32
                      %71 = memref.load %33[%c0] : memref<1xi32>
                      %72 = arith.muli %70, %71 : i32
                      %73 = arith.addi %68, %72 : i32
                      %74 = arith.index_cast %73 : i32 to index
                      %75 = memref.load %5[] : memref<memref<?xf32>>
                      %76 = arith.subi %69, %c1_i32 : i32
                      %77 = arith.muli %76, %66 : i32
                      %78 = arith.muli %77, %71 : i32
                      %79 = arith.addi %68, %78 : i32
                      %80 = arith.index_cast %79 : i32 to index
                      %81 = arith.addi %80, %c0 : index
                      %82 = memref.load %75[%81] : memref<?xf32>
                      %83 = arith.addi %74, %c0 : index
                      memref.store %82, %63[%83] : memref<?xf32>
                    }
                    %60 = memref.load %50[] : memref<i1>
                    memref.store %60, %49[] : memref<i1>
                    %61 = memref.load %49[] : memref<i1>
                    %62 = scf.if %61 -> (i32) {
                      %63 = memref.load %0[] : memref<i32>
                      %64 = arith.addi %51, %c1_i32 : i32
                      memref.store %64, %0[] : memref<i32>
                      scf.yield %64 : i32
                    } else {
                      scf.yield %51 : i32
                    }
                    cf.br ^bb1(%62 : i32)
                  ^bb3:  // pred: ^bb1
                    scf.yield %51 : i32
                  }
                  scf.yield %46 : i32
                } else {
                  scf.yield %30 : i32
                }
                scf.yield %45 : i32
              } else {
                scf.yield %30 : i32
              }
              %41 = memref.load %29[] : memref<i1>
              memref.store %41, %28[] : memref<i1>
              %42 = memref.load %28[] : memref<i1>
              %43 = scf.if %42 -> (i32) {
                %44 = memref.load %2[] : memref<i32>
                %45 = arith.addi %31, %c1_i32 : i32
                memref.store %45, %2[] : memref<i32>
                scf.yield %45 : i32
              } else {
                scf.yield %31 : i32
              }
              cf.br ^bb1(%40, %43 : i32, i32)
            ^bb3:  // pred: ^bb1
              scf.yield %30, %31 : i32, i32
            }
            scf.yield %25#0, %25#1 : i32, i32
          } else {
            scf.yield %12, %13 : i32, i32
          }
          scf.yield %24#0, %24#1 : i32, i32
        } else {
          scf.yield %12, %13 : i32, i32
        }
        %21 = memref.load %11[] : memref<i1>
        memref.store %21, %10[] : memref<i1>
        %22 = memref.load %10[] : memref<i1>
        scf.if %22 {
          %23 = memref.load %3[] : memref<i32>
          %24 = arith.subi %23, %c1_i32 : i32
          memref.store %24, %3[] : memref<i32>
        }
        cf.br ^bb1(%20#0, %20#1 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}
Matching Store: mlir-asm-printer: Verifying operation: func.func
memref.store %24, %3[] : memref<i32>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%23 = memref.load %3[] : memref<i32>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%69 = memref.load %3[] : memref<i32>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%14 = memref.load %3[] : memref<i32>
Matching Store: mlir-asm-printer: Verifying operation: func.func
memref.store %24, %3[] : memref<i32>
Matching Store: mlir-asm-printer: Verifying operation: func.func
memref.store %1, %3[] : memref<i32>
 storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %1, %3[] : memref<i32>
 storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %24, %3[] : memref<i32>
 storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %24, %3[] : memref<i32>
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd98166c60
 derived storing block: 0x7fbd98166b90
 initial storing block: 0x7fbd9800bfc0
 derived storing block: 0x7fbd98167b50
 initial storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd98166b90
 derived storing block: 0x7fbd981669f0
 initial storing block: 0x7fbd98167b50
 derived storing block: 0x7fbd981669f0
 initial storing block: 0x7fbd981669f0
 derived storing block: 0x7fbd98166740
 initial storing block: 0x7fbd981669f0
 derived storing block: 0x7fbd98166740
 initial storing block: 0x7fbd98166740
 derived storing block: 0x7fbd98164100
 initial storing block: 0x7fbd98166740
 derived storing block: 0x7fbd98164100
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32):
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %7 {
    %8 = memref.load %6[] : memref<i1>
    scf.if %8 {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        scf.if %9 {
          %23 = memref.get_global @kbm3 : memref<1xi32>
          %24 = memref.load %23[%c0] : memref<1xi32>
          memref.store %24, %3[] : memref<i32>
        }
        %10 = memref.alloca() : memref<i1>
        %11 = memref.alloca() : memref<i1>
        memref.store %true, %11[] : memref<i1>
        cf.br ^bb1(%1, %1 : i32, i32)
      ^bb1(%12: i32, %13: i32):  // 2 preds: ^bb0, ^bb2
        %14 = memref.load %3[] : memref<i32>
        %15 = arith.cmpi sgt, %14, %c0_i32 : i32
        %16 = memref.load %11[] : memref<i1>
        %17 = arith.andi %15, %16 : i1
        cf.cond_br %17, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %18 = memref.load %11[] : memref<i1>
        memref.store %18, %10[] : memref<i1>
        %19 = memref.load %10[] : memref<i1>
        %20:2 = scf.if %19 -> (i32, i32) {
          %23 = memref.load %10[] : memref<i1>
          %24:2 = scf.if %23 -> (i32, i32) {
            %25:2 = scf.execute_region -> (i32, i32) {
              %26 = memref.load %10[] : memref<i1>
              %27 = scf.if %26 -> (i32) {
                memref.store %c0_i32, %2[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %13 : i32
              }
              %28 = memref.alloca() : memref<i1>
              %29 = memref.alloca() : memref<i1>
              memref.store %true, %29[] : memref<i1>
              cf.br ^bb1(%12, %27 : i32, i32)
            ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
              %32 = memref.load %2[] : memref<i32>
              %33 = memref.get_global @jm : memref<1xi32>
              %34 = memref.load %33[%c0] : memref<1xi32>
              %35 = arith.cmpi slt, %31, %34 : i32
              %36 = memref.load %29[] : memref<i1>
              %37 = arith.andi %35, %36 : i1
              cf.cond_br %37, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %38 = memref.load %29[] : memref<i1>
              memref.store %38, %28[] : memref<i1>
              %39 = memref.load %28[] : memref<i1>
              %40 = scf.if %39 -> (i32) {
                %44 = memref.load %28[] : memref<i1>
                %45 = scf.if %44 -> (i32) {
                  %46 = scf.execute_region -> i32 {
                    %47 = memref.load %28[] : memref<i1>
                    %48 = scf.if %47 -> (i32) {
                      memref.store %c0_i32, %0[] : memref<i32>
                      scf.yield %c0_i32 : i32
                    } else {
                      scf.yield %30 : i32
                    }
                    %49 = memref.alloca() : memref<i1>
                    %50 = memref.alloca() : memref<i1>
                    memref.store %true, %50[] : memref<i1>
                    cf.br ^bb1(%48 : i32)
                  ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
                    %52 = memref.load %0[] : memref<i32>
                    %53 = memref.get_global @im : memref<1xi32>
                    %54 = memref.load %53[%c0] : memref<1xi32>
                    %55 = arith.cmpi slt, %51, %54 : i32
                    %56 = memref.load %50[] : memref<i1>
                    %57 = arith.andi %55, %56 : i1
                    cf.cond_br %57, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %58 = memref.load %50[] : memref<i1>
                    memref.store %58, %49[] : memref<i1>
                    %59 = memref.load %49[] : memref<i1>
                    scf.if %59 {
                      %63 = memref.load %4[] : memref<memref<?xf32>>
                      %64 = memref.load %0[] : memref<i32>
                      %65 = memref.load %2[] : memref<i32>
                      %66 = memref.load %53[%c0] : memref<1xi32>
                      %67 = arith.muli %31, %66 : i32
                      %68 = arith.addi %51, %67 : i32
                      %69 = memref.load %3[] : memref<i32>
                      %70 = arith.muli %69, %66 : i32
                      %71 = memref.load %33[%c0] : memref<1xi32>
                      %72 = arith.muli %70, %71 : i32
                      %73 = arith.addi %68, %72 : i32
                      %74 = arith.index_cast %73 : i32 to index
                      %75 = memref.load %5[] : memref<memref<?xf32>>
                      %76 = arith.subi %69, %c1_i32 : i32
                      %77 = arith.muli %76, %66 : i32
                      %78 = arith.muli %77, %71 : i32
                      %79 = arith.addi %68, %78 : i32
                      %80 = arith.index_cast %79 : i32 to index
                      %81 = arith.addi %80, %c0 : index
                      %82 = memref.load %75[%81] : memref<?xf32>
                      %83 = arith.addi %74, %c0 : index
                      memref.store %82, %63[%83] : memref<?xf32>
                    }
                    %60 = memref.load %50[] : memref<i1>
                    memref.store %60, %49[] : memref<i1>
                    %61 = memref.load %49[] : memref<i1>
                    %62 = scf.if %61 -> (i32) {
                      %63 = memref.load %0[] : memref<i32>
                      %64 = arith.addi %51, %c1_i32 : i32
                      memref.store %64, %0[] : memref<i32>
                      scf.yield %64 : i32
                    } else {
                      scf.yield %51 : i32
                    }
                    cf.br ^bb1(%62 : i32)
                  ^bb3:  // pred: ^bb1
                    scf.yield %51 : i32
                  }
                  scf.yield %46 : i32
                } else {
                  scf.yield %30 : i32
                }
                scf.yield %45 : i32
              } else {
                scf.yield %30 : i32
              }
              %41 = memref.load %29[] : memref<i1>
              memref.store %41, %28[] : memref<i1>
              %42 = memref.load %28[] : memref<i1>
              %43 = scf.if %42 -> (i32) {
                %44 = memref.load %2[] : memref<i32>
                %45 = arith.addi %31, %c1_i32 : i32
                memref.store %45, %2[] : memref<i32>
                scf.yield %45 : i32
              } else {
                scf.yield %31 : i32
              }
              cf.br ^bb1(%40, %43 : i32, i32)
            ^bb3:  // pred: ^bb1
              scf.yield %30, %31 : i32, i32
            }
            scf.yield %25#0, %25#1 : i32, i32
          } else {
            scf.yield %12, %13 : i32, i32
          }
          scf.yield %24#0, %24#1 : i32, i32
        } else {
          scf.yield %12, %13 : i32, i32
        }
        %21 = memref.load %11[] : memref<i1>
        memref.store %21, %10[] : memref<i1>
        %22 = memref.load %10[] : memref<i1>
        scf.if %22 {
          %23 = memref.load %3[] : memref<i32>
          %24 = arith.subi %23, %c1_i32 : i32
          memref.store %24, %3[] : memref<i32>
        }
        cf.br ^bb1(%20#0, %20#1 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  func.return


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%1 = llvm.mlir.undef : i32
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %8 = memref.load %6[] : memref<i1>
  scf.if %8 {
    scf.execute_region {
      %9 = memref.load %6[] : memref<i1>
      scf.if %9 {
        %23 = memref.get_global @kbm3 : memref<1xi32>
        %24 = memref.load %23[%c0] : memref<1xi32>
        memref.store %24, %3[] : memref<i32>
      }
      %10 = memref.alloca() : memref<i1>
      %11 = memref.alloca() : memref<i1>
      memref.store %true, %11[] : memref<i1>
      cf.br ^bb1(%1, %1 : i32, i32)
    ^bb1(%12: i32, %13: i32):  // 2 preds: ^bb0, ^bb2
      %14 = memref.load %3[] : memref<i32>
      %15 = arith.cmpi sgt, %14, %c0_i32 : i32
      %16 = memref.load %11[] : memref<i1>
      %17 = arith.andi %15, %16 : i1
      cf.cond_br %17, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %18 = memref.load %11[] : memref<i1>
      memref.store %18, %10[] : memref<i1>
      %19 = memref.load %10[] : memref<i1>
      %20:2 = scf.if %19 -> (i32, i32) {
        %23 = memref.load %10[] : memref<i1>
        %24:2 = scf.if %23 -> (i32, i32) {
          %25:2 = scf.execute_region -> (i32, i32) {
            %26 = memref.load %10[] : memref<i1>
            %27 = scf.if %26 -> (i32) {
              memref.store %c0_i32, %2[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %13 : i32
            }
            %28 = memref.alloca() : memref<i1>
            %29 = memref.alloca() : memref<i1>
            memref.store %true, %29[] : memref<i1>
            cf.br ^bb1(%12, %27 : i32, i32)
          ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
            %32 = memref.load %2[] : memref<i32>
            %33 = memref.get_global @jm : memref<1xi32>
            %34 = memref.load %33[%c0] : memref<1xi32>
            %35 = arith.cmpi slt, %31, %34 : i32
            %36 = memref.load %29[] : memref<i1>
            %37 = arith.andi %35, %36 : i1
            cf.cond_br %37, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %38 = memref.load %29[] : memref<i1>
            memref.store %38, %28[] : memref<i1>
            %39 = memref.load %28[] : memref<i1>
            %40 = scf.if %39 -> (i32) {
              %44 = memref.load %28[] : memref<i1>
              %45 = scf.if %44 -> (i32) {
                %46 = scf.execute_region -> i32 {
                  %47 = memref.load %28[] : memref<i1>
                  %48 = scf.if %47 -> (i32) {
                    memref.store %c0_i32, %0[] : memref<i32>
                    scf.yield %c0_i32 : i32
                  } else {
                    scf.yield %30 : i32
                  }
                  %49 = memref.alloca() : memref<i1>
                  %50 = memref.alloca() : memref<i1>
                  memref.store %true, %50[] : memref<i1>
                  cf.br ^bb1(%48 : i32)
                ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
                  %52 = memref.load %0[] : memref<i32>
                  %53 = memref.get_global @im : memref<1xi32>
                  %54 = memref.load %53[%c0] : memref<1xi32>
                  %55 = arith.cmpi slt, %51, %54 : i32
                  %56 = memref.load %50[] : memref<i1>
                  %57 = arith.andi %55, %56 : i1
                  cf.cond_br %57, ^bb2, ^bb3
                ^bb2:  // pred: ^bb1
                  %58 = memref.load %50[] : memref<i1>
                  memref.store %58, %49[] : memref<i1>
                  %59 = memref.load %49[] : memref<i1>
                  scf.if %59 {
                    %63 = memref.load %4[] : memref<memref<?xf32>>
                    %64 = memref.load %0[] : memref<i32>
                    %65 = memref.load %2[] : memref<i32>
                    %66 = memref.load %53[%c0] : memref<1xi32>
                    %67 = arith.muli %31, %66 : i32
                    %68 = arith.addi %51, %67 : i32
                    %69 = memref.load %3[] : memref<i32>
                    %70 = arith.muli %69, %66 : i32
                    %71 = memref.load %33[%c0] : memref<1xi32>
                    %72 = arith.muli %70, %71 : i32
                    %73 = arith.addi %68, %72 : i32
                    %74 = arith.index_cast %73 : i32 to index
                    %75 = memref.load %5[] : memref<memref<?xf32>>
                    %76 = arith.subi %69, %c1_i32 : i32
                    %77 = arith.muli %76, %66 : i32
                    %78 = arith.muli %77, %71 : i32
                    %79 = arith.addi %68, %78 : i32
                    %80 = arith.index_cast %79 : i32 to index
                    %81 = arith.addi %80, %c0 : index
                    %82 = memref.load %75[%81] : memref<?xf32>
                    %83 = arith.addi %74, %c0 : index
                    memref.store %82, %63[%83] : memref<?xf32>
                  }
                  %60 = memref.load %50[] : memref<i1>
                  memref.store %60, %49[] : memref<i1>
                  %61 = memref.load %49[] : memref<i1>
                  %62 = scf.if %61 -> (i32) {
                    %63 = memref.load %0[] : memref<i32>
                    %64 = arith.addi %51, %c1_i32 : i32
                    memref.store %64, %0[] : memref<i32>
                    scf.yield %64 : i32
                  } else {
                    scf.yield %51 : i32
                  }
                  cf.br ^bb1(%62 : i32)
                ^bb3:  // pred: ^bb1
                  scf.yield %51 : i32
                }
                scf.yield %46 : i32
              } else {
                scf.yield %30 : i32
              }
              scf.yield %45 : i32
            } else {
              scf.yield %30 : i32
            }
            %41 = memref.load %29[] : memref<i1>
            memref.store %41, %28[] : memref<i1>
            %42 = memref.load %28[] : memref<i1>
            %43 = scf.if %42 -> (i32) {
              %44 = memref.load %2[] : memref<i32>
              %45 = arith.addi %31, %c1_i32 : i32
              memref.store %45, %2[] : memref<i32>
              scf.yield %45 : i32
            } else {
              scf.yield %31 : i32
            }
            cf.br ^bb1(%40, %43 : i32, i32)
          ^bb3:  // pred: ^bb1
            scf.yield %30, %31 : i32, i32
          }
          scf.yield %25#0, %25#1 : i32, i32
        } else {
          scf.yield %12, %13 : i32, i32
        }
        scf.yield %24#0, %24#1 : i32, i32
      } else {
        scf.yield %12, %13 : i32, i32
      }
      %21 = memref.load %11[] : memref<i1>
      memref.store %21, %10[] : memref<i1>
      %22 = memref.load %10[] : memref<i1>
      scf.if %22 {
        %23 = memref.load %3[] : memref<i32>
        %24 = arith.subi %23, %c1_i32 : i32
        memref.store %24, %3[] : memref<i32>
      }
      cf.br ^bb1(%20#0, %20#1 : i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
  scf.yield


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%1 = llvm.mlir.undef : i32
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.execute_region {
    %9 = memref.load %6[] : memref<i1>
    scf.if %9 {
      %23 = memref.get_global @kbm3 : memref<1xi32>
      %24 = memref.load %23[%c0] : memref<1xi32>
      memref.store %24, %3[] : memref<i32>
    }
    %10 = memref.alloca() : memref<i1>
    %11 = memref.alloca() : memref<i1>
    memref.store %true, %11[] : memref<i1>
    cf.br ^bb1(%1, %1 : i32, i32)
  ^bb1(%12: i32, %13: i32):  // 2 preds: ^bb0, ^bb2
    %14 = memref.load %3[] : memref<i32>
    %15 = arith.cmpi sgt, %14, %c0_i32 : i32
    %16 = memref.load %11[] : memref<i1>
    %17 = arith.andi %15, %16 : i1
    cf.cond_br %17, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %18 = memref.load %11[] : memref<i1>
    memref.store %18, %10[] : memref<i1>
    %19 = memref.load %10[] : memref<i1>
    %20:2 = scf.if %19 -> (i32, i32) {
      %23 = memref.load %10[] : memref<i1>
      %24:2 = scf.if %23 -> (i32, i32) {
        %25:2 = scf.execute_region -> (i32, i32) {
          %26 = memref.load %10[] : memref<i1>
          %27 = scf.if %26 -> (i32) {
            memref.store %c0_i32, %2[] : memref<i32>
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %13 : i32
          }
          %28 = memref.alloca() : memref<i1>
          %29 = memref.alloca() : memref<i1>
          memref.store %true, %29[] : memref<i1>
          cf.br ^bb1(%12, %27 : i32, i32)
        ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
          %32 = memref.load %2[] : memref<i32>
          %33 = memref.get_global @jm : memref<1xi32>
          %34 = memref.load %33[%c0] : memref<1xi32>
          %35 = arith.cmpi slt, %31, %34 : i32
          %36 = memref.load %29[] : memref<i1>
          %37 = arith.andi %35, %36 : i1
          cf.cond_br %37, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %38 = memref.load %29[] : memref<i1>
          memref.store %38, %28[] : memref<i1>
          %39 = memref.load %28[] : memref<i1>
          %40 = scf.if %39 -> (i32) {
            %44 = memref.load %28[] : memref<i1>
            %45 = scf.if %44 -> (i32) {
              %46 = scf.execute_region -> i32 {
                %47 = memref.load %28[] : memref<i1>
                %48 = scf.if %47 -> (i32) {
                  memref.store %c0_i32, %0[] : memref<i32>
                  scf.yield %c0_i32 : i32
                } else {
                  scf.yield %30 : i32
                }
                %49 = memref.alloca() : memref<i1>
                %50 = memref.alloca() : memref<i1>
                memref.store %true, %50[] : memref<i1>
                cf.br ^bb1(%48 : i32)
              ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
                %52 = memref.load %0[] : memref<i32>
                %53 = memref.get_global @im : memref<1xi32>
                %54 = memref.load %53[%c0] : memref<1xi32>
                %55 = arith.cmpi slt, %51, %54 : i32
                %56 = memref.load %50[] : memref<i1>
                %57 = arith.andi %55, %56 : i1
                cf.cond_br %57, ^bb2, ^bb3
              ^bb2:  // pred: ^bb1
                %58 = memref.load %50[] : memref<i1>
                memref.store %58, %49[] : memref<i1>
                %59 = memref.load %49[] : memref<i1>
                scf.if %59 {
                  %63 = memref.load %4[] : memref<memref<?xf32>>
                  %64 = memref.load %0[] : memref<i32>
                  %65 = memref.load %2[] : memref<i32>
                  %66 = memref.load %53[%c0] : memref<1xi32>
                  %67 = arith.muli %31, %66 : i32
                  %68 = arith.addi %51, %67 : i32
                  %69 = memref.load %3[] : memref<i32>
                  %70 = arith.muli %69, %66 : i32
                  %71 = memref.load %33[%c0] : memref<1xi32>
                  %72 = arith.muli %70, %71 : i32
                  %73 = arith.addi %68, %72 : i32
                  %74 = arith.index_cast %73 : i32 to index
                  %75 = memref.load %5[] : memref<memref<?xf32>>
                  %76 = arith.subi %69, %c1_i32 : i32
                  %77 = arith.muli %76, %66 : i32
                  %78 = arith.muli %77, %71 : i32
                  %79 = arith.addi %68, %78 : i32
                  %80 = arith.index_cast %79 : i32 to index
                  %81 = arith.addi %80, %c0 : index
                  %82 = memref.load %75[%81] : memref<?xf32>
                  %83 = arith.addi %74, %c0 : index
                  memref.store %82, %63[%83] : memref<?xf32>
                }
                %60 = memref.load %50[] : memref<i1>
                memref.store %60, %49[] : memref<i1>
                %61 = memref.load %49[] : memref<i1>
                %62 = scf.if %61 -> (i32) {
                  %63 = memref.load %0[] : memref<i32>
                  %64 = arith.addi %51, %c1_i32 : i32
                  memref.store %64, %0[] : memref<i32>
                  scf.yield %64 : i32
                } else {
                  scf.yield %51 : i32
                }
                cf.br ^bb1(%62 : i32)
              ^bb3:  // pred: ^bb1
                scf.yield %51 : i32
              }
              scf.yield %46 : i32
            } else {
              scf.yield %30 : i32
            }
            scf.yield %45 : i32
          } else {
            scf.yield %30 : i32
          }
          %41 = memref.load %29[] : memref<i1>
          memref.store %41, %28[] : memref<i1>
          %42 = memref.load %28[] : memref<i1>
          %43 = scf.if %42 -> (i32) {
            %44 = memref.load %2[] : memref<i32>
            %45 = arith.addi %31, %c1_i32 : i32
            memref.store %45, %2[] : memref<i32>
            scf.yield %45 : i32
          } else {
            scf.yield %31 : i32
          }
          cf.br ^bb1(%40, %43 : i32, i32)
        ^bb3:  // pred: ^bb1
          scf.yield %30, %31 : i32, i32
        }
        scf.yield %25#0, %25#1 : i32, i32
      } else {
        scf.yield %12, %13 : i32, i32
      }
      scf.yield %24#0, %24#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    %21 = memref.load %11[] : memref<i1>
    memref.store %21, %10[] : memref<i1>
    %22 = memref.load %10[] : memref<i1>
    scf.if %22 {
      %23 = memref.load %3[] : memref<i32>
      %24 = arith.subi %23, %c1_i32 : i32
      memref.store %24, %3[] : memref<i32>
    }
    cf.br ^bb1(%20#0, %20#1 : i32, i32)
  ^bb3:  // pred: ^bb1
    scf.yield
  }
  scf.yield


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%1 = llvm.mlir.undef : i32
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %9 = memref.load %6[] : memref<i1>
  scf.if %9 {
    %23 = memref.get_global @kbm3 : memref<1xi32>
    %24 = memref.load %23[%c0] : memref<1xi32>
    memref.store %24, %3[] : memref<i32>
  }
  %10 = memref.alloca() : memref<i1>
  %11 = memref.alloca() : memref<i1>
  memref.store %true, %11[] : memref<i1>
  cf.br ^bb1(%1, %1 : i32, i32)


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%1 = llvm.mlir.undef : i32
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %23 = memref.get_global @kbm3 : memref<1xi32>
  %24 = memref.load %23[%c0] : memref<1xi32>
  memref.store %24, %3[] : memref<i32>
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %23 = memref.get_global @kbm3 : memref<1xi32>
  %24 = memref.load %23[%c0] : memref<1xi32>
  memref.store %24, %3[] : memref<i32>
  scf.yield
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%24 = memref.load %23[%c0] : memref<1xi32>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %9 = memref.load %6[] : memref<i1>
  scf.if %9 {
    %23 = memref.get_global @kbm3 : memref<1xi32>
    %24 = memref.load %23[%c0] : memref<1xi32>
    memref.store %24, %3[] : memref<i32>
  }
  %10 = memref.alloca() : memref<i1>
  %11 = memref.alloca() : memref<i1>
  memref.store %true, %11[] : memref<i1>
  cf.br ^bb1(%1, %1 : i32, i32)
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %9 {
  %23 = memref.get_global @kbm3 : memref<1xi32>
  %24 = memref.load %23[%c0] : memref<1xi32>
  memref.store %24, %3[] : memref<i32>
}

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb1(%12: i32, %13: i32):  // 2 preds: ^bb0, ^bb2
  %14 = memref.load %3[] : memref<i32>
  %15 = arith.cmpi sgt, %14, %c0_i32 : i32
  %16 = memref.load %11[] : memref<i1>
  %17 = arith.andi %15, %16 : i1
  cf.cond_br %17, ^bb2, ^bb3

mlir-asm-printer: Verifying operation: builtin.module
^bb1(%12: i32, %13: i32):  // 2 preds: ^bb0, ^bb2
  %14 = memref.load %3[] : memref<i32>
  %15 = arith.cmpi sgt, %14, %c0_i32 : i32
  %16 = memref.load %11[] : memref<i1>
  %17 = arith.andi %15, %16 : i1
  cf.cond_br %17, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%12: i32, %13: i32):  // 2 preds: ^bb0, ^bb2
  %14 = memref.load %3[] : memref<i32>
  %15 = arith.cmpi sgt, %14, %c0_i32 : i32
  %16 = memref.load %11[] : memref<i1>
  %17 = arith.andi %15, %16 : i1
  cf.cond_br %17, ^bb2, ^bb3
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%14 = memref.load %3[] : memref<i32>

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %23 = memref.load %10[] : memref<i1>
  %24:2 = scf.if %23 -> (i32, i32) {
    %25:2 = scf.execute_region -> (i32, i32) {
      %26 = memref.load %10[] : memref<i1>
      %27 = scf.if %26 -> (i32) {
        memref.store %c0_i32, %2[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %13 : i32
      }
      %28 = memref.alloca() : memref<i1>
      %29 = memref.alloca() : memref<i1>
      memref.store %true, %29[] : memref<i1>
      cf.br ^bb1(%12, %27 : i32, i32)
    ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
      %32 = memref.load %2[] : memref<i32>
      %33 = memref.get_global @jm : memref<1xi32>
      %34 = memref.load %33[%c0] : memref<1xi32>
      %35 = arith.cmpi slt, %31, %34 : i32
      %36 = memref.load %29[] : memref<i1>
      %37 = arith.andi %35, %36 : i1
      cf.cond_br %37, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %38 = memref.load %29[] : memref<i1>
      memref.store %38, %28[] : memref<i1>
      %39 = memref.load %28[] : memref<i1>
      %40 = scf.if %39 -> (i32) {
        %44 = memref.load %28[] : memref<i1>
        %45 = scf.if %44 -> (i32) {
          %46 = scf.execute_region -> i32 {
            %47 = memref.load %28[] : memref<i1>
            %48 = scf.if %47 -> (i32) {
              memref.store %c0_i32, %0[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %30 : i32
            }
            %49 = memref.alloca() : memref<i1>
            %50 = memref.alloca() : memref<i1>
            memref.store %true, %50[] : memref<i1>
            cf.br ^bb1(%48 : i32)
          ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
            %52 = memref.load %0[] : memref<i32>
            %53 = memref.get_global @im : memref<1xi32>
            %54 = memref.load %53[%c0] : memref<1xi32>
            %55 = arith.cmpi slt, %51, %54 : i32
            %56 = memref.load %50[] : memref<i1>
            %57 = arith.andi %55, %56 : i1
            cf.cond_br %57, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %58 = memref.load %50[] : memref<i1>
            memref.store %58, %49[] : memref<i1>
            %59 = memref.load %49[] : memref<i1>
            scf.if %59 {
              %63 = memref.load %4[] : memref<memref<?xf32>>
              %64 = memref.load %0[] : memref<i32>
              %65 = memref.load %2[] : memref<i32>
              %66 = memref.load %53[%c0] : memref<1xi32>
              %67 = arith.muli %31, %66 : i32
              %68 = arith.addi %51, %67 : i32
              %69 = memref.load %3[] : memref<i32>
              %70 = arith.muli %69, %66 : i32
              %71 = memref.load %33[%c0] : memref<1xi32>
              %72 = arith.muli %70, %71 : i32
              %73 = arith.addi %68, %72 : i32
              %74 = arith.index_cast %73 : i32 to index
              %75 = memref.load %5[] : memref<memref<?xf32>>
              %76 = arith.subi %69, %c1_i32 : i32
              %77 = arith.muli %76, %66 : i32
              %78 = arith.muli %77, %71 : i32
              %79 = arith.addi %68, %78 : i32
              %80 = arith.index_cast %79 : i32 to index
              %81 = arith.addi %80, %c0 : index
              %82 = memref.load %75[%81] : memref<?xf32>
              %83 = arith.addi %74, %c0 : index
              memref.store %82, %63[%83] : memref<?xf32>
            }
            %60 = memref.load %50[] : memref<i1>
            memref.store %60, %49[] : memref<i1>
            %61 = memref.load %49[] : memref<i1>
            %62 = scf.if %61 -> (i32) {
              %63 = memref.load %0[] : memref<i32>
              %64 = arith.addi %51, %c1_i32 : i32
              memref.store %64, %0[] : memref<i32>
              scf.yield %64 : i32
            } else {
              scf.yield %51 : i32
            }
            cf.br ^bb1(%62 : i32)
          ^bb3:  // pred: ^bb1
            scf.yield %51 : i32
          }
          scf.yield %46 : i32
        } else {
          scf.yield %30 : i32
        }
        scf.yield %45 : i32
      } else {
        scf.yield %30 : i32
      }
      %41 = memref.load %29[] : memref<i1>
      memref.store %41, %28[] : memref<i1>
      %42 = memref.load %28[] : memref<i1>
      %43 = scf.if %42 -> (i32) {
        %44 = memref.load %2[] : memref<i32>
        %45 = arith.addi %31, %c1_i32 : i32
        memref.store %45, %2[] : memref<i32>
        scf.yield %45 : i32
      } else {
        scf.yield %31 : i32
      }
      cf.br ^bb1(%40, %43 : i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield %30, %31 : i32, i32
    }
    scf.yield %25#0, %25#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  scf.yield %24#0, %24#1 : i32, i32


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %25:2 = scf.execute_region -> (i32, i32) {
    %26 = memref.load %10[] : memref<i1>
    %27 = scf.if %26 -> (i32) {
      memref.store %c0_i32, %2[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %13 : i32
    }
    %28 = memref.alloca() : memref<i1>
    %29 = memref.alloca() : memref<i1>
    memref.store %true, %29[] : memref<i1>
    cf.br ^bb1(%12, %27 : i32, i32)
  ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
    %32 = memref.load %2[] : memref<i32>
    %33 = memref.get_global @jm : memref<1xi32>
    %34 = memref.load %33[%c0] : memref<1xi32>
    %35 = arith.cmpi slt, %31, %34 : i32
    %36 = memref.load %29[] : memref<i1>
    %37 = arith.andi %35, %36 : i1
    cf.cond_br %37, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %38 = memref.load %29[] : memref<i1>
    memref.store %38, %28[] : memref<i1>
    %39 = memref.load %28[] : memref<i1>
    %40 = scf.if %39 -> (i32) {
      %44 = memref.load %28[] : memref<i1>
      %45 = scf.if %44 -> (i32) {
        %46 = scf.execute_region -> i32 {
          %47 = memref.load %28[] : memref<i1>
          %48 = scf.if %47 -> (i32) {
            memref.store %c0_i32, %0[] : memref<i32>
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %30 : i32
          }
          %49 = memref.alloca() : memref<i1>
          %50 = memref.alloca() : memref<i1>
          memref.store %true, %50[] : memref<i1>
          cf.br ^bb1(%48 : i32)
        ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
          %52 = memref.load %0[] : memref<i32>
          %53 = memref.get_global @im : memref<1xi32>
          %54 = memref.load %53[%c0] : memref<1xi32>
          %55 = arith.cmpi slt, %51, %54 : i32
          %56 = memref.load %50[] : memref<i1>
          %57 = arith.andi %55, %56 : i1
          cf.cond_br %57, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %58 = memref.load %50[] : memref<i1>
          memref.store %58, %49[] : memref<i1>
          %59 = memref.load %49[] : memref<i1>
          scf.if %59 {
            %63 = memref.load %4[] : memref<memref<?xf32>>
            %64 = memref.load %0[] : memref<i32>
            %65 = memref.load %2[] : memref<i32>
            %66 = memref.load %53[%c0] : memref<1xi32>
            %67 = arith.muli %31, %66 : i32
            %68 = arith.addi %51, %67 : i32
            %69 = memref.load %3[] : memref<i32>
            %70 = arith.muli %69, %66 : i32
            %71 = memref.load %33[%c0] : memref<1xi32>
            %72 = arith.muli %70, %71 : i32
            %73 = arith.addi %68, %72 : i32
            %74 = arith.index_cast %73 : i32 to index
            %75 = memref.load %5[] : memref<memref<?xf32>>
            %76 = arith.subi %69, %c1_i32 : i32
            %77 = arith.muli %76, %66 : i32
            %78 = arith.muli %77, %71 : i32
            %79 = arith.addi %68, %78 : i32
            %80 = arith.index_cast %79 : i32 to index
            %81 = arith.addi %80, %c0 : index
            %82 = memref.load %75[%81] : memref<?xf32>
            %83 = arith.addi %74, %c0 : index
            memref.store %82, %63[%83] : memref<?xf32>
          }
          %60 = memref.load %50[] : memref<i1>
          memref.store %60, %49[] : memref<i1>
          %61 = memref.load %49[] : memref<i1>
          %62 = scf.if %61 -> (i32) {
            %63 = memref.load %0[] : memref<i32>
            %64 = arith.addi %51, %c1_i32 : i32
            memref.store %64, %0[] : memref<i32>
            scf.yield %64 : i32
          } else {
            scf.yield %51 : i32
          }
          cf.br ^bb1(%62 : i32)
        ^bb3:  // pred: ^bb1
          scf.yield %51 : i32
        }
        scf.yield %46 : i32
      } else {
        scf.yield %30 : i32
      }
      scf.yield %45 : i32
    } else {
      scf.yield %30 : i32
    }
    %41 = memref.load %29[] : memref<i1>
    memref.store %41, %28[] : memref<i1>
    %42 = memref.load %28[] : memref<i1>
    %43 = scf.if %42 -> (i32) {
      %44 = memref.load %2[] : memref<i32>
      %45 = arith.addi %31, %c1_i32 : i32
      memref.store %45, %2[] : memref<i32>
      scf.yield %45 : i32
    } else {
      scf.yield %31 : i32
    }
    cf.br ^bb1(%40, %43 : i32, i32)
  ^bb3:  // pred: ^bb1
    scf.yield %30, %31 : i32, i32
  }
  scf.yield %25#0, %25#1 : i32, i32


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.load %10[] : memref<i1>
  %27 = scf.if %26 -> (i32) {
    memref.store %c0_i32, %2[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %13 : i32
  }
  %28 = memref.alloca() : memref<i1>
  %29 = memref.alloca() : memref<i1>
  memref.store %true, %29[] : memref<i1>
  cf.br ^bb1(%12, %27 : i32, i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %2[] : memref<i32>
  scf.yield %c0_i32 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %2[] : memref<i32>
  scf.yield %c0_i32 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %13 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %13 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.load %10[] : memref<i1>
  %27 = scf.if %26 -> (i32) {
    memref.store %c0_i32, %2[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %13 : i32
  }
  %28 = memref.alloca() : memref<i1>
  %29 = memref.alloca() : memref<i1>
  memref.store %true, %29[] : memref<i1>
  cf.br ^bb1(%12, %27 : i32, i32)
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
  %32 = memref.load %2[] : memref<i32>
  %33 = memref.get_global @jm : memref<1xi32>
  %34 = memref.load %33[%c0] : memref<1xi32>
  %35 = arith.cmpi slt, %31, %34 : i32
  %36 = memref.load %29[] : memref<i1>
  %37 = arith.andi %35, %36 : i1
  cf.cond_br %37, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
  %32 = memref.load %2[] : memref<i32>
  %33 = memref.get_global @jm : memref<1xi32>
  %34 = memref.load %33[%c0] : memref<1xi32>
  %35 = arith.cmpi slt, %31, %34 : i32
  %36 = memref.load %29[] : memref<i1>
  %37 = arith.andi %35, %36 : i1
  cf.cond_br %37, ^bb2, ^bb3
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %38 = memref.load %29[] : memref<i1>
  memref.store %38, %28[] : memref<i1>
  %39 = memref.load %28[] : memref<i1>
  %40 = scf.if %39 -> (i32) {
    %44 = memref.load %28[] : memref<i1>
    %45 = scf.if %44 -> (i32) {
      %46 = scf.execute_region -> i32 {
        %47 = memref.load %28[] : memref<i1>
        %48 = scf.if %47 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %30 : i32
        }
        %49 = memref.alloca() : memref<i1>
        %50 = memref.alloca() : memref<i1>
        memref.store %true, %50[] : memref<i1>
        cf.br ^bb1(%48 : i32)
      ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
        %52 = memref.load %0[] : memref<i32>
        %53 = memref.get_global @im : memref<1xi32>
        %54 = memref.load %53[%c0] : memref<1xi32>
        %55 = arith.cmpi slt, %51, %54 : i32
        %56 = memref.load %50[] : memref<i1>
        %57 = arith.andi %55, %56 : i1
        cf.cond_br %57, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %58 = memref.load %50[] : memref<i1>
        memref.store %58, %49[] : memref<i1>
        %59 = memref.load %49[] : memref<i1>
        scf.if %59 {
          %63 = memref.load %4[] : memref<memref<?xf32>>
          %64 = memref.load %0[] : memref<i32>
          %65 = memref.load %2[] : memref<i32>
          %66 = memref.load %53[%c0] : memref<1xi32>
          %67 = arith.muli %31, %66 : i32
          %68 = arith.addi %51, %67 : i32
          %69 = memref.load %3[] : memref<i32>
          %70 = arith.muli %69, %66 : i32
          %71 = memref.load %33[%c0] : memref<1xi32>
          %72 = arith.muli %70, %71 : i32
          %73 = arith.addi %68, %72 : i32
          %74 = arith.index_cast %73 : i32 to index
          %75 = memref.load %5[] : memref<memref<?xf32>>
          %76 = arith.subi %69, %c1_i32 : i32
          %77 = arith.muli %76, %66 : i32
          %78 = arith.muli %77, %71 : i32
          %79 = arith.addi %68, %78 : i32
          %80 = arith.index_cast %79 : i32 to index
          %81 = arith.addi %80, %c0 : index
          %82 = memref.load %75[%81] : memref<?xf32>
          %83 = arith.addi %74, %c0 : index
          memref.store %82, %63[%83] : memref<?xf32>
        }
        %60 = memref.load %50[] : memref<i1>
        memref.store %60, %49[] : memref<i1>
        %61 = memref.load %49[] : memref<i1>
        %62 = scf.if %61 -> (i32) {
          %63 = memref.load %0[] : memref<i32>
          %64 = arith.addi %51, %c1_i32 : i32
          memref.store %64, %0[] : memref<i32>
          scf.yield %64 : i32
        } else {
          scf.yield %51 : i32
        }
        cf.br ^bb1(%62 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %51 : i32
      }
      scf.yield %46 : i32
    } else {
      scf.yield %30 : i32
    }
    scf.yield %45 : i32
  } else {
    scf.yield %30 : i32
  }
  %41 = memref.load %29[] : memref<i1>
  memref.store %41, %28[] : memref<i1>
  %42 = memref.load %28[] : memref<i1>
  %43 = scf.if %42 -> (i32) {
    %44 = memref.load %2[] : memref<i32>
    %45 = arith.addi %31, %c1_i32 : i32
    memref.store %45, %2[] : memref<i32>
    scf.yield %45 : i32
  } else {
    scf.yield %31 : i32
  }
  cf.br ^bb1(%40, %43 : i32, i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %44 = memref.load %28[] : memref<i1>
  %45 = scf.if %44 -> (i32) {
    %46 = scf.execute_region -> i32 {
      %47 = memref.load %28[] : memref<i1>
      %48 = scf.if %47 -> (i32) {
        memref.store %c0_i32, %0[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %30 : i32
      }
      %49 = memref.alloca() : memref<i1>
      %50 = memref.alloca() : memref<i1>
      memref.store %true, %50[] : memref<i1>
      cf.br ^bb1(%48 : i32)
    ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
      %52 = memref.load %0[] : memref<i32>
      %53 = memref.get_global @im : memref<1xi32>
      %54 = memref.load %53[%c0] : memref<1xi32>
      %55 = arith.cmpi slt, %51, %54 : i32
      %56 = memref.load %50[] : memref<i1>
      %57 = arith.andi %55, %56 : i1
      cf.cond_br %57, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %58 = memref.load %50[] : memref<i1>
      memref.store %58, %49[] : memref<i1>
      %59 = memref.load %49[] : memref<i1>
      scf.if %59 {
        %63 = memref.load %4[] : memref<memref<?xf32>>
        %64 = memref.load %0[] : memref<i32>
        %65 = memref.load %2[] : memref<i32>
        %66 = memref.load %53[%c0] : memref<1xi32>
        %67 = arith.muli %31, %66 : i32
        %68 = arith.addi %51, %67 : i32
        %69 = memref.load %3[] : memref<i32>
        %70 = arith.muli %69, %66 : i32
        %71 = memref.load %33[%c0] : memref<1xi32>
        %72 = arith.muli %70, %71 : i32
        %73 = arith.addi %68, %72 : i32
        %74 = arith.index_cast %73 : i32 to index
        %75 = memref.load %5[] : memref<memref<?xf32>>
        %76 = arith.subi %69, %c1_i32 : i32
        %77 = arith.muli %76, %66 : i32
        %78 = arith.muli %77, %71 : i32
        %79 = arith.addi %68, %78 : i32
        %80 = arith.index_cast %79 : i32 to index
        %81 = arith.addi %80, %c0 : index
        %82 = memref.load %75[%81] : memref<?xf32>
        %83 = arith.addi %74, %c0 : index
        memref.store %82, %63[%83] : memref<?xf32>
      }
      %60 = memref.load %50[] : memref<i1>
      memref.store %60, %49[] : memref<i1>
      %61 = memref.load %49[] : memref<i1>
      %62 = scf.if %61 -> (i32) {
        %63 = memref.load %0[] : memref<i32>
        %64 = arith.addi %51, %c1_i32 : i32
        memref.store %64, %0[] : memref<i32>
        scf.yield %64 : i32
      } else {
        scf.yield %51 : i32
      }
      cf.br ^bb1(%62 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %51 : i32
    }
    scf.yield %46 : i32
  } else {
    scf.yield %30 : i32
  }
  scf.yield %45 : i32


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %46 = scf.execute_region -> i32 {
    %47 = memref.load %28[] : memref<i1>
    %48 = scf.if %47 -> (i32) {
      memref.store %c0_i32, %0[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %30 : i32
    }
    %49 = memref.alloca() : memref<i1>
    %50 = memref.alloca() : memref<i1>
    memref.store %true, %50[] : memref<i1>
    cf.br ^bb1(%48 : i32)
  ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
    %52 = memref.load %0[] : memref<i32>
    %53 = memref.get_global @im : memref<1xi32>
    %54 = memref.load %53[%c0] : memref<1xi32>
    %55 = arith.cmpi slt, %51, %54 : i32
    %56 = memref.load %50[] : memref<i1>
    %57 = arith.andi %55, %56 : i1
    cf.cond_br %57, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %58 = memref.load %50[] : memref<i1>
    memref.store %58, %49[] : memref<i1>
    %59 = memref.load %49[] : memref<i1>
    scf.if %59 {
      %63 = memref.load %4[] : memref<memref<?xf32>>
      %64 = memref.load %0[] : memref<i32>
      %65 = memref.load %2[] : memref<i32>
      %66 = memref.load %53[%c0] : memref<1xi32>
      %67 = arith.muli %31, %66 : i32
      %68 = arith.addi %51, %67 : i32
      %69 = memref.load %3[] : memref<i32>
      %70 = arith.muli %69, %66 : i32
      %71 = memref.load %33[%c0] : memref<1xi32>
      %72 = arith.muli %70, %71 : i32
      %73 = arith.addi %68, %72 : i32
      %74 = arith.index_cast %73 : i32 to index
      %75 = memref.load %5[] : memref<memref<?xf32>>
      %76 = arith.subi %69, %c1_i32 : i32
      %77 = arith.muli %76, %66 : i32
      %78 = arith.muli %77, %71 : i32
      %79 = arith.addi %68, %78 : i32
      %80 = arith.index_cast %79 : i32 to index
      %81 = arith.addi %80, %c0 : index
      %82 = memref.load %75[%81] : memref<?xf32>
      %83 = arith.addi %74, %c0 : index
      memref.store %82, %63[%83] : memref<?xf32>
    }
    %60 = memref.load %50[] : memref<i1>
    memref.store %60, %49[] : memref<i1>
    %61 = memref.load %49[] : memref<i1>
    %62 = scf.if %61 -> (i32) {
      %63 = memref.load %0[] : memref<i32>
      %64 = arith.addi %51, %c1_i32 : i32
      memref.store %64, %0[] : memref<i32>
      scf.yield %64 : i32
    } else {
      scf.yield %51 : i32
    }
    cf.br ^bb1(%62 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %51 : i32
  }
  scf.yield %46 : i32


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %28[] : memref<i1>
  %48 = scf.if %47 -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %30 : i32
  }
  %49 = memref.alloca() : memref<i1>
  %50 = memref.alloca() : memref<i1>
  memref.store %true, %50[] : memref<i1>
  cf.br ^bb1(%48 : i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield %c0_i32 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield %c0_i32 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %30 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %30 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %28[] : memref<i1>
  %48 = scf.if %47 -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %30 : i32
  }
  %49 = memref.alloca() : memref<i1>
  %50 = memref.alloca() : memref<i1>
  memref.store %true, %50[] : memref<i1>
  cf.br ^bb1(%48 : i32)
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
  %52 = memref.load %0[] : memref<i32>
  %53 = memref.get_global @im : memref<1xi32>
  %54 = memref.load %53[%c0] : memref<1xi32>
  %55 = arith.cmpi slt, %51, %54 : i32
  %56 = memref.load %50[] : memref<i1>
  %57 = arith.andi %55, %56 : i1
  cf.cond_br %57, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
  %52 = memref.load %0[] : memref<i32>
  %53 = memref.get_global @im : memref<1xi32>
  %54 = memref.load %53[%c0] : memref<1xi32>
  %55 = arith.cmpi slt, %51, %54 : i32
  %56 = memref.load %50[] : memref<i1>
  %57 = arith.andi %55, %56 : i1
  cf.cond_br %57, ^bb2, ^bb3
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %58 = memref.load %50[] : memref<i1>
  memref.store %58, %49[] : memref<i1>
  %59 = memref.load %49[] : memref<i1>
  scf.if %59 {
    %63 = memref.load %4[] : memref<memref<?xf32>>
    %64 = memref.load %0[] : memref<i32>
    %65 = memref.load %2[] : memref<i32>
    %66 = memref.load %53[%c0] : memref<1xi32>
    %67 = arith.muli %31, %66 : i32
    %68 = arith.addi %51, %67 : i32
    %69 = memref.load %3[] : memref<i32>
    %70 = arith.muli %69, %66 : i32
    %71 = memref.load %33[%c0] : memref<1xi32>
    %72 = arith.muli %70, %71 : i32
    %73 = arith.addi %68, %72 : i32
    %74 = arith.index_cast %73 : i32 to index
    %75 = memref.load %5[] : memref<memref<?xf32>>
    %76 = arith.subi %69, %c1_i32 : i32
    %77 = arith.muli %76, %66 : i32
    %78 = arith.muli %77, %71 : i32
    %79 = arith.addi %68, %78 : i32
    %80 = arith.index_cast %79 : i32 to index
    %81 = arith.addi %80, %c0 : index
    %82 = memref.load %75[%81] : memref<?xf32>
    %83 = arith.addi %74, %c0 : index
    memref.store %82, %63[%83] : memref<?xf32>
  }
  %60 = memref.load %50[] : memref<i1>
  memref.store %60, %49[] : memref<i1>
  %61 = memref.load %49[] : memref<i1>
  %62 = scf.if %61 -> (i32) {
    %63 = memref.load %0[] : memref<i32>
    %64 = arith.addi %51, %c1_i32 : i32
    memref.store %64, %0[] : memref<i32>
    scf.yield %64 : i32
  } else {
    scf.yield %51 : i32
  }
  cf.br ^bb1(%62 : i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %63 = memref.load %4[] : memref<memref<?xf32>>
  %64 = memref.load %0[] : memref<i32>
  %65 = memref.load %2[] : memref<i32>
  %66 = memref.load %53[%c0] : memref<1xi32>
  %67 = arith.muli %31, %66 : i32
  %68 = arith.addi %51, %67 : i32
  %69 = memref.load %3[] : memref<i32>
  %70 = arith.muli %69, %66 : i32
  %71 = memref.load %33[%c0] : memref<1xi32>
  %72 = arith.muli %70, %71 : i32
  %73 = arith.addi %68, %72 : i32
  %74 = arith.index_cast %73 : i32 to index
  %75 = memref.load %5[] : memref<memref<?xf32>>
  %76 = arith.subi %69, %c1_i32 : i32
  %77 = arith.muli %76, %66 : i32
  %78 = arith.muli %77, %71 : i32
  %79 = arith.addi %68, %78 : i32
  %80 = arith.index_cast %79 : i32 to index
  %81 = arith.addi %80, %c0 : index
  %82 = memref.load %75[%81] : memref<?xf32>
  %83 = arith.addi %74, %c0 : index
  memref.store %82, %63[%83] : memref<?xf32>
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %63 = memref.load %4[] : memref<memref<?xf32>>
  %64 = memref.load %0[] : memref<i32>
  %65 = memref.load %2[] : memref<i32>
  %66 = memref.load %53[%c0] : memref<1xi32>
  %67 = arith.muli %31, %66 : i32
  %68 = arith.addi %51, %67 : i32
  %69 = memref.load %3[] : memref<i32>
  %70 = arith.muli %69, %66 : i32
  %71 = memref.load %33[%c0] : memref<1xi32>
  %72 = arith.muli %70, %71 : i32
  %73 = arith.addi %68, %72 : i32
  %74 = arith.index_cast %73 : i32 to index
  %75 = memref.load %5[] : memref<memref<?xf32>>
  %76 = arith.subi %69, %c1_i32 : i32
  %77 = arith.muli %76, %66 : i32
  %78 = arith.muli %77, %71 : i32
  %79 = arith.addi %68, %78 : i32
  %80 = arith.index_cast %79 : i32 to index
  %81 = arith.addi %80, %c0 : index
  %82 = memref.load %75[%81] : memref<?xf32>
  %83 = arith.addi %74, %c0 : index
  memref.store %82, %63[%83] : memref<?xf32>
  scf.yield
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%69 = memref.load %3[] : memref<i32>

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %63 = memref.load %0[] : memref<i32>
  %64 = arith.addi %51, %c1_i32 : i32
  memref.store %64, %0[] : memref<i32>
  scf.yield %64 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %63 = memref.load %0[] : memref<i32>
  %64 = arith.addi %51, %c1_i32 : i32
  memref.store %64, %0[] : memref<i32>
  scf.yield %64 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %51 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %51 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %58 = memref.load %50[] : memref<i1>
  memref.store %58, %49[] : memref<i1>
  %59 = memref.load %49[] : memref<i1>
  scf.if %59 {
    %63 = memref.load %4[] : memref<memref<?xf32>>
    %64 = memref.load %0[] : memref<i32>
    %65 = memref.load %2[] : memref<i32>
    %66 = memref.load %53[%c0] : memref<1xi32>
    %67 = arith.muli %31, %66 : i32
    %68 = arith.addi %51, %67 : i32
    %69 = memref.load %3[] : memref<i32>
    %70 = arith.muli %69, %66 : i32
    %71 = memref.load %33[%c0] : memref<1xi32>
    %72 = arith.muli %70, %71 : i32
    %73 = arith.addi %68, %72 : i32
    %74 = arith.index_cast %73 : i32 to index
    %75 = memref.load %5[] : memref<memref<?xf32>>
    %76 = arith.subi %69, %c1_i32 : i32
    %77 = arith.muli %76, %66 : i32
    %78 = arith.muli %77, %71 : i32
    %79 = arith.addi %68, %78 : i32
    %80 = arith.index_cast %79 : i32 to index
    %81 = arith.addi %80, %c0 : index
    %82 = memref.load %75[%81] : memref<?xf32>
    %83 = arith.addi %74, %c0 : index
    memref.store %82, %63[%83] : memref<?xf32>
  }
  %60 = memref.load %50[] : memref<i1>
  memref.store %60, %49[] : memref<i1>
  %61 = memref.load %49[] : memref<i1>
  %62 = scf.if %61 -> (i32) {
    %63 = memref.load %0[] : memref<i32>
    %64 = arith.addi %51, %c1_i32 : i32
    memref.store %64, %0[] : memref<i32>
    scf.yield %64 : i32
  } else {
    scf.yield %51 : i32
  }
  cf.br ^bb1(%62 : i32)
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %51 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %51 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %46 = scf.execute_region -> i32 {
    %47 = memref.load %28[] : memref<i1>
    %48 = scf.if %47 -> (i32) {
      memref.store %c0_i32, %0[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %30 : i32
    }
    %49 = memref.alloca() : memref<i1>
    %50 = memref.alloca() : memref<i1>
    memref.store %true, %50[] : memref<i1>
    cf.br ^bb1(%48 : i32)
  ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
    %52 = memref.load %0[] : memref<i32>
    %53 = memref.get_global @im : memref<1xi32>
    %54 = memref.load %53[%c0] : memref<1xi32>
    %55 = arith.cmpi slt, %51, %54 : i32
    %56 = memref.load %50[] : memref<i1>
    %57 = arith.andi %55, %56 : i1
    cf.cond_br %57, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %58 = memref.load %50[] : memref<i1>
    memref.store %58, %49[] : memref<i1>
    %59 = memref.load %49[] : memref<i1>
    scf.if %59 {
      %63 = memref.load %4[] : memref<memref<?xf32>>
      %64 = memref.load %0[] : memref<i32>
      %65 = memref.load %2[] : memref<i32>
      %66 = memref.load %53[%c0] : memref<1xi32>
      %67 = arith.muli %31, %66 : i32
      %68 = arith.addi %51, %67 : i32
      %69 = memref.load %3[] : memref<i32>
      %70 = arith.muli %69, %66 : i32
      %71 = memref.load %33[%c0] : memref<1xi32>
      %72 = arith.muli %70, %71 : i32
      %73 = arith.addi %68, %72 : i32
      %74 = arith.index_cast %73 : i32 to index
      %75 = memref.load %5[] : memref<memref<?xf32>>
      %76 = arith.subi %69, %c1_i32 : i32
      %77 = arith.muli %76, %66 : i32
      %78 = arith.muli %77, %71 : i32
      %79 = arith.addi %68, %78 : i32
      %80 = arith.index_cast %79 : i32 to index
      %81 = arith.addi %80, %c0 : index
      %82 = memref.load %75[%81] : memref<?xf32>
      %83 = arith.addi %74, %c0 : index
      memref.store %82, %63[%83] : memref<?xf32>
    }
    %60 = memref.load %50[] : memref<i1>
    memref.store %60, %49[] : memref<i1>
    %61 = memref.load %49[] : memref<i1>
    %62 = scf.if %61 -> (i32) {
      %63 = memref.load %0[] : memref<i32>
      %64 = arith.addi %51, %c1_i32 : i32
      memref.store %64, %0[] : memref<i32>
      scf.yield %64 : i32
    } else {
      scf.yield %51 : i32
    }
    cf.br ^bb1(%62 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %51 : i32
  }
  scf.yield %46 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %30 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %30 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %44 = memref.load %28[] : memref<i1>
  %45 = scf.if %44 -> (i32) {
    %46 = scf.execute_region -> i32 {
      %47 = memref.load %28[] : memref<i1>
      %48 = scf.if %47 -> (i32) {
        memref.store %c0_i32, %0[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %30 : i32
      }
      %49 = memref.alloca() : memref<i1>
      %50 = memref.alloca() : memref<i1>
      memref.store %true, %50[] : memref<i1>
      cf.br ^bb1(%48 : i32)
    ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
      %52 = memref.load %0[] : memref<i32>
      %53 = memref.get_global @im : memref<1xi32>
      %54 = memref.load %53[%c0] : memref<1xi32>
      %55 = arith.cmpi slt, %51, %54 : i32
      %56 = memref.load %50[] : memref<i1>
      %57 = arith.andi %55, %56 : i1
      cf.cond_br %57, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %58 = memref.load %50[] : memref<i1>
      memref.store %58, %49[] : memref<i1>
      %59 = memref.load %49[] : memref<i1>
      scf.if %59 {
        %63 = memref.load %4[] : memref<memref<?xf32>>
        %64 = memref.load %0[] : memref<i32>
        %65 = memref.load %2[] : memref<i32>
        %66 = memref.load %53[%c0] : memref<1xi32>
        %67 = arith.muli %31, %66 : i32
        %68 = arith.addi %51, %67 : i32
        %69 = memref.load %3[] : memref<i32>
        %70 = arith.muli %69, %66 : i32
        %71 = memref.load %33[%c0] : memref<1xi32>
        %72 = arith.muli %70, %71 : i32
        %73 = arith.addi %68, %72 : i32
        %74 = arith.index_cast %73 : i32 to index
        %75 = memref.load %5[] : memref<memref<?xf32>>
        %76 = arith.subi %69, %c1_i32 : i32
        %77 = arith.muli %76, %66 : i32
        %78 = arith.muli %77, %71 : i32
        %79 = arith.addi %68, %78 : i32
        %80 = arith.index_cast %79 : i32 to index
        %81 = arith.addi %80, %c0 : index
        %82 = memref.load %75[%81] : memref<?xf32>
        %83 = arith.addi %74, %c0 : index
        memref.store %82, %63[%83] : memref<?xf32>
      }
      %60 = memref.load %50[] : memref<i1>
      memref.store %60, %49[] : memref<i1>
      %61 = memref.load %49[] : memref<i1>
      %62 = scf.if %61 -> (i32) {
        %63 = memref.load %0[] : memref<i32>
        %64 = arith.addi %51, %c1_i32 : i32
        memref.store %64, %0[] : memref<i32>
        scf.yield %64 : i32
      } else {
        scf.yield %51 : i32
      }
      cf.br ^bb1(%62 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %51 : i32
    }
    scf.yield %46 : i32
  } else {
    scf.yield %30 : i32
  }
  scf.yield %45 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %30 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %30 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %44 = memref.load %2[] : memref<i32>
  %45 = arith.addi %31, %c1_i32 : i32
  memref.store %45, %2[] : memref<i32>
  scf.yield %45 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %44 = memref.load %2[] : memref<i32>
  %45 = arith.addi %31, %c1_i32 : i32
  memref.store %45, %2[] : memref<i32>
  scf.yield %45 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %31 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %31 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %38 = memref.load %29[] : memref<i1>
  memref.store %38, %28[] : memref<i1>
  %39 = memref.load %28[] : memref<i1>
  %40 = scf.if %39 -> (i32) {
    %44 = memref.load %28[] : memref<i1>
    %45 = scf.if %44 -> (i32) {
      %46 = scf.execute_region -> i32 {
        %47 = memref.load %28[] : memref<i1>
        %48 = scf.if %47 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %30 : i32
        }
        %49 = memref.alloca() : memref<i1>
        %50 = memref.alloca() : memref<i1>
        memref.store %true, %50[] : memref<i1>
        cf.br ^bb1(%48 : i32)
      ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
        %52 = memref.load %0[] : memref<i32>
        %53 = memref.get_global @im : memref<1xi32>
        %54 = memref.load %53[%c0] : memref<1xi32>
        %55 = arith.cmpi slt, %51, %54 : i32
        %56 = memref.load %50[] : memref<i1>
        %57 = arith.andi %55, %56 : i1
        cf.cond_br %57, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %58 = memref.load %50[] : memref<i1>
        memref.store %58, %49[] : memref<i1>
        %59 = memref.load %49[] : memref<i1>
        scf.if %59 {
          %63 = memref.load %4[] : memref<memref<?xf32>>
          %64 = memref.load %0[] : memref<i32>
          %65 = memref.load %2[] : memref<i32>
          %66 = memref.load %53[%c0] : memref<1xi32>
          %67 = arith.muli %31, %66 : i32
          %68 = arith.addi %51, %67 : i32
          %69 = memref.load %3[] : memref<i32>
          %70 = arith.muli %69, %66 : i32
          %71 = memref.load %33[%c0] : memref<1xi32>
          %72 = arith.muli %70, %71 : i32
          %73 = arith.addi %68, %72 : i32
          %74 = arith.index_cast %73 : i32 to index
          %75 = memref.load %5[] : memref<memref<?xf32>>
          %76 = arith.subi %69, %c1_i32 : i32
          %77 = arith.muli %76, %66 : i32
          %78 = arith.muli %77, %71 : i32
          %79 = arith.addi %68, %78 : i32
          %80 = arith.index_cast %79 : i32 to index
          %81 = arith.addi %80, %c0 : index
          %82 = memref.load %75[%81] : memref<?xf32>
          %83 = arith.addi %74, %c0 : index
          memref.store %82, %63[%83] : memref<?xf32>
        }
        %60 = memref.load %50[] : memref<i1>
        memref.store %60, %49[] : memref<i1>
        %61 = memref.load %49[] : memref<i1>
        %62 = scf.if %61 -> (i32) {
          %63 = memref.load %0[] : memref<i32>
          %64 = arith.addi %51, %c1_i32 : i32
          memref.store %64, %0[] : memref<i32>
          scf.yield %64 : i32
        } else {
          scf.yield %51 : i32
        }
        cf.br ^bb1(%62 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %51 : i32
      }
      scf.yield %46 : i32
    } else {
      scf.yield %30 : i32
    }
    scf.yield %45 : i32
  } else {
    scf.yield %30 : i32
  }
  %41 = memref.load %29[] : memref<i1>
  memref.store %41, %28[] : memref<i1>
  %42 = memref.load %28[] : memref<i1>
  %43 = scf.if %42 -> (i32) {
    %44 = memref.load %2[] : memref<i32>
    %45 = arith.addi %31, %c1_i32 : i32
    memref.store %45, %2[] : memref<i32>
    scf.yield %45 : i32
  } else {
    scf.yield %31 : i32
  }
  cf.br ^bb1(%40, %43 : i32, i32)
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %30, %31 : i32, i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %30, %31 : i32, i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %25:2 = scf.execute_region -> (i32, i32) {
    %26 = memref.load %10[] : memref<i1>
    %27 = scf.if %26 -> (i32) {
      memref.store %c0_i32, %2[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %13 : i32
    }
    %28 = memref.alloca() : memref<i1>
    %29 = memref.alloca() : memref<i1>
    memref.store %true, %29[] : memref<i1>
    cf.br ^bb1(%12, %27 : i32, i32)
  ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
    %32 = memref.load %2[] : memref<i32>
    %33 = memref.get_global @jm : memref<1xi32>
    %34 = memref.load %33[%c0] : memref<1xi32>
    %35 = arith.cmpi slt, %31, %34 : i32
    %36 = memref.load %29[] : memref<i1>
    %37 = arith.andi %35, %36 : i1
    cf.cond_br %37, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %38 = memref.load %29[] : memref<i1>
    memref.store %38, %28[] : memref<i1>
    %39 = memref.load %28[] : memref<i1>
    %40 = scf.if %39 -> (i32) {
      %44 = memref.load %28[] : memref<i1>
      %45 = scf.if %44 -> (i32) {
        %46 = scf.execute_region -> i32 {
          %47 = memref.load %28[] : memref<i1>
          %48 = scf.if %47 -> (i32) {
            memref.store %c0_i32, %0[] : memref<i32>
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %30 : i32
          }
          %49 = memref.alloca() : memref<i1>
          %50 = memref.alloca() : memref<i1>
          memref.store %true, %50[] : memref<i1>
          cf.br ^bb1(%48 : i32)
        ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
          %52 = memref.load %0[] : memref<i32>
          %53 = memref.get_global @im : memref<1xi32>
          %54 = memref.load %53[%c0] : memref<1xi32>
          %55 = arith.cmpi slt, %51, %54 : i32
          %56 = memref.load %50[] : memref<i1>
          %57 = arith.andi %55, %56 : i1
          cf.cond_br %57, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %58 = memref.load %50[] : memref<i1>
          memref.store %58, %49[] : memref<i1>
          %59 = memref.load %49[] : memref<i1>
          scf.if %59 {
            %63 = memref.load %4[] : memref<memref<?xf32>>
            %64 = memref.load %0[] : memref<i32>
            %65 = memref.load %2[] : memref<i32>
            %66 = memref.load %53[%c0] : memref<1xi32>
            %67 = arith.muli %31, %66 : i32
            %68 = arith.addi %51, %67 : i32
            %69 = memref.load %3[] : memref<i32>
            %70 = arith.muli %69, %66 : i32
            %71 = memref.load %33[%c0] : memref<1xi32>
            %72 = arith.muli %70, %71 : i32
            %73 = arith.addi %68, %72 : i32
            %74 = arith.index_cast %73 : i32 to index
            %75 = memref.load %5[] : memref<memref<?xf32>>
            %76 = arith.subi %69, %c1_i32 : i32
            %77 = arith.muli %76, %66 : i32
            %78 = arith.muli %77, %71 : i32
            %79 = arith.addi %68, %78 : i32
            %80 = arith.index_cast %79 : i32 to index
            %81 = arith.addi %80, %c0 : index
            %82 = memref.load %75[%81] : memref<?xf32>
            %83 = arith.addi %74, %c0 : index
            memref.store %82, %63[%83] : memref<?xf32>
          }
          %60 = memref.load %50[] : memref<i1>
          memref.store %60, %49[] : memref<i1>
          %61 = memref.load %49[] : memref<i1>
          %62 = scf.if %61 -> (i32) {
            %63 = memref.load %0[] : memref<i32>
            %64 = arith.addi %51, %c1_i32 : i32
            memref.store %64, %0[] : memref<i32>
            scf.yield %64 : i32
          } else {
            scf.yield %51 : i32
          }
          cf.br ^bb1(%62 : i32)
        ^bb3:  // pred: ^bb1
          scf.yield %51 : i32
        }
        scf.yield %46 : i32
      } else {
        scf.yield %30 : i32
      }
      scf.yield %45 : i32
    } else {
      scf.yield %30 : i32
    }
    %41 = memref.load %29[] : memref<i1>
    memref.store %41, %28[] : memref<i1>
    %42 = memref.load %28[] : memref<i1>
    %43 = scf.if %42 -> (i32) {
      %44 = memref.load %2[] : memref<i32>
      %45 = arith.addi %31, %c1_i32 : i32
      memref.store %45, %2[] : memref<i32>
      scf.yield %45 : i32
    } else {
      scf.yield %31 : i32
    }
    cf.br ^bb1(%40, %43 : i32, i32)
  ^bb3:  // pred: ^bb1
    scf.yield %30, %31 : i32, i32
  }
  scf.yield %25#0, %25#1 : i32, i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %12, %13 : i32, i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %12, %13 : i32, i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %23 = memref.load %10[] : memref<i1>
  %24:2 = scf.if %23 -> (i32, i32) {
    %25:2 = scf.execute_region -> (i32, i32) {
      %26 = memref.load %10[] : memref<i1>
      %27 = scf.if %26 -> (i32) {
        memref.store %c0_i32, %2[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %13 : i32
      }
      %28 = memref.alloca() : memref<i1>
      %29 = memref.alloca() : memref<i1>
      memref.store %true, %29[] : memref<i1>
      cf.br ^bb1(%12, %27 : i32, i32)
    ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
      %32 = memref.load %2[] : memref<i32>
      %33 = memref.get_global @jm : memref<1xi32>
      %34 = memref.load %33[%c0] : memref<1xi32>
      %35 = arith.cmpi slt, %31, %34 : i32
      %36 = memref.load %29[] : memref<i1>
      %37 = arith.andi %35, %36 : i1
      cf.cond_br %37, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %38 = memref.load %29[] : memref<i1>
      memref.store %38, %28[] : memref<i1>
      %39 = memref.load %28[] : memref<i1>
      %40 = scf.if %39 -> (i32) {
        %44 = memref.load %28[] : memref<i1>
        %45 = scf.if %44 -> (i32) {
          %46 = scf.execute_region -> i32 {
            %47 = memref.load %28[] : memref<i1>
            %48 = scf.if %47 -> (i32) {
              memref.store %c0_i32, %0[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %30 : i32
            }
            %49 = memref.alloca() : memref<i1>
            %50 = memref.alloca() : memref<i1>
            memref.store %true, %50[] : memref<i1>
            cf.br ^bb1(%48 : i32)
          ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
            %52 = memref.load %0[] : memref<i32>
            %53 = memref.get_global @im : memref<1xi32>
            %54 = memref.load %53[%c0] : memref<1xi32>
            %55 = arith.cmpi slt, %51, %54 : i32
            %56 = memref.load %50[] : memref<i1>
            %57 = arith.andi %55, %56 : i1
            cf.cond_br %57, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %58 = memref.load %50[] : memref<i1>
            memref.store %58, %49[] : memref<i1>
            %59 = memref.load %49[] : memref<i1>
            scf.if %59 {
              %63 = memref.load %4[] : memref<memref<?xf32>>
              %64 = memref.load %0[] : memref<i32>
              %65 = memref.load %2[] : memref<i32>
              %66 = memref.load %53[%c0] : memref<1xi32>
              %67 = arith.muli %31, %66 : i32
              %68 = arith.addi %51, %67 : i32
              %69 = memref.load %3[] : memref<i32>
              %70 = arith.muli %69, %66 : i32
              %71 = memref.load %33[%c0] : memref<1xi32>
              %72 = arith.muli %70, %71 : i32
              %73 = arith.addi %68, %72 : i32
              %74 = arith.index_cast %73 : i32 to index
              %75 = memref.load %5[] : memref<memref<?xf32>>
              %76 = arith.subi %69, %c1_i32 : i32
              %77 = arith.muli %76, %66 : i32
              %78 = arith.muli %77, %71 : i32
              %79 = arith.addi %68, %78 : i32
              %80 = arith.index_cast %79 : i32 to index
              %81 = arith.addi %80, %c0 : index
              %82 = memref.load %75[%81] : memref<?xf32>
              %83 = arith.addi %74, %c0 : index
              memref.store %82, %63[%83] : memref<?xf32>
            }
            %60 = memref.load %50[] : memref<i1>
            memref.store %60, %49[] : memref<i1>
            %61 = memref.load %49[] : memref<i1>
            %62 = scf.if %61 -> (i32) {
              %63 = memref.load %0[] : memref<i32>
              %64 = arith.addi %51, %c1_i32 : i32
              memref.store %64, %0[] : memref<i32>
              scf.yield %64 : i32
            } else {
              scf.yield %51 : i32
            }
            cf.br ^bb1(%62 : i32)
          ^bb3:  // pred: ^bb1
            scf.yield %51 : i32
          }
          scf.yield %46 : i32
        } else {
          scf.yield %30 : i32
        }
        scf.yield %45 : i32
      } else {
        scf.yield %30 : i32
      }
      %41 = memref.load %29[] : memref<i1>
      memref.store %41, %28[] : memref<i1>
      %42 = memref.load %28[] : memref<i1>
      %43 = scf.if %42 -> (i32) {
        %44 = memref.load %2[] : memref<i32>
        %45 = arith.addi %31, %c1_i32 : i32
        memref.store %45, %2[] : memref<i32>
        scf.yield %45 : i32
      } else {
        scf.yield %31 : i32
      }
      cf.br ^bb1(%40, %43 : i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield %30, %31 : i32, i32
    }
    scf.yield %25#0, %25#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  scf.yield %24#0, %24#1 : i32, i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %12, %13 : i32, i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %12, %13 : i32, i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %23 = memref.load %3[] : memref<i32>
  %24 = arith.subi %23, %c1_i32 : i32
  memref.store %24, %3[] : memref<i32>
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %23 = memref.load %3[] : memref<i32>
  %24 = arith.subi %23, %c1_i32 : i32
  memref.store %24, %3[] : memref<i32>
  scf.yield
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%24 = arith.subi %23, %c1_i32 : i32
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %22 {
  %23 = memref.load %3[] : memref<i32>
  %24 = arith.subi %23, %c1_i32 : i32
  memref.store %24, %3[] : memref<i32>
}

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield

mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.execute_region {
    %9 = memref.load %6[] : memref<i1>
    scf.if %9 {
      %23 = memref.get_global @kbm3 : memref<1xi32>
      %24 = memref.load %23[%c0] : memref<1xi32>
      memref.store %24, %3[] : memref<i32>
    }
    %10 = memref.alloca() : memref<i1>
    %11 = memref.alloca() : memref<i1>
    memref.store %true, %11[] : memref<i1>
    cf.br ^bb1(%1, %1 : i32, i32)
  ^bb1(%12: i32, %13: i32):  // 2 preds: ^bb0, ^bb2
    %14 = memref.load %3[] : memref<i32>
    %15 = arith.cmpi sgt, %14, %c0_i32 : i32
    %16 = memref.load %11[] : memref<i1>
    %17 = arith.andi %15, %16 : i1
    cf.cond_br %17, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %18 = memref.load %11[] : memref<i1>
    memref.store %18, %10[] : memref<i1>
    %19 = memref.load %10[] : memref<i1>
    %20:2 = scf.if %19 -> (i32, i32) {
      %23 = memref.load %10[] : memref<i1>
      %24:2 = scf.if %23 -> (i32, i32) {
        %25:2 = scf.execute_region -> (i32, i32) {
          %26 = memref.load %10[] : memref<i1>
          %27 = scf.if %26 -> (i32) {
            memref.store %c0_i32, %2[] : memref<i32>
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %13 : i32
          }
          %28 = memref.alloca() : memref<i1>
          %29 = memref.alloca() : memref<i1>
          memref.store %true, %29[] : memref<i1>
          cf.br ^bb1(%12, %27 : i32, i32)
        ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
          %32 = memref.load %2[] : memref<i32>
          %33 = memref.get_global @jm : memref<1xi32>
          %34 = memref.load %33[%c0] : memref<1xi32>
          %35 = arith.cmpi slt, %31, %34 : i32
          %36 = memref.load %29[] : memref<i1>
          %37 = arith.andi %35, %36 : i1
          cf.cond_br %37, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %38 = memref.load %29[] : memref<i1>
          memref.store %38, %28[] : memref<i1>
          %39 = memref.load %28[] : memref<i1>
          %40 = scf.if %39 -> (i32) {
            %44 = memref.load %28[] : memref<i1>
            %45 = scf.if %44 -> (i32) {
              %46 = scf.execute_region -> i32 {
                %47 = memref.load %28[] : memref<i1>
                %48 = scf.if %47 -> (i32) {
                  memref.store %c0_i32, %0[] : memref<i32>
                  scf.yield %c0_i32 : i32
                } else {
                  scf.yield %30 : i32
                }
                %49 = memref.alloca() : memref<i1>
                %50 = memref.alloca() : memref<i1>
                memref.store %true, %50[] : memref<i1>
                cf.br ^bb1(%48 : i32)
              ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
                %52 = memref.load %0[] : memref<i32>
                %53 = memref.get_global @im : memref<1xi32>
                %54 = memref.load %53[%c0] : memref<1xi32>
                %55 = arith.cmpi slt, %51, %54 : i32
                %56 = memref.load %50[] : memref<i1>
                %57 = arith.andi %55, %56 : i1
                cf.cond_br %57, ^bb2, ^bb3
              ^bb2:  // pred: ^bb1
                %58 = memref.load %50[] : memref<i1>
                memref.store %58, %49[] : memref<i1>
                %59 = memref.load %49[] : memref<i1>
                scf.if %59 {
                  %63 = memref.load %4[] : memref<memref<?xf32>>
                  %64 = memref.load %0[] : memref<i32>
                  %65 = memref.load %2[] : memref<i32>
                  %66 = memref.load %53[%c0] : memref<1xi32>
                  %67 = arith.muli %31, %66 : i32
                  %68 = arith.addi %51, %67 : i32
                  %69 = memref.load %3[] : memref<i32>
                  %70 = arith.muli %69, %66 : i32
                  %71 = memref.load %33[%c0] : memref<1xi32>
                  %72 = arith.muli %70, %71 : i32
                  %73 = arith.addi %68, %72 : i32
                  %74 = arith.index_cast %73 : i32 to index
                  %75 = memref.load %5[] : memref<memref<?xf32>>
                  %76 = arith.subi %69, %c1_i32 : i32
                  %77 = arith.muli %76, %66 : i32
                  %78 = arith.muli %77, %71 : i32
                  %79 = arith.addi %68, %78 : i32
                  %80 = arith.index_cast %79 : i32 to index
                  %81 = arith.addi %80, %c0 : index
                  %82 = memref.load %75[%81] : memref<?xf32>
                  %83 = arith.addi %74, %c0 : index
                  memref.store %82, %63[%83] : memref<?xf32>
                }
                %60 = memref.load %50[] : memref<i1>
                memref.store %60, %49[] : memref<i1>
                %61 = memref.load %49[] : memref<i1>
                %62 = scf.if %61 -> (i32) {
                  %63 = memref.load %0[] : memref<i32>
                  %64 = arith.addi %51, %c1_i32 : i32
                  memref.store %64, %0[] : memref<i32>
                  scf.yield %64 : i32
                } else {
                  scf.yield %51 : i32
                }
                cf.br ^bb1(%62 : i32)
              ^bb3:  // pred: ^bb1
                scf.yield %51 : i32
              }
              scf.yield %46 : i32
            } else {
              scf.yield %30 : i32
            }
            scf.yield %45 : i32
          } else {
            scf.yield %30 : i32
          }
          %41 = memref.load %29[] : memref<i1>
          memref.store %41, %28[] : memref<i1>
          %42 = memref.load %28[] : memref<i1>
          %43 = scf.if %42 -> (i32) {
            %44 = memref.load %2[] : memref<i32>
            %45 = arith.addi %31, %c1_i32 : i32
            memref.store %45, %2[] : memref<i32>
            scf.yield %45 : i32
          } else {
            scf.yield %31 : i32
          }
          cf.br ^bb1(%40, %43 : i32, i32)
        ^bb3:  // pred: ^bb1
          scf.yield %30, %31 : i32, i32
        }
        scf.yield %25#0, %25#1 : i32, i32
      } else {
        scf.yield %12, %13 : i32, i32
      }
      scf.yield %24#0, %24#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    %21 = memref.load %11[] : memref<i1>
    memref.store %21, %10[] : memref<i1>
    %22 = memref.load %10[] : memref<i1>
    scf.if %22 {
      %23 = memref.load %3[] : memref<i32>
      %24 = arith.subi %23, %c1_i32 : i32
      memref.store %24, %3[] : memref<i32>
    }
    cf.br ^bb1(%20#0, %20#1 : i32, i32)
  ^bb3:  // pred: ^bb1
    scf.yield
  }
  scf.yield
 with val:exOp:mlir-asm-printer: Verifying operation: func.func
scf.execute_region {
  %9 = memref.load %6[] : memref<i1>
  scf.if %9 {
    %23 = memref.get_global @kbm3 : memref<1xi32>
    %24 = memref.load %23[%c0] : memref<1xi32>
    memref.store %24, %3[] : memref<i32>
  }
  %10 = memref.alloca() : memref<i1>
  %11 = memref.alloca() : memref<i1>
  memref.store %true, %11[] : memref<i1>
  cf.br ^bb1(%1, %1 : i32, i32)
^bb1(%12: i32, %13: i32):  // 2 preds: ^bb0, ^bb2
  %14 = memref.load %3[] : memref<i32>
  %15 = arith.cmpi sgt, %14, %c0_i32 : i32
  %16 = memref.load %11[] : memref<i1>
  %17 = arith.andi %15, %16 : i1
  cf.cond_br %17, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %18 = memref.load %11[] : memref<i1>
  memref.store %18, %10[] : memref<i1>
  %19 = memref.load %10[] : memref<i1>
  %20:2 = scf.if %19 -> (i32, i32) {
    %23 = memref.load %10[] : memref<i1>
    %24:2 = scf.if %23 -> (i32, i32) {
      %25:2 = scf.execute_region -> (i32, i32) {
        %26 = memref.load %10[] : memref<i1>
        %27 = scf.if %26 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %13 : i32
        }
        %28 = memref.alloca() : memref<i1>
        %29 = memref.alloca() : memref<i1>
        memref.store %true, %29[] : memref<i1>
        cf.br ^bb1(%12, %27 : i32, i32)
      ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
        %32 = memref.load %2[] : memref<i32>
        %33 = memref.get_global @jm : memref<1xi32>
        %34 = memref.load %33[%c0] : memref<1xi32>
        %35 = arith.cmpi slt, %31, %34 : i32
        %36 = memref.load %29[] : memref<i1>
        %37 = arith.andi %35, %36 : i1
        cf.cond_br %37, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %38 = memref.load %29[] : memref<i1>
        memref.store %38, %28[] : memref<i1>
        %39 = memref.load %28[] : memref<i1>
        %40 = scf.if %39 -> (i32) {
          %44 = memref.load %28[] : memref<i1>
          %45 = scf.if %44 -> (i32) {
            %46 = scf.execute_region -> i32 {
              %47 = memref.load %28[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %30 : i32
              }
              %49 = memref.alloca() : memref<i1>
              %50 = memref.alloca() : memref<i1>
              memref.store %true, %50[] : memref<i1>
              cf.br ^bb1(%48 : i32)
            ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
              %52 = memref.load %0[] : memref<i32>
              %53 = memref.get_global @im : memref<1xi32>
              %54 = memref.load %53[%c0] : memref<1xi32>
              %55 = arith.cmpi slt, %51, %54 : i32
              %56 = memref.load %50[] : memref<i1>
              %57 = arith.andi %55, %56 : i1
              cf.cond_br %57, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %58 = memref.load %50[] : memref<i1>
              memref.store %58, %49[] : memref<i1>
              %59 = memref.load %49[] : memref<i1>
              scf.if %59 {
                %63 = memref.load %4[] : memref<memref<?xf32>>
                %64 = memref.load %0[] : memref<i32>
                %65 = memref.load %2[] : memref<i32>
                %66 = memref.load %53[%c0] : memref<1xi32>
                %67 = arith.muli %31, %66 : i32
                %68 = arith.addi %51, %67 : i32
                %69 = memref.load %3[] : memref<i32>
                %70 = arith.muli %69, %66 : i32
                %71 = memref.load %33[%c0] : memref<1xi32>
                %72 = arith.muli %70, %71 : i32
                %73 = arith.addi %68, %72 : i32
                %74 = arith.index_cast %73 : i32 to index
                %75 = memref.load %5[] : memref<memref<?xf32>>
                %76 = arith.subi %69, %c1_i32 : i32
                %77 = arith.muli %76, %66 : i32
                %78 = arith.muli %77, %71 : i32
                %79 = arith.addi %68, %78 : i32
                %80 = arith.index_cast %79 : i32 to index
                %81 = arith.addi %80, %c0 : index
                %82 = memref.load %75[%81] : memref<?xf32>
                %83 = arith.addi %74, %c0 : index
                memref.store %82, %63[%83] : memref<?xf32>
              }
              %60 = memref.load %50[] : memref<i1>
              memref.store %60, %49[] : memref<i1>
              %61 = memref.load %49[] : memref<i1>
              %62 = scf.if %61 -> (i32) {
                %63 = memref.load %0[] : memref<i32>
                %64 = arith.addi %51, %c1_i32 : i32
                memref.store %64, %0[] : memref<i32>
                scf.yield %64 : i32
              } else {
                scf.yield %51 : i32
              }
              cf.br ^bb1(%62 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %51 : i32
            }
            scf.yield %46 : i32
          } else {
            scf.yield %30 : i32
          }
          scf.yield %45 : i32
        } else {
          scf.yield %30 : i32
        }
        %41 = memref.load %29[] : memref<i1>
        memref.store %41, %28[] : memref<i1>
        %42 = memref.load %28[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %44 = memref.load %2[] : memref<i32>
          %45 = arith.addi %31, %c1_i32 : i32
          memref.store %45, %2[] : memref<i32>
          scf.yield %45 : i32
        } else {
          scf.yield %31 : i32
        }
        cf.br ^bb1(%40, %43 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %30, %31 : i32, i32
      }
      scf.yield %25#0, %25#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    scf.yield %24#0, %24#1 : i32, i32
  } else {
    scf.yield %12, %13 : i32, i32
  }
  %21 = memref.load %11[] : memref<i1>
  memref.store %21, %10[] : memref<i1>
  %22 = memref.load %10[] : memref<i1>
  scf.if %22 {
    %23 = memref.load %3[] : memref<i32>
    %24 = arith.subi %23, %c1_i32 : i32
    memref.store %24, %3[] : memref<i32>
  }
  cf.br ^bb1(%20#0, %20#1 : i32, i32)
^bb3:  // pred: ^bb1
  scf.yield
}
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %8 = memref.load %6[] : memref<i1>
  scf.if %8 {
    scf.execute_region {
      %9 = memref.load %6[] : memref<i1>
      scf.if %9 {
        %23 = memref.get_global @kbm3 : memref<1xi32>
        %24 = memref.load %23[%c0] : memref<1xi32>
        memref.store %24, %3[] : memref<i32>
      }
      %10 = memref.alloca() : memref<i1>
      %11 = memref.alloca() : memref<i1>
      memref.store %true, %11[] : memref<i1>
      cf.br ^bb1(%1, %1 : i32, i32)
    ^bb1(%12: i32, %13: i32):  // 2 preds: ^bb0, ^bb2
      %14 = memref.load %3[] : memref<i32>
      %15 = arith.cmpi sgt, %14, %c0_i32 : i32
      %16 = memref.load %11[] : memref<i1>
      %17 = arith.andi %15, %16 : i1
      cf.cond_br %17, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %18 = memref.load %11[] : memref<i1>
      memref.store %18, %10[] : memref<i1>
      %19 = memref.load %10[] : memref<i1>
      %20:2 = scf.if %19 -> (i32, i32) {
        %23 = memref.load %10[] : memref<i1>
        %24:2 = scf.if %23 -> (i32, i32) {
          %25:2 = scf.execute_region -> (i32, i32) {
            %26 = memref.load %10[] : memref<i1>
            %27 = scf.if %26 -> (i32) {
              memref.store %c0_i32, %2[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %13 : i32
            }
            %28 = memref.alloca() : memref<i1>
            %29 = memref.alloca() : memref<i1>
            memref.store %true, %29[] : memref<i1>
            cf.br ^bb1(%12, %27 : i32, i32)
          ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
            %32 = memref.load %2[] : memref<i32>
            %33 = memref.get_global @jm : memref<1xi32>
            %34 = memref.load %33[%c0] : memref<1xi32>
            %35 = arith.cmpi slt, %31, %34 : i32
            %36 = memref.load %29[] : memref<i1>
            %37 = arith.andi %35, %36 : i1
            cf.cond_br %37, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %38 = memref.load %29[] : memref<i1>
            memref.store %38, %28[] : memref<i1>
            %39 = memref.load %28[] : memref<i1>
            %40 = scf.if %39 -> (i32) {
              %44 = memref.load %28[] : memref<i1>
              %45 = scf.if %44 -> (i32) {
                %46 = scf.execute_region -> i32 {
                  %47 = memref.load %28[] : memref<i1>
                  %48 = scf.if %47 -> (i32) {
                    memref.store %c0_i32, %0[] : memref<i32>
                    scf.yield %c0_i32 : i32
                  } else {
                    scf.yield %30 : i32
                  }
                  %49 = memref.alloca() : memref<i1>
                  %50 = memref.alloca() : memref<i1>
                  memref.store %true, %50[] : memref<i1>
                  cf.br ^bb1(%48 : i32)
                ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
                  %52 = memref.load %0[] : memref<i32>
                  %53 = memref.get_global @im : memref<1xi32>
                  %54 = memref.load %53[%c0] : memref<1xi32>
                  %55 = arith.cmpi slt, %51, %54 : i32
                  %56 = memref.load %50[] : memref<i1>
                  %57 = arith.andi %55, %56 : i1
                  cf.cond_br %57, ^bb2, ^bb3
                ^bb2:  // pred: ^bb1
                  %58 = memref.load %50[] : memref<i1>
                  memref.store %58, %49[] : memref<i1>
                  %59 = memref.load %49[] : memref<i1>
                  scf.if %59 {
                    %63 = memref.load %4[] : memref<memref<?xf32>>
                    %64 = memref.load %0[] : memref<i32>
                    %65 = memref.load %2[] : memref<i32>
                    %66 = memref.load %53[%c0] : memref<1xi32>
                    %67 = arith.muli %31, %66 : i32
                    %68 = arith.addi %51, %67 : i32
                    %69 = memref.load %3[] : memref<i32>
                    %70 = arith.muli %69, %66 : i32
                    %71 = memref.load %33[%c0] : memref<1xi32>
                    %72 = arith.muli %70, %71 : i32
                    %73 = arith.addi %68, %72 : i32
                    %74 = arith.index_cast %73 : i32 to index
                    %75 = memref.load %5[] : memref<memref<?xf32>>
                    %76 = arith.subi %69, %c1_i32 : i32
                    %77 = arith.muli %76, %66 : i32
                    %78 = arith.muli %77, %71 : i32
                    %79 = arith.addi %68, %78 : i32
                    %80 = arith.index_cast %79 : i32 to index
                    %81 = arith.addi %80, %c0 : index
                    %82 = memref.load %75[%81] : memref<?xf32>
                    %83 = arith.addi %74, %c0 : index
                    memref.store %82, %63[%83] : memref<?xf32>
                  }
                  %60 = memref.load %50[] : memref<i1>
                  memref.store %60, %49[] : memref<i1>
                  %61 = memref.load %49[] : memref<i1>
                  %62 = scf.if %61 -> (i32) {
                    %63 = memref.load %0[] : memref<i32>
                    %64 = arith.addi %51, %c1_i32 : i32
                    memref.store %64, %0[] : memref<i32>
                    scf.yield %64 : i32
                  } else {
                    scf.yield %51 : i32
                  }
                  cf.br ^bb1(%62 : i32)
                ^bb3:  // pred: ^bb1
                  scf.yield %51 : i32
                }
                scf.yield %46 : i32
              } else {
                scf.yield %30 : i32
              }
              scf.yield %45 : i32
            } else {
              scf.yield %30 : i32
            }
            %41 = memref.load %29[] : memref<i1>
            memref.store %41, %28[] : memref<i1>
            %42 = memref.load %28[] : memref<i1>
            %43 = scf.if %42 -> (i32) {
              %44 = memref.load %2[] : memref<i32>
              %45 = arith.addi %31, %c1_i32 : i32
              memref.store %45, %2[] : memref<i32>
              scf.yield %45 : i32
            } else {
              scf.yield %31 : i32
            }
            cf.br ^bb1(%40, %43 : i32, i32)
          ^bb3:  // pred: ^bb1
            scf.yield %30, %31 : i32, i32
          }
          scf.yield %25#0, %25#1 : i32, i32
        } else {
          scf.yield %12, %13 : i32, i32
        }
        scf.yield %24#0, %24#1 : i32, i32
      } else {
        scf.yield %12, %13 : i32, i32
      }
      %21 = memref.load %11[] : memref<i1>
      memref.store %21, %10[] : memref<i1>
      %22 = memref.load %10[] : memref<i1>
      scf.if %22 {
        %23 = memref.load %3[] : memref<i32>
        %24 = arith.subi %23, %c1_i32 : i32
        memref.store %24, %3[] : memref<i32>
      }
      cf.br ^bb1(%20#0, %20#1 : i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
  scf.yield
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %8 {
  scf.execute_region {
    %9 = memref.load %6[] : memref<i1>
    scf.if %9 {
      %23 = memref.get_global @kbm3 : memref<1xi32>
      %24 = memref.load %23[%c0] : memref<1xi32>
      memref.store %24, %3[] : memref<i32>
    }
    %10 = memref.alloca() : memref<i1>
    %11 = memref.alloca() : memref<i1>
    memref.store %true, %11[] : memref<i1>
    cf.br ^bb1(%1, %1 : i32, i32)
  ^bb1(%12: i32, %13: i32):  // 2 preds: ^bb0, ^bb2
    %14 = memref.load %3[] : memref<i32>
    %15 = arith.cmpi sgt, %14, %c0_i32 : i32
    %16 = memref.load %11[] : memref<i1>
    %17 = arith.andi %15, %16 : i1
    cf.cond_br %17, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %18 = memref.load %11[] : memref<i1>
    memref.store %18, %10[] : memref<i1>
    %19 = memref.load %10[] : memref<i1>
    %20:2 = scf.if %19 -> (i32, i32) {
      %23 = memref.load %10[] : memref<i1>
      %24:2 = scf.if %23 -> (i32, i32) {
        %25:2 = scf.execute_region -> (i32, i32) {
          %26 = memref.load %10[] : memref<i1>
          %27 = scf.if %26 -> (i32) {
            memref.store %c0_i32, %2[] : memref<i32>
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %13 : i32
          }
          %28 = memref.alloca() : memref<i1>
          %29 = memref.alloca() : memref<i1>
          memref.store %true, %29[] : memref<i1>
          cf.br ^bb1(%12, %27 : i32, i32)
        ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
          %32 = memref.load %2[] : memref<i32>
          %33 = memref.get_global @jm : memref<1xi32>
          %34 = memref.load %33[%c0] : memref<1xi32>
          %35 = arith.cmpi slt, %31, %34 : i32
          %36 = memref.load %29[] : memref<i1>
          %37 = arith.andi %35, %36 : i1
          cf.cond_br %37, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %38 = memref.load %29[] : memref<i1>
          memref.store %38, %28[] : memref<i1>
          %39 = memref.load %28[] : memref<i1>
          %40 = scf.if %39 -> (i32) {
            %44 = memref.load %28[] : memref<i1>
            %45 = scf.if %44 -> (i32) {
              %46 = scf.execute_region -> i32 {
                %47 = memref.load %28[] : memref<i1>
                %48 = scf.if %47 -> (i32) {
                  memref.store %c0_i32, %0[] : memref<i32>
                  scf.yield %c0_i32 : i32
                } else {
                  scf.yield %30 : i32
                }
                %49 = memref.alloca() : memref<i1>
                %50 = memref.alloca() : memref<i1>
                memref.store %true, %50[] : memref<i1>
                cf.br ^bb1(%48 : i32)
              ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
                %52 = memref.load %0[] : memref<i32>
                %53 = memref.get_global @im : memref<1xi32>
                %54 = memref.load %53[%c0] : memref<1xi32>
                %55 = arith.cmpi slt, %51, %54 : i32
                %56 = memref.load %50[] : memref<i1>
                %57 = arith.andi %55, %56 : i1
                cf.cond_br %57, ^bb2, ^bb3
              ^bb2:  // pred: ^bb1
                %58 = memref.load %50[] : memref<i1>
                memref.store %58, %49[] : memref<i1>
                %59 = memref.load %49[] : memref<i1>
                scf.if %59 {
                  %63 = memref.load %4[] : memref<memref<?xf32>>
                  %64 = memref.load %0[] : memref<i32>
                  %65 = memref.load %2[] : memref<i32>
                  %66 = memref.load %53[%c0] : memref<1xi32>
                  %67 = arith.muli %31, %66 : i32
                  %68 = arith.addi %51, %67 : i32
                  %69 = memref.load %3[] : memref<i32>
                  %70 = arith.muli %69, %66 : i32
                  %71 = memref.load %33[%c0] : memref<1xi32>
                  %72 = arith.muli %70, %71 : i32
                  %73 = arith.addi %68, %72 : i32
                  %74 = arith.index_cast %73 : i32 to index
                  %75 = memref.load %5[] : memref<memref<?xf32>>
                  %76 = arith.subi %69, %c1_i32 : i32
                  %77 = arith.muli %76, %66 : i32
                  %78 = arith.muli %77, %71 : i32
                  %79 = arith.addi %68, %78 : i32
                  %80 = arith.index_cast %79 : i32 to index
                  %81 = arith.addi %80, %c0 : index
                  %82 = memref.load %75[%81] : memref<?xf32>
                  %83 = arith.addi %74, %c0 : index
                  memref.store %82, %63[%83] : memref<?xf32>
                }
                %60 = memref.load %50[] : memref<i1>
                memref.store %60, %49[] : memref<i1>
                %61 = memref.load %49[] : memref<i1>
                %62 = scf.if %61 -> (i32) {
                  %63 = memref.load %0[] : memref<i32>
                  %64 = arith.addi %51, %c1_i32 : i32
                  memref.store %64, %0[] : memref<i32>
                  scf.yield %64 : i32
                } else {
                  scf.yield %51 : i32
                }
                cf.br ^bb1(%62 : i32)
              ^bb3:  // pred: ^bb1
                scf.yield %51 : i32
              }
              scf.yield %46 : i32
            } else {
              scf.yield %30 : i32
            }
            scf.yield %45 : i32
          } else {
            scf.yield %30 : i32
          }
          %41 = memref.load %29[] : memref<i1>
          memref.store %41, %28[] : memref<i1>
          %42 = memref.load %28[] : memref<i1>
          %43 = scf.if %42 -> (i32) {
            %44 = memref.load %2[] : memref<i32>
            %45 = arith.addi %31, %c1_i32 : i32
            memref.store %45, %2[] : memref<i32>
            scf.yield %45 : i32
          } else {
            scf.yield %31 : i32
          }
          cf.br ^bb1(%40, %43 : i32, i32)
        ^bb3:  // pred: ^bb1
          scf.yield %30, %31 : i32, i32
        }
        scf.yield %25#0, %25#1 : i32, i32
      } else {
        scf.yield %12, %13 : i32, i32
      }
      scf.yield %24#0, %24#1 : i32, i32
    } else {
      scf.yield %12, %13 : i32, i32
    }
    %21 = memref.load %11[] : memref<i1>
    memref.store %21, %10[] : memref<i1>
    %22 = memref.load %10[] : memref<i1>
    scf.if %22 {
      %23 = memref.load %3[] : memref<i32>
      %24 = arith.subi %23, %c1_i32 : i32
      memref.store %24, %3[] : memref<i32>
    }
    cf.br ^bb1(%20#0, %20#1 : i32, i32)
  ^bb3:  // pred: ^bb1
    scf.yield
  }
}
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32):
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %7 {
    %8 = memref.load %6[] : memref<i1>
    scf.if %8 {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        scf.if %9 {
          %23 = memref.get_global @kbm3 : memref<1xi32>
          %24 = memref.load %23[%c0] : memref<1xi32>
          memref.store %24, %3[] : memref<i32>
        }
        %10 = memref.alloca() : memref<i1>
        %11 = memref.alloca() : memref<i1>
        memref.store %true, %11[] : memref<i1>
        cf.br ^bb1(%1, %1 : i32, i32)
      ^bb1(%12: i32, %13: i32):  // 2 preds: ^bb0, ^bb2
        %14 = memref.load %3[] : memref<i32>
        %15 = arith.cmpi sgt, %14, %c0_i32 : i32
        %16 = memref.load %11[] : memref<i1>
        %17 = arith.andi %15, %16 : i1
        cf.cond_br %17, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %18 = memref.load %11[] : memref<i1>
        memref.store %18, %10[] : memref<i1>
        %19 = memref.load %10[] : memref<i1>
        %20:2 = scf.if %19 -> (i32, i32) {
          %23 = memref.load %10[] : memref<i1>
          %24:2 = scf.if %23 -> (i32, i32) {
            %25:2 = scf.execute_region -> (i32, i32) {
              %26 = memref.load %10[] : memref<i1>
              %27 = scf.if %26 -> (i32) {
                memref.store %c0_i32, %2[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %13 : i32
              }
              %28 = memref.alloca() : memref<i1>
              %29 = memref.alloca() : memref<i1>
              memref.store %true, %29[] : memref<i1>
              cf.br ^bb1(%12, %27 : i32, i32)
            ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
              %32 = memref.load %2[] : memref<i32>
              %33 = memref.get_global @jm : memref<1xi32>
              %34 = memref.load %33[%c0] : memref<1xi32>
              %35 = arith.cmpi slt, %31, %34 : i32
              %36 = memref.load %29[] : memref<i1>
              %37 = arith.andi %35, %36 : i1
              cf.cond_br %37, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %38 = memref.load %29[] : memref<i1>
              memref.store %38, %28[] : memref<i1>
              %39 = memref.load %28[] : memref<i1>
              %40 = scf.if %39 -> (i32) {
                %44 = memref.load %28[] : memref<i1>
                %45 = scf.if %44 -> (i32) {
                  %46 = scf.execute_region -> i32 {
                    %47 = memref.load %28[] : memref<i1>
                    %48 = scf.if %47 -> (i32) {
                      memref.store %c0_i32, %0[] : memref<i32>
                      scf.yield %c0_i32 : i32
                    } else {
                      scf.yield %30 : i32
                    }
                    %49 = memref.alloca() : memref<i1>
                    %50 = memref.alloca() : memref<i1>
                    memref.store %true, %50[] : memref<i1>
                    cf.br ^bb1(%48 : i32)
                  ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
                    %52 = memref.load %0[] : memref<i32>
                    %53 = memref.get_global @im : memref<1xi32>
                    %54 = memref.load %53[%c0] : memref<1xi32>
                    %55 = arith.cmpi slt, %51, %54 : i32
                    %56 = memref.load %50[] : memref<i1>
                    %57 = arith.andi %55, %56 : i1
                    cf.cond_br %57, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %58 = memref.load %50[] : memref<i1>
                    memref.store %58, %49[] : memref<i1>
                    %59 = memref.load %49[] : memref<i1>
                    scf.if %59 {
                      %63 = memref.load %4[] : memref<memref<?xf32>>
                      %64 = memref.load %0[] : memref<i32>
                      %65 = memref.load %2[] : memref<i32>
                      %66 = memref.load %53[%c0] : memref<1xi32>
                      %67 = arith.muli %31, %66 : i32
                      %68 = arith.addi %51, %67 : i32
                      %69 = memref.load %3[] : memref<i32>
                      %70 = arith.muli %69, %66 : i32
                      %71 = memref.load %33[%c0] : memref<1xi32>
                      %72 = arith.muli %70, %71 : i32
                      %73 = arith.addi %68, %72 : i32
                      %74 = arith.index_cast %73 : i32 to index
                      %75 = memref.load %5[] : memref<memref<?xf32>>
                      %76 = arith.subi %69, %c1_i32 : i32
                      %77 = arith.muli %76, %66 : i32
                      %78 = arith.muli %77, %71 : i32
                      %79 = arith.addi %68, %78 : i32
                      %80 = arith.index_cast %79 : i32 to index
                      %81 = arith.addi %80, %c0 : index
                      %82 = memref.load %75[%81] : memref<?xf32>
                      %83 = arith.addi %74, %c0 : index
                      memref.store %82, %63[%83] : memref<?xf32>
                    }
                    %60 = memref.load %50[] : memref<i1>
                    memref.store %60, %49[] : memref<i1>
                    %61 = memref.load %49[] : memref<i1>
                    %62 = scf.if %61 -> (i32) {
                      %63 = memref.load %0[] : memref<i32>
                      %64 = arith.addi %51, %c1_i32 : i32
                      memref.store %64, %0[] : memref<i32>
                      scf.yield %64 : i32
                    } else {
                      scf.yield %51 : i32
                    }
                    cf.br ^bb1(%62 : i32)
                  ^bb3:  // pred: ^bb1
                    scf.yield %51 : i32
                  }
                  scf.yield %46 : i32
                } else {
                  scf.yield %30 : i32
                }
                scf.yield %45 : i32
              } else {
                scf.yield %30 : i32
              }
              %41 = memref.load %29[] : memref<i1>
              memref.store %41, %28[] : memref<i1>
              %42 = memref.load %28[] : memref<i1>
              %43 = scf.if %42 -> (i32) {
                %44 = memref.load %2[] : memref<i32>
                %45 = arith.addi %31, %c1_i32 : i32
                memref.store %45, %2[] : memref<i32>
                scf.yield %45 : i32
              } else {
                scf.yield %31 : i32
              }
              cf.br ^bb1(%40, %43 : i32, i32)
            ^bb3:  // pred: ^bb1
              scf.yield %30, %31 : i32, i32
            }
            scf.yield %25#0, %25#1 : i32, i32
          } else {
            scf.yield %12, %13 : i32, i32
          }
          scf.yield %24#0, %24#1 : i32, i32
        } else {
          scf.yield %12, %13 : i32, i32
        }
        %21 = memref.load %11[] : memref<i1>
        memref.store %21, %10[] : memref<i1>
        %22 = memref.load %10[] : memref<i1>
        scf.if %22 {
          %23 = memref.load %3[] : memref<i32>
          %24 = arith.subi %23, %c1_i32 : i32
          memref.store %24, %3[] : memref<i32>
        }
        cf.br ^bb1(%20#0, %20#1 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  func.return
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %7 {
  %8 = memref.load %6[] : memref<i1>
  scf.if %8 {
    scf.execute_region {
      %9 = memref.load %6[] : memref<i1>
      scf.if %9 {
        %23 = memref.get_global @kbm3 : memref<1xi32>
        %24 = memref.load %23[%c0] : memref<1xi32>
        memref.store %24, %3[] : memref<i32>
      }
      %10 = memref.alloca() : memref<i1>
      %11 = memref.alloca() : memref<i1>
      memref.store %true, %11[] : memref<i1>
      cf.br ^bb1(%1, %1 : i32, i32)
    ^bb1(%12: i32, %13: i32):  // 2 preds: ^bb0, ^bb2
      %14 = memref.load %3[] : memref<i32>
      %15 = arith.cmpi sgt, %14, %c0_i32 : i32
      %16 = memref.load %11[] : memref<i1>
      %17 = arith.andi %15, %16 : i1
      cf.cond_br %17, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %18 = memref.load %11[] : memref<i1>
      memref.store %18, %10[] : memref<i1>
      %19 = memref.load %10[] : memref<i1>
      %20:2 = scf.if %19 -> (i32, i32) {
        %23 = memref.load %10[] : memref<i1>
        %24:2 = scf.if %23 -> (i32, i32) {
          %25:2 = scf.execute_region -> (i32, i32) {
            %26 = memref.load %10[] : memref<i1>
            %27 = scf.if %26 -> (i32) {
              memref.store %c0_i32, %2[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %13 : i32
            }
            %28 = memref.alloca() : memref<i1>
            %29 = memref.alloca() : memref<i1>
            memref.store %true, %29[] : memref<i1>
            cf.br ^bb1(%12, %27 : i32, i32)
          ^bb1(%30: i32, %31: i32):  // 2 preds: ^bb0, ^bb2
            %32 = memref.load %2[] : memref<i32>
            %33 = memref.get_global @jm : memref<1xi32>
            %34 = memref.load %33[%c0] : memref<1xi32>
            %35 = arith.cmpi slt, %31, %34 : i32
            %36 = memref.load %29[] : memref<i1>
            %37 = arith.andi %35, %36 : i1
            cf.cond_br %37, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %38 = memref.load %29[] : memref<i1>
            memref.store %38, %28[] : memref<i1>
            %39 = memref.load %28[] : memref<i1>
            %40 = scf.if %39 -> (i32) {
              %44 = memref.load %28[] : memref<i1>
              %45 = scf.if %44 -> (i32) {
                %46 = scf.execute_region -> i32 {
                  %47 = memref.load %28[] : memref<i1>
                  %48 = scf.if %47 -> (i32) {
                    memref.store %c0_i32, %0[] : memref<i32>
                    scf.yield %c0_i32 : i32
                  } else {
                    scf.yield %30 : i32
                  }
                  %49 = memref.alloca() : memref<i1>
                  %50 = memref.alloca() : memref<i1>
                  memref.store %true, %50[] : memref<i1>
                  cf.br ^bb1(%48 : i32)
                ^bb1(%51: i32):  // 2 preds: ^bb0, ^bb2
                  %52 = memref.load %0[] : memref<i32>
                  %53 = memref.get_global @im : memref<1xi32>
                  %54 = memref.load %53[%c0] : memref<1xi32>
                  %55 = arith.cmpi slt, %51, %54 : i32
                  %56 = memref.load %50[] : memref<i1>
                  %57 = arith.andi %55, %56 : i1
                  cf.cond_br %57, ^bb2, ^bb3
                ^bb2:  // pred: ^bb1
                  %58 = memref.load %50[] : memref<i1>
                  memref.store %58, %49[] : memref<i1>
                  %59 = memref.load %49[] : memref<i1>
                  scf.if %59 {
                    %63 = memref.load %4[] : memref<memref<?xf32>>
                    %64 = memref.load %0[] : memref<i32>
                    %65 = memref.load %2[] : memref<i32>
                    %66 = memref.load %53[%c0] : memref<1xi32>
                    %67 = arith.muli %31, %66 : i32
                    %68 = arith.addi %51, %67 : i32
                    %69 = memref.load %3[] : memref<i32>
                    %70 = arith.muli %69, %66 : i32
                    %71 = memref.load %33[%c0] : memref<1xi32>
                    %72 = arith.muli %70, %71 : i32
                    %73 = arith.addi %68, %72 : i32
                    %74 = arith.index_cast %73 : i32 to index
                    %75 = memref.load %5[] : memref<memref<?xf32>>
                    %76 = arith.subi %69, %c1_i32 : i32
                    %77 = arith.muli %76, %66 : i32
                    %78 = arith.muli %77, %71 : i32
                    %79 = arith.addi %68, %78 : i32
                    %80 = arith.index_cast %79 : i32 to index
                    %81 = arith.addi %80, %c0 : index
                    %82 = memref.load %75[%81] : memref<?xf32>
                    %83 = arith.addi %74, %c0 : index
                    memref.store %82, %63[%83] : memref<?xf32>
                  }
                  %60 = memref.load %50[] : memref<i1>
                  memref.store %60, %49[] : memref<i1>
                  %61 = memref.load %49[] : memref<i1>
                  %62 = scf.if %61 -> (i32) {
                    %63 = memref.load %0[] : memref<i32>
                    %64 = arith.addi %51, %c1_i32 : i32
                    memref.store %64, %0[] : memref<i32>
                    scf.yield %64 : i32
                  } else {
                    scf.yield %51 : i32
                  }
                  cf.br ^bb1(%62 : i32)
                ^bb3:  // pred: ^bb1
                  scf.yield %51 : i32
                }
                scf.yield %46 : i32
              } else {
                scf.yield %30 : i32
              }
              scf.yield %45 : i32
            } else {
              scf.yield %30 : i32
            }
            %41 = memref.load %29[] : memref<i1>
            memref.store %41, %28[] : memref<i1>
            %42 = memref.load %28[] : memref<i1>
            %43 = scf.if %42 -> (i32) {
              %44 = memref.load %2[] : memref<i32>
              %45 = arith.addi %31, %c1_i32 : i32
              memref.store %45, %2[] : memref<i32>
              scf.yield %45 : i32
            } else {
              scf.yield %31 : i32
            }
            cf.br ^bb1(%40, %43 : i32, i32)
          ^bb3:  // pred: ^bb1
            scf.yield %30, %31 : i32, i32
          }
          scf.yield %25#0, %25#1 : i32, i32
        } else {
          scf.yield %12, %13 : i32, i32
        }
        scf.yield %24#0, %24#1 : i32, i32
      } else {
        scf.yield %12, %13 : i32, i32
      }
      %21 = memref.load %11[] : memref<i1>
      memref.store %21, %10[] : memref<i1>
      %22 = memref.load %10[] : memref<i1>
      scf.if %22 {
        %23 = memref.load %3[] : memref<i32>
        %24 = arith.subi %23, %c1_i32 : i32
        memref.store %24, %3[] : memref<i32>
      }
      cf.br ^bb1(%20#0, %20#1 : i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
}
 replaced mlir-asm-printer: Verifying operation: builtin.module
branch has 2 operands for successor #0, but target block has 3
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%19 = "memref.load"(%7) : (memref<i32>) -> i32 with <block argument> of type 'i32' at index: 2
 replaced mlir-asm-printer: Verifying operation: builtin.module
branch has 2 operands for successor #0, but target block has 3
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%75 = "memref.load"(%7) : (memref<i32>) -> i32 with <block argument> of type 'i32' at index: 0
 replaced mlir-asm-printer: Verifying operation: builtin.module
branch has 2 operands for successor #0, but target block has 3
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%29 = "memref.load"(%7) : (memref<i32>) -> i32 with <block argument> of type 'i32' at index: 0
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%4 = memref.alloca() : memref<memref<?xf32>>
 + forwarding vec to promote {} of mlir-asm-printer: Verifying operation: builtin.module
%4 = memref.alloca() : memref<memref<?xf32>>
Begin forwarding store of mlir-asm-printer: Verifying operation: builtin.module
%4 = memref.alloca() : memref<memref<?xf32>> to load
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %7 {
    %8 = memref.load %6[] : memref<i1>
    scf.if %8 {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        %10 = scf.if %9 -> (i32) {
          %26 = memref.get_global @kbm3 : memref<1xi32>
          %27 = memref.load %26[%c0] : memref<1xi32>
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %1 : i32
        }
        %11 = memref.alloca() : memref<i1>
        %12 = memref.alloca() : memref<i1>
        memref.store %true, %12[] : memref<i1>
        cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
      ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
        %16 = memref.load %3[] : memref<i32>
        %17 = arith.cmpi sgt, %15, %c0_i32 : i32
        %18 = memref.load %12[] : memref<i1>
        %19 = arith.andi %17, %18 : i1
        cf.cond_br %19, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %20 = memref.load %12[] : memref<i1>
        memref.store %20, %11[] : memref<i1>
        %21 = memref.load %11[] : memref<i1>
        %22:2 = scf.if %21 -> (i32, i32) {
          %26 = memref.load %11[] : memref<i1>
          %27:2 = scf.if %26 -> (i32, i32) {
            %28:2 = scf.execute_region -> (i32, i32) {
              %29 = memref.load %11[] : memref<i1>
              %30 = scf.if %29 -> (i32) {
                memref.store %c0_i32, %2[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %14 : i32
              }
              %31 = memref.alloca() : memref<i1>
              %32 = memref.alloca() : memref<i1>
              memref.store %true, %32[] : memref<i1>
              cf.br ^bb1(%13, %30 : i32, i32)
            ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
              %35 = memref.load %2[] : memref<i32>
              %36 = memref.get_global @jm : memref<1xi32>
              %37 = memref.load %36[%c0] : memref<1xi32>
              %38 = arith.cmpi slt, %34, %37 : i32
              %39 = memref.load %32[] : memref<i1>
              %40 = arith.andi %38, %39 : i1
              cf.cond_br %40, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %41 = memref.load %32[] : memref<i1>
              memref.store %41, %31[] : memref<i1>
              %42 = memref.load %31[] : memref<i1>
              %43 = scf.if %42 -> (i32) {
                %47 = memref.load %31[] : memref<i1>
                %48 = scf.if %47 -> (i32) {
                  %49 = scf.execute_region -> i32 {
                    %50 = memref.load %31[] : memref<i1>
                    %51 = scf.if %50 -> (i32) {
                      memref.store %c0_i32, %0[] : memref<i32>
                      scf.yield %c0_i32 : i32
                    } else {
                      scf.yield %33 : i32
                    }
                    %52 = memref.alloca() : memref<i1>
                    %53 = memref.alloca() : memref<i1>
                    memref.store %true, %53[] : memref<i1>
                    cf.br ^bb1(%51 : i32)
                  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                    %55 = memref.load %0[] : memref<i32>
                    %56 = memref.get_global @im : memref<1xi32>
                    %57 = memref.load %56[%c0] : memref<1xi32>
                    %58 = arith.cmpi slt, %54, %57 : i32
                    %59 = memref.load %53[] : memref<i1>
                    %60 = arith.andi %58, %59 : i1
                    cf.cond_br %60, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %61 = memref.load %53[] : memref<i1>
                    memref.store %61, %52[] : memref<i1>
                    %62 = memref.load %52[] : memref<i1>
                    scf.if %62 {
                      %66 = memref.load %4[] : memref<memref<?xf32>>
                      %67 = memref.load %0[] : memref<i32>
                      %68 = memref.load %2[] : memref<i32>
                      %69 = memref.load %56[%c0] : memref<1xi32>
                      %70 = arith.muli %34, %69 : i32
                      %71 = arith.addi %54, %70 : i32
                      %72 = memref.load %3[] : memref<i32>
                      %73 = arith.muli %15, %69 : i32
                      %74 = memref.load %36[%c0] : memref<1xi32>
                      %75 = arith.muli %73, %74 : i32
                      %76 = arith.addi %71, %75 : i32
                      %77 = arith.index_cast %76 : i32 to index
                      %78 = memref.load %5[] : memref<memref<?xf32>>
                      %79 = arith.subi %15, %c1_i32 : i32
                      %80 = arith.muli %79, %69 : i32
                      %81 = arith.muli %80, %74 : i32
                      %82 = arith.addi %71, %81 : i32
                      %83 = arith.index_cast %82 : i32 to index
                      %84 = arith.addi %83, %c0 : index
                      %85 = memref.load %78[%84] : memref<?xf32>
                      %86 = arith.addi %77, %c0 : index
                      memref.store %85, %66[%86] : memref<?xf32>
                    }
                    %63 = memref.load %53[] : memref<i1>
                    memref.store %63, %52[] : memref<i1>
                    %64 = memref.load %52[] : memref<i1>
                    %65 = scf.if %64 -> (i32) {
                      %66 = memref.load %0[] : memref<i32>
                      %67 = arith.addi %54, %c1_i32 : i32
                      memref.store %67, %0[] : memref<i32>
                      scf.yield %67 : i32
                    } else {
                      scf.yield %54 : i32
                    }
                    cf.br ^bb1(%65 : i32)
                  ^bb3:  // pred: ^bb1
                    scf.yield %54 : i32
                  }
                  scf.yield %49 : i32
                } else {
                  scf.yield %33 : i32
                }
                scf.yield %48 : i32
              } else {
                scf.yield %33 : i32
              }
              %44 = memref.load %32[] : memref<i1>
              memref.store %44, %31[] : memref<i1>
              %45 = memref.load %31[] : memref<i1>
              %46 = scf.if %45 -> (i32) {
                %47 = memref.load %2[] : memref<i32>
                %48 = arith.addi %34, %c1_i32 : i32
                memref.store %48, %2[] : memref<i32>
                scf.yield %48 : i32
              } else {
                scf.yield %34 : i32
              }
              cf.br ^bb1(%43, %46 : i32, i32)
            ^bb3:  // pred: ^bb1
              scf.yield %33, %34 : i32, i32
            }
            scf.yield %28#0, %28#1 : i32, i32
          } else {
            scf.yield %13, %14 : i32, i32
          }
          scf.yield %27#0, %27#1 : i32, i32
        } else {
          scf.yield %13, %14 : i32, i32
        }
        %23 = memref.load %12[] : memref<i1>
        memref.store %23, %11[] : memref<i1>
        %24 = memref.load %11[] : memref<i1>
        %25 = scf.if %24 -> (i32) {
          %26 = memref.load %3[] : memref<i32>
          %27 = arith.subi %15, %c1_i32 : i32
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %15 : i32
        }
        cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}
Matching Load: mlir-asm-printer: Verifying operation: func.func
%66 = memref.load %4[] : memref<memref<?xf32>>
Matching Store: mlir-asm-printer: Verifying operation: func.func
memref.store %arg2, %4[] : memref<memref<?xf32>>
 storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %arg2, %4[] : memref<memref<?xf32>>
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32):
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %7 {
    %8 = memref.load %6[] : memref<i1>
    scf.if %8 {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        %10 = scf.if %9 -> (i32) {
          %26 = memref.get_global @kbm3 : memref<1xi32>
          %27 = memref.load %26[%c0] : memref<1xi32>
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %1 : i32
        }
        %11 = memref.alloca() : memref<i1>
        %12 = memref.alloca() : memref<i1>
        memref.store %true, %12[] : memref<i1>
        cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
      ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
        %16 = memref.load %3[] : memref<i32>
        %17 = arith.cmpi sgt, %15, %c0_i32 : i32
        %18 = memref.load %12[] : memref<i1>
        %19 = arith.andi %17, %18 : i1
        cf.cond_br %19, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %20 = memref.load %12[] : memref<i1>
        memref.store %20, %11[] : memref<i1>
        %21 = memref.load %11[] : memref<i1>
        %22:2 = scf.if %21 -> (i32, i32) {
          %26 = memref.load %11[] : memref<i1>
          %27:2 = scf.if %26 -> (i32, i32) {
            %28:2 = scf.execute_region -> (i32, i32) {
              %29 = memref.load %11[] : memref<i1>
              %30 = scf.if %29 -> (i32) {
                memref.store %c0_i32, %2[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %14 : i32
              }
              %31 = memref.alloca() : memref<i1>
              %32 = memref.alloca() : memref<i1>
              memref.store %true, %32[] : memref<i1>
              cf.br ^bb1(%13, %30 : i32, i32)
            ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
              %35 = memref.load %2[] : memref<i32>
              %36 = memref.get_global @jm : memref<1xi32>
              %37 = memref.load %36[%c0] : memref<1xi32>
              %38 = arith.cmpi slt, %34, %37 : i32
              %39 = memref.load %32[] : memref<i1>
              %40 = arith.andi %38, %39 : i1
              cf.cond_br %40, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %41 = memref.load %32[] : memref<i1>
              memref.store %41, %31[] : memref<i1>
              %42 = memref.load %31[] : memref<i1>
              %43 = scf.if %42 -> (i32) {
                %47 = memref.load %31[] : memref<i1>
                %48 = scf.if %47 -> (i32) {
                  %49 = scf.execute_region -> i32 {
                    %50 = memref.load %31[] : memref<i1>
                    %51 = scf.if %50 -> (i32) {
                      memref.store %c0_i32, %0[] : memref<i32>
                      scf.yield %c0_i32 : i32
                    } else {
                      scf.yield %33 : i32
                    }
                    %52 = memref.alloca() : memref<i1>
                    %53 = memref.alloca() : memref<i1>
                    memref.store %true, %53[] : memref<i1>
                    cf.br ^bb1(%51 : i32)
                  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                    %55 = memref.load %0[] : memref<i32>
                    %56 = memref.get_global @im : memref<1xi32>
                    %57 = memref.load %56[%c0] : memref<1xi32>
                    %58 = arith.cmpi slt, %54, %57 : i32
                    %59 = memref.load %53[] : memref<i1>
                    %60 = arith.andi %58, %59 : i1
                    cf.cond_br %60, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %61 = memref.load %53[] : memref<i1>
                    memref.store %61, %52[] : memref<i1>
                    %62 = memref.load %52[] : memref<i1>
                    scf.if %62 {
                      %66 = memref.load %4[] : memref<memref<?xf32>>
                      %67 = memref.load %0[] : memref<i32>
                      %68 = memref.load %2[] : memref<i32>
                      %69 = memref.load %56[%c0] : memref<1xi32>
                      %70 = arith.muli %34, %69 : i32
                      %71 = arith.addi %54, %70 : i32
                      %72 = memref.load %3[] : memref<i32>
                      %73 = arith.muli %15, %69 : i32
                      %74 = memref.load %36[%c0] : memref<1xi32>
                      %75 = arith.muli %73, %74 : i32
                      %76 = arith.addi %71, %75 : i32
                      %77 = arith.index_cast %76 : i32 to index
                      %78 = memref.load %5[] : memref<memref<?xf32>>
                      %79 = arith.subi %15, %c1_i32 : i32
                      %80 = arith.muli %79, %69 : i32
                      %81 = arith.muli %80, %74 : i32
                      %82 = arith.addi %71, %81 : i32
                      %83 = arith.index_cast %82 : i32 to index
                      %84 = arith.addi %83, %c0 : index
                      %85 = memref.load %78[%84] : memref<?xf32>
                      %86 = arith.addi %77, %c0 : index
                      memref.store %85, %66[%86] : memref<?xf32>
                    }
                    %63 = memref.load %53[] : memref<i1>
                    memref.store %63, %52[] : memref<i1>
                    %64 = memref.load %52[] : memref<i1>
                    %65 = scf.if %64 -> (i32) {
                      %66 = memref.load %0[] : memref<i32>
                      %67 = arith.addi %54, %c1_i32 : i32
                      memref.store %67, %0[] : memref<i32>
                      scf.yield %67 : i32
                    } else {
                      scf.yield %54 : i32
                    }
                    cf.br ^bb1(%65 : i32)
                  ^bb3:  // pred: ^bb1
                    scf.yield %54 : i32
                  }
                  scf.yield %49 : i32
                } else {
                  scf.yield %33 : i32
                }
                scf.yield %48 : i32
              } else {
                scf.yield %33 : i32
              }
              %44 = memref.load %32[] : memref<i1>
              memref.store %44, %31[] : memref<i1>
              %45 = memref.load %31[] : memref<i1>
              %46 = scf.if %45 -> (i32) {
                %47 = memref.load %2[] : memref<i32>
                %48 = arith.addi %34, %c1_i32 : i32
                memref.store %48, %2[] : memref<i32>
                scf.yield %48 : i32
              } else {
                scf.yield %34 : i32
              }
              cf.br ^bb1(%43, %46 : i32, i32)
            ^bb3:  // pred: ^bb1
              scf.yield %33, %34 : i32, i32
            }
            scf.yield %28#0, %28#1 : i32, i32
          } else {
            scf.yield %13, %14 : i32, i32
          }
          scf.yield %27#0, %27#1 : i32, i32
        } else {
          scf.yield %13, %14 : i32, i32
        }
        %23 = memref.load %12[] : memref<i1>
        memref.store %23, %11[] : memref<i1>
        %24 = memref.load %11[] : memref<i1>
        %25 = scf.if %24 -> (i32) {
          %26 = memref.load %3[] : memref<i32>
          %27 = arith.subi %15, %c1_i32 : i32
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %15 : i32
        }
        cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  func.return


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %8 = memref.load %6[] : memref<i1>
  scf.if %8 {
    scf.execute_region {
      %9 = memref.load %6[] : memref<i1>
      %10 = scf.if %9 -> (i32) {
        %26 = memref.get_global @kbm3 : memref<1xi32>
        %27 = memref.load %26[%c0] : memref<1xi32>
        memref.store %27, %3[] : memref<i32>
        scf.yield %27 : i32
      } else {
        scf.yield %1 : i32
      }
      %11 = memref.alloca() : memref<i1>
      %12 = memref.alloca() : memref<i1>
      memref.store %true, %12[] : memref<i1>
      cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
    ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
      %16 = memref.load %3[] : memref<i32>
      %17 = arith.cmpi sgt, %15, %c0_i32 : i32
      %18 = memref.load %12[] : memref<i1>
      %19 = arith.andi %17, %18 : i1
      cf.cond_br %19, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %20 = memref.load %12[] : memref<i1>
      memref.store %20, %11[] : memref<i1>
      %21 = memref.load %11[] : memref<i1>
      %22:2 = scf.if %21 -> (i32, i32) {
        %26 = memref.load %11[] : memref<i1>
        %27:2 = scf.if %26 -> (i32, i32) {
          %28:2 = scf.execute_region -> (i32, i32) {
            %29 = memref.load %11[] : memref<i1>
            %30 = scf.if %29 -> (i32) {
              memref.store %c0_i32, %2[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %14 : i32
            }
            %31 = memref.alloca() : memref<i1>
            %32 = memref.alloca() : memref<i1>
            memref.store %true, %32[] : memref<i1>
            cf.br ^bb1(%13, %30 : i32, i32)
          ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
            %35 = memref.load %2[] : memref<i32>
            %36 = memref.get_global @jm : memref<1xi32>
            %37 = memref.load %36[%c0] : memref<1xi32>
            %38 = arith.cmpi slt, %34, %37 : i32
            %39 = memref.load %32[] : memref<i1>
            %40 = arith.andi %38, %39 : i1
            cf.cond_br %40, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %41 = memref.load %32[] : memref<i1>
            memref.store %41, %31[] : memref<i1>
            %42 = memref.load %31[] : memref<i1>
            %43 = scf.if %42 -> (i32) {
              %47 = memref.load %31[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                %49 = scf.execute_region -> i32 {
                  %50 = memref.load %31[] : memref<i1>
                  %51 = scf.if %50 -> (i32) {
                    memref.store %c0_i32, %0[] : memref<i32>
                    scf.yield %c0_i32 : i32
                  } else {
                    scf.yield %33 : i32
                  }
                  %52 = memref.alloca() : memref<i1>
                  %53 = memref.alloca() : memref<i1>
                  memref.store %true, %53[] : memref<i1>
                  cf.br ^bb1(%51 : i32)
                ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                  %55 = memref.load %0[] : memref<i32>
                  %56 = memref.get_global @im : memref<1xi32>
                  %57 = memref.load %56[%c0] : memref<1xi32>
                  %58 = arith.cmpi slt, %54, %57 : i32
                  %59 = memref.load %53[] : memref<i1>
                  %60 = arith.andi %58, %59 : i1
                  cf.cond_br %60, ^bb2, ^bb3
                ^bb2:  // pred: ^bb1
                  %61 = memref.load %53[] : memref<i1>
                  memref.store %61, %52[] : memref<i1>
                  %62 = memref.load %52[] : memref<i1>
                  scf.if %62 {
                    %66 = memref.load %4[] : memref<memref<?xf32>>
                    %67 = memref.load %0[] : memref<i32>
                    %68 = memref.load %2[] : memref<i32>
                    %69 = memref.load %56[%c0] : memref<1xi32>
                    %70 = arith.muli %34, %69 : i32
                    %71 = arith.addi %54, %70 : i32
                    %72 = memref.load %3[] : memref<i32>
                    %73 = arith.muli %15, %69 : i32
                    %74 = memref.load %36[%c0] : memref<1xi32>
                    %75 = arith.muli %73, %74 : i32
                    %76 = arith.addi %71, %75 : i32
                    %77 = arith.index_cast %76 : i32 to index
                    %78 = memref.load %5[] : memref<memref<?xf32>>
                    %79 = arith.subi %15, %c1_i32 : i32
                    %80 = arith.muli %79, %69 : i32
                    %81 = arith.muli %80, %74 : i32
                    %82 = arith.addi %71, %81 : i32
                    %83 = arith.index_cast %82 : i32 to index
                    %84 = arith.addi %83, %c0 : index
                    %85 = memref.load %78[%84] : memref<?xf32>
                    %86 = arith.addi %77, %c0 : index
                    memref.store %85, %66[%86] : memref<?xf32>
                  }
                  %63 = memref.load %53[] : memref<i1>
                  memref.store %63, %52[] : memref<i1>
                  %64 = memref.load %52[] : memref<i1>
                  %65 = scf.if %64 -> (i32) {
                    %66 = memref.load %0[] : memref<i32>
                    %67 = arith.addi %54, %c1_i32 : i32
                    memref.store %67, %0[] : memref<i32>
                    scf.yield %67 : i32
                  } else {
                    scf.yield %54 : i32
                  }
                  cf.br ^bb1(%65 : i32)
                ^bb3:  // pred: ^bb1
                  scf.yield %54 : i32
                }
                scf.yield %49 : i32
              } else {
                scf.yield %33 : i32
              }
              scf.yield %48 : i32
            } else {
              scf.yield %33 : i32
            }
            %44 = memref.load %32[] : memref<i1>
            memref.store %44, %31[] : memref<i1>
            %45 = memref.load %31[] : memref<i1>
            %46 = scf.if %45 -> (i32) {
              %47 = memref.load %2[] : memref<i32>
              %48 = arith.addi %34, %c1_i32 : i32
              memref.store %48, %2[] : memref<i32>
              scf.yield %48 : i32
            } else {
              scf.yield %34 : i32
            }
            cf.br ^bb1(%43, %46 : i32, i32)
          ^bb3:  // pred: ^bb1
            scf.yield %33, %34 : i32, i32
          }
          scf.yield %28#0, %28#1 : i32, i32
        } else {
          scf.yield %13, %14 : i32, i32
        }
        scf.yield %27#0, %27#1 : i32, i32
      } else {
        scf.yield %13, %14 : i32, i32
      }
      %23 = memref.load %12[] : memref<i1>
      memref.store %23, %11[] : memref<i1>
      %24 = memref.load %11[] : memref<i1>
      %25 = scf.if %24 -> (i32) {
        %26 = memref.load %3[] : memref<i32>
        %27 = arith.subi %15, %c1_i32 : i32
        memref.store %27, %3[] : memref<i32>
        scf.yield %27 : i32
      } else {
        scf.yield %15 : i32
      }
      cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
  scf.yield


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.execute_region {
    %9 = memref.load %6[] : memref<i1>
    %10 = scf.if %9 -> (i32) {
      %26 = memref.get_global @kbm3 : memref<1xi32>
      %27 = memref.load %26[%c0] : memref<1xi32>
      memref.store %27, %3[] : memref<i32>
      scf.yield %27 : i32
    } else {
      scf.yield %1 : i32
    }
    %11 = memref.alloca() : memref<i1>
    %12 = memref.alloca() : memref<i1>
    memref.store %true, %12[] : memref<i1>
    cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
  ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
    %16 = memref.load %3[] : memref<i32>
    %17 = arith.cmpi sgt, %15, %c0_i32 : i32
    %18 = memref.load %12[] : memref<i1>
    %19 = arith.andi %17, %18 : i1
    cf.cond_br %19, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %20 = memref.load %12[] : memref<i1>
    memref.store %20, %11[] : memref<i1>
    %21 = memref.load %11[] : memref<i1>
    %22:2 = scf.if %21 -> (i32, i32) {
      %26 = memref.load %11[] : memref<i1>
      %27:2 = scf.if %26 -> (i32, i32) {
        %28:2 = scf.execute_region -> (i32, i32) {
          %29 = memref.load %11[] : memref<i1>
          %30 = scf.if %29 -> (i32) {
            memref.store %c0_i32, %2[] : memref<i32>
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %14 : i32
          }
          %31 = memref.alloca() : memref<i1>
          %32 = memref.alloca() : memref<i1>
          memref.store %true, %32[] : memref<i1>
          cf.br ^bb1(%13, %30 : i32, i32)
        ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
          %35 = memref.load %2[] : memref<i32>
          %36 = memref.get_global @jm : memref<1xi32>
          %37 = memref.load %36[%c0] : memref<1xi32>
          %38 = arith.cmpi slt, %34, %37 : i32
          %39 = memref.load %32[] : memref<i1>
          %40 = arith.andi %38, %39 : i1
          cf.cond_br %40, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %41 = memref.load %32[] : memref<i1>
          memref.store %41, %31[] : memref<i1>
          %42 = memref.load %31[] : memref<i1>
          %43 = scf.if %42 -> (i32) {
            %47 = memref.load %31[] : memref<i1>
            %48 = scf.if %47 -> (i32) {
              %49 = scf.execute_region -> i32 {
                %50 = memref.load %31[] : memref<i1>
                %51 = scf.if %50 -> (i32) {
                  memref.store %c0_i32, %0[] : memref<i32>
                  scf.yield %c0_i32 : i32
                } else {
                  scf.yield %33 : i32
                }
                %52 = memref.alloca() : memref<i1>
                %53 = memref.alloca() : memref<i1>
                memref.store %true, %53[] : memref<i1>
                cf.br ^bb1(%51 : i32)
              ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                %55 = memref.load %0[] : memref<i32>
                %56 = memref.get_global @im : memref<1xi32>
                %57 = memref.load %56[%c0] : memref<1xi32>
                %58 = arith.cmpi slt, %54, %57 : i32
                %59 = memref.load %53[] : memref<i1>
                %60 = arith.andi %58, %59 : i1
                cf.cond_br %60, ^bb2, ^bb3
              ^bb2:  // pred: ^bb1
                %61 = memref.load %53[] : memref<i1>
                memref.store %61, %52[] : memref<i1>
                %62 = memref.load %52[] : memref<i1>
                scf.if %62 {
                  %66 = memref.load %4[] : memref<memref<?xf32>>
                  %67 = memref.load %0[] : memref<i32>
                  %68 = memref.load %2[] : memref<i32>
                  %69 = memref.load %56[%c0] : memref<1xi32>
                  %70 = arith.muli %34, %69 : i32
                  %71 = arith.addi %54, %70 : i32
                  %72 = memref.load %3[] : memref<i32>
                  %73 = arith.muli %15, %69 : i32
                  %74 = memref.load %36[%c0] : memref<1xi32>
                  %75 = arith.muli %73, %74 : i32
                  %76 = arith.addi %71, %75 : i32
                  %77 = arith.index_cast %76 : i32 to index
                  %78 = memref.load %5[] : memref<memref<?xf32>>
                  %79 = arith.subi %15, %c1_i32 : i32
                  %80 = arith.muli %79, %69 : i32
                  %81 = arith.muli %80, %74 : i32
                  %82 = arith.addi %71, %81 : i32
                  %83 = arith.index_cast %82 : i32 to index
                  %84 = arith.addi %83, %c0 : index
                  %85 = memref.load %78[%84] : memref<?xf32>
                  %86 = arith.addi %77, %c0 : index
                  memref.store %85, %66[%86] : memref<?xf32>
                }
                %63 = memref.load %53[] : memref<i1>
                memref.store %63, %52[] : memref<i1>
                %64 = memref.load %52[] : memref<i1>
                %65 = scf.if %64 -> (i32) {
                  %66 = memref.load %0[] : memref<i32>
                  %67 = arith.addi %54, %c1_i32 : i32
                  memref.store %67, %0[] : memref<i32>
                  scf.yield %67 : i32
                } else {
                  scf.yield %54 : i32
                }
                cf.br ^bb1(%65 : i32)
              ^bb3:  // pred: ^bb1
                scf.yield %54 : i32
              }
              scf.yield %49 : i32
            } else {
              scf.yield %33 : i32
            }
            scf.yield %48 : i32
          } else {
            scf.yield %33 : i32
          }
          %44 = memref.load %32[] : memref<i1>
          memref.store %44, %31[] : memref<i1>
          %45 = memref.load %31[] : memref<i1>
          %46 = scf.if %45 -> (i32) {
            %47 = memref.load %2[] : memref<i32>
            %48 = arith.addi %34, %c1_i32 : i32
            memref.store %48, %2[] : memref<i32>
            scf.yield %48 : i32
          } else {
            scf.yield %34 : i32
          }
          cf.br ^bb1(%43, %46 : i32, i32)
        ^bb3:  // pred: ^bb1
          scf.yield %33, %34 : i32, i32
        }
        scf.yield %28#0, %28#1 : i32, i32
      } else {
        scf.yield %13, %14 : i32, i32
      }
      scf.yield %27#0, %27#1 : i32, i32
    } else {
      scf.yield %13, %14 : i32, i32
    }
    %23 = memref.load %12[] : memref<i1>
    memref.store %23, %11[] : memref<i1>
    %24 = memref.load %11[] : memref<i1>
    %25 = scf.if %24 -> (i32) {
      %26 = memref.load %3[] : memref<i32>
      %27 = arith.subi %15, %c1_i32 : i32
      memref.store %27, %3[] : memref<i32>
      scf.yield %27 : i32
    } else {
      scf.yield %15 : i32
    }
    cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
  ^bb3:  // pred: ^bb1
    scf.yield
  }
  scf.yield


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %9 = memref.load %6[] : memref<i1>
  %10 = scf.if %9 -> (i32) {
    %26 = memref.get_global @kbm3 : memref<1xi32>
    %27 = memref.load %26[%c0] : memref<1xi32>
    memref.store %27, %3[] : memref<i32>
    scf.yield %27 : i32
  } else {
    scf.yield %1 : i32
  }
  %11 = memref.alloca() : memref<i1>
  %12 = memref.alloca() : memref<i1>
  memref.store %true, %12[] : memref<i1>
  cf.br ^bb1(%1, %1, %10 : i32, i32, i32)


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.get_global @kbm3 : memref<1xi32>
  %27 = memref.load %26[%c0] : memref<1xi32>
  memref.store %27, %3[] : memref<i32>
  scf.yield %27 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.get_global @kbm3 : memref<1xi32>
  %27 = memref.load %26[%c0] : memref<1xi32>
  memref.store %27, %3[] : memref<i32>
  scf.yield %27 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %1 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %1 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %9 = memref.load %6[] : memref<i1>
  %10 = scf.if %9 -> (i32) {
    %26 = memref.get_global @kbm3 : memref<1xi32>
    %27 = memref.load %26[%c0] : memref<1xi32>
    memref.store %27, %3[] : memref<i32>
    scf.yield %27 : i32
  } else {
    scf.yield %1 : i32
  }
  %11 = memref.alloca() : memref<i1>
  %12 = memref.alloca() : memref<i1>
  memref.store %true, %12[] : memref<i1>
  cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
  %16 = memref.load %3[] : memref<i32>
  %17 = arith.cmpi sgt, %15, %c0_i32 : i32
  %18 = memref.load %12[] : memref<i1>
  %19 = arith.andi %17, %18 : i1
  cf.cond_br %19, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
  %16 = memref.load %3[] : memref<i32>
  %17 = arith.cmpi sgt, %15, %c0_i32 : i32
  %18 = memref.load %12[] : memref<i1>
  %19 = arith.andi %17, %18 : i1
  cf.cond_br %19, ^bb2, ^bb3
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %20 = memref.load %12[] : memref<i1>
  memref.store %20, %11[] : memref<i1>
  %21 = memref.load %11[] : memref<i1>
  %22:2 = scf.if %21 -> (i32, i32) {
    %26 = memref.load %11[] : memref<i1>
    %27:2 = scf.if %26 -> (i32, i32) {
      %28:2 = scf.execute_region -> (i32, i32) {
        %29 = memref.load %11[] : memref<i1>
        %30 = scf.if %29 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %14 : i32
        }
        %31 = memref.alloca() : memref<i1>
        %32 = memref.alloca() : memref<i1>
        memref.store %true, %32[] : memref<i1>
        cf.br ^bb1(%13, %30 : i32, i32)
      ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
        %35 = memref.load %2[] : memref<i32>
        %36 = memref.get_global @jm : memref<1xi32>
        %37 = memref.load %36[%c0] : memref<1xi32>
        %38 = arith.cmpi slt, %34, %37 : i32
        %39 = memref.load %32[] : memref<i1>
        %40 = arith.andi %38, %39 : i1
        cf.cond_br %40, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %41 = memref.load %32[] : memref<i1>
        memref.store %41, %31[] : memref<i1>
        %42 = memref.load %31[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %47 = memref.load %31[] : memref<i1>
          %48 = scf.if %47 -> (i32) {
            %49 = scf.execute_region -> i32 {
              %50 = memref.load %31[] : memref<i1>
              %51 = scf.if %50 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %33 : i32
              }
              %52 = memref.alloca() : memref<i1>
              %53 = memref.alloca() : memref<i1>
              memref.store %true, %53[] : memref<i1>
              cf.br ^bb1(%51 : i32)
            ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
              %55 = memref.load %0[] : memref<i32>
              %56 = memref.get_global @im : memref<1xi32>
              %57 = memref.load %56[%c0] : memref<1xi32>
              %58 = arith.cmpi slt, %54, %57 : i32
              %59 = memref.load %53[] : memref<i1>
              %60 = arith.andi %58, %59 : i1
              cf.cond_br %60, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %61 = memref.load %53[] : memref<i1>
              memref.store %61, %52[] : memref<i1>
              %62 = memref.load %52[] : memref<i1>
              scf.if %62 {
                %66 = memref.load %4[] : memref<memref<?xf32>>
                %67 = memref.load %0[] : memref<i32>
                %68 = memref.load %2[] : memref<i32>
                %69 = memref.load %56[%c0] : memref<1xi32>
                %70 = arith.muli %34, %69 : i32
                %71 = arith.addi %54, %70 : i32
                %72 = memref.load %3[] : memref<i32>
                %73 = arith.muli %15, %69 : i32
                %74 = memref.load %36[%c0] : memref<1xi32>
                %75 = arith.muli %73, %74 : i32
                %76 = arith.addi %71, %75 : i32
                %77 = arith.index_cast %76 : i32 to index
                %78 = memref.load %5[] : memref<memref<?xf32>>
                %79 = arith.subi %15, %c1_i32 : i32
                %80 = arith.muli %79, %69 : i32
                %81 = arith.muli %80, %74 : i32
                %82 = arith.addi %71, %81 : i32
                %83 = arith.index_cast %82 : i32 to index
                %84 = arith.addi %83, %c0 : index
                %85 = memref.load %78[%84] : memref<?xf32>
                %86 = arith.addi %77, %c0 : index
                memref.store %85, %66[%86] : memref<?xf32>
              }
              %63 = memref.load %53[] : memref<i1>
              memref.store %63, %52[] : memref<i1>
              %64 = memref.load %52[] : memref<i1>
              %65 = scf.if %64 -> (i32) {
                %66 = memref.load %0[] : memref<i32>
                %67 = arith.addi %54, %c1_i32 : i32
                memref.store %67, %0[] : memref<i32>
                scf.yield %67 : i32
              } else {
                scf.yield %54 : i32
              }
              cf.br ^bb1(%65 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %54 : i32
            }
            scf.yield %49 : i32
          } else {
            scf.yield %33 : i32
          }
          scf.yield %48 : i32
        } else {
          scf.yield %33 : i32
        }
        %44 = memref.load %32[] : memref<i1>
        memref.store %44, %31[] : memref<i1>
        %45 = memref.load %31[] : memref<i1>
        %46 = scf.if %45 -> (i32) {
          %47 = memref.load %2[] : memref<i32>
          %48 = arith.addi %34, %c1_i32 : i32
          memref.store %48, %2[] : memref<i32>
          scf.yield %48 : i32
        } else {
          scf.yield %34 : i32
        }
        cf.br ^bb1(%43, %46 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %33, %34 : i32, i32
      }
      scf.yield %28#0, %28#1 : i32, i32
    } else {
      scf.yield %13, %14 : i32, i32
    }
    scf.yield %27#0, %27#1 : i32, i32
  } else {
    scf.yield %13, %14 : i32, i32
  }
  %23 = memref.load %12[] : memref<i1>
  memref.store %23, %11[] : memref<i1>
  %24 = memref.load %11[] : memref<i1>
  %25 = scf.if %24 -> (i32) {
    %26 = memref.load %3[] : memref<i32>
    %27 = arith.subi %15, %c1_i32 : i32
    memref.store %27, %3[] : memref<i32>
    scf.yield %27 : i32
  } else {
    scf.yield %15 : i32
  }
  cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.load %11[] : memref<i1>
  %27:2 = scf.if %26 -> (i32, i32) {
    %28:2 = scf.execute_region -> (i32, i32) {
      %29 = memref.load %11[] : memref<i1>
      %30 = scf.if %29 -> (i32) {
        memref.store %c0_i32, %2[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %14 : i32
      }
      %31 = memref.alloca() : memref<i1>
      %32 = memref.alloca() : memref<i1>
      memref.store %true, %32[] : memref<i1>
      cf.br ^bb1(%13, %30 : i32, i32)
    ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
      %35 = memref.load %2[] : memref<i32>
      %36 = memref.get_global @jm : memref<1xi32>
      %37 = memref.load %36[%c0] : memref<1xi32>
      %38 = arith.cmpi slt, %34, %37 : i32
      %39 = memref.load %32[] : memref<i1>
      %40 = arith.andi %38, %39 : i1
      cf.cond_br %40, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %41 = memref.load %32[] : memref<i1>
      memref.store %41, %31[] : memref<i1>
      %42 = memref.load %31[] : memref<i1>
      %43 = scf.if %42 -> (i32) {
        %47 = memref.load %31[] : memref<i1>
        %48 = scf.if %47 -> (i32) {
          %49 = scf.execute_region -> i32 {
            %50 = memref.load %31[] : memref<i1>
            %51 = scf.if %50 -> (i32) {
              memref.store %c0_i32, %0[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %33 : i32
            }
            %52 = memref.alloca() : memref<i1>
            %53 = memref.alloca() : memref<i1>
            memref.store %true, %53[] : memref<i1>
            cf.br ^bb1(%51 : i32)
          ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
            %55 = memref.load %0[] : memref<i32>
            %56 = memref.get_global @im : memref<1xi32>
            %57 = memref.load %56[%c0] : memref<1xi32>
            %58 = arith.cmpi slt, %54, %57 : i32
            %59 = memref.load %53[] : memref<i1>
            %60 = arith.andi %58, %59 : i1
            cf.cond_br %60, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %61 = memref.load %53[] : memref<i1>
            memref.store %61, %52[] : memref<i1>
            %62 = memref.load %52[] : memref<i1>
            scf.if %62 {
              %66 = memref.load %4[] : memref<memref<?xf32>>
              %67 = memref.load %0[] : memref<i32>
              %68 = memref.load %2[] : memref<i32>
              %69 = memref.load %56[%c0] : memref<1xi32>
              %70 = arith.muli %34, %69 : i32
              %71 = arith.addi %54, %70 : i32
              %72 = memref.load %3[] : memref<i32>
              %73 = arith.muli %15, %69 : i32
              %74 = memref.load %36[%c0] : memref<1xi32>
              %75 = arith.muli %73, %74 : i32
              %76 = arith.addi %71, %75 : i32
              %77 = arith.index_cast %76 : i32 to index
              %78 = memref.load %5[] : memref<memref<?xf32>>
              %79 = arith.subi %15, %c1_i32 : i32
              %80 = arith.muli %79, %69 : i32
              %81 = arith.muli %80, %74 : i32
              %82 = arith.addi %71, %81 : i32
              %83 = arith.index_cast %82 : i32 to index
              %84 = arith.addi %83, %c0 : index
              %85 = memref.load %78[%84] : memref<?xf32>
              %86 = arith.addi %77, %c0 : index
              memref.store %85, %66[%86] : memref<?xf32>
            }
            %63 = memref.load %53[] : memref<i1>
            memref.store %63, %52[] : memref<i1>
            %64 = memref.load %52[] : memref<i1>
            %65 = scf.if %64 -> (i32) {
              %66 = memref.load %0[] : memref<i32>
              %67 = arith.addi %54, %c1_i32 : i32
              memref.store %67, %0[] : memref<i32>
              scf.yield %67 : i32
            } else {
              scf.yield %54 : i32
            }
            cf.br ^bb1(%65 : i32)
          ^bb3:  // pred: ^bb1
            scf.yield %54 : i32
          }
          scf.yield %49 : i32
        } else {
          scf.yield %33 : i32
        }
        scf.yield %48 : i32
      } else {
        scf.yield %33 : i32
      }
      %44 = memref.load %32[] : memref<i1>
      memref.store %44, %31[] : memref<i1>
      %45 = memref.load %31[] : memref<i1>
      %46 = scf.if %45 -> (i32) {
        %47 = memref.load %2[] : memref<i32>
        %48 = arith.addi %34, %c1_i32 : i32
        memref.store %48, %2[] : memref<i32>
        scf.yield %48 : i32
      } else {
        scf.yield %34 : i32
      }
      cf.br ^bb1(%43, %46 : i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield %33, %34 : i32, i32
    }
    scf.yield %28#0, %28#1 : i32, i32
  } else {
    scf.yield %13, %14 : i32, i32
  }
  scf.yield %27#0, %27#1 : i32, i32


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %28:2 = scf.execute_region -> (i32, i32) {
    %29 = memref.load %11[] : memref<i1>
    %30 = scf.if %29 -> (i32) {
      memref.store %c0_i32, %2[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %14 : i32
    }
    %31 = memref.alloca() : memref<i1>
    %32 = memref.alloca() : memref<i1>
    memref.store %true, %32[] : memref<i1>
    cf.br ^bb1(%13, %30 : i32, i32)
  ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
    %35 = memref.load %2[] : memref<i32>
    %36 = memref.get_global @jm : memref<1xi32>
    %37 = memref.load %36[%c0] : memref<1xi32>
    %38 = arith.cmpi slt, %34, %37 : i32
    %39 = memref.load %32[] : memref<i1>
    %40 = arith.andi %38, %39 : i1
    cf.cond_br %40, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %41 = memref.load %32[] : memref<i1>
    memref.store %41, %31[] : memref<i1>
    %42 = memref.load %31[] : memref<i1>
    %43 = scf.if %42 -> (i32) {
      %47 = memref.load %31[] : memref<i1>
      %48 = scf.if %47 -> (i32) {
        %49 = scf.execute_region -> i32 {
          %50 = memref.load %31[] : memref<i1>
          %51 = scf.if %50 -> (i32) {
            memref.store %c0_i32, %0[] : memref<i32>
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %33 : i32
          }
          %52 = memref.alloca() : memref<i1>
          %53 = memref.alloca() : memref<i1>
          memref.store %true, %53[] : memref<i1>
          cf.br ^bb1(%51 : i32)
        ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
          %55 = memref.load %0[] : memref<i32>
          %56 = memref.get_global @im : memref<1xi32>
          %57 = memref.load %56[%c0] : memref<1xi32>
          %58 = arith.cmpi slt, %54, %57 : i32
          %59 = memref.load %53[] : memref<i1>
          %60 = arith.andi %58, %59 : i1
          cf.cond_br %60, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %61 = memref.load %53[] : memref<i1>
          memref.store %61, %52[] : memref<i1>
          %62 = memref.load %52[] : memref<i1>
          scf.if %62 {
            %66 = memref.load %4[] : memref<memref<?xf32>>
            %67 = memref.load %0[] : memref<i32>
            %68 = memref.load %2[] : memref<i32>
            %69 = memref.load %56[%c0] : memref<1xi32>
            %70 = arith.muli %34, %69 : i32
            %71 = arith.addi %54, %70 : i32
            %72 = memref.load %3[] : memref<i32>
            %73 = arith.muli %15, %69 : i32
            %74 = memref.load %36[%c0] : memref<1xi32>
            %75 = arith.muli %73, %74 : i32
            %76 = arith.addi %71, %75 : i32
            %77 = arith.index_cast %76 : i32 to index
            %78 = memref.load %5[] : memref<memref<?xf32>>
            %79 = arith.subi %15, %c1_i32 : i32
            %80 = arith.muli %79, %69 : i32
            %81 = arith.muli %80, %74 : i32
            %82 = arith.addi %71, %81 : i32
            %83 = arith.index_cast %82 : i32 to index
            %84 = arith.addi %83, %c0 : index
            %85 = memref.load %78[%84] : memref<?xf32>
            %86 = arith.addi %77, %c0 : index
            memref.store %85, %66[%86] : memref<?xf32>
          }
          %63 = memref.load %53[] : memref<i1>
          memref.store %63, %52[] : memref<i1>
          %64 = memref.load %52[] : memref<i1>
          %65 = scf.if %64 -> (i32) {
            %66 = memref.load %0[] : memref<i32>
            %67 = arith.addi %54, %c1_i32 : i32
            memref.store %67, %0[] : memref<i32>
            scf.yield %67 : i32
          } else {
            scf.yield %54 : i32
          }
          cf.br ^bb1(%65 : i32)
        ^bb3:  // pred: ^bb1
          scf.yield %54 : i32
        }
        scf.yield %49 : i32
      } else {
        scf.yield %33 : i32
      }
      scf.yield %48 : i32
    } else {
      scf.yield %33 : i32
    }
    %44 = memref.load %32[] : memref<i1>
    memref.store %44, %31[] : memref<i1>
    %45 = memref.load %31[] : memref<i1>
    %46 = scf.if %45 -> (i32) {
      %47 = memref.load %2[] : memref<i32>
      %48 = arith.addi %34, %c1_i32 : i32
      memref.store %48, %2[] : memref<i32>
      scf.yield %48 : i32
    } else {
      scf.yield %34 : i32
    }
    cf.br ^bb1(%43, %46 : i32, i32)
  ^bb3:  // pred: ^bb1
    scf.yield %33, %34 : i32, i32
  }
  scf.yield %28#0, %28#1 : i32, i32


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %29 = memref.load %11[] : memref<i1>
  %30 = scf.if %29 -> (i32) {
    memref.store %c0_i32, %2[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %14 : i32
  }
  %31 = memref.alloca() : memref<i1>
  %32 = memref.alloca() : memref<i1>
  memref.store %true, %32[] : memref<i1>
  cf.br ^bb1(%13, %30 : i32, i32)


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %2[] : memref<i32>
  scf.yield %c0_i32 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %2[] : memref<i32>
  scf.yield %c0_i32 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %14 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %14 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %29 = memref.load %11[] : memref<i1>
  %30 = scf.if %29 -> (i32) {
    memref.store %c0_i32, %2[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %14 : i32
  }
  %31 = memref.alloca() : memref<i1>
  %32 = memref.alloca() : memref<i1>
  memref.store %true, %32[] : memref<i1>
  cf.br ^bb1(%13, %30 : i32, i32)
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
  %35 = memref.load %2[] : memref<i32>
  %36 = memref.get_global @jm : memref<1xi32>
  %37 = memref.load %36[%c0] : memref<1xi32>
  %38 = arith.cmpi slt, %34, %37 : i32
  %39 = memref.load %32[] : memref<i1>
  %40 = arith.andi %38, %39 : i1
  cf.cond_br %40, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
  %35 = memref.load %2[] : memref<i32>
  %36 = memref.get_global @jm : memref<1xi32>
  %37 = memref.load %36[%c0] : memref<1xi32>
  %38 = arith.cmpi slt, %34, %37 : i32
  %39 = memref.load %32[] : memref<i1>
  %40 = arith.andi %38, %39 : i1
  cf.cond_br %40, ^bb2, ^bb3
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %41, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %42 -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %47 -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %50 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %59 : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %61, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %62 {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %78[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %66[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %63, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %64 -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %44, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %45 -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %31[] : memref<i1>
  %48 = scf.if %47 -> (i32) {
    %49 = scf.execute_region -> i32 {
      %50 = memref.load %31[] : memref<i1>
      %51 = scf.if %50 -> (i32) {
        memref.store %c0_i32, %0[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %33 : i32
      }
      %52 = memref.alloca() : memref<i1>
      %53 = memref.alloca() : memref<i1>
      memref.store %true, %53[] : memref<i1>
      cf.br ^bb1(%51 : i32)
    ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
      %55 = memref.load %0[] : memref<i32>
      %56 = memref.get_global @im : memref<1xi32>
      %57 = memref.load %56[%c0] : memref<1xi32>
      %58 = arith.cmpi slt, %54, %57 : i32
      %59 = memref.load %53[] : memref<i1>
      %60 = arith.andi %58, %59 : i1
      cf.cond_br %60, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %61 = memref.load %53[] : memref<i1>
      memref.store %61, %52[] : memref<i1>
      %62 = memref.load %52[] : memref<i1>
      scf.if %62 {
        %66 = memref.load %4[] : memref<memref<?xf32>>
        %67 = memref.load %0[] : memref<i32>
        %68 = memref.load %2[] : memref<i32>
        %69 = memref.load %56[%c0] : memref<1xi32>
        %70 = arith.muli %34, %69 : i32
        %71 = arith.addi %54, %70 : i32
        %72 = memref.load %3[] : memref<i32>
        %73 = arith.muli %15, %69 : i32
        %74 = memref.load %36[%c0] : memref<1xi32>
        %75 = arith.muli %73, %74 : i32
        %76 = arith.addi %71, %75 : i32
        %77 = arith.index_cast %76 : i32 to index
        %78 = memref.load %5[] : memref<memref<?xf32>>
        %79 = arith.subi %15, %c1_i32 : i32
        %80 = arith.muli %79, %69 : i32
        %81 = arith.muli %80, %74 : i32
        %82 = arith.addi %71, %81 : i32
        %83 = arith.index_cast %82 : i32 to index
        %84 = arith.addi %83, %c0 : index
        %85 = memref.load %78[%84] : memref<?xf32>
        %86 = arith.addi %77, %c0 : index
        memref.store %85, %66[%86] : memref<?xf32>
      }
      %63 = memref.load %53[] : memref<i1>
      memref.store %63, %52[] : memref<i1>
      %64 = memref.load %52[] : memref<i1>
      %65 = scf.if %64 -> (i32) {
        %66 = memref.load %0[] : memref<i32>
        %67 = arith.addi %54, %c1_i32 : i32
        memref.store %67, %0[] : memref<i32>
        scf.yield %67 : i32
      } else {
        scf.yield %54 : i32
      }
      cf.br ^bb1(%65 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %54 : i32
    }
    scf.yield %49 : i32
  } else {
    scf.yield %33 : i32
  }
  scf.yield %48 : i32


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %49 = scf.execute_region -> i32 {
    %50 = memref.load %31[] : memref<i1>
    %51 = scf.if %50 -> (i32) {
      memref.store %c0_i32, %0[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %33 : i32
    }
    %52 = memref.alloca() : memref<i1>
    %53 = memref.alloca() : memref<i1>
    memref.store %true, %53[] : memref<i1>
    cf.br ^bb1(%51 : i32)
  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
    %55 = memref.load %0[] : memref<i32>
    %56 = memref.get_global @im : memref<1xi32>
    %57 = memref.load %56[%c0] : memref<1xi32>
    %58 = arith.cmpi slt, %54, %57 : i32
    %59 = memref.load %53[] : memref<i1>
    %60 = arith.andi %58, %59 : i1
    cf.cond_br %60, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %61 = memref.load %53[] : memref<i1>
    memref.store %61, %52[] : memref<i1>
    %62 = memref.load %52[] : memref<i1>
    scf.if %62 {
      %66 = memref.load %4[] : memref<memref<?xf32>>
      %67 = memref.load %0[] : memref<i32>
      %68 = memref.load %2[] : memref<i32>
      %69 = memref.load %56[%c0] : memref<1xi32>
      %70 = arith.muli %34, %69 : i32
      %71 = arith.addi %54, %70 : i32
      %72 = memref.load %3[] : memref<i32>
      %73 = arith.muli %15, %69 : i32
      %74 = memref.load %36[%c0] : memref<1xi32>
      %75 = arith.muli %73, %74 : i32
      %76 = arith.addi %71, %75 : i32
      %77 = arith.index_cast %76 : i32 to index
      %78 = memref.load %5[] : memref<memref<?xf32>>
      %79 = arith.subi %15, %c1_i32 : i32
      %80 = arith.muli %79, %69 : i32
      %81 = arith.muli %80, %74 : i32
      %82 = arith.addi %71, %81 : i32
      %83 = arith.index_cast %82 : i32 to index
      %84 = arith.addi %83, %c0 : index
      %85 = memref.load %78[%84] : memref<?xf32>
      %86 = arith.addi %77, %c0 : index
      memref.store %85, %66[%86] : memref<?xf32>
    }
    %63 = memref.load %53[] : memref<i1>
    memref.store %63, %52[] : memref<i1>
    %64 = memref.load %52[] : memref<i1>
    %65 = scf.if %64 -> (i32) {
      %66 = memref.load %0[] : memref<i32>
      %67 = arith.addi %54, %c1_i32 : i32
      memref.store %67, %0[] : memref<i32>
      scf.yield %67 : i32
    } else {
      scf.yield %54 : i32
    }
    cf.br ^bb1(%65 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %54 : i32
  }
  scf.yield %49 : i32


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %50 = memref.load %31[] : memref<i1>
  %51 = scf.if %50 -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %33 : i32
  }
  %52 = memref.alloca() : memref<i1>
  %53 = memref.alloca() : memref<i1>
  memref.store %true, %53[] : memref<i1>
  cf.br ^bb1(%51 : i32)


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield %c0_i32 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield %c0_i32 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %50 = memref.load %31[] : memref<i1>
  %51 = scf.if %50 -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %33 : i32
  }
  %52 = memref.alloca() : memref<i1>
  %53 = memref.alloca() : memref<i1>
  memref.store %true, %53[] : memref<i1>
  cf.br ^bb1(%51 : i32)
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %59 : i1
  cf.cond_br %60, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %59 : i1
  cf.cond_br %60, ^bb2, ^bb3
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %61, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %62 {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %78[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %66[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %63, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %64 -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %78[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %66[%86] : memref<?xf32>
  scf.yield

 replaced mlir-asm-printer: Verifying operation: builtin.module
%66 = memref.load %4[] : memref<memref<?xf32>> with <block argument> of type 'memref<?xf32>' at index: 2
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %78[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
  scf.yield
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %0[] : memref<i32>
  %67 = arith.addi %54, %c1_i32 : i32
  memref.store %67, %0[] : memref<i32>
  scf.yield %67 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %0[] : memref<i32>
  %67 = arith.addi %54, %c1_i32 : i32
  memref.store %67, %0[] : memref<i32>
  scf.yield %67 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %54 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %54 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %61, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %62 {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %78[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %63, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %64 -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %49 = scf.execute_region -> i32 {
    %50 = memref.load %31[] : memref<i1>
    %51 = scf.if %50 -> (i32) {
      memref.store %c0_i32, %0[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %33 : i32
    }
    %52 = memref.alloca() : memref<i1>
    %53 = memref.alloca() : memref<i1>
    memref.store %true, %53[] : memref<i1>
    cf.br ^bb1(%51 : i32)
  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
    %55 = memref.load %0[] : memref<i32>
    %56 = memref.get_global @im : memref<1xi32>
    %57 = memref.load %56[%c0] : memref<1xi32>
    %58 = arith.cmpi slt, %54, %57 : i32
    %59 = memref.load %53[] : memref<i1>
    %60 = arith.andi %58, %59 : i1
    cf.cond_br %60, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %61 = memref.load %53[] : memref<i1>
    memref.store %61, %52[] : memref<i1>
    %62 = memref.load %52[] : memref<i1>
    scf.if %62 {
      %66 = memref.load %4[] : memref<memref<?xf32>>
      %67 = memref.load %0[] : memref<i32>
      %68 = memref.load %2[] : memref<i32>
      %69 = memref.load %56[%c0] : memref<1xi32>
      %70 = arith.muli %34, %69 : i32
      %71 = arith.addi %54, %70 : i32
      %72 = memref.load %3[] : memref<i32>
      %73 = arith.muli %15, %69 : i32
      %74 = memref.load %36[%c0] : memref<1xi32>
      %75 = arith.muli %73, %74 : i32
      %76 = arith.addi %71, %75 : i32
      %77 = arith.index_cast %76 : i32 to index
      %78 = memref.load %5[] : memref<memref<?xf32>>
      %79 = arith.subi %15, %c1_i32 : i32
      %80 = arith.muli %79, %69 : i32
      %81 = arith.muli %80, %74 : i32
      %82 = arith.addi %71, %81 : i32
      %83 = arith.index_cast %82 : i32 to index
      %84 = arith.addi %83, %c0 : index
      %85 = memref.load %78[%84] : memref<?xf32>
      %86 = arith.addi %77, %c0 : index
      memref.store %85, %arg2[%86] : memref<?xf32>
    }
    %63 = memref.load %53[] : memref<i1>
    memref.store %63, %52[] : memref<i1>
    %64 = memref.load %52[] : memref<i1>
    %65 = scf.if %64 -> (i32) {
      %66 = memref.load %0[] : memref<i32>
      %67 = arith.addi %54, %c1_i32 : i32
      memref.store %67, %0[] : memref<i32>
      scf.yield %67 : i32
    } else {
      scf.yield %54 : i32
    }
    cf.br ^bb1(%65 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %54 : i32
  }
  scf.yield %49 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %31[] : memref<i1>
  %48 = scf.if %47 -> (i32) {
    %49 = scf.execute_region -> i32 {
      %50 = memref.load %31[] : memref<i1>
      %51 = scf.if %50 -> (i32) {
        memref.store %c0_i32, %0[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %33 : i32
      }
      %52 = memref.alloca() : memref<i1>
      %53 = memref.alloca() : memref<i1>
      memref.store %true, %53[] : memref<i1>
      cf.br ^bb1(%51 : i32)
    ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
      %55 = memref.load %0[] : memref<i32>
      %56 = memref.get_global @im : memref<1xi32>
      %57 = memref.load %56[%c0] : memref<1xi32>
      %58 = arith.cmpi slt, %54, %57 : i32
      %59 = memref.load %53[] : memref<i1>
      %60 = arith.andi %58, %59 : i1
      cf.cond_br %60, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %61 = memref.load %53[] : memref<i1>
      memref.store %61, %52[] : memref<i1>
      %62 = memref.load %52[] : memref<i1>
      scf.if %62 {
        %66 = memref.load %4[] : memref<memref<?xf32>>
        %67 = memref.load %0[] : memref<i32>
        %68 = memref.load %2[] : memref<i32>
        %69 = memref.load %56[%c0] : memref<1xi32>
        %70 = arith.muli %34, %69 : i32
        %71 = arith.addi %54, %70 : i32
        %72 = memref.load %3[] : memref<i32>
        %73 = arith.muli %15, %69 : i32
        %74 = memref.load %36[%c0] : memref<1xi32>
        %75 = arith.muli %73, %74 : i32
        %76 = arith.addi %71, %75 : i32
        %77 = arith.index_cast %76 : i32 to index
        %78 = memref.load %5[] : memref<memref<?xf32>>
        %79 = arith.subi %15, %c1_i32 : i32
        %80 = arith.muli %79, %69 : i32
        %81 = arith.muli %80, %74 : i32
        %82 = arith.addi %71, %81 : i32
        %83 = arith.index_cast %82 : i32 to index
        %84 = arith.addi %83, %c0 : index
        %85 = memref.load %78[%84] : memref<?xf32>
        %86 = arith.addi %77, %c0 : index
        memref.store %85, %arg2[%86] : memref<?xf32>
      }
      %63 = memref.load %53[] : memref<i1>
      memref.store %63, %52[] : memref<i1>
      %64 = memref.load %52[] : memref<i1>
      %65 = scf.if %64 -> (i32) {
        %66 = memref.load %0[] : memref<i32>
        %67 = arith.addi %54, %c1_i32 : i32
        memref.store %67, %0[] : memref<i32>
        scf.yield %67 : i32
      } else {
        scf.yield %54 : i32
      }
      cf.br ^bb1(%65 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %54 : i32
    }
    scf.yield %49 : i32
  } else {
    scf.yield %33 : i32
  }
  scf.yield %48 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %2[] : memref<i32>
  %48 = arith.addi %34, %c1_i32 : i32
  memref.store %48, %2[] : memref<i32>
  scf.yield %48 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %2[] : memref<i32>
  %48 = arith.addi %34, %c1_i32 : i32
  memref.store %48, %2[] : memref<i32>
  scf.yield %48 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %34 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %34 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %41, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %42 -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %47 -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %50 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %59 : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %61, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %62 {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %78[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %63, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %64 -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %44, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %45 -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %33, %34 : i32, i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %33, %34 : i32, i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %28:2 = scf.execute_region -> (i32, i32) {
    %29 = memref.load %11[] : memref<i1>
    %30 = scf.if %29 -> (i32) {
      memref.store %c0_i32, %2[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %14 : i32
    }
    %31 = memref.alloca() : memref<i1>
    %32 = memref.alloca() : memref<i1>
    memref.store %true, %32[] : memref<i1>
    cf.br ^bb1(%13, %30 : i32, i32)
  ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
    %35 = memref.load %2[] : memref<i32>
    %36 = memref.get_global @jm : memref<1xi32>
    %37 = memref.load %36[%c0] : memref<1xi32>
    %38 = arith.cmpi slt, %34, %37 : i32
    %39 = memref.load %32[] : memref<i1>
    %40 = arith.andi %38, %39 : i1
    cf.cond_br %40, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %41 = memref.load %32[] : memref<i1>
    memref.store %41, %31[] : memref<i1>
    %42 = memref.load %31[] : memref<i1>
    %43 = scf.if %42 -> (i32) {
      %47 = memref.load %31[] : memref<i1>
      %48 = scf.if %47 -> (i32) {
        %49 = scf.execute_region -> i32 {
          %50 = memref.load %31[] : memref<i1>
          %51 = scf.if %50 -> (i32) {
            memref.store %c0_i32, %0[] : memref<i32>
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %33 : i32
          }
          %52 = memref.alloca() : memref<i1>
          %53 = memref.alloca() : memref<i1>
          memref.store %true, %53[] : memref<i1>
          cf.br ^bb1(%51 : i32)
        ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
          %55 = memref.load %0[] : memref<i32>
          %56 = memref.get_global @im : memref<1xi32>
          %57 = memref.load %56[%c0] : memref<1xi32>
          %58 = arith.cmpi slt, %54, %57 : i32
          %59 = memref.load %53[] : memref<i1>
          %60 = arith.andi %58, %59 : i1
          cf.cond_br %60, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %61 = memref.load %53[] : memref<i1>
          memref.store %61, %52[] : memref<i1>
          %62 = memref.load %52[] : memref<i1>
          scf.if %62 {
            %66 = memref.load %4[] : memref<memref<?xf32>>
            %67 = memref.load %0[] : memref<i32>
            %68 = memref.load %2[] : memref<i32>
            %69 = memref.load %56[%c0] : memref<1xi32>
            %70 = arith.muli %34, %69 : i32
            %71 = arith.addi %54, %70 : i32
            %72 = memref.load %3[] : memref<i32>
            %73 = arith.muli %15, %69 : i32
            %74 = memref.load %36[%c0] : memref<1xi32>
            %75 = arith.muli %73, %74 : i32
            %76 = arith.addi %71, %75 : i32
            %77 = arith.index_cast %76 : i32 to index
            %78 = memref.load %5[] : memref<memref<?xf32>>
            %79 = arith.subi %15, %c1_i32 : i32
            %80 = arith.muli %79, %69 : i32
            %81 = arith.muli %80, %74 : i32
            %82 = arith.addi %71, %81 : i32
            %83 = arith.index_cast %82 : i32 to index
            %84 = arith.addi %83, %c0 : index
            %85 = memref.load %78[%84] : memref<?xf32>
            %86 = arith.addi %77, %c0 : index
            memref.store %85, %arg2[%86] : memref<?xf32>
          }
          %63 = memref.load %53[] : memref<i1>
          memref.store %63, %52[] : memref<i1>
          %64 = memref.load %52[] : memref<i1>
          %65 = scf.if %64 -> (i32) {
            %66 = memref.load %0[] : memref<i32>
            %67 = arith.addi %54, %c1_i32 : i32
            memref.store %67, %0[] : memref<i32>
            scf.yield %67 : i32
          } else {
            scf.yield %54 : i32
          }
          cf.br ^bb1(%65 : i32)
        ^bb3:  // pred: ^bb1
          scf.yield %54 : i32
        }
        scf.yield %49 : i32
      } else {
        scf.yield %33 : i32
      }
      scf.yield %48 : i32
    } else {
      scf.yield %33 : i32
    }
    %44 = memref.load %32[] : memref<i1>
    memref.store %44, %31[] : memref<i1>
    %45 = memref.load %31[] : memref<i1>
    %46 = scf.if %45 -> (i32) {
      %47 = memref.load %2[] : memref<i32>
      %48 = arith.addi %34, %c1_i32 : i32
      memref.store %48, %2[] : memref<i32>
      scf.yield %48 : i32
    } else {
      scf.yield %34 : i32
    }
    cf.br ^bb1(%43, %46 : i32, i32)
  ^bb3:  // pred: ^bb1
    scf.yield %33, %34 : i32, i32
  }
  scf.yield %28#0, %28#1 : i32, i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %13, %14 : i32, i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %13, %14 : i32, i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.load %11[] : memref<i1>
  %27:2 = scf.if %26 -> (i32, i32) {
    %28:2 = scf.execute_region -> (i32, i32) {
      %29 = memref.load %11[] : memref<i1>
      %30 = scf.if %29 -> (i32) {
        memref.store %c0_i32, %2[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %14 : i32
      }
      %31 = memref.alloca() : memref<i1>
      %32 = memref.alloca() : memref<i1>
      memref.store %true, %32[] : memref<i1>
      cf.br ^bb1(%13, %30 : i32, i32)
    ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
      %35 = memref.load %2[] : memref<i32>
      %36 = memref.get_global @jm : memref<1xi32>
      %37 = memref.load %36[%c0] : memref<1xi32>
      %38 = arith.cmpi slt, %34, %37 : i32
      %39 = memref.load %32[] : memref<i1>
      %40 = arith.andi %38, %39 : i1
      cf.cond_br %40, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %41 = memref.load %32[] : memref<i1>
      memref.store %41, %31[] : memref<i1>
      %42 = memref.load %31[] : memref<i1>
      %43 = scf.if %42 -> (i32) {
        %47 = memref.load %31[] : memref<i1>
        %48 = scf.if %47 -> (i32) {
          %49 = scf.execute_region -> i32 {
            %50 = memref.load %31[] : memref<i1>
            %51 = scf.if %50 -> (i32) {
              memref.store %c0_i32, %0[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %33 : i32
            }
            %52 = memref.alloca() : memref<i1>
            %53 = memref.alloca() : memref<i1>
            memref.store %true, %53[] : memref<i1>
            cf.br ^bb1(%51 : i32)
          ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
            %55 = memref.load %0[] : memref<i32>
            %56 = memref.get_global @im : memref<1xi32>
            %57 = memref.load %56[%c0] : memref<1xi32>
            %58 = arith.cmpi slt, %54, %57 : i32
            %59 = memref.load %53[] : memref<i1>
            %60 = arith.andi %58, %59 : i1
            cf.cond_br %60, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %61 = memref.load %53[] : memref<i1>
            memref.store %61, %52[] : memref<i1>
            %62 = memref.load %52[] : memref<i1>
            scf.if %62 {
              %66 = memref.load %4[] : memref<memref<?xf32>>
              %67 = memref.load %0[] : memref<i32>
              %68 = memref.load %2[] : memref<i32>
              %69 = memref.load %56[%c0] : memref<1xi32>
              %70 = arith.muli %34, %69 : i32
              %71 = arith.addi %54, %70 : i32
              %72 = memref.load %3[] : memref<i32>
              %73 = arith.muli %15, %69 : i32
              %74 = memref.load %36[%c0] : memref<1xi32>
              %75 = arith.muli %73, %74 : i32
              %76 = arith.addi %71, %75 : i32
              %77 = arith.index_cast %76 : i32 to index
              %78 = memref.load %5[] : memref<memref<?xf32>>
              %79 = arith.subi %15, %c1_i32 : i32
              %80 = arith.muli %79, %69 : i32
              %81 = arith.muli %80, %74 : i32
              %82 = arith.addi %71, %81 : i32
              %83 = arith.index_cast %82 : i32 to index
              %84 = arith.addi %83, %c0 : index
              %85 = memref.load %78[%84] : memref<?xf32>
              %86 = arith.addi %77, %c0 : index
              memref.store %85, %arg2[%86] : memref<?xf32>
            }
            %63 = memref.load %53[] : memref<i1>
            memref.store %63, %52[] : memref<i1>
            %64 = memref.load %52[] : memref<i1>
            %65 = scf.if %64 -> (i32) {
              %66 = memref.load %0[] : memref<i32>
              %67 = arith.addi %54, %c1_i32 : i32
              memref.store %67, %0[] : memref<i32>
              scf.yield %67 : i32
            } else {
              scf.yield %54 : i32
            }
            cf.br ^bb1(%65 : i32)
          ^bb3:  // pred: ^bb1
            scf.yield %54 : i32
          }
          scf.yield %49 : i32
        } else {
          scf.yield %33 : i32
        }
        scf.yield %48 : i32
      } else {
        scf.yield %33 : i32
      }
      %44 = memref.load %32[] : memref<i1>
      memref.store %44, %31[] : memref<i1>
      %45 = memref.load %31[] : memref<i1>
      %46 = scf.if %45 -> (i32) {
        %47 = memref.load %2[] : memref<i32>
        %48 = arith.addi %34, %c1_i32 : i32
        memref.store %48, %2[] : memref<i32>
        scf.yield %48 : i32
      } else {
        scf.yield %34 : i32
      }
      cf.br ^bb1(%43, %46 : i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield %33, %34 : i32, i32
    }
    scf.yield %28#0, %28#1 : i32, i32
  } else {
    scf.yield %13, %14 : i32, i32
  }
  scf.yield %27#0, %27#1 : i32, i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %13, %14 : i32, i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %13, %14 : i32, i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.load %3[] : memref<i32>
  %27 = arith.subi %15, %c1_i32 : i32
  memref.store %27, %3[] : memref<i32>
  scf.yield %27 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.load %3[] : memref<i32>
  %27 = arith.subi %15, %c1_i32 : i32
  memref.store %27, %3[] : memref<i32>
  scf.yield %27 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %15 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %15 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %20 = memref.load %12[] : memref<i1>
  memref.store %20, %11[] : memref<i1>
  %21 = memref.load %11[] : memref<i1>
  %22:2 = scf.if %21 -> (i32, i32) {
    %26 = memref.load %11[] : memref<i1>
    %27:2 = scf.if %26 -> (i32, i32) {
      %28:2 = scf.execute_region -> (i32, i32) {
        %29 = memref.load %11[] : memref<i1>
        %30 = scf.if %29 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %14 : i32
        }
        %31 = memref.alloca() : memref<i1>
        %32 = memref.alloca() : memref<i1>
        memref.store %true, %32[] : memref<i1>
        cf.br ^bb1(%13, %30 : i32, i32)
      ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
        %35 = memref.load %2[] : memref<i32>
        %36 = memref.get_global @jm : memref<1xi32>
        %37 = memref.load %36[%c0] : memref<1xi32>
        %38 = arith.cmpi slt, %34, %37 : i32
        %39 = memref.load %32[] : memref<i1>
        %40 = arith.andi %38, %39 : i1
        cf.cond_br %40, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %41 = memref.load %32[] : memref<i1>
        memref.store %41, %31[] : memref<i1>
        %42 = memref.load %31[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %47 = memref.load %31[] : memref<i1>
          %48 = scf.if %47 -> (i32) {
            %49 = scf.execute_region -> i32 {
              %50 = memref.load %31[] : memref<i1>
              %51 = scf.if %50 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %33 : i32
              }
              %52 = memref.alloca() : memref<i1>
              %53 = memref.alloca() : memref<i1>
              memref.store %true, %53[] : memref<i1>
              cf.br ^bb1(%51 : i32)
            ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
              %55 = memref.load %0[] : memref<i32>
              %56 = memref.get_global @im : memref<1xi32>
              %57 = memref.load %56[%c0] : memref<1xi32>
              %58 = arith.cmpi slt, %54, %57 : i32
              %59 = memref.load %53[] : memref<i1>
              %60 = arith.andi %58, %59 : i1
              cf.cond_br %60, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %61 = memref.load %53[] : memref<i1>
              memref.store %61, %52[] : memref<i1>
              %62 = memref.load %52[] : memref<i1>
              scf.if %62 {
                %66 = memref.load %4[] : memref<memref<?xf32>>
                %67 = memref.load %0[] : memref<i32>
                %68 = memref.load %2[] : memref<i32>
                %69 = memref.load %56[%c0] : memref<1xi32>
                %70 = arith.muli %34, %69 : i32
                %71 = arith.addi %54, %70 : i32
                %72 = memref.load %3[] : memref<i32>
                %73 = arith.muli %15, %69 : i32
                %74 = memref.load %36[%c0] : memref<1xi32>
                %75 = arith.muli %73, %74 : i32
                %76 = arith.addi %71, %75 : i32
                %77 = arith.index_cast %76 : i32 to index
                %78 = memref.load %5[] : memref<memref<?xf32>>
                %79 = arith.subi %15, %c1_i32 : i32
                %80 = arith.muli %79, %69 : i32
                %81 = arith.muli %80, %74 : i32
                %82 = arith.addi %71, %81 : i32
                %83 = arith.index_cast %82 : i32 to index
                %84 = arith.addi %83, %c0 : index
                %85 = memref.load %78[%84] : memref<?xf32>
                %86 = arith.addi %77, %c0 : index
                memref.store %85, %arg2[%86] : memref<?xf32>
              }
              %63 = memref.load %53[] : memref<i1>
              memref.store %63, %52[] : memref<i1>
              %64 = memref.load %52[] : memref<i1>
              %65 = scf.if %64 -> (i32) {
                %66 = memref.load %0[] : memref<i32>
                %67 = arith.addi %54, %c1_i32 : i32
                memref.store %67, %0[] : memref<i32>
                scf.yield %67 : i32
              } else {
                scf.yield %54 : i32
              }
              cf.br ^bb1(%65 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %54 : i32
            }
            scf.yield %49 : i32
          } else {
            scf.yield %33 : i32
          }
          scf.yield %48 : i32
        } else {
          scf.yield %33 : i32
        }
        %44 = memref.load %32[] : memref<i1>
        memref.store %44, %31[] : memref<i1>
        %45 = memref.load %31[] : memref<i1>
        %46 = scf.if %45 -> (i32) {
          %47 = memref.load %2[] : memref<i32>
          %48 = arith.addi %34, %c1_i32 : i32
          memref.store %48, %2[] : memref<i32>
          scf.yield %48 : i32
        } else {
          scf.yield %34 : i32
        }
        cf.br ^bb1(%43, %46 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %33, %34 : i32, i32
      }
      scf.yield %28#0, %28#1 : i32, i32
    } else {
      scf.yield %13, %14 : i32, i32
    }
    scf.yield %27#0, %27#1 : i32, i32
  } else {
    scf.yield %13, %14 : i32, i32
  }
  %23 = memref.load %12[] : memref<i1>
  memref.store %23, %11[] : memref<i1>
  %24 = memref.load %11[] : memref<i1>
  %25 = scf.if %24 -> (i32) {
    %26 = memref.load %3[] : memref<i32>
    %27 = arith.subi %15, %c1_i32 : i32
    memref.store %27, %3[] : memref<i32>
    scf.yield %27 : i32
  } else {
    scf.yield %15 : i32
  }
  cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 2
mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.execute_region {
    %9 = memref.load %6[] : memref<i1>
    %10 = scf.if %9 -> (i32) {
      %26 = memref.get_global @kbm3 : memref<1xi32>
      %27 = memref.load %26[%c0] : memref<1xi32>
      memref.store %27, %3[] : memref<i32>
      scf.yield %27 : i32
    } else {
      scf.yield %1 : i32
    }
    %11 = memref.alloca() : memref<i1>
    %12 = memref.alloca() : memref<i1>
    memref.store %true, %12[] : memref<i1>
    cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
  ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
    %16 = memref.load %3[] : memref<i32>
    %17 = arith.cmpi sgt, %15, %c0_i32 : i32
    %18 = memref.load %12[] : memref<i1>
    %19 = arith.andi %17, %18 : i1
    cf.cond_br %19, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %20 = memref.load %12[] : memref<i1>
    memref.store %20, %11[] : memref<i1>
    %21 = memref.load %11[] : memref<i1>
    %22:2 = scf.if %21 -> (i32, i32) {
      %26 = memref.load %11[] : memref<i1>
      %27:2 = scf.if %26 -> (i32, i32) {
        %28:2 = scf.execute_region -> (i32, i32) {
          %29 = memref.load %11[] : memref<i1>
          %30 = scf.if %29 -> (i32) {
            memref.store %c0_i32, %2[] : memref<i32>
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %14 : i32
          }
          %31 = memref.alloca() : memref<i1>
          %32 = memref.alloca() : memref<i1>
          memref.store %true, %32[] : memref<i1>
          cf.br ^bb1(%13, %30 : i32, i32)
        ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
          %35 = memref.load %2[] : memref<i32>
          %36 = memref.get_global @jm : memref<1xi32>
          %37 = memref.load %36[%c0] : memref<1xi32>
          %38 = arith.cmpi slt, %34, %37 : i32
          %39 = memref.load %32[] : memref<i1>
          %40 = arith.andi %38, %39 : i1
          cf.cond_br %40, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %41 = memref.load %32[] : memref<i1>
          memref.store %41, %31[] : memref<i1>
          %42 = memref.load %31[] : memref<i1>
          %43 = scf.if %42 -> (i32) {
            %47 = memref.load %31[] : memref<i1>
            %48 = scf.if %47 -> (i32) {
              %49 = scf.execute_region -> i32 {
                %50 = memref.load %31[] : memref<i1>
                %51 = scf.if %50 -> (i32) {
                  memref.store %c0_i32, %0[] : memref<i32>
                  scf.yield %c0_i32 : i32
                } else {
                  scf.yield %33 : i32
                }
                %52 = memref.alloca() : memref<i1>
                %53 = memref.alloca() : memref<i1>
                memref.store %true, %53[] : memref<i1>
                cf.br ^bb1(%51 : i32)
              ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                %55 = memref.load %0[] : memref<i32>
                %56 = memref.get_global @im : memref<1xi32>
                %57 = memref.load %56[%c0] : memref<1xi32>
                %58 = arith.cmpi slt, %54, %57 : i32
                %59 = memref.load %53[] : memref<i1>
                %60 = arith.andi %58, %59 : i1
                cf.cond_br %60, ^bb2, ^bb3
              ^bb2:  // pred: ^bb1
                %61 = memref.load %53[] : memref<i1>
                memref.store %61, %52[] : memref<i1>
                %62 = memref.load %52[] : memref<i1>
                scf.if %62 {
                  %66 = memref.load %4[] : memref<memref<?xf32>>
                  %67 = memref.load %0[] : memref<i32>
                  %68 = memref.load %2[] : memref<i32>
                  %69 = memref.load %56[%c0] : memref<1xi32>
                  %70 = arith.muli %34, %69 : i32
                  %71 = arith.addi %54, %70 : i32
                  %72 = memref.load %3[] : memref<i32>
                  %73 = arith.muli %15, %69 : i32
                  %74 = memref.load %36[%c0] : memref<1xi32>
                  %75 = arith.muli %73, %74 : i32
                  %76 = arith.addi %71, %75 : i32
                  %77 = arith.index_cast %76 : i32 to index
                  %78 = memref.load %5[] : memref<memref<?xf32>>
                  %79 = arith.subi %15, %c1_i32 : i32
                  %80 = arith.muli %79, %69 : i32
                  %81 = arith.muli %80, %74 : i32
                  %82 = arith.addi %71, %81 : i32
                  %83 = arith.index_cast %82 : i32 to index
                  %84 = arith.addi %83, %c0 : index
                  %85 = memref.load %78[%84] : memref<?xf32>
                  %86 = arith.addi %77, %c0 : index
                  memref.store %85, %arg2[%86] : memref<?xf32>
                }
                %63 = memref.load %53[] : memref<i1>
                memref.store %63, %52[] : memref<i1>
                %64 = memref.load %52[] : memref<i1>
                %65 = scf.if %64 -> (i32) {
                  %66 = memref.load %0[] : memref<i32>
                  %67 = arith.addi %54, %c1_i32 : i32
                  memref.store %67, %0[] : memref<i32>
                  scf.yield %67 : i32
                } else {
                  scf.yield %54 : i32
                }
                cf.br ^bb1(%65 : i32)
              ^bb3:  // pred: ^bb1
                scf.yield %54 : i32
              }
              scf.yield %49 : i32
            } else {
              scf.yield %33 : i32
            }
            scf.yield %48 : i32
          } else {
            scf.yield %33 : i32
          }
          %44 = memref.load %32[] : memref<i1>
          memref.store %44, %31[] : memref<i1>
          %45 = memref.load %31[] : memref<i1>
          %46 = scf.if %45 -> (i32) {
            %47 = memref.load %2[] : memref<i32>
            %48 = arith.addi %34, %c1_i32 : i32
            memref.store %48, %2[] : memref<i32>
            scf.yield %48 : i32
          } else {
            scf.yield %34 : i32
          }
          cf.br ^bb1(%43, %46 : i32, i32)
        ^bb3:  // pred: ^bb1
          scf.yield %33, %34 : i32, i32
        }
        scf.yield %28#0, %28#1 : i32, i32
      } else {
        scf.yield %13, %14 : i32, i32
      }
      scf.yield %27#0, %27#1 : i32, i32
    } else {
      scf.yield %13, %14 : i32, i32
    }
    %23 = memref.load %12[] : memref<i1>
    memref.store %23, %11[] : memref<i1>
    %24 = memref.load %11[] : memref<i1>
    %25 = scf.if %24 -> (i32) {
      %26 = memref.load %3[] : memref<i32>
      %27 = arith.subi %15, %c1_i32 : i32
      memref.store %27, %3[] : memref<i32>
      scf.yield %27 : i32
    } else {
      scf.yield %15 : i32
    }
    cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
  ^bb3:  // pred: ^bb1
    scf.yield
  }
  scf.yield
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %8 = memref.load %6[] : memref<i1>
  scf.if %8 {
    scf.execute_region {
      %9 = memref.load %6[] : memref<i1>
      %10 = scf.if %9 -> (i32) {
        %26 = memref.get_global @kbm3 : memref<1xi32>
        %27 = memref.load %26[%c0] : memref<1xi32>
        memref.store %27, %3[] : memref<i32>
        scf.yield %27 : i32
      } else {
        scf.yield %1 : i32
      }
      %11 = memref.alloca() : memref<i1>
      %12 = memref.alloca() : memref<i1>
      memref.store %true, %12[] : memref<i1>
      cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
    ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
      %16 = memref.load %3[] : memref<i32>
      %17 = arith.cmpi sgt, %15, %c0_i32 : i32
      %18 = memref.load %12[] : memref<i1>
      %19 = arith.andi %17, %18 : i1
      cf.cond_br %19, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %20 = memref.load %12[] : memref<i1>
      memref.store %20, %11[] : memref<i1>
      %21 = memref.load %11[] : memref<i1>
      %22:2 = scf.if %21 -> (i32, i32) {
        %26 = memref.load %11[] : memref<i1>
        %27:2 = scf.if %26 -> (i32, i32) {
          %28:2 = scf.execute_region -> (i32, i32) {
            %29 = memref.load %11[] : memref<i1>
            %30 = scf.if %29 -> (i32) {
              memref.store %c0_i32, %2[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %14 : i32
            }
            %31 = memref.alloca() : memref<i1>
            %32 = memref.alloca() : memref<i1>
            memref.store %true, %32[] : memref<i1>
            cf.br ^bb1(%13, %30 : i32, i32)
          ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
            %35 = memref.load %2[] : memref<i32>
            %36 = memref.get_global @jm : memref<1xi32>
            %37 = memref.load %36[%c0] : memref<1xi32>
            %38 = arith.cmpi slt, %34, %37 : i32
            %39 = memref.load %32[] : memref<i1>
            %40 = arith.andi %38, %39 : i1
            cf.cond_br %40, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %41 = memref.load %32[] : memref<i1>
            memref.store %41, %31[] : memref<i1>
            %42 = memref.load %31[] : memref<i1>
            %43 = scf.if %42 -> (i32) {
              %47 = memref.load %31[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                %49 = scf.execute_region -> i32 {
                  %50 = memref.load %31[] : memref<i1>
                  %51 = scf.if %50 -> (i32) {
                    memref.store %c0_i32, %0[] : memref<i32>
                    scf.yield %c0_i32 : i32
                  } else {
                    scf.yield %33 : i32
                  }
                  %52 = memref.alloca() : memref<i1>
                  %53 = memref.alloca() : memref<i1>
                  memref.store %true, %53[] : memref<i1>
                  cf.br ^bb1(%51 : i32)
                ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                  %55 = memref.load %0[] : memref<i32>
                  %56 = memref.get_global @im : memref<1xi32>
                  %57 = memref.load %56[%c0] : memref<1xi32>
                  %58 = arith.cmpi slt, %54, %57 : i32
                  %59 = memref.load %53[] : memref<i1>
                  %60 = arith.andi %58, %59 : i1
                  cf.cond_br %60, ^bb2, ^bb3
                ^bb2:  // pred: ^bb1
                  %61 = memref.load %53[] : memref<i1>
                  memref.store %61, %52[] : memref<i1>
                  %62 = memref.load %52[] : memref<i1>
                  scf.if %62 {
                    %66 = memref.load %4[] : memref<memref<?xf32>>
                    %67 = memref.load %0[] : memref<i32>
                    %68 = memref.load %2[] : memref<i32>
                    %69 = memref.load %56[%c0] : memref<1xi32>
                    %70 = arith.muli %34, %69 : i32
                    %71 = arith.addi %54, %70 : i32
                    %72 = memref.load %3[] : memref<i32>
                    %73 = arith.muli %15, %69 : i32
                    %74 = memref.load %36[%c0] : memref<1xi32>
                    %75 = arith.muli %73, %74 : i32
                    %76 = arith.addi %71, %75 : i32
                    %77 = arith.index_cast %76 : i32 to index
                    %78 = memref.load %5[] : memref<memref<?xf32>>
                    %79 = arith.subi %15, %c1_i32 : i32
                    %80 = arith.muli %79, %69 : i32
                    %81 = arith.muli %80, %74 : i32
                    %82 = arith.addi %71, %81 : i32
                    %83 = arith.index_cast %82 : i32 to index
                    %84 = arith.addi %83, %c0 : index
                    %85 = memref.load %78[%84] : memref<?xf32>
                    %86 = arith.addi %77, %c0 : index
                    memref.store %85, %arg2[%86] : memref<?xf32>
                  }
                  %63 = memref.load %53[] : memref<i1>
                  memref.store %63, %52[] : memref<i1>
                  %64 = memref.load %52[] : memref<i1>
                  %65 = scf.if %64 -> (i32) {
                    %66 = memref.load %0[] : memref<i32>
                    %67 = arith.addi %54, %c1_i32 : i32
                    memref.store %67, %0[] : memref<i32>
                    scf.yield %67 : i32
                  } else {
                    scf.yield %54 : i32
                  }
                  cf.br ^bb1(%65 : i32)
                ^bb3:  // pred: ^bb1
                  scf.yield %54 : i32
                }
                scf.yield %49 : i32
              } else {
                scf.yield %33 : i32
              }
              scf.yield %48 : i32
            } else {
              scf.yield %33 : i32
            }
            %44 = memref.load %32[] : memref<i1>
            memref.store %44, %31[] : memref<i1>
            %45 = memref.load %31[] : memref<i1>
            %46 = scf.if %45 -> (i32) {
              %47 = memref.load %2[] : memref<i32>
              %48 = arith.addi %34, %c1_i32 : i32
              memref.store %48, %2[] : memref<i32>
              scf.yield %48 : i32
            } else {
              scf.yield %34 : i32
            }
            cf.br ^bb1(%43, %46 : i32, i32)
          ^bb3:  // pred: ^bb1
            scf.yield %33, %34 : i32, i32
          }
          scf.yield %28#0, %28#1 : i32, i32
        } else {
          scf.yield %13, %14 : i32, i32
        }
        scf.yield %27#0, %27#1 : i32, i32
      } else {
        scf.yield %13, %14 : i32, i32
      }
      %23 = memref.load %12[] : memref<i1>
      memref.store %23, %11[] : memref<i1>
      %24 = memref.load %11[] : memref<i1>
      %25 = scf.if %24 -> (i32) {
        %26 = memref.load %3[] : memref<i32>
        %27 = arith.subi %15, %c1_i32 : i32
        memref.store %27, %3[] : memref<i32>
        scf.yield %27 : i32
      } else {
        scf.yield %15 : i32
      }
      cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
  scf.yield
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32):
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %7 {
    %8 = memref.load %6[] : memref<i1>
    scf.if %8 {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        %10 = scf.if %9 -> (i32) {
          %26 = memref.get_global @kbm3 : memref<1xi32>
          %27 = memref.load %26[%c0] : memref<1xi32>
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %1 : i32
        }
        %11 = memref.alloca() : memref<i1>
        %12 = memref.alloca() : memref<i1>
        memref.store %true, %12[] : memref<i1>
        cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
      ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
        %16 = memref.load %3[] : memref<i32>
        %17 = arith.cmpi sgt, %15, %c0_i32 : i32
        %18 = memref.load %12[] : memref<i1>
        %19 = arith.andi %17, %18 : i1
        cf.cond_br %19, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %20 = memref.load %12[] : memref<i1>
        memref.store %20, %11[] : memref<i1>
        %21 = memref.load %11[] : memref<i1>
        %22:2 = scf.if %21 -> (i32, i32) {
          %26 = memref.load %11[] : memref<i1>
          %27:2 = scf.if %26 -> (i32, i32) {
            %28:2 = scf.execute_region -> (i32, i32) {
              %29 = memref.load %11[] : memref<i1>
              %30 = scf.if %29 -> (i32) {
                memref.store %c0_i32, %2[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %14 : i32
              }
              %31 = memref.alloca() : memref<i1>
              %32 = memref.alloca() : memref<i1>
              memref.store %true, %32[] : memref<i1>
              cf.br ^bb1(%13, %30 : i32, i32)
            ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
              %35 = memref.load %2[] : memref<i32>
              %36 = memref.get_global @jm : memref<1xi32>
              %37 = memref.load %36[%c0] : memref<1xi32>
              %38 = arith.cmpi slt, %34, %37 : i32
              %39 = memref.load %32[] : memref<i1>
              %40 = arith.andi %38, %39 : i1
              cf.cond_br %40, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %41 = memref.load %32[] : memref<i1>
              memref.store %41, %31[] : memref<i1>
              %42 = memref.load %31[] : memref<i1>
              %43 = scf.if %42 -> (i32) {
                %47 = memref.load %31[] : memref<i1>
                %48 = scf.if %47 -> (i32) {
                  %49 = scf.execute_region -> i32 {
                    %50 = memref.load %31[] : memref<i1>
                    %51 = scf.if %50 -> (i32) {
                      memref.store %c0_i32, %0[] : memref<i32>
                      scf.yield %c0_i32 : i32
                    } else {
                      scf.yield %33 : i32
                    }
                    %52 = memref.alloca() : memref<i1>
                    %53 = memref.alloca() : memref<i1>
                    memref.store %true, %53[] : memref<i1>
                    cf.br ^bb1(%51 : i32)
                  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                    %55 = memref.load %0[] : memref<i32>
                    %56 = memref.get_global @im : memref<1xi32>
                    %57 = memref.load %56[%c0] : memref<1xi32>
                    %58 = arith.cmpi slt, %54, %57 : i32
                    %59 = memref.load %53[] : memref<i1>
                    %60 = arith.andi %58, %59 : i1
                    cf.cond_br %60, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %61 = memref.load %53[] : memref<i1>
                    memref.store %61, %52[] : memref<i1>
                    %62 = memref.load %52[] : memref<i1>
                    scf.if %62 {
                      %66 = memref.load %4[] : memref<memref<?xf32>>
                      %67 = memref.load %0[] : memref<i32>
                      %68 = memref.load %2[] : memref<i32>
                      %69 = memref.load %56[%c0] : memref<1xi32>
                      %70 = arith.muli %34, %69 : i32
                      %71 = arith.addi %54, %70 : i32
                      %72 = memref.load %3[] : memref<i32>
                      %73 = arith.muli %15, %69 : i32
                      %74 = memref.load %36[%c0] : memref<1xi32>
                      %75 = arith.muli %73, %74 : i32
                      %76 = arith.addi %71, %75 : i32
                      %77 = arith.index_cast %76 : i32 to index
                      %78 = memref.load %5[] : memref<memref<?xf32>>
                      %79 = arith.subi %15, %c1_i32 : i32
                      %80 = arith.muli %79, %69 : i32
                      %81 = arith.muli %80, %74 : i32
                      %82 = arith.addi %71, %81 : i32
                      %83 = arith.index_cast %82 : i32 to index
                      %84 = arith.addi %83, %c0 : index
                      %85 = memref.load %78[%84] : memref<?xf32>
                      %86 = arith.addi %77, %c0 : index
                      memref.store %85, %arg2[%86] : memref<?xf32>
                    }
                    %63 = memref.load %53[] : memref<i1>
                    memref.store %63, %52[] : memref<i1>
                    %64 = memref.load %52[] : memref<i1>
                    %65 = scf.if %64 -> (i32) {
                      %66 = memref.load %0[] : memref<i32>
                      %67 = arith.addi %54, %c1_i32 : i32
                      memref.store %67, %0[] : memref<i32>
                      scf.yield %67 : i32
                    } else {
                      scf.yield %54 : i32
                    }
                    cf.br ^bb1(%65 : i32)
                  ^bb3:  // pred: ^bb1
                    scf.yield %54 : i32
                  }
                  scf.yield %49 : i32
                } else {
                  scf.yield %33 : i32
                }
                scf.yield %48 : i32
              } else {
                scf.yield %33 : i32
              }
              %44 = memref.load %32[] : memref<i1>
              memref.store %44, %31[] : memref<i1>
              %45 = memref.load %31[] : memref<i1>
              %46 = scf.if %45 -> (i32) {
                %47 = memref.load %2[] : memref<i32>
                %48 = arith.addi %34, %c1_i32 : i32
                memref.store %48, %2[] : memref<i32>
                scf.yield %48 : i32
              } else {
                scf.yield %34 : i32
              }
              cf.br ^bb1(%43, %46 : i32, i32)
            ^bb3:  // pred: ^bb1
              scf.yield %33, %34 : i32, i32
            }
            scf.yield %28#0, %28#1 : i32, i32
          } else {
            scf.yield %13, %14 : i32, i32
          }
          scf.yield %27#0, %27#1 : i32, i32
        } else {
          scf.yield %13, %14 : i32, i32
        }
        %23 = memref.load %12[] : memref<i1>
        memref.store %23, %11[] : memref<i1>
        %24 = memref.load %11[] : memref<i1>
        %25 = scf.if %24 -> (i32) {
          %26 = memref.load %3[] : memref<i32>
          %27 = arith.subi %15, %c1_i32 : i32
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %15 : i32
        }
        cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  func.return
 with val:val:<block argument> of type 'memref<?xf32>' at index: 2
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%5 = memref.alloca() : memref<memref<?xf32>>
 + forwarding vec to promote {} of mlir-asm-printer: Verifying operation: builtin.module
%5 = memref.alloca() : memref<memref<?xf32>>
Begin forwarding store of mlir-asm-printer: Verifying operation: builtin.module
%5 = memref.alloca() : memref<memref<?xf32>> to load
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %7 {
    %8 = memref.load %6[] : memref<i1>
    scf.if %8 {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        %10 = scf.if %9 -> (i32) {
          %26 = memref.get_global @kbm3 : memref<1xi32>
          %27 = memref.load %26[%c0] : memref<1xi32>
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %1 : i32
        }
        %11 = memref.alloca() : memref<i1>
        %12 = memref.alloca() : memref<i1>
        memref.store %true, %12[] : memref<i1>
        cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
      ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
        %16 = memref.load %3[] : memref<i32>
        %17 = arith.cmpi sgt, %15, %c0_i32 : i32
        %18 = memref.load %12[] : memref<i1>
        %19 = arith.andi %17, %18 : i1
        cf.cond_br %19, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %20 = memref.load %12[] : memref<i1>
        memref.store %20, %11[] : memref<i1>
        %21 = memref.load %11[] : memref<i1>
        %22:2 = scf.if %21 -> (i32, i32) {
          %26 = memref.load %11[] : memref<i1>
          %27:2 = scf.if %26 -> (i32, i32) {
            %28:2 = scf.execute_region -> (i32, i32) {
              %29 = memref.load %11[] : memref<i1>
              %30 = scf.if %29 -> (i32) {
                memref.store %c0_i32, %2[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %14 : i32
              }
              %31 = memref.alloca() : memref<i1>
              %32 = memref.alloca() : memref<i1>
              memref.store %true, %32[] : memref<i1>
              cf.br ^bb1(%13, %30 : i32, i32)
            ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
              %35 = memref.load %2[] : memref<i32>
              %36 = memref.get_global @jm : memref<1xi32>
              %37 = memref.load %36[%c0] : memref<1xi32>
              %38 = arith.cmpi slt, %34, %37 : i32
              %39 = memref.load %32[] : memref<i1>
              %40 = arith.andi %38, %39 : i1
              cf.cond_br %40, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %41 = memref.load %32[] : memref<i1>
              memref.store %41, %31[] : memref<i1>
              %42 = memref.load %31[] : memref<i1>
              %43 = scf.if %42 -> (i32) {
                %47 = memref.load %31[] : memref<i1>
                %48 = scf.if %47 -> (i32) {
                  %49 = scf.execute_region -> i32 {
                    %50 = memref.load %31[] : memref<i1>
                    %51 = scf.if %50 -> (i32) {
                      memref.store %c0_i32, %0[] : memref<i32>
                      scf.yield %c0_i32 : i32
                    } else {
                      scf.yield %33 : i32
                    }
                    %52 = memref.alloca() : memref<i1>
                    %53 = memref.alloca() : memref<i1>
                    memref.store %true, %53[] : memref<i1>
                    cf.br ^bb1(%51 : i32)
                  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                    %55 = memref.load %0[] : memref<i32>
                    %56 = memref.get_global @im : memref<1xi32>
                    %57 = memref.load %56[%c0] : memref<1xi32>
                    %58 = arith.cmpi slt, %54, %57 : i32
                    %59 = memref.load %53[] : memref<i1>
                    %60 = arith.andi %58, %59 : i1
                    cf.cond_br %60, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %61 = memref.load %53[] : memref<i1>
                    memref.store %61, %52[] : memref<i1>
                    %62 = memref.load %52[] : memref<i1>
                    scf.if %62 {
                      %66 = memref.load %4[] : memref<memref<?xf32>>
                      %67 = memref.load %0[] : memref<i32>
                      %68 = memref.load %2[] : memref<i32>
                      %69 = memref.load %56[%c0] : memref<1xi32>
                      %70 = arith.muli %34, %69 : i32
                      %71 = arith.addi %54, %70 : i32
                      %72 = memref.load %3[] : memref<i32>
                      %73 = arith.muli %15, %69 : i32
                      %74 = memref.load %36[%c0] : memref<1xi32>
                      %75 = arith.muli %73, %74 : i32
                      %76 = arith.addi %71, %75 : i32
                      %77 = arith.index_cast %76 : i32 to index
                      %78 = memref.load %5[] : memref<memref<?xf32>>
                      %79 = arith.subi %15, %c1_i32 : i32
                      %80 = arith.muli %79, %69 : i32
                      %81 = arith.muli %80, %74 : i32
                      %82 = arith.addi %71, %81 : i32
                      %83 = arith.index_cast %82 : i32 to index
                      %84 = arith.addi %83, %c0 : index
                      %85 = memref.load %78[%84] : memref<?xf32>
                      %86 = arith.addi %77, %c0 : index
                      memref.store %85, %arg2[%86] : memref<?xf32>
                    }
                    %63 = memref.load %53[] : memref<i1>
                    memref.store %63, %52[] : memref<i1>
                    %64 = memref.load %52[] : memref<i1>
                    %65 = scf.if %64 -> (i32) {
                      %66 = memref.load %0[] : memref<i32>
                      %67 = arith.addi %54, %c1_i32 : i32
                      memref.store %67, %0[] : memref<i32>
                      scf.yield %67 : i32
                    } else {
                      scf.yield %54 : i32
                    }
                    cf.br ^bb1(%65 : i32)
                  ^bb3:  // pred: ^bb1
                    scf.yield %54 : i32
                  }
                  scf.yield %49 : i32
                } else {
                  scf.yield %33 : i32
                }
                scf.yield %48 : i32
              } else {
                scf.yield %33 : i32
              }
              %44 = memref.load %32[] : memref<i1>
              memref.store %44, %31[] : memref<i1>
              %45 = memref.load %31[] : memref<i1>
              %46 = scf.if %45 -> (i32) {
                %47 = memref.load %2[] : memref<i32>
                %48 = arith.addi %34, %c1_i32 : i32
                memref.store %48, %2[] : memref<i32>
                scf.yield %48 : i32
              } else {
                scf.yield %34 : i32
              }
              cf.br ^bb1(%43, %46 : i32, i32)
            ^bb3:  // pred: ^bb1
              scf.yield %33, %34 : i32, i32
            }
            scf.yield %28#0, %28#1 : i32, i32
          } else {
            scf.yield %13, %14 : i32, i32
          }
          scf.yield %27#0, %27#1 : i32, i32
        } else {
          scf.yield %13, %14 : i32, i32
        }
        %23 = memref.load %12[] : memref<i1>
        memref.store %23, %11[] : memref<i1>
        %24 = memref.load %11[] : memref<i1>
        %25 = scf.if %24 -> (i32) {
          %26 = memref.load %3[] : memref<i32>
          %27 = arith.subi %15, %c1_i32 : i32
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %15 : i32
        }
        cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}
Matching Load: mlir-asm-printer: Verifying operation: func.func
%78 = memref.load %5[] : memref<memref<?xf32>>
Matching Store: mlir-asm-printer: Verifying operation: func.func
memref.store %arg0, %5[] : memref<memref<?xf32>>
 storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %arg0, %5[] : memref<memref<?xf32>>
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32):
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %7 {
    %8 = memref.load %6[] : memref<i1>
    scf.if %8 {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        %10 = scf.if %9 -> (i32) {
          %26 = memref.get_global @kbm3 : memref<1xi32>
          %27 = memref.load %26[%c0] : memref<1xi32>
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %1 : i32
        }
        %11 = memref.alloca() : memref<i1>
        %12 = memref.alloca() : memref<i1>
        memref.store %true, %12[] : memref<i1>
        cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
      ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
        %16 = memref.load %3[] : memref<i32>
        %17 = arith.cmpi sgt, %15, %c0_i32 : i32
        %18 = memref.load %12[] : memref<i1>
        %19 = arith.andi %17, %18 : i1
        cf.cond_br %19, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %20 = memref.load %12[] : memref<i1>
        memref.store %20, %11[] : memref<i1>
        %21 = memref.load %11[] : memref<i1>
        %22:2 = scf.if %21 -> (i32, i32) {
          %26 = memref.load %11[] : memref<i1>
          %27:2 = scf.if %26 -> (i32, i32) {
            %28:2 = scf.execute_region -> (i32, i32) {
              %29 = memref.load %11[] : memref<i1>
              %30 = scf.if %29 -> (i32) {
                memref.store %c0_i32, %2[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %14 : i32
              }
              %31 = memref.alloca() : memref<i1>
              %32 = memref.alloca() : memref<i1>
              memref.store %true, %32[] : memref<i1>
              cf.br ^bb1(%13, %30 : i32, i32)
            ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
              %35 = memref.load %2[] : memref<i32>
              %36 = memref.get_global @jm : memref<1xi32>
              %37 = memref.load %36[%c0] : memref<1xi32>
              %38 = arith.cmpi slt, %34, %37 : i32
              %39 = memref.load %32[] : memref<i1>
              %40 = arith.andi %38, %39 : i1
              cf.cond_br %40, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %41 = memref.load %32[] : memref<i1>
              memref.store %41, %31[] : memref<i1>
              %42 = memref.load %31[] : memref<i1>
              %43 = scf.if %42 -> (i32) {
                %47 = memref.load %31[] : memref<i1>
                %48 = scf.if %47 -> (i32) {
                  %49 = scf.execute_region -> i32 {
                    %50 = memref.load %31[] : memref<i1>
                    %51 = scf.if %50 -> (i32) {
                      memref.store %c0_i32, %0[] : memref<i32>
                      scf.yield %c0_i32 : i32
                    } else {
                      scf.yield %33 : i32
                    }
                    %52 = memref.alloca() : memref<i1>
                    %53 = memref.alloca() : memref<i1>
                    memref.store %true, %53[] : memref<i1>
                    cf.br ^bb1(%51 : i32)
                  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                    %55 = memref.load %0[] : memref<i32>
                    %56 = memref.get_global @im : memref<1xi32>
                    %57 = memref.load %56[%c0] : memref<1xi32>
                    %58 = arith.cmpi slt, %54, %57 : i32
                    %59 = memref.load %53[] : memref<i1>
                    %60 = arith.andi %58, %59 : i1
                    cf.cond_br %60, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %61 = memref.load %53[] : memref<i1>
                    memref.store %61, %52[] : memref<i1>
                    %62 = memref.load %52[] : memref<i1>
                    scf.if %62 {
                      %66 = memref.load %4[] : memref<memref<?xf32>>
                      %67 = memref.load %0[] : memref<i32>
                      %68 = memref.load %2[] : memref<i32>
                      %69 = memref.load %56[%c0] : memref<1xi32>
                      %70 = arith.muli %34, %69 : i32
                      %71 = arith.addi %54, %70 : i32
                      %72 = memref.load %3[] : memref<i32>
                      %73 = arith.muli %15, %69 : i32
                      %74 = memref.load %36[%c0] : memref<1xi32>
                      %75 = arith.muli %73, %74 : i32
                      %76 = arith.addi %71, %75 : i32
                      %77 = arith.index_cast %76 : i32 to index
                      %78 = memref.load %5[] : memref<memref<?xf32>>
                      %79 = arith.subi %15, %c1_i32 : i32
                      %80 = arith.muli %79, %69 : i32
                      %81 = arith.muli %80, %74 : i32
                      %82 = arith.addi %71, %81 : i32
                      %83 = arith.index_cast %82 : i32 to index
                      %84 = arith.addi %83, %c0 : index
                      %85 = memref.load %78[%84] : memref<?xf32>
                      %86 = arith.addi %77, %c0 : index
                      memref.store %85, %arg2[%86] : memref<?xf32>
                    }
                    %63 = memref.load %53[] : memref<i1>
                    memref.store %63, %52[] : memref<i1>
                    %64 = memref.load %52[] : memref<i1>
                    %65 = scf.if %64 -> (i32) {
                      %66 = memref.load %0[] : memref<i32>
                      %67 = arith.addi %54, %c1_i32 : i32
                      memref.store %67, %0[] : memref<i32>
                      scf.yield %67 : i32
                    } else {
                      scf.yield %54 : i32
                    }
                    cf.br ^bb1(%65 : i32)
                  ^bb3:  // pred: ^bb1
                    scf.yield %54 : i32
                  }
                  scf.yield %49 : i32
                } else {
                  scf.yield %33 : i32
                }
                scf.yield %48 : i32
              } else {
                scf.yield %33 : i32
              }
              %44 = memref.load %32[] : memref<i1>
              memref.store %44, %31[] : memref<i1>
              %45 = memref.load %31[] : memref<i1>
              %46 = scf.if %45 -> (i32) {
                %47 = memref.load %2[] : memref<i32>
                %48 = arith.addi %34, %c1_i32 : i32
                memref.store %48, %2[] : memref<i32>
                scf.yield %48 : i32
              } else {
                scf.yield %34 : i32
              }
              cf.br ^bb1(%43, %46 : i32, i32)
            ^bb3:  // pred: ^bb1
              scf.yield %33, %34 : i32, i32
            }
            scf.yield %28#0, %28#1 : i32, i32
          } else {
            scf.yield %13, %14 : i32, i32
          }
          scf.yield %27#0, %27#1 : i32, i32
        } else {
          scf.yield %13, %14 : i32, i32
        }
        %23 = memref.load %12[] : memref<i1>
        memref.store %23, %11[] : memref<i1>
        %24 = memref.load %11[] : memref<i1>
        %25 = scf.if %24 -> (i32) {
          %26 = memref.load %3[] : memref<i32>
          %27 = arith.subi %15, %c1_i32 : i32
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %15 : i32
        }
        cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  func.return


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %8 = memref.load %6[] : memref<i1>
  scf.if %8 {
    scf.execute_region {
      %9 = memref.load %6[] : memref<i1>
      %10 = scf.if %9 -> (i32) {
        %26 = memref.get_global @kbm3 : memref<1xi32>
        %27 = memref.load %26[%c0] : memref<1xi32>
        memref.store %27, %3[] : memref<i32>
        scf.yield %27 : i32
      } else {
        scf.yield %1 : i32
      }
      %11 = memref.alloca() : memref<i1>
      %12 = memref.alloca() : memref<i1>
      memref.store %true, %12[] : memref<i1>
      cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
    ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
      %16 = memref.load %3[] : memref<i32>
      %17 = arith.cmpi sgt, %15, %c0_i32 : i32
      %18 = memref.load %12[] : memref<i1>
      %19 = arith.andi %17, %18 : i1
      cf.cond_br %19, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %20 = memref.load %12[] : memref<i1>
      memref.store %20, %11[] : memref<i1>
      %21 = memref.load %11[] : memref<i1>
      %22:2 = scf.if %21 -> (i32, i32) {
        %26 = memref.load %11[] : memref<i1>
        %27:2 = scf.if %26 -> (i32, i32) {
          %28:2 = scf.execute_region -> (i32, i32) {
            %29 = memref.load %11[] : memref<i1>
            %30 = scf.if %29 -> (i32) {
              memref.store %c0_i32, %2[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %14 : i32
            }
            %31 = memref.alloca() : memref<i1>
            %32 = memref.alloca() : memref<i1>
            memref.store %true, %32[] : memref<i1>
            cf.br ^bb1(%13, %30 : i32, i32)
          ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
            %35 = memref.load %2[] : memref<i32>
            %36 = memref.get_global @jm : memref<1xi32>
            %37 = memref.load %36[%c0] : memref<1xi32>
            %38 = arith.cmpi slt, %34, %37 : i32
            %39 = memref.load %32[] : memref<i1>
            %40 = arith.andi %38, %39 : i1
            cf.cond_br %40, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %41 = memref.load %32[] : memref<i1>
            memref.store %41, %31[] : memref<i1>
            %42 = memref.load %31[] : memref<i1>
            %43 = scf.if %42 -> (i32) {
              %47 = memref.load %31[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                %49 = scf.execute_region -> i32 {
                  %50 = memref.load %31[] : memref<i1>
                  %51 = scf.if %50 -> (i32) {
                    memref.store %c0_i32, %0[] : memref<i32>
                    scf.yield %c0_i32 : i32
                  } else {
                    scf.yield %33 : i32
                  }
                  %52 = memref.alloca() : memref<i1>
                  %53 = memref.alloca() : memref<i1>
                  memref.store %true, %53[] : memref<i1>
                  cf.br ^bb1(%51 : i32)
                ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                  %55 = memref.load %0[] : memref<i32>
                  %56 = memref.get_global @im : memref<1xi32>
                  %57 = memref.load %56[%c0] : memref<1xi32>
                  %58 = arith.cmpi slt, %54, %57 : i32
                  %59 = memref.load %53[] : memref<i1>
                  %60 = arith.andi %58, %59 : i1
                  cf.cond_br %60, ^bb2, ^bb3
                ^bb2:  // pred: ^bb1
                  %61 = memref.load %53[] : memref<i1>
                  memref.store %61, %52[] : memref<i1>
                  %62 = memref.load %52[] : memref<i1>
                  scf.if %62 {
                    %66 = memref.load %4[] : memref<memref<?xf32>>
                    %67 = memref.load %0[] : memref<i32>
                    %68 = memref.load %2[] : memref<i32>
                    %69 = memref.load %56[%c0] : memref<1xi32>
                    %70 = arith.muli %34, %69 : i32
                    %71 = arith.addi %54, %70 : i32
                    %72 = memref.load %3[] : memref<i32>
                    %73 = arith.muli %15, %69 : i32
                    %74 = memref.load %36[%c0] : memref<1xi32>
                    %75 = arith.muli %73, %74 : i32
                    %76 = arith.addi %71, %75 : i32
                    %77 = arith.index_cast %76 : i32 to index
                    %78 = memref.load %5[] : memref<memref<?xf32>>
                    %79 = arith.subi %15, %c1_i32 : i32
                    %80 = arith.muli %79, %69 : i32
                    %81 = arith.muli %80, %74 : i32
                    %82 = arith.addi %71, %81 : i32
                    %83 = arith.index_cast %82 : i32 to index
                    %84 = arith.addi %83, %c0 : index
                    %85 = memref.load %78[%84] : memref<?xf32>
                    %86 = arith.addi %77, %c0 : index
                    memref.store %85, %arg2[%86] : memref<?xf32>
                  }
                  %63 = memref.load %53[] : memref<i1>
                  memref.store %63, %52[] : memref<i1>
                  %64 = memref.load %52[] : memref<i1>
                  %65 = scf.if %64 -> (i32) {
                    %66 = memref.load %0[] : memref<i32>
                    %67 = arith.addi %54, %c1_i32 : i32
                    memref.store %67, %0[] : memref<i32>
                    scf.yield %67 : i32
                  } else {
                    scf.yield %54 : i32
                  }
                  cf.br ^bb1(%65 : i32)
                ^bb3:  // pred: ^bb1
                  scf.yield %54 : i32
                }
                scf.yield %49 : i32
              } else {
                scf.yield %33 : i32
              }
              scf.yield %48 : i32
            } else {
              scf.yield %33 : i32
            }
            %44 = memref.load %32[] : memref<i1>
            memref.store %44, %31[] : memref<i1>
            %45 = memref.load %31[] : memref<i1>
            %46 = scf.if %45 -> (i32) {
              %47 = memref.load %2[] : memref<i32>
              %48 = arith.addi %34, %c1_i32 : i32
              memref.store %48, %2[] : memref<i32>
              scf.yield %48 : i32
            } else {
              scf.yield %34 : i32
            }
            cf.br ^bb1(%43, %46 : i32, i32)
          ^bb3:  // pred: ^bb1
            scf.yield %33, %34 : i32, i32
          }
          scf.yield %28#0, %28#1 : i32, i32
        } else {
          scf.yield %13, %14 : i32, i32
        }
        scf.yield %27#0, %27#1 : i32, i32
      } else {
        scf.yield %13, %14 : i32, i32
      }
      %23 = memref.load %12[] : memref<i1>
      memref.store %23, %11[] : memref<i1>
      %24 = memref.load %11[] : memref<i1>
      %25 = scf.if %24 -> (i32) {
        %26 = memref.load %3[] : memref<i32>
        %27 = arith.subi %15, %c1_i32 : i32
        memref.store %27, %3[] : memref<i32>
        scf.yield %27 : i32
      } else {
        scf.yield %15 : i32
      }
      cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
  scf.yield


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.execute_region {
    %9 = memref.load %6[] : memref<i1>
    %10 = scf.if %9 -> (i32) {
      %26 = memref.get_global @kbm3 : memref<1xi32>
      %27 = memref.load %26[%c0] : memref<1xi32>
      memref.store %27, %3[] : memref<i32>
      scf.yield %27 : i32
    } else {
      scf.yield %1 : i32
    }
    %11 = memref.alloca() : memref<i1>
    %12 = memref.alloca() : memref<i1>
    memref.store %true, %12[] : memref<i1>
    cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
  ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
    %16 = memref.load %3[] : memref<i32>
    %17 = arith.cmpi sgt, %15, %c0_i32 : i32
    %18 = memref.load %12[] : memref<i1>
    %19 = arith.andi %17, %18 : i1
    cf.cond_br %19, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %20 = memref.load %12[] : memref<i1>
    memref.store %20, %11[] : memref<i1>
    %21 = memref.load %11[] : memref<i1>
    %22:2 = scf.if %21 -> (i32, i32) {
      %26 = memref.load %11[] : memref<i1>
      %27:2 = scf.if %26 -> (i32, i32) {
        %28:2 = scf.execute_region -> (i32, i32) {
          %29 = memref.load %11[] : memref<i1>
          %30 = scf.if %29 -> (i32) {
            memref.store %c0_i32, %2[] : memref<i32>
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %14 : i32
          }
          %31 = memref.alloca() : memref<i1>
          %32 = memref.alloca() : memref<i1>
          memref.store %true, %32[] : memref<i1>
          cf.br ^bb1(%13, %30 : i32, i32)
        ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
          %35 = memref.load %2[] : memref<i32>
          %36 = memref.get_global @jm : memref<1xi32>
          %37 = memref.load %36[%c0] : memref<1xi32>
          %38 = arith.cmpi slt, %34, %37 : i32
          %39 = memref.load %32[] : memref<i1>
          %40 = arith.andi %38, %39 : i1
          cf.cond_br %40, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %41 = memref.load %32[] : memref<i1>
          memref.store %41, %31[] : memref<i1>
          %42 = memref.load %31[] : memref<i1>
          %43 = scf.if %42 -> (i32) {
            %47 = memref.load %31[] : memref<i1>
            %48 = scf.if %47 -> (i32) {
              %49 = scf.execute_region -> i32 {
                %50 = memref.load %31[] : memref<i1>
                %51 = scf.if %50 -> (i32) {
                  memref.store %c0_i32, %0[] : memref<i32>
                  scf.yield %c0_i32 : i32
                } else {
                  scf.yield %33 : i32
                }
                %52 = memref.alloca() : memref<i1>
                %53 = memref.alloca() : memref<i1>
                memref.store %true, %53[] : memref<i1>
                cf.br ^bb1(%51 : i32)
              ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                %55 = memref.load %0[] : memref<i32>
                %56 = memref.get_global @im : memref<1xi32>
                %57 = memref.load %56[%c0] : memref<1xi32>
                %58 = arith.cmpi slt, %54, %57 : i32
                %59 = memref.load %53[] : memref<i1>
                %60 = arith.andi %58, %59 : i1
                cf.cond_br %60, ^bb2, ^bb3
              ^bb2:  // pred: ^bb1
                %61 = memref.load %53[] : memref<i1>
                memref.store %61, %52[] : memref<i1>
                %62 = memref.load %52[] : memref<i1>
                scf.if %62 {
                  %66 = memref.load %4[] : memref<memref<?xf32>>
                  %67 = memref.load %0[] : memref<i32>
                  %68 = memref.load %2[] : memref<i32>
                  %69 = memref.load %56[%c0] : memref<1xi32>
                  %70 = arith.muli %34, %69 : i32
                  %71 = arith.addi %54, %70 : i32
                  %72 = memref.load %3[] : memref<i32>
                  %73 = arith.muli %15, %69 : i32
                  %74 = memref.load %36[%c0] : memref<1xi32>
                  %75 = arith.muli %73, %74 : i32
                  %76 = arith.addi %71, %75 : i32
                  %77 = arith.index_cast %76 : i32 to index
                  %78 = memref.load %5[] : memref<memref<?xf32>>
                  %79 = arith.subi %15, %c1_i32 : i32
                  %80 = arith.muli %79, %69 : i32
                  %81 = arith.muli %80, %74 : i32
                  %82 = arith.addi %71, %81 : i32
                  %83 = arith.index_cast %82 : i32 to index
                  %84 = arith.addi %83, %c0 : index
                  %85 = memref.load %78[%84] : memref<?xf32>
                  %86 = arith.addi %77, %c0 : index
                  memref.store %85, %arg2[%86] : memref<?xf32>
                }
                %63 = memref.load %53[] : memref<i1>
                memref.store %63, %52[] : memref<i1>
                %64 = memref.load %52[] : memref<i1>
                %65 = scf.if %64 -> (i32) {
                  %66 = memref.load %0[] : memref<i32>
                  %67 = arith.addi %54, %c1_i32 : i32
                  memref.store %67, %0[] : memref<i32>
                  scf.yield %67 : i32
                } else {
                  scf.yield %54 : i32
                }
                cf.br ^bb1(%65 : i32)
              ^bb3:  // pred: ^bb1
                scf.yield %54 : i32
              }
              scf.yield %49 : i32
            } else {
              scf.yield %33 : i32
            }
            scf.yield %48 : i32
          } else {
            scf.yield %33 : i32
          }
          %44 = memref.load %32[] : memref<i1>
          memref.store %44, %31[] : memref<i1>
          %45 = memref.load %31[] : memref<i1>
          %46 = scf.if %45 -> (i32) {
            %47 = memref.load %2[] : memref<i32>
            %48 = arith.addi %34, %c1_i32 : i32
            memref.store %48, %2[] : memref<i32>
            scf.yield %48 : i32
          } else {
            scf.yield %34 : i32
          }
          cf.br ^bb1(%43, %46 : i32, i32)
        ^bb3:  // pred: ^bb1
          scf.yield %33, %34 : i32, i32
        }
        scf.yield %28#0, %28#1 : i32, i32
      } else {
        scf.yield %13, %14 : i32, i32
      }
      scf.yield %27#0, %27#1 : i32, i32
    } else {
      scf.yield %13, %14 : i32, i32
    }
    %23 = memref.load %12[] : memref<i1>
    memref.store %23, %11[] : memref<i1>
    %24 = memref.load %11[] : memref<i1>
    %25 = scf.if %24 -> (i32) {
      %26 = memref.load %3[] : memref<i32>
      %27 = arith.subi %15, %c1_i32 : i32
      memref.store %27, %3[] : memref<i32>
      scf.yield %27 : i32
    } else {
      scf.yield %15 : i32
    }
    cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
  ^bb3:  // pred: ^bb1
    scf.yield
  }
  scf.yield


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %9 = memref.load %6[] : memref<i1>
  %10 = scf.if %9 -> (i32) {
    %26 = memref.get_global @kbm3 : memref<1xi32>
    %27 = memref.load %26[%c0] : memref<1xi32>
    memref.store %27, %3[] : memref<i32>
    scf.yield %27 : i32
  } else {
    scf.yield %1 : i32
  }
  %11 = memref.alloca() : memref<i1>
  %12 = memref.alloca() : memref<i1>
  memref.store %true, %12[] : memref<i1>
  cf.br ^bb1(%1, %1, %10 : i32, i32, i32)


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.get_global @kbm3 : memref<1xi32>
  %27 = memref.load %26[%c0] : memref<1xi32>
  memref.store %27, %3[] : memref<i32>
  scf.yield %27 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.get_global @kbm3 : memref<1xi32>
  %27 = memref.load %26[%c0] : memref<1xi32>
  memref.store %27, %3[] : memref<i32>
  scf.yield %27 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %1 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %1 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %9 = memref.load %6[] : memref<i1>
  %10 = scf.if %9 -> (i32) {
    %26 = memref.get_global @kbm3 : memref<1xi32>
    %27 = memref.load %26[%c0] : memref<1xi32>
    memref.store %27, %3[] : memref<i32>
    scf.yield %27 : i32
  } else {
    scf.yield %1 : i32
  }
  %11 = memref.alloca() : memref<i1>
  %12 = memref.alloca() : memref<i1>
  memref.store %true, %12[] : memref<i1>
  cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
  %16 = memref.load %3[] : memref<i32>
  %17 = arith.cmpi sgt, %15, %c0_i32 : i32
  %18 = memref.load %12[] : memref<i1>
  %19 = arith.andi %17, %18 : i1
  cf.cond_br %19, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
  %16 = memref.load %3[] : memref<i32>
  %17 = arith.cmpi sgt, %15, %c0_i32 : i32
  %18 = memref.load %12[] : memref<i1>
  %19 = arith.andi %17, %18 : i1
  cf.cond_br %19, ^bb2, ^bb3
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %20 = memref.load %12[] : memref<i1>
  memref.store %20, %11[] : memref<i1>
  %21 = memref.load %11[] : memref<i1>
  %22:2 = scf.if %21 -> (i32, i32) {
    %26 = memref.load %11[] : memref<i1>
    %27:2 = scf.if %26 -> (i32, i32) {
      %28:2 = scf.execute_region -> (i32, i32) {
        %29 = memref.load %11[] : memref<i1>
        %30 = scf.if %29 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %14 : i32
        }
        %31 = memref.alloca() : memref<i1>
        %32 = memref.alloca() : memref<i1>
        memref.store %true, %32[] : memref<i1>
        cf.br ^bb1(%13, %30 : i32, i32)
      ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
        %35 = memref.load %2[] : memref<i32>
        %36 = memref.get_global @jm : memref<1xi32>
        %37 = memref.load %36[%c0] : memref<1xi32>
        %38 = arith.cmpi slt, %34, %37 : i32
        %39 = memref.load %32[] : memref<i1>
        %40 = arith.andi %38, %39 : i1
        cf.cond_br %40, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %41 = memref.load %32[] : memref<i1>
        memref.store %41, %31[] : memref<i1>
        %42 = memref.load %31[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %47 = memref.load %31[] : memref<i1>
          %48 = scf.if %47 -> (i32) {
            %49 = scf.execute_region -> i32 {
              %50 = memref.load %31[] : memref<i1>
              %51 = scf.if %50 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %33 : i32
              }
              %52 = memref.alloca() : memref<i1>
              %53 = memref.alloca() : memref<i1>
              memref.store %true, %53[] : memref<i1>
              cf.br ^bb1(%51 : i32)
            ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
              %55 = memref.load %0[] : memref<i32>
              %56 = memref.get_global @im : memref<1xi32>
              %57 = memref.load %56[%c0] : memref<1xi32>
              %58 = arith.cmpi slt, %54, %57 : i32
              %59 = memref.load %53[] : memref<i1>
              %60 = arith.andi %58, %59 : i1
              cf.cond_br %60, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %61 = memref.load %53[] : memref<i1>
              memref.store %61, %52[] : memref<i1>
              %62 = memref.load %52[] : memref<i1>
              scf.if %62 {
                %66 = memref.load %4[] : memref<memref<?xf32>>
                %67 = memref.load %0[] : memref<i32>
                %68 = memref.load %2[] : memref<i32>
                %69 = memref.load %56[%c0] : memref<1xi32>
                %70 = arith.muli %34, %69 : i32
                %71 = arith.addi %54, %70 : i32
                %72 = memref.load %3[] : memref<i32>
                %73 = arith.muli %15, %69 : i32
                %74 = memref.load %36[%c0] : memref<1xi32>
                %75 = arith.muli %73, %74 : i32
                %76 = arith.addi %71, %75 : i32
                %77 = arith.index_cast %76 : i32 to index
                %78 = memref.load %5[] : memref<memref<?xf32>>
                %79 = arith.subi %15, %c1_i32 : i32
                %80 = arith.muli %79, %69 : i32
                %81 = arith.muli %80, %74 : i32
                %82 = arith.addi %71, %81 : i32
                %83 = arith.index_cast %82 : i32 to index
                %84 = arith.addi %83, %c0 : index
                %85 = memref.load %78[%84] : memref<?xf32>
                %86 = arith.addi %77, %c0 : index
                memref.store %85, %arg2[%86] : memref<?xf32>
              }
              %63 = memref.load %53[] : memref<i1>
              memref.store %63, %52[] : memref<i1>
              %64 = memref.load %52[] : memref<i1>
              %65 = scf.if %64 -> (i32) {
                %66 = memref.load %0[] : memref<i32>
                %67 = arith.addi %54, %c1_i32 : i32
                memref.store %67, %0[] : memref<i32>
                scf.yield %67 : i32
              } else {
                scf.yield %54 : i32
              }
              cf.br ^bb1(%65 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %54 : i32
            }
            scf.yield %49 : i32
          } else {
            scf.yield %33 : i32
          }
          scf.yield %48 : i32
        } else {
          scf.yield %33 : i32
        }
        %44 = memref.load %32[] : memref<i1>
        memref.store %44, %31[] : memref<i1>
        %45 = memref.load %31[] : memref<i1>
        %46 = scf.if %45 -> (i32) {
          %47 = memref.load %2[] : memref<i32>
          %48 = arith.addi %34, %c1_i32 : i32
          memref.store %48, %2[] : memref<i32>
          scf.yield %48 : i32
        } else {
          scf.yield %34 : i32
        }
        cf.br ^bb1(%43, %46 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %33, %34 : i32, i32
      }
      scf.yield %28#0, %28#1 : i32, i32
    } else {
      scf.yield %13, %14 : i32, i32
    }
    scf.yield %27#0, %27#1 : i32, i32
  } else {
    scf.yield %13, %14 : i32, i32
  }
  %23 = memref.load %12[] : memref<i1>
  memref.store %23, %11[] : memref<i1>
  %24 = memref.load %11[] : memref<i1>
  %25 = scf.if %24 -> (i32) {
    %26 = memref.load %3[] : memref<i32>
    %27 = arith.subi %15, %c1_i32 : i32
    memref.store %27, %3[] : memref<i32>
    scf.yield %27 : i32
  } else {
    scf.yield %15 : i32
  }
  cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.load %11[] : memref<i1>
  %27:2 = scf.if %26 -> (i32, i32) {
    %28:2 = scf.execute_region -> (i32, i32) {
      %29 = memref.load %11[] : memref<i1>
      %30 = scf.if %29 -> (i32) {
        memref.store %c0_i32, %2[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %14 : i32
      }
      %31 = memref.alloca() : memref<i1>
      %32 = memref.alloca() : memref<i1>
      memref.store %true, %32[] : memref<i1>
      cf.br ^bb1(%13, %30 : i32, i32)
    ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
      %35 = memref.load %2[] : memref<i32>
      %36 = memref.get_global @jm : memref<1xi32>
      %37 = memref.load %36[%c0] : memref<1xi32>
      %38 = arith.cmpi slt, %34, %37 : i32
      %39 = memref.load %32[] : memref<i1>
      %40 = arith.andi %38, %39 : i1
      cf.cond_br %40, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %41 = memref.load %32[] : memref<i1>
      memref.store %41, %31[] : memref<i1>
      %42 = memref.load %31[] : memref<i1>
      %43 = scf.if %42 -> (i32) {
        %47 = memref.load %31[] : memref<i1>
        %48 = scf.if %47 -> (i32) {
          %49 = scf.execute_region -> i32 {
            %50 = memref.load %31[] : memref<i1>
            %51 = scf.if %50 -> (i32) {
              memref.store %c0_i32, %0[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %33 : i32
            }
            %52 = memref.alloca() : memref<i1>
            %53 = memref.alloca() : memref<i1>
            memref.store %true, %53[] : memref<i1>
            cf.br ^bb1(%51 : i32)
          ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
            %55 = memref.load %0[] : memref<i32>
            %56 = memref.get_global @im : memref<1xi32>
            %57 = memref.load %56[%c0] : memref<1xi32>
            %58 = arith.cmpi slt, %54, %57 : i32
            %59 = memref.load %53[] : memref<i1>
            %60 = arith.andi %58, %59 : i1
            cf.cond_br %60, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %61 = memref.load %53[] : memref<i1>
            memref.store %61, %52[] : memref<i1>
            %62 = memref.load %52[] : memref<i1>
            scf.if %62 {
              %66 = memref.load %4[] : memref<memref<?xf32>>
              %67 = memref.load %0[] : memref<i32>
              %68 = memref.load %2[] : memref<i32>
              %69 = memref.load %56[%c0] : memref<1xi32>
              %70 = arith.muli %34, %69 : i32
              %71 = arith.addi %54, %70 : i32
              %72 = memref.load %3[] : memref<i32>
              %73 = arith.muli %15, %69 : i32
              %74 = memref.load %36[%c0] : memref<1xi32>
              %75 = arith.muli %73, %74 : i32
              %76 = arith.addi %71, %75 : i32
              %77 = arith.index_cast %76 : i32 to index
              %78 = memref.load %5[] : memref<memref<?xf32>>
              %79 = arith.subi %15, %c1_i32 : i32
              %80 = arith.muli %79, %69 : i32
              %81 = arith.muli %80, %74 : i32
              %82 = arith.addi %71, %81 : i32
              %83 = arith.index_cast %82 : i32 to index
              %84 = arith.addi %83, %c0 : index
              %85 = memref.load %78[%84] : memref<?xf32>
              %86 = arith.addi %77, %c0 : index
              memref.store %85, %arg2[%86] : memref<?xf32>
            }
            %63 = memref.load %53[] : memref<i1>
            memref.store %63, %52[] : memref<i1>
            %64 = memref.load %52[] : memref<i1>
            %65 = scf.if %64 -> (i32) {
              %66 = memref.load %0[] : memref<i32>
              %67 = arith.addi %54, %c1_i32 : i32
              memref.store %67, %0[] : memref<i32>
              scf.yield %67 : i32
            } else {
              scf.yield %54 : i32
            }
            cf.br ^bb1(%65 : i32)
          ^bb3:  // pred: ^bb1
            scf.yield %54 : i32
          }
          scf.yield %49 : i32
        } else {
          scf.yield %33 : i32
        }
        scf.yield %48 : i32
      } else {
        scf.yield %33 : i32
      }
      %44 = memref.load %32[] : memref<i1>
      memref.store %44, %31[] : memref<i1>
      %45 = memref.load %31[] : memref<i1>
      %46 = scf.if %45 -> (i32) {
        %47 = memref.load %2[] : memref<i32>
        %48 = arith.addi %34, %c1_i32 : i32
        memref.store %48, %2[] : memref<i32>
        scf.yield %48 : i32
      } else {
        scf.yield %34 : i32
      }
      cf.br ^bb1(%43, %46 : i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield %33, %34 : i32, i32
    }
    scf.yield %28#0, %28#1 : i32, i32
  } else {
    scf.yield %13, %14 : i32, i32
  }
  scf.yield %27#0, %27#1 : i32, i32


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %28:2 = scf.execute_region -> (i32, i32) {
    %29 = memref.load %11[] : memref<i1>
    %30 = scf.if %29 -> (i32) {
      memref.store %c0_i32, %2[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %14 : i32
    }
    %31 = memref.alloca() : memref<i1>
    %32 = memref.alloca() : memref<i1>
    memref.store %true, %32[] : memref<i1>
    cf.br ^bb1(%13, %30 : i32, i32)
  ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
    %35 = memref.load %2[] : memref<i32>
    %36 = memref.get_global @jm : memref<1xi32>
    %37 = memref.load %36[%c0] : memref<1xi32>
    %38 = arith.cmpi slt, %34, %37 : i32
    %39 = memref.load %32[] : memref<i1>
    %40 = arith.andi %38, %39 : i1
    cf.cond_br %40, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %41 = memref.load %32[] : memref<i1>
    memref.store %41, %31[] : memref<i1>
    %42 = memref.load %31[] : memref<i1>
    %43 = scf.if %42 -> (i32) {
      %47 = memref.load %31[] : memref<i1>
      %48 = scf.if %47 -> (i32) {
        %49 = scf.execute_region -> i32 {
          %50 = memref.load %31[] : memref<i1>
          %51 = scf.if %50 -> (i32) {
            memref.store %c0_i32, %0[] : memref<i32>
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %33 : i32
          }
          %52 = memref.alloca() : memref<i1>
          %53 = memref.alloca() : memref<i1>
          memref.store %true, %53[] : memref<i1>
          cf.br ^bb1(%51 : i32)
        ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
          %55 = memref.load %0[] : memref<i32>
          %56 = memref.get_global @im : memref<1xi32>
          %57 = memref.load %56[%c0] : memref<1xi32>
          %58 = arith.cmpi slt, %54, %57 : i32
          %59 = memref.load %53[] : memref<i1>
          %60 = arith.andi %58, %59 : i1
          cf.cond_br %60, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %61 = memref.load %53[] : memref<i1>
          memref.store %61, %52[] : memref<i1>
          %62 = memref.load %52[] : memref<i1>
          scf.if %62 {
            %66 = memref.load %4[] : memref<memref<?xf32>>
            %67 = memref.load %0[] : memref<i32>
            %68 = memref.load %2[] : memref<i32>
            %69 = memref.load %56[%c0] : memref<1xi32>
            %70 = arith.muli %34, %69 : i32
            %71 = arith.addi %54, %70 : i32
            %72 = memref.load %3[] : memref<i32>
            %73 = arith.muli %15, %69 : i32
            %74 = memref.load %36[%c0] : memref<1xi32>
            %75 = arith.muli %73, %74 : i32
            %76 = arith.addi %71, %75 : i32
            %77 = arith.index_cast %76 : i32 to index
            %78 = memref.load %5[] : memref<memref<?xf32>>
            %79 = arith.subi %15, %c1_i32 : i32
            %80 = arith.muli %79, %69 : i32
            %81 = arith.muli %80, %74 : i32
            %82 = arith.addi %71, %81 : i32
            %83 = arith.index_cast %82 : i32 to index
            %84 = arith.addi %83, %c0 : index
            %85 = memref.load %78[%84] : memref<?xf32>
            %86 = arith.addi %77, %c0 : index
            memref.store %85, %arg2[%86] : memref<?xf32>
          }
          %63 = memref.load %53[] : memref<i1>
          memref.store %63, %52[] : memref<i1>
          %64 = memref.load %52[] : memref<i1>
          %65 = scf.if %64 -> (i32) {
            %66 = memref.load %0[] : memref<i32>
            %67 = arith.addi %54, %c1_i32 : i32
            memref.store %67, %0[] : memref<i32>
            scf.yield %67 : i32
          } else {
            scf.yield %54 : i32
          }
          cf.br ^bb1(%65 : i32)
        ^bb3:  // pred: ^bb1
          scf.yield %54 : i32
        }
        scf.yield %49 : i32
      } else {
        scf.yield %33 : i32
      }
      scf.yield %48 : i32
    } else {
      scf.yield %33 : i32
    }
    %44 = memref.load %32[] : memref<i1>
    memref.store %44, %31[] : memref<i1>
    %45 = memref.load %31[] : memref<i1>
    %46 = scf.if %45 -> (i32) {
      %47 = memref.load %2[] : memref<i32>
      %48 = arith.addi %34, %c1_i32 : i32
      memref.store %48, %2[] : memref<i32>
      scf.yield %48 : i32
    } else {
      scf.yield %34 : i32
    }
    cf.br ^bb1(%43, %46 : i32, i32)
  ^bb3:  // pred: ^bb1
    scf.yield %33, %34 : i32, i32
  }
  scf.yield %28#0, %28#1 : i32, i32


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %29 = memref.load %11[] : memref<i1>
  %30 = scf.if %29 -> (i32) {
    memref.store %c0_i32, %2[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %14 : i32
  }
  %31 = memref.alloca() : memref<i1>
  %32 = memref.alloca() : memref<i1>
  memref.store %true, %32[] : memref<i1>
  cf.br ^bb1(%13, %30 : i32, i32)


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %2[] : memref<i32>
  scf.yield %c0_i32 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %2[] : memref<i32>
  scf.yield %c0_i32 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %14 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %14 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %29 = memref.load %11[] : memref<i1>
  %30 = scf.if %29 -> (i32) {
    memref.store %c0_i32, %2[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %14 : i32
  }
  %31 = memref.alloca() : memref<i1>
  %32 = memref.alloca() : memref<i1>
  memref.store %true, %32[] : memref<i1>
  cf.br ^bb1(%13, %30 : i32, i32)
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
  %35 = memref.load %2[] : memref<i32>
  %36 = memref.get_global @jm : memref<1xi32>
  %37 = memref.load %36[%c0] : memref<1xi32>
  %38 = arith.cmpi slt, %34, %37 : i32
  %39 = memref.load %32[] : memref<i1>
  %40 = arith.andi %38, %39 : i1
  cf.cond_br %40, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
  %35 = memref.load %2[] : memref<i32>
  %36 = memref.get_global @jm : memref<1xi32>
  %37 = memref.load %36[%c0] : memref<1xi32>
  %38 = arith.cmpi slt, %34, %37 : i32
  %39 = memref.load %32[] : memref<i1>
  %40 = arith.andi %38, %39 : i1
  cf.cond_br %40, ^bb2, ^bb3
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %41, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %42 -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %47 -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %50 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %59 : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %61, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %62 {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %78[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %63, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %64 -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %44, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %45 -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %31[] : memref<i1>
  %48 = scf.if %47 -> (i32) {
    %49 = scf.execute_region -> i32 {
      %50 = memref.load %31[] : memref<i1>
      %51 = scf.if %50 -> (i32) {
        memref.store %c0_i32, %0[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %33 : i32
      }
      %52 = memref.alloca() : memref<i1>
      %53 = memref.alloca() : memref<i1>
      memref.store %true, %53[] : memref<i1>
      cf.br ^bb1(%51 : i32)
    ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
      %55 = memref.load %0[] : memref<i32>
      %56 = memref.get_global @im : memref<1xi32>
      %57 = memref.load %56[%c0] : memref<1xi32>
      %58 = arith.cmpi slt, %54, %57 : i32
      %59 = memref.load %53[] : memref<i1>
      %60 = arith.andi %58, %59 : i1
      cf.cond_br %60, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %61 = memref.load %53[] : memref<i1>
      memref.store %61, %52[] : memref<i1>
      %62 = memref.load %52[] : memref<i1>
      scf.if %62 {
        %66 = memref.load %4[] : memref<memref<?xf32>>
        %67 = memref.load %0[] : memref<i32>
        %68 = memref.load %2[] : memref<i32>
        %69 = memref.load %56[%c0] : memref<1xi32>
        %70 = arith.muli %34, %69 : i32
        %71 = arith.addi %54, %70 : i32
        %72 = memref.load %3[] : memref<i32>
        %73 = arith.muli %15, %69 : i32
        %74 = memref.load %36[%c0] : memref<1xi32>
        %75 = arith.muli %73, %74 : i32
        %76 = arith.addi %71, %75 : i32
        %77 = arith.index_cast %76 : i32 to index
        %78 = memref.load %5[] : memref<memref<?xf32>>
        %79 = arith.subi %15, %c1_i32 : i32
        %80 = arith.muli %79, %69 : i32
        %81 = arith.muli %80, %74 : i32
        %82 = arith.addi %71, %81 : i32
        %83 = arith.index_cast %82 : i32 to index
        %84 = arith.addi %83, %c0 : index
        %85 = memref.load %78[%84] : memref<?xf32>
        %86 = arith.addi %77, %c0 : index
        memref.store %85, %arg2[%86] : memref<?xf32>
      }
      %63 = memref.load %53[] : memref<i1>
      memref.store %63, %52[] : memref<i1>
      %64 = memref.load %52[] : memref<i1>
      %65 = scf.if %64 -> (i32) {
        %66 = memref.load %0[] : memref<i32>
        %67 = arith.addi %54, %c1_i32 : i32
        memref.store %67, %0[] : memref<i32>
        scf.yield %67 : i32
      } else {
        scf.yield %54 : i32
      }
      cf.br ^bb1(%65 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %54 : i32
    }
    scf.yield %49 : i32
  } else {
    scf.yield %33 : i32
  }
  scf.yield %48 : i32


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %49 = scf.execute_region -> i32 {
    %50 = memref.load %31[] : memref<i1>
    %51 = scf.if %50 -> (i32) {
      memref.store %c0_i32, %0[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %33 : i32
    }
    %52 = memref.alloca() : memref<i1>
    %53 = memref.alloca() : memref<i1>
    memref.store %true, %53[] : memref<i1>
    cf.br ^bb1(%51 : i32)
  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
    %55 = memref.load %0[] : memref<i32>
    %56 = memref.get_global @im : memref<1xi32>
    %57 = memref.load %56[%c0] : memref<1xi32>
    %58 = arith.cmpi slt, %54, %57 : i32
    %59 = memref.load %53[] : memref<i1>
    %60 = arith.andi %58, %59 : i1
    cf.cond_br %60, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %61 = memref.load %53[] : memref<i1>
    memref.store %61, %52[] : memref<i1>
    %62 = memref.load %52[] : memref<i1>
    scf.if %62 {
      %66 = memref.load %4[] : memref<memref<?xf32>>
      %67 = memref.load %0[] : memref<i32>
      %68 = memref.load %2[] : memref<i32>
      %69 = memref.load %56[%c0] : memref<1xi32>
      %70 = arith.muli %34, %69 : i32
      %71 = arith.addi %54, %70 : i32
      %72 = memref.load %3[] : memref<i32>
      %73 = arith.muli %15, %69 : i32
      %74 = memref.load %36[%c0] : memref<1xi32>
      %75 = arith.muli %73, %74 : i32
      %76 = arith.addi %71, %75 : i32
      %77 = arith.index_cast %76 : i32 to index
      %78 = memref.load %5[] : memref<memref<?xf32>>
      %79 = arith.subi %15, %c1_i32 : i32
      %80 = arith.muli %79, %69 : i32
      %81 = arith.muli %80, %74 : i32
      %82 = arith.addi %71, %81 : i32
      %83 = arith.index_cast %82 : i32 to index
      %84 = arith.addi %83, %c0 : index
      %85 = memref.load %78[%84] : memref<?xf32>
      %86 = arith.addi %77, %c0 : index
      memref.store %85, %arg2[%86] : memref<?xf32>
    }
    %63 = memref.load %53[] : memref<i1>
    memref.store %63, %52[] : memref<i1>
    %64 = memref.load %52[] : memref<i1>
    %65 = scf.if %64 -> (i32) {
      %66 = memref.load %0[] : memref<i32>
      %67 = arith.addi %54, %c1_i32 : i32
      memref.store %67, %0[] : memref<i32>
      scf.yield %67 : i32
    } else {
      scf.yield %54 : i32
    }
    cf.br ^bb1(%65 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %54 : i32
  }
  scf.yield %49 : i32


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %50 = memref.load %31[] : memref<i1>
  %51 = scf.if %50 -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %33 : i32
  }
  %52 = memref.alloca() : memref<i1>
  %53 = memref.alloca() : memref<i1>
  memref.store %true, %53[] : memref<i1>
  cf.br ^bb1(%51 : i32)


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield %c0_i32 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield %c0_i32 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %50 = memref.load %31[] : memref<i1>
  %51 = scf.if %50 -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %33 : i32
  }
  %52 = memref.alloca() : memref<i1>
  %53 = memref.alloca() : memref<i1>
  memref.store %true, %53[] : memref<i1>
  cf.br ^bb1(%51 : i32)
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %59 : i1
  cf.cond_br %60, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %59 : i1
  cf.cond_br %60, ^bb2, ^bb3
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %61, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %62 {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %78[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %63, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %64 -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)


starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %78[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
  scf.yield

 replaced mlir-asm-printer: Verifying operation: builtin.module
%78 = memref.load %5[] : memref<memref<?xf32>> with <block argument> of type 'memref<?xf32>' at index: 0
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
  scf.yield
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %0[] : memref<i32>
  %67 = arith.addi %54, %c1_i32 : i32
  memref.store %67, %0[] : memref<i32>
  scf.yield %67 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %0[] : memref<i32>
  %67 = arith.addi %54, %c1_i32 : i32
  memref.store %67, %0[] : memref<i32>
  scf.yield %67 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %54 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %54 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %61, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %62 {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %63, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %64 -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %49 = scf.execute_region -> i32 {
    %50 = memref.load %31[] : memref<i1>
    %51 = scf.if %50 -> (i32) {
      memref.store %c0_i32, %0[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %33 : i32
    }
    %52 = memref.alloca() : memref<i1>
    %53 = memref.alloca() : memref<i1>
    memref.store %true, %53[] : memref<i1>
    cf.br ^bb1(%51 : i32)
  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
    %55 = memref.load %0[] : memref<i32>
    %56 = memref.get_global @im : memref<1xi32>
    %57 = memref.load %56[%c0] : memref<1xi32>
    %58 = arith.cmpi slt, %54, %57 : i32
    %59 = memref.load %53[] : memref<i1>
    %60 = arith.andi %58, %59 : i1
    cf.cond_br %60, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %61 = memref.load %53[] : memref<i1>
    memref.store %61, %52[] : memref<i1>
    %62 = memref.load %52[] : memref<i1>
    scf.if %62 {
      %66 = memref.load %4[] : memref<memref<?xf32>>
      %67 = memref.load %0[] : memref<i32>
      %68 = memref.load %2[] : memref<i32>
      %69 = memref.load %56[%c0] : memref<1xi32>
      %70 = arith.muli %34, %69 : i32
      %71 = arith.addi %54, %70 : i32
      %72 = memref.load %3[] : memref<i32>
      %73 = arith.muli %15, %69 : i32
      %74 = memref.load %36[%c0] : memref<1xi32>
      %75 = arith.muli %73, %74 : i32
      %76 = arith.addi %71, %75 : i32
      %77 = arith.index_cast %76 : i32 to index
      %78 = memref.load %5[] : memref<memref<?xf32>>
      %79 = arith.subi %15, %c1_i32 : i32
      %80 = arith.muli %79, %69 : i32
      %81 = arith.muli %80, %74 : i32
      %82 = arith.addi %71, %81 : i32
      %83 = arith.index_cast %82 : i32 to index
      %84 = arith.addi %83, %c0 : index
      %85 = memref.load %arg0[%84] : memref<?xf32>
      %86 = arith.addi %77, %c0 : index
      memref.store %85, %arg2[%86] : memref<?xf32>
    }
    %63 = memref.load %53[] : memref<i1>
    memref.store %63, %52[] : memref<i1>
    %64 = memref.load %52[] : memref<i1>
    %65 = scf.if %64 -> (i32) {
      %66 = memref.load %0[] : memref<i32>
      %67 = arith.addi %54, %c1_i32 : i32
      memref.store %67, %0[] : memref<i32>
      scf.yield %67 : i32
    } else {
      scf.yield %54 : i32
    }
    cf.br ^bb1(%65 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %54 : i32
  }
  scf.yield %49 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %31[] : memref<i1>
  %48 = scf.if %47 -> (i32) {
    %49 = scf.execute_region -> i32 {
      %50 = memref.load %31[] : memref<i1>
      %51 = scf.if %50 -> (i32) {
        memref.store %c0_i32, %0[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %33 : i32
      }
      %52 = memref.alloca() : memref<i1>
      %53 = memref.alloca() : memref<i1>
      memref.store %true, %53[] : memref<i1>
      cf.br ^bb1(%51 : i32)
    ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
      %55 = memref.load %0[] : memref<i32>
      %56 = memref.get_global @im : memref<1xi32>
      %57 = memref.load %56[%c0] : memref<1xi32>
      %58 = arith.cmpi slt, %54, %57 : i32
      %59 = memref.load %53[] : memref<i1>
      %60 = arith.andi %58, %59 : i1
      cf.cond_br %60, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %61 = memref.load %53[] : memref<i1>
      memref.store %61, %52[] : memref<i1>
      %62 = memref.load %52[] : memref<i1>
      scf.if %62 {
        %66 = memref.load %4[] : memref<memref<?xf32>>
        %67 = memref.load %0[] : memref<i32>
        %68 = memref.load %2[] : memref<i32>
        %69 = memref.load %56[%c0] : memref<1xi32>
        %70 = arith.muli %34, %69 : i32
        %71 = arith.addi %54, %70 : i32
        %72 = memref.load %3[] : memref<i32>
        %73 = arith.muli %15, %69 : i32
        %74 = memref.load %36[%c0] : memref<1xi32>
        %75 = arith.muli %73, %74 : i32
        %76 = arith.addi %71, %75 : i32
        %77 = arith.index_cast %76 : i32 to index
        %78 = memref.load %5[] : memref<memref<?xf32>>
        %79 = arith.subi %15, %c1_i32 : i32
        %80 = arith.muli %79, %69 : i32
        %81 = arith.muli %80, %74 : i32
        %82 = arith.addi %71, %81 : i32
        %83 = arith.index_cast %82 : i32 to index
        %84 = arith.addi %83, %c0 : index
        %85 = memref.load %arg0[%84] : memref<?xf32>
        %86 = arith.addi %77, %c0 : index
        memref.store %85, %arg2[%86] : memref<?xf32>
      }
      %63 = memref.load %53[] : memref<i1>
      memref.store %63, %52[] : memref<i1>
      %64 = memref.load %52[] : memref<i1>
      %65 = scf.if %64 -> (i32) {
        %66 = memref.load %0[] : memref<i32>
        %67 = arith.addi %54, %c1_i32 : i32
        memref.store %67, %0[] : memref<i32>
        scf.yield %67 : i32
      } else {
        scf.yield %54 : i32
      }
      cf.br ^bb1(%65 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %54 : i32
    }
    scf.yield %49 : i32
  } else {
    scf.yield %33 : i32
  }
  scf.yield %48 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %2[] : memref<i32>
  %48 = arith.addi %34, %c1_i32 : i32
  memref.store %48, %2[] : memref<i32>
  scf.yield %48 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %2[] : memref<i32>
  %48 = arith.addi %34, %c1_i32 : i32
  memref.store %48, %2[] : memref<i32>
  scf.yield %48 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %34 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %34 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %41, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %42 -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %47 -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %50 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %59 : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %61, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %62 {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %63, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %64 -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %44, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %45 -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %33, %34 : i32, i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %33, %34 : i32, i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %28:2 = scf.execute_region -> (i32, i32) {
    %29 = memref.load %11[] : memref<i1>
    %30 = scf.if %29 -> (i32) {
      memref.store %c0_i32, %2[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %14 : i32
    }
    %31 = memref.alloca() : memref<i1>
    %32 = memref.alloca() : memref<i1>
    memref.store %true, %32[] : memref<i1>
    cf.br ^bb1(%13, %30 : i32, i32)
  ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
    %35 = memref.load %2[] : memref<i32>
    %36 = memref.get_global @jm : memref<1xi32>
    %37 = memref.load %36[%c0] : memref<1xi32>
    %38 = arith.cmpi slt, %34, %37 : i32
    %39 = memref.load %32[] : memref<i1>
    %40 = arith.andi %38, %39 : i1
    cf.cond_br %40, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %41 = memref.load %32[] : memref<i1>
    memref.store %41, %31[] : memref<i1>
    %42 = memref.load %31[] : memref<i1>
    %43 = scf.if %42 -> (i32) {
      %47 = memref.load %31[] : memref<i1>
      %48 = scf.if %47 -> (i32) {
        %49 = scf.execute_region -> i32 {
          %50 = memref.load %31[] : memref<i1>
          %51 = scf.if %50 -> (i32) {
            memref.store %c0_i32, %0[] : memref<i32>
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %33 : i32
          }
          %52 = memref.alloca() : memref<i1>
          %53 = memref.alloca() : memref<i1>
          memref.store %true, %53[] : memref<i1>
          cf.br ^bb1(%51 : i32)
        ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
          %55 = memref.load %0[] : memref<i32>
          %56 = memref.get_global @im : memref<1xi32>
          %57 = memref.load %56[%c0] : memref<1xi32>
          %58 = arith.cmpi slt, %54, %57 : i32
          %59 = memref.load %53[] : memref<i1>
          %60 = arith.andi %58, %59 : i1
          cf.cond_br %60, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %61 = memref.load %53[] : memref<i1>
          memref.store %61, %52[] : memref<i1>
          %62 = memref.load %52[] : memref<i1>
          scf.if %62 {
            %66 = memref.load %4[] : memref<memref<?xf32>>
            %67 = memref.load %0[] : memref<i32>
            %68 = memref.load %2[] : memref<i32>
            %69 = memref.load %56[%c0] : memref<1xi32>
            %70 = arith.muli %34, %69 : i32
            %71 = arith.addi %54, %70 : i32
            %72 = memref.load %3[] : memref<i32>
            %73 = arith.muli %15, %69 : i32
            %74 = memref.load %36[%c0] : memref<1xi32>
            %75 = arith.muli %73, %74 : i32
            %76 = arith.addi %71, %75 : i32
            %77 = arith.index_cast %76 : i32 to index
            %78 = memref.load %5[] : memref<memref<?xf32>>
            %79 = arith.subi %15, %c1_i32 : i32
            %80 = arith.muli %79, %69 : i32
            %81 = arith.muli %80, %74 : i32
            %82 = arith.addi %71, %81 : i32
            %83 = arith.index_cast %82 : i32 to index
            %84 = arith.addi %83, %c0 : index
            %85 = memref.load %arg0[%84] : memref<?xf32>
            %86 = arith.addi %77, %c0 : index
            memref.store %85, %arg2[%86] : memref<?xf32>
          }
          %63 = memref.load %53[] : memref<i1>
          memref.store %63, %52[] : memref<i1>
          %64 = memref.load %52[] : memref<i1>
          %65 = scf.if %64 -> (i32) {
            %66 = memref.load %0[] : memref<i32>
            %67 = arith.addi %54, %c1_i32 : i32
            memref.store %67, %0[] : memref<i32>
            scf.yield %67 : i32
          } else {
            scf.yield %54 : i32
          }
          cf.br ^bb1(%65 : i32)
        ^bb3:  // pred: ^bb1
          scf.yield %54 : i32
        }
        scf.yield %49 : i32
      } else {
        scf.yield %33 : i32
      }
      scf.yield %48 : i32
    } else {
      scf.yield %33 : i32
    }
    %44 = memref.load %32[] : memref<i1>
    memref.store %44, %31[] : memref<i1>
    %45 = memref.load %31[] : memref<i1>
    %46 = scf.if %45 -> (i32) {
      %47 = memref.load %2[] : memref<i32>
      %48 = arith.addi %34, %c1_i32 : i32
      memref.store %48, %2[] : memref<i32>
      scf.yield %48 : i32
    } else {
      scf.yield %34 : i32
    }
    cf.br ^bb1(%43, %46 : i32, i32)
  ^bb3:  // pred: ^bb1
    scf.yield %33, %34 : i32, i32
  }
  scf.yield %28#0, %28#1 : i32, i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %13, %14 : i32, i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %13, %14 : i32, i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.load %11[] : memref<i1>
  %27:2 = scf.if %26 -> (i32, i32) {
    %28:2 = scf.execute_region -> (i32, i32) {
      %29 = memref.load %11[] : memref<i1>
      %30 = scf.if %29 -> (i32) {
        memref.store %c0_i32, %2[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %14 : i32
      }
      %31 = memref.alloca() : memref<i1>
      %32 = memref.alloca() : memref<i1>
      memref.store %true, %32[] : memref<i1>
      cf.br ^bb1(%13, %30 : i32, i32)
    ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
      %35 = memref.load %2[] : memref<i32>
      %36 = memref.get_global @jm : memref<1xi32>
      %37 = memref.load %36[%c0] : memref<1xi32>
      %38 = arith.cmpi slt, %34, %37 : i32
      %39 = memref.load %32[] : memref<i1>
      %40 = arith.andi %38, %39 : i1
      cf.cond_br %40, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %41 = memref.load %32[] : memref<i1>
      memref.store %41, %31[] : memref<i1>
      %42 = memref.load %31[] : memref<i1>
      %43 = scf.if %42 -> (i32) {
        %47 = memref.load %31[] : memref<i1>
        %48 = scf.if %47 -> (i32) {
          %49 = scf.execute_region -> i32 {
            %50 = memref.load %31[] : memref<i1>
            %51 = scf.if %50 -> (i32) {
              memref.store %c0_i32, %0[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %33 : i32
            }
            %52 = memref.alloca() : memref<i1>
            %53 = memref.alloca() : memref<i1>
            memref.store %true, %53[] : memref<i1>
            cf.br ^bb1(%51 : i32)
          ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
            %55 = memref.load %0[] : memref<i32>
            %56 = memref.get_global @im : memref<1xi32>
            %57 = memref.load %56[%c0] : memref<1xi32>
            %58 = arith.cmpi slt, %54, %57 : i32
            %59 = memref.load %53[] : memref<i1>
            %60 = arith.andi %58, %59 : i1
            cf.cond_br %60, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %61 = memref.load %53[] : memref<i1>
            memref.store %61, %52[] : memref<i1>
            %62 = memref.load %52[] : memref<i1>
            scf.if %62 {
              %66 = memref.load %4[] : memref<memref<?xf32>>
              %67 = memref.load %0[] : memref<i32>
              %68 = memref.load %2[] : memref<i32>
              %69 = memref.load %56[%c0] : memref<1xi32>
              %70 = arith.muli %34, %69 : i32
              %71 = arith.addi %54, %70 : i32
              %72 = memref.load %3[] : memref<i32>
              %73 = arith.muli %15, %69 : i32
              %74 = memref.load %36[%c0] : memref<1xi32>
              %75 = arith.muli %73, %74 : i32
              %76 = arith.addi %71, %75 : i32
              %77 = arith.index_cast %76 : i32 to index
              %78 = memref.load %5[] : memref<memref<?xf32>>
              %79 = arith.subi %15, %c1_i32 : i32
              %80 = arith.muli %79, %69 : i32
              %81 = arith.muli %80, %74 : i32
              %82 = arith.addi %71, %81 : i32
              %83 = arith.index_cast %82 : i32 to index
              %84 = arith.addi %83, %c0 : index
              %85 = memref.load %arg0[%84] : memref<?xf32>
              %86 = arith.addi %77, %c0 : index
              memref.store %85, %arg2[%86] : memref<?xf32>
            }
            %63 = memref.load %53[] : memref<i1>
            memref.store %63, %52[] : memref<i1>
            %64 = memref.load %52[] : memref<i1>
            %65 = scf.if %64 -> (i32) {
              %66 = memref.load %0[] : memref<i32>
              %67 = arith.addi %54, %c1_i32 : i32
              memref.store %67, %0[] : memref<i32>
              scf.yield %67 : i32
            } else {
              scf.yield %54 : i32
            }
            cf.br ^bb1(%65 : i32)
          ^bb3:  // pred: ^bb1
            scf.yield %54 : i32
          }
          scf.yield %49 : i32
        } else {
          scf.yield %33 : i32
        }
        scf.yield %48 : i32
      } else {
        scf.yield %33 : i32
      }
      %44 = memref.load %32[] : memref<i1>
      memref.store %44, %31[] : memref<i1>
      %45 = memref.load %31[] : memref<i1>
      %46 = scf.if %45 -> (i32) {
        %47 = memref.load %2[] : memref<i32>
        %48 = arith.addi %34, %c1_i32 : i32
        memref.store %48, %2[] : memref<i32>
        scf.yield %48 : i32
      } else {
        scf.yield %34 : i32
      }
      cf.br ^bb1(%43, %46 : i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield %33, %34 : i32, i32
    }
    scf.yield %28#0, %28#1 : i32, i32
  } else {
    scf.yield %13, %14 : i32, i32
  }
  scf.yield %27#0, %27#1 : i32, i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %13, %14 : i32, i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %13, %14 : i32, i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.load %3[] : memref<i32>
  %27 = arith.subi %15, %c1_i32 : i32
  memref.store %27, %3[] : memref<i32>
  scf.yield %27 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.load %3[] : memref<i32>
  %27 = arith.subi %15, %c1_i32 : i32
  memref.store %27, %3[] : memref<i32>
  scf.yield %27 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %15 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %15 : i32
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %20 = memref.load %12[] : memref<i1>
  memref.store %20, %11[] : memref<i1>
  %21 = memref.load %11[] : memref<i1>
  %22:2 = scf.if %21 -> (i32, i32) {
    %26 = memref.load %11[] : memref<i1>
    %27:2 = scf.if %26 -> (i32, i32) {
      %28:2 = scf.execute_region -> (i32, i32) {
        %29 = memref.load %11[] : memref<i1>
        %30 = scf.if %29 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %14 : i32
        }
        %31 = memref.alloca() : memref<i1>
        %32 = memref.alloca() : memref<i1>
        memref.store %true, %32[] : memref<i1>
        cf.br ^bb1(%13, %30 : i32, i32)
      ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
        %35 = memref.load %2[] : memref<i32>
        %36 = memref.get_global @jm : memref<1xi32>
        %37 = memref.load %36[%c0] : memref<1xi32>
        %38 = arith.cmpi slt, %34, %37 : i32
        %39 = memref.load %32[] : memref<i1>
        %40 = arith.andi %38, %39 : i1
        cf.cond_br %40, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %41 = memref.load %32[] : memref<i1>
        memref.store %41, %31[] : memref<i1>
        %42 = memref.load %31[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %47 = memref.load %31[] : memref<i1>
          %48 = scf.if %47 -> (i32) {
            %49 = scf.execute_region -> i32 {
              %50 = memref.load %31[] : memref<i1>
              %51 = scf.if %50 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %33 : i32
              }
              %52 = memref.alloca() : memref<i1>
              %53 = memref.alloca() : memref<i1>
              memref.store %true, %53[] : memref<i1>
              cf.br ^bb1(%51 : i32)
            ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
              %55 = memref.load %0[] : memref<i32>
              %56 = memref.get_global @im : memref<1xi32>
              %57 = memref.load %56[%c0] : memref<1xi32>
              %58 = arith.cmpi slt, %54, %57 : i32
              %59 = memref.load %53[] : memref<i1>
              %60 = arith.andi %58, %59 : i1
              cf.cond_br %60, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %61 = memref.load %53[] : memref<i1>
              memref.store %61, %52[] : memref<i1>
              %62 = memref.load %52[] : memref<i1>
              scf.if %62 {
                %66 = memref.load %4[] : memref<memref<?xf32>>
                %67 = memref.load %0[] : memref<i32>
                %68 = memref.load %2[] : memref<i32>
                %69 = memref.load %56[%c0] : memref<1xi32>
                %70 = arith.muli %34, %69 : i32
                %71 = arith.addi %54, %70 : i32
                %72 = memref.load %3[] : memref<i32>
                %73 = arith.muli %15, %69 : i32
                %74 = memref.load %36[%c0] : memref<1xi32>
                %75 = arith.muli %73, %74 : i32
                %76 = arith.addi %71, %75 : i32
                %77 = arith.index_cast %76 : i32 to index
                %78 = memref.load %5[] : memref<memref<?xf32>>
                %79 = arith.subi %15, %c1_i32 : i32
                %80 = arith.muli %79, %69 : i32
                %81 = arith.muli %80, %74 : i32
                %82 = arith.addi %71, %81 : i32
                %83 = arith.index_cast %82 : i32 to index
                %84 = arith.addi %83, %c0 : index
                %85 = memref.load %arg0[%84] : memref<?xf32>
                %86 = arith.addi %77, %c0 : index
                memref.store %85, %arg2[%86] : memref<?xf32>
              }
              %63 = memref.load %53[] : memref<i1>
              memref.store %63, %52[] : memref<i1>
              %64 = memref.load %52[] : memref<i1>
              %65 = scf.if %64 -> (i32) {
                %66 = memref.load %0[] : memref<i32>
                %67 = arith.addi %54, %c1_i32 : i32
                memref.store %67, %0[] : memref<i32>
                scf.yield %67 : i32
              } else {
                scf.yield %54 : i32
              }
              cf.br ^bb1(%65 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %54 : i32
            }
            scf.yield %49 : i32
          } else {
            scf.yield %33 : i32
          }
          scf.yield %48 : i32
        } else {
          scf.yield %33 : i32
        }
        %44 = memref.load %32[] : memref<i1>
        memref.store %44, %31[] : memref<i1>
        %45 = memref.load %31[] : memref<i1>
        %46 = scf.if %45 -> (i32) {
          %47 = memref.load %2[] : memref<i32>
          %48 = arith.addi %34, %c1_i32 : i32
          memref.store %48, %2[] : memref<i32>
          scf.yield %48 : i32
        } else {
          scf.yield %34 : i32
        }
        cf.br ^bb1(%43, %46 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %33, %34 : i32, i32
      }
      scf.yield %28#0, %28#1 : i32, i32
    } else {
      scf.yield %13, %14 : i32, i32
    }
    scf.yield %27#0, %27#1 : i32, i32
  } else {
    scf.yield %13, %14 : i32, i32
  }
  %23 = memref.load %12[] : memref<i1>
  memref.store %23, %11[] : memref<i1>
  %24 = memref.load %11[] : memref<i1>
  %25 = scf.if %24 -> (i32) {
    %26 = memref.load %3[] : memref<i32>
    %27 = arith.subi %15, %c1_i32 : i32
    memref.store %27, %3[] : memref<i32>
    scf.yield %27 : i32
  } else {
    scf.yield %15 : i32
  }
  cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0

starting block: lastVal=val:<block argument> of type 'memref<?xf32>' at index: 0
mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.execute_region {
    %9 = memref.load %6[] : memref<i1>
    %10 = scf.if %9 -> (i32) {
      %26 = memref.get_global @kbm3 : memref<1xi32>
      %27 = memref.load %26[%c0] : memref<1xi32>
      memref.store %27, %3[] : memref<i32>
      scf.yield %27 : i32
    } else {
      scf.yield %1 : i32
    }
    %11 = memref.alloca() : memref<i1>
    %12 = memref.alloca() : memref<i1>
    memref.store %true, %12[] : memref<i1>
    cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
  ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
    %16 = memref.load %3[] : memref<i32>
    %17 = arith.cmpi sgt, %15, %c0_i32 : i32
    %18 = memref.load %12[] : memref<i1>
    %19 = arith.andi %17, %18 : i1
    cf.cond_br %19, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %20 = memref.load %12[] : memref<i1>
    memref.store %20, %11[] : memref<i1>
    %21 = memref.load %11[] : memref<i1>
    %22:2 = scf.if %21 -> (i32, i32) {
      %26 = memref.load %11[] : memref<i1>
      %27:2 = scf.if %26 -> (i32, i32) {
        %28:2 = scf.execute_region -> (i32, i32) {
          %29 = memref.load %11[] : memref<i1>
          %30 = scf.if %29 -> (i32) {
            memref.store %c0_i32, %2[] : memref<i32>
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %14 : i32
          }
          %31 = memref.alloca() : memref<i1>
          %32 = memref.alloca() : memref<i1>
          memref.store %true, %32[] : memref<i1>
          cf.br ^bb1(%13, %30 : i32, i32)
        ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
          %35 = memref.load %2[] : memref<i32>
          %36 = memref.get_global @jm : memref<1xi32>
          %37 = memref.load %36[%c0] : memref<1xi32>
          %38 = arith.cmpi slt, %34, %37 : i32
          %39 = memref.load %32[] : memref<i1>
          %40 = arith.andi %38, %39 : i1
          cf.cond_br %40, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %41 = memref.load %32[] : memref<i1>
          memref.store %41, %31[] : memref<i1>
          %42 = memref.load %31[] : memref<i1>
          %43 = scf.if %42 -> (i32) {
            %47 = memref.load %31[] : memref<i1>
            %48 = scf.if %47 -> (i32) {
              %49 = scf.execute_region -> i32 {
                %50 = memref.load %31[] : memref<i1>
                %51 = scf.if %50 -> (i32) {
                  memref.store %c0_i32, %0[] : memref<i32>
                  scf.yield %c0_i32 : i32
                } else {
                  scf.yield %33 : i32
                }
                %52 = memref.alloca() : memref<i1>
                %53 = memref.alloca() : memref<i1>
                memref.store %true, %53[] : memref<i1>
                cf.br ^bb1(%51 : i32)
              ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                %55 = memref.load %0[] : memref<i32>
                %56 = memref.get_global @im : memref<1xi32>
                %57 = memref.load %56[%c0] : memref<1xi32>
                %58 = arith.cmpi slt, %54, %57 : i32
                %59 = memref.load %53[] : memref<i1>
                %60 = arith.andi %58, %59 : i1
                cf.cond_br %60, ^bb2, ^bb3
              ^bb2:  // pred: ^bb1
                %61 = memref.load %53[] : memref<i1>
                memref.store %61, %52[] : memref<i1>
                %62 = memref.load %52[] : memref<i1>
                scf.if %62 {
                  %66 = memref.load %4[] : memref<memref<?xf32>>
                  %67 = memref.load %0[] : memref<i32>
                  %68 = memref.load %2[] : memref<i32>
                  %69 = memref.load %56[%c0] : memref<1xi32>
                  %70 = arith.muli %34, %69 : i32
                  %71 = arith.addi %54, %70 : i32
                  %72 = memref.load %3[] : memref<i32>
                  %73 = arith.muli %15, %69 : i32
                  %74 = memref.load %36[%c0] : memref<1xi32>
                  %75 = arith.muli %73, %74 : i32
                  %76 = arith.addi %71, %75 : i32
                  %77 = arith.index_cast %76 : i32 to index
                  %78 = memref.load %5[] : memref<memref<?xf32>>
                  %79 = arith.subi %15, %c1_i32 : i32
                  %80 = arith.muli %79, %69 : i32
                  %81 = arith.muli %80, %74 : i32
                  %82 = arith.addi %71, %81 : i32
                  %83 = arith.index_cast %82 : i32 to index
                  %84 = arith.addi %83, %c0 : index
                  %85 = memref.load %arg0[%84] : memref<?xf32>
                  %86 = arith.addi %77, %c0 : index
                  memref.store %85, %arg2[%86] : memref<?xf32>
                }
                %63 = memref.load %53[] : memref<i1>
                memref.store %63, %52[] : memref<i1>
                %64 = memref.load %52[] : memref<i1>
                %65 = scf.if %64 -> (i32) {
                  %66 = memref.load %0[] : memref<i32>
                  %67 = arith.addi %54, %c1_i32 : i32
                  memref.store %67, %0[] : memref<i32>
                  scf.yield %67 : i32
                } else {
                  scf.yield %54 : i32
                }
                cf.br ^bb1(%65 : i32)
              ^bb3:  // pred: ^bb1
                scf.yield %54 : i32
              }
              scf.yield %49 : i32
            } else {
              scf.yield %33 : i32
            }
            scf.yield %48 : i32
          } else {
            scf.yield %33 : i32
          }
          %44 = memref.load %32[] : memref<i1>
          memref.store %44, %31[] : memref<i1>
          %45 = memref.load %31[] : memref<i1>
          %46 = scf.if %45 -> (i32) {
            %47 = memref.load %2[] : memref<i32>
            %48 = arith.addi %34, %c1_i32 : i32
            memref.store %48, %2[] : memref<i32>
            scf.yield %48 : i32
          } else {
            scf.yield %34 : i32
          }
          cf.br ^bb1(%43, %46 : i32, i32)
        ^bb3:  // pred: ^bb1
          scf.yield %33, %34 : i32, i32
        }
        scf.yield %28#0, %28#1 : i32, i32
      } else {
        scf.yield %13, %14 : i32, i32
      }
      scf.yield %27#0, %27#1 : i32, i32
    } else {
      scf.yield %13, %14 : i32, i32
    }
    %23 = memref.load %12[] : memref<i1>
    memref.store %23, %11[] : memref<i1>
    %24 = memref.load %11[] : memref<i1>
    %25 = scf.if %24 -> (i32) {
      %26 = memref.load %3[] : memref<i32>
      %27 = arith.subi %15, %c1_i32 : i32
      memref.store %27, %3[] : memref<i32>
      scf.yield %27 : i32
    } else {
      scf.yield %15 : i32
    }
    cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
  ^bb3:  // pred: ^bb1
    scf.yield
  }
  scf.yield
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %8 = memref.load %6[] : memref<i1>
  scf.if %8 {
    scf.execute_region {
      %9 = memref.load %6[] : memref<i1>
      %10 = scf.if %9 -> (i32) {
        %26 = memref.get_global @kbm3 : memref<1xi32>
        %27 = memref.load %26[%c0] : memref<1xi32>
        memref.store %27, %3[] : memref<i32>
        scf.yield %27 : i32
      } else {
        scf.yield %1 : i32
      }
      %11 = memref.alloca() : memref<i1>
      %12 = memref.alloca() : memref<i1>
      memref.store %true, %12[] : memref<i1>
      cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
    ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
      %16 = memref.load %3[] : memref<i32>
      %17 = arith.cmpi sgt, %15, %c0_i32 : i32
      %18 = memref.load %12[] : memref<i1>
      %19 = arith.andi %17, %18 : i1
      cf.cond_br %19, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %20 = memref.load %12[] : memref<i1>
      memref.store %20, %11[] : memref<i1>
      %21 = memref.load %11[] : memref<i1>
      %22:2 = scf.if %21 -> (i32, i32) {
        %26 = memref.load %11[] : memref<i1>
        %27:2 = scf.if %26 -> (i32, i32) {
          %28:2 = scf.execute_region -> (i32, i32) {
            %29 = memref.load %11[] : memref<i1>
            %30 = scf.if %29 -> (i32) {
              memref.store %c0_i32, %2[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %14 : i32
            }
            %31 = memref.alloca() : memref<i1>
            %32 = memref.alloca() : memref<i1>
            memref.store %true, %32[] : memref<i1>
            cf.br ^bb1(%13, %30 : i32, i32)
          ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
            %35 = memref.load %2[] : memref<i32>
            %36 = memref.get_global @jm : memref<1xi32>
            %37 = memref.load %36[%c0] : memref<1xi32>
            %38 = arith.cmpi slt, %34, %37 : i32
            %39 = memref.load %32[] : memref<i1>
            %40 = arith.andi %38, %39 : i1
            cf.cond_br %40, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %41 = memref.load %32[] : memref<i1>
            memref.store %41, %31[] : memref<i1>
            %42 = memref.load %31[] : memref<i1>
            %43 = scf.if %42 -> (i32) {
              %47 = memref.load %31[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                %49 = scf.execute_region -> i32 {
                  %50 = memref.load %31[] : memref<i1>
                  %51 = scf.if %50 -> (i32) {
                    memref.store %c0_i32, %0[] : memref<i32>
                    scf.yield %c0_i32 : i32
                  } else {
                    scf.yield %33 : i32
                  }
                  %52 = memref.alloca() : memref<i1>
                  %53 = memref.alloca() : memref<i1>
                  memref.store %true, %53[] : memref<i1>
                  cf.br ^bb1(%51 : i32)
                ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                  %55 = memref.load %0[] : memref<i32>
                  %56 = memref.get_global @im : memref<1xi32>
                  %57 = memref.load %56[%c0] : memref<1xi32>
                  %58 = arith.cmpi slt, %54, %57 : i32
                  %59 = memref.load %53[] : memref<i1>
                  %60 = arith.andi %58, %59 : i1
                  cf.cond_br %60, ^bb2, ^bb3
                ^bb2:  // pred: ^bb1
                  %61 = memref.load %53[] : memref<i1>
                  memref.store %61, %52[] : memref<i1>
                  %62 = memref.load %52[] : memref<i1>
                  scf.if %62 {
                    %66 = memref.load %4[] : memref<memref<?xf32>>
                    %67 = memref.load %0[] : memref<i32>
                    %68 = memref.load %2[] : memref<i32>
                    %69 = memref.load %56[%c0] : memref<1xi32>
                    %70 = arith.muli %34, %69 : i32
                    %71 = arith.addi %54, %70 : i32
                    %72 = memref.load %3[] : memref<i32>
                    %73 = arith.muli %15, %69 : i32
                    %74 = memref.load %36[%c0] : memref<1xi32>
                    %75 = arith.muli %73, %74 : i32
                    %76 = arith.addi %71, %75 : i32
                    %77 = arith.index_cast %76 : i32 to index
                    %78 = memref.load %5[] : memref<memref<?xf32>>
                    %79 = arith.subi %15, %c1_i32 : i32
                    %80 = arith.muli %79, %69 : i32
                    %81 = arith.muli %80, %74 : i32
                    %82 = arith.addi %71, %81 : i32
                    %83 = arith.index_cast %82 : i32 to index
                    %84 = arith.addi %83, %c0 : index
                    %85 = memref.load %arg0[%84] : memref<?xf32>
                    %86 = arith.addi %77, %c0 : index
                    memref.store %85, %arg2[%86] : memref<?xf32>
                  }
                  %63 = memref.load %53[] : memref<i1>
                  memref.store %63, %52[] : memref<i1>
                  %64 = memref.load %52[] : memref<i1>
                  %65 = scf.if %64 -> (i32) {
                    %66 = memref.load %0[] : memref<i32>
                    %67 = arith.addi %54, %c1_i32 : i32
                    memref.store %67, %0[] : memref<i32>
                    scf.yield %67 : i32
                  } else {
                    scf.yield %54 : i32
                  }
                  cf.br ^bb1(%65 : i32)
                ^bb3:  // pred: ^bb1
                  scf.yield %54 : i32
                }
                scf.yield %49 : i32
              } else {
                scf.yield %33 : i32
              }
              scf.yield %48 : i32
            } else {
              scf.yield %33 : i32
            }
            %44 = memref.load %32[] : memref<i1>
            memref.store %44, %31[] : memref<i1>
            %45 = memref.load %31[] : memref<i1>
            %46 = scf.if %45 -> (i32) {
              %47 = memref.load %2[] : memref<i32>
              %48 = arith.addi %34, %c1_i32 : i32
              memref.store %48, %2[] : memref<i32>
              scf.yield %48 : i32
            } else {
              scf.yield %34 : i32
            }
            cf.br ^bb1(%43, %46 : i32, i32)
          ^bb3:  // pred: ^bb1
            scf.yield %33, %34 : i32, i32
          }
          scf.yield %28#0, %28#1 : i32, i32
        } else {
          scf.yield %13, %14 : i32, i32
        }
        scf.yield %27#0, %27#1 : i32, i32
      } else {
        scf.yield %13, %14 : i32, i32
      }
      %23 = memref.load %12[] : memref<i1>
      memref.store %23, %11[] : memref<i1>
      %24 = memref.load %11[] : memref<i1>
      %25 = scf.if %24 -> (i32) {
        %26 = memref.load %3[] : memref<i32>
        %27 = arith.subi %15, %c1_i32 : i32
        memref.store %27, %3[] : memref<i32>
        scf.yield %27 : i32
      } else {
        scf.yield %15 : i32
      }
      cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
  scf.yield
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32):
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %7 {
    %8 = memref.load %6[] : memref<i1>
    scf.if %8 {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        %10 = scf.if %9 -> (i32) {
          %26 = memref.get_global @kbm3 : memref<1xi32>
          %27 = memref.load %26[%c0] : memref<1xi32>
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %1 : i32
        }
        %11 = memref.alloca() : memref<i1>
        %12 = memref.alloca() : memref<i1>
        memref.store %true, %12[] : memref<i1>
        cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
      ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
        %16 = memref.load %3[] : memref<i32>
        %17 = arith.cmpi sgt, %15, %c0_i32 : i32
        %18 = memref.load %12[] : memref<i1>
        %19 = arith.andi %17, %18 : i1
        cf.cond_br %19, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %20 = memref.load %12[] : memref<i1>
        memref.store %20, %11[] : memref<i1>
        %21 = memref.load %11[] : memref<i1>
        %22:2 = scf.if %21 -> (i32, i32) {
          %26 = memref.load %11[] : memref<i1>
          %27:2 = scf.if %26 -> (i32, i32) {
            %28:2 = scf.execute_region -> (i32, i32) {
              %29 = memref.load %11[] : memref<i1>
              %30 = scf.if %29 -> (i32) {
                memref.store %c0_i32, %2[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %14 : i32
              }
              %31 = memref.alloca() : memref<i1>
              %32 = memref.alloca() : memref<i1>
              memref.store %true, %32[] : memref<i1>
              cf.br ^bb1(%13, %30 : i32, i32)
            ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
              %35 = memref.load %2[] : memref<i32>
              %36 = memref.get_global @jm : memref<1xi32>
              %37 = memref.load %36[%c0] : memref<1xi32>
              %38 = arith.cmpi slt, %34, %37 : i32
              %39 = memref.load %32[] : memref<i1>
              %40 = arith.andi %38, %39 : i1
              cf.cond_br %40, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %41 = memref.load %32[] : memref<i1>
              memref.store %41, %31[] : memref<i1>
              %42 = memref.load %31[] : memref<i1>
              %43 = scf.if %42 -> (i32) {
                %47 = memref.load %31[] : memref<i1>
                %48 = scf.if %47 -> (i32) {
                  %49 = scf.execute_region -> i32 {
                    %50 = memref.load %31[] : memref<i1>
                    %51 = scf.if %50 -> (i32) {
                      memref.store %c0_i32, %0[] : memref<i32>
                      scf.yield %c0_i32 : i32
                    } else {
                      scf.yield %33 : i32
                    }
                    %52 = memref.alloca() : memref<i1>
                    %53 = memref.alloca() : memref<i1>
                    memref.store %true, %53[] : memref<i1>
                    cf.br ^bb1(%51 : i32)
                  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                    %55 = memref.load %0[] : memref<i32>
                    %56 = memref.get_global @im : memref<1xi32>
                    %57 = memref.load %56[%c0] : memref<1xi32>
                    %58 = arith.cmpi slt, %54, %57 : i32
                    %59 = memref.load %53[] : memref<i1>
                    %60 = arith.andi %58, %59 : i1
                    cf.cond_br %60, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %61 = memref.load %53[] : memref<i1>
                    memref.store %61, %52[] : memref<i1>
                    %62 = memref.load %52[] : memref<i1>
                    scf.if %62 {
                      %66 = memref.load %4[] : memref<memref<?xf32>>
                      %67 = memref.load %0[] : memref<i32>
                      %68 = memref.load %2[] : memref<i32>
                      %69 = memref.load %56[%c0] : memref<1xi32>
                      %70 = arith.muli %34, %69 : i32
                      %71 = arith.addi %54, %70 : i32
                      %72 = memref.load %3[] : memref<i32>
                      %73 = arith.muli %15, %69 : i32
                      %74 = memref.load %36[%c0] : memref<1xi32>
                      %75 = arith.muli %73, %74 : i32
                      %76 = arith.addi %71, %75 : i32
                      %77 = arith.index_cast %76 : i32 to index
                      %78 = memref.load %5[] : memref<memref<?xf32>>
                      %79 = arith.subi %15, %c1_i32 : i32
                      %80 = arith.muli %79, %69 : i32
                      %81 = arith.muli %80, %74 : i32
                      %82 = arith.addi %71, %81 : i32
                      %83 = arith.index_cast %82 : i32 to index
                      %84 = arith.addi %83, %c0 : index
                      %85 = memref.load %arg0[%84] : memref<?xf32>
                      %86 = arith.addi %77, %c0 : index
                      memref.store %85, %arg2[%86] : memref<?xf32>
                    }
                    %63 = memref.load %53[] : memref<i1>
                    memref.store %63, %52[] : memref<i1>
                    %64 = memref.load %52[] : memref<i1>
                    %65 = scf.if %64 -> (i32) {
                      %66 = memref.load %0[] : memref<i32>
                      %67 = arith.addi %54, %c1_i32 : i32
                      memref.store %67, %0[] : memref<i32>
                      scf.yield %67 : i32
                    } else {
                      scf.yield %54 : i32
                    }
                    cf.br ^bb1(%65 : i32)
                  ^bb3:  // pred: ^bb1
                    scf.yield %54 : i32
                  }
                  scf.yield %49 : i32
                } else {
                  scf.yield %33 : i32
                }
                scf.yield %48 : i32
              } else {
                scf.yield %33 : i32
              }
              %44 = memref.load %32[] : memref<i1>
              memref.store %44, %31[] : memref<i1>
              %45 = memref.load %31[] : memref<i1>
              %46 = scf.if %45 -> (i32) {
                %47 = memref.load %2[] : memref<i32>
                %48 = arith.addi %34, %c1_i32 : i32
                memref.store %48, %2[] : memref<i32>
                scf.yield %48 : i32
              } else {
                scf.yield %34 : i32
              }
              cf.br ^bb1(%43, %46 : i32, i32)
            ^bb3:  // pred: ^bb1
              scf.yield %33, %34 : i32, i32
            }
            scf.yield %28#0, %28#1 : i32, i32
          } else {
            scf.yield %13, %14 : i32, i32
          }
          scf.yield %27#0, %27#1 : i32, i32
        } else {
          scf.yield %13, %14 : i32, i32
        }
        %23 = memref.load %12[] : memref<i1>
        memref.store %23, %11[] : memref<i1>
        %24 = memref.load %11[] : memref<i1>
        %25 = scf.if %24 -> (i32) {
          %26 = memref.load %3[] : memref<i32>
          %27 = arith.subi %15, %c1_i32 : i32
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %15 : i32
        }
        cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  func.return
 with val:val:<block argument> of type 'memref<?xf32>' at index: 0
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%6 = memref.alloca() : memref<i1>
 + forwarding vec to promote {} of mlir-asm-printer: Verifying operation: builtin.module
%6 = memref.alloca() : memref<i1>
Begin forwarding store of mlir-asm-printer: Verifying operation: builtin.module
%6 = memref.alloca() : memref<i1> to load
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %7 {
    %8 = memref.load %6[] : memref<i1>
    scf.if %8 {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        %10 = scf.if %9 -> (i32) {
          %26 = memref.get_global @kbm3 : memref<1xi32>
          %27 = memref.load %26[%c0] : memref<1xi32>
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %1 : i32
        }
        %11 = memref.alloca() : memref<i1>
        %12 = memref.alloca() : memref<i1>
        memref.store %true, %12[] : memref<i1>
        cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
      ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
        %16 = memref.load %3[] : memref<i32>
        %17 = arith.cmpi sgt, %15, %c0_i32 : i32
        %18 = memref.load %12[] : memref<i1>
        %19 = arith.andi %17, %18 : i1
        cf.cond_br %19, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %20 = memref.load %12[] : memref<i1>
        memref.store %20, %11[] : memref<i1>
        %21 = memref.load %11[] : memref<i1>
        %22:2 = scf.if %21 -> (i32, i32) {
          %26 = memref.load %11[] : memref<i1>
          %27:2 = scf.if %26 -> (i32, i32) {
            %28:2 = scf.execute_region -> (i32, i32) {
              %29 = memref.load %11[] : memref<i1>
              %30 = scf.if %29 -> (i32) {
                memref.store %c0_i32, %2[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %14 : i32
              }
              %31 = memref.alloca() : memref<i1>
              %32 = memref.alloca() : memref<i1>
              memref.store %true, %32[] : memref<i1>
              cf.br ^bb1(%13, %30 : i32, i32)
            ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
              %35 = memref.load %2[] : memref<i32>
              %36 = memref.get_global @jm : memref<1xi32>
              %37 = memref.load %36[%c0] : memref<1xi32>
              %38 = arith.cmpi slt, %34, %37 : i32
              %39 = memref.load %32[] : memref<i1>
              %40 = arith.andi %38, %39 : i1
              cf.cond_br %40, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %41 = memref.load %32[] : memref<i1>
              memref.store %41, %31[] : memref<i1>
              %42 = memref.load %31[] : memref<i1>
              %43 = scf.if %42 -> (i32) {
                %47 = memref.load %31[] : memref<i1>
                %48 = scf.if %47 -> (i32) {
                  %49 = scf.execute_region -> i32 {
                    %50 = memref.load %31[] : memref<i1>
                    %51 = scf.if %50 -> (i32) {
                      memref.store %c0_i32, %0[] : memref<i32>
                      scf.yield %c0_i32 : i32
                    } else {
                      scf.yield %33 : i32
                    }
                    %52 = memref.alloca() : memref<i1>
                    %53 = memref.alloca() : memref<i1>
                    memref.store %true, %53[] : memref<i1>
                    cf.br ^bb1(%51 : i32)
                  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                    %55 = memref.load %0[] : memref<i32>
                    %56 = memref.get_global @im : memref<1xi32>
                    %57 = memref.load %56[%c0] : memref<1xi32>
                    %58 = arith.cmpi slt, %54, %57 : i32
                    %59 = memref.load %53[] : memref<i1>
                    %60 = arith.andi %58, %59 : i1
                    cf.cond_br %60, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %61 = memref.load %53[] : memref<i1>
                    memref.store %61, %52[] : memref<i1>
                    %62 = memref.load %52[] : memref<i1>
                    scf.if %62 {
                      %66 = memref.load %4[] : memref<memref<?xf32>>
                      %67 = memref.load %0[] : memref<i32>
                      %68 = memref.load %2[] : memref<i32>
                      %69 = memref.load %56[%c0] : memref<1xi32>
                      %70 = arith.muli %34, %69 : i32
                      %71 = arith.addi %54, %70 : i32
                      %72 = memref.load %3[] : memref<i32>
                      %73 = arith.muli %15, %69 : i32
                      %74 = memref.load %36[%c0] : memref<1xi32>
                      %75 = arith.muli %73, %74 : i32
                      %76 = arith.addi %71, %75 : i32
                      %77 = arith.index_cast %76 : i32 to index
                      %78 = memref.load %5[] : memref<memref<?xf32>>
                      %79 = arith.subi %15, %c1_i32 : i32
                      %80 = arith.muli %79, %69 : i32
                      %81 = arith.muli %80, %74 : i32
                      %82 = arith.addi %71, %81 : i32
                      %83 = arith.index_cast %82 : i32 to index
                      %84 = arith.addi %83, %c0 : index
                      %85 = memref.load %arg0[%84] : memref<?xf32>
                      %86 = arith.addi %77, %c0 : index
                      memref.store %85, %arg2[%86] : memref<?xf32>
                    }
                    %63 = memref.load %53[] : memref<i1>
                    memref.store %63, %52[] : memref<i1>
                    %64 = memref.load %52[] : memref<i1>
                    %65 = scf.if %64 -> (i32) {
                      %66 = memref.load %0[] : memref<i32>
                      %67 = arith.addi %54, %c1_i32 : i32
                      memref.store %67, %0[] : memref<i32>
                      scf.yield %67 : i32
                    } else {
                      scf.yield %54 : i32
                    }
                    cf.br ^bb1(%65 : i32)
                  ^bb3:  // pred: ^bb1
                    scf.yield %54 : i32
                  }
                  scf.yield %49 : i32
                } else {
                  scf.yield %33 : i32
                }
                scf.yield %48 : i32
              } else {
                scf.yield %33 : i32
              }
              %44 = memref.load %32[] : memref<i1>
              memref.store %44, %31[] : memref<i1>
              %45 = memref.load %31[] : memref<i1>
              %46 = scf.if %45 -> (i32) {
                %47 = memref.load %2[] : memref<i32>
                %48 = arith.addi %34, %c1_i32 : i32
                memref.store %48, %2[] : memref<i32>
                scf.yield %48 : i32
              } else {
                scf.yield %34 : i32
              }
              cf.br ^bb1(%43, %46 : i32, i32)
            ^bb3:  // pred: ^bb1
              scf.yield %33, %34 : i32, i32
            }
            scf.yield %28#0, %28#1 : i32, i32
          } else {
            scf.yield %13, %14 : i32, i32
          }
          scf.yield %27#0, %27#1 : i32, i32
        } else {
          scf.yield %13, %14 : i32, i32
        }
        %23 = memref.load %12[] : memref<i1>
        memref.store %23, %11[] : memref<i1>
        %24 = memref.load %11[] : memref<i1>
        %25 = scf.if %24 -> (i32) {
          %26 = memref.load %3[] : memref<i32>
          %27 = arith.subi %15, %c1_i32 : i32
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %15 : i32
        }
        cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}
Matching Load: mlir-asm-printer: Verifying operation: func.func
%9 = memref.load %6[] : memref<i1>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%8 = memref.load %6[] : memref<i1>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%7 = memref.load %6[] : memref<i1>
Matching Store: mlir-asm-printer: Verifying operation: func.func
memref.store %true, %6[] : memref<i1>
 storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %true, %6[] : memref<i1>
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32):
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %7 {
    %8 = memref.load %6[] : memref<i1>
    scf.if %8 {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        %10 = scf.if %9 -> (i32) {
          %26 = memref.get_global @kbm3 : memref<1xi32>
          %27 = memref.load %26[%c0] : memref<1xi32>
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %1 : i32
        }
        %11 = memref.alloca() : memref<i1>
        %12 = memref.alloca() : memref<i1>
        memref.store %true, %12[] : memref<i1>
        cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
      ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
        %16 = memref.load %3[] : memref<i32>
        %17 = arith.cmpi sgt, %15, %c0_i32 : i32
        %18 = memref.load %12[] : memref<i1>
        %19 = arith.andi %17, %18 : i1
        cf.cond_br %19, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %20 = memref.load %12[] : memref<i1>
        memref.store %20, %11[] : memref<i1>
        %21 = memref.load %11[] : memref<i1>
        %22:2 = scf.if %21 -> (i32, i32) {
          %26 = memref.load %11[] : memref<i1>
          %27:2 = scf.if %26 -> (i32, i32) {
            %28:2 = scf.execute_region -> (i32, i32) {
              %29 = memref.load %11[] : memref<i1>
              %30 = scf.if %29 -> (i32) {
                memref.store %c0_i32, %2[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %14 : i32
              }
              %31 = memref.alloca() : memref<i1>
              %32 = memref.alloca() : memref<i1>
              memref.store %true, %32[] : memref<i1>
              cf.br ^bb1(%13, %30 : i32, i32)
            ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
              %35 = memref.load %2[] : memref<i32>
              %36 = memref.get_global @jm : memref<1xi32>
              %37 = memref.load %36[%c0] : memref<1xi32>
              %38 = arith.cmpi slt, %34, %37 : i32
              %39 = memref.load %32[] : memref<i1>
              %40 = arith.andi %38, %39 : i1
              cf.cond_br %40, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %41 = memref.load %32[] : memref<i1>
              memref.store %41, %31[] : memref<i1>
              %42 = memref.load %31[] : memref<i1>
              %43 = scf.if %42 -> (i32) {
                %47 = memref.load %31[] : memref<i1>
                %48 = scf.if %47 -> (i32) {
                  %49 = scf.execute_region -> i32 {
                    %50 = memref.load %31[] : memref<i1>
                    %51 = scf.if %50 -> (i32) {
                      memref.store %c0_i32, %0[] : memref<i32>
                      scf.yield %c0_i32 : i32
                    } else {
                      scf.yield %33 : i32
                    }
                    %52 = memref.alloca() : memref<i1>
                    %53 = memref.alloca() : memref<i1>
                    memref.store %true, %53[] : memref<i1>
                    cf.br ^bb1(%51 : i32)
                  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                    %55 = memref.load %0[] : memref<i32>
                    %56 = memref.get_global @im : memref<1xi32>
                    %57 = memref.load %56[%c0] : memref<1xi32>
                    %58 = arith.cmpi slt, %54, %57 : i32
                    %59 = memref.load %53[] : memref<i1>
                    %60 = arith.andi %58, %59 : i1
                    cf.cond_br %60, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %61 = memref.load %53[] : memref<i1>
                    memref.store %61, %52[] : memref<i1>
                    %62 = memref.load %52[] : memref<i1>
                    scf.if %62 {
                      %66 = memref.load %4[] : memref<memref<?xf32>>
                      %67 = memref.load %0[] : memref<i32>
                      %68 = memref.load %2[] : memref<i32>
                      %69 = memref.load %56[%c0] : memref<1xi32>
                      %70 = arith.muli %34, %69 : i32
                      %71 = arith.addi %54, %70 : i32
                      %72 = memref.load %3[] : memref<i32>
                      %73 = arith.muli %15, %69 : i32
                      %74 = memref.load %36[%c0] : memref<1xi32>
                      %75 = arith.muli %73, %74 : i32
                      %76 = arith.addi %71, %75 : i32
                      %77 = arith.index_cast %76 : i32 to index
                      %78 = memref.load %5[] : memref<memref<?xf32>>
                      %79 = arith.subi %15, %c1_i32 : i32
                      %80 = arith.muli %79, %69 : i32
                      %81 = arith.muli %80, %74 : i32
                      %82 = arith.addi %71, %81 : i32
                      %83 = arith.index_cast %82 : i32 to index
                      %84 = arith.addi %83, %c0 : index
                      %85 = memref.load %arg0[%84] : memref<?xf32>
                      %86 = arith.addi %77, %c0 : index
                      memref.store %85, %arg2[%86] : memref<?xf32>
                    }
                    %63 = memref.load %53[] : memref<i1>
                    memref.store %63, %52[] : memref<i1>
                    %64 = memref.load %52[] : memref<i1>
                    %65 = scf.if %64 -> (i32) {
                      %66 = memref.load %0[] : memref<i32>
                      %67 = arith.addi %54, %c1_i32 : i32
                      memref.store %67, %0[] : memref<i32>
                      scf.yield %67 : i32
                    } else {
                      scf.yield %54 : i32
                    }
                    cf.br ^bb1(%65 : i32)
                  ^bb3:  // pred: ^bb1
                    scf.yield %54 : i32
                  }
                  scf.yield %49 : i32
                } else {
                  scf.yield %33 : i32
                }
                scf.yield %48 : i32
              } else {
                scf.yield %33 : i32
              }
              %44 = memref.load %32[] : memref<i1>
              memref.store %44, %31[] : memref<i1>
              %45 = memref.load %31[] : memref<i1>
              %46 = scf.if %45 -> (i32) {
                %47 = memref.load %2[] : memref<i32>
                %48 = arith.addi %34, %c1_i32 : i32
                memref.store %48, %2[] : memref<i32>
                scf.yield %48 : i32
              } else {
                scf.yield %34 : i32
              }
              cf.br ^bb1(%43, %46 : i32, i32)
            ^bb3:  // pred: ^bb1
              scf.yield %33, %34 : i32, i32
            }
            scf.yield %28#0, %28#1 : i32, i32
          } else {
            scf.yield %13, %14 : i32, i32
          }
          scf.yield %27#0, %27#1 : i32, i32
        } else {
          scf.yield %13, %14 : i32, i32
        }
        %23 = memref.load %12[] : memref<i1>
        memref.store %23, %11[] : memref<i1>
        %24 = memref.load %11[] : memref<i1>
        %25 = scf.if %24 -> (i32) {
          %26 = memref.load %3[] : memref<i32>
          %27 = arith.subi %15, %c1_i32 : i32
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %15 : i32
        }
        cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  func.return

 replaced mlir-asm-printer: Verifying operation: builtin.module
%7 = memref.load %6[] : memref<i1> with mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %8 = memref.load %6[] : memref<i1>
  scf.if %8 {
    scf.execute_region {
      %9 = memref.load %6[] : memref<i1>
      %10 = scf.if %9 -> (i32) {
        %26 = memref.get_global @kbm3 : memref<1xi32>
        %27 = memref.load %26[%c0] : memref<1xi32>
        memref.store %27, %3[] : memref<i32>
        scf.yield %27 : i32
      } else {
        scf.yield %1 : i32
      }
      %11 = memref.alloca() : memref<i1>
      %12 = memref.alloca() : memref<i1>
      memref.store %true, %12[] : memref<i1>
      cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
    ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
      %16 = memref.load %3[] : memref<i32>
      %17 = arith.cmpi sgt, %15, %c0_i32 : i32
      %18 = memref.load %12[] : memref<i1>
      %19 = arith.andi %17, %18 : i1
      cf.cond_br %19, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %20 = memref.load %12[] : memref<i1>
      memref.store %20, %11[] : memref<i1>
      %21 = memref.load %11[] : memref<i1>
      %22:2 = scf.if %21 -> (i32, i32) {
        %26 = memref.load %11[] : memref<i1>
        %27:2 = scf.if %26 -> (i32, i32) {
          %28:2 = scf.execute_region -> (i32, i32) {
            %29 = memref.load %11[] : memref<i1>
            %30 = scf.if %29 -> (i32) {
              memref.store %c0_i32, %2[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %14 : i32
            }
            %31 = memref.alloca() : memref<i1>
            %32 = memref.alloca() : memref<i1>
            memref.store %true, %32[] : memref<i1>
            cf.br ^bb1(%13, %30 : i32, i32)
          ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
            %35 = memref.load %2[] : memref<i32>
            %36 = memref.get_global @jm : memref<1xi32>
            %37 = memref.load %36[%c0] : memref<1xi32>
            %38 = arith.cmpi slt, %34, %37 : i32
            %39 = memref.load %32[] : memref<i1>
            %40 = arith.andi %38, %39 : i1
            cf.cond_br %40, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %41 = memref.load %32[] : memref<i1>
            memref.store %41, %31[] : memref<i1>
            %42 = memref.load %31[] : memref<i1>
            %43 = scf.if %42 -> (i32) {
              %47 = memref.load %31[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                %49 = scf.execute_region -> i32 {
                  %50 = memref.load %31[] : memref<i1>
                  %51 = scf.if %50 -> (i32) {
                    memref.store %c0_i32, %0[] : memref<i32>
                    scf.yield %c0_i32 : i32
                  } else {
                    scf.yield %33 : i32
                  }
                  %52 = memref.alloca() : memref<i1>
                  %53 = memref.alloca() : memref<i1>
                  memref.store %true, %53[] : memref<i1>
                  cf.br ^bb1(%51 : i32)
                ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                  %55 = memref.load %0[] : memref<i32>
                  %56 = memref.get_global @im : memref<1xi32>
                  %57 = memref.load %56[%c0] : memref<1xi32>
                  %58 = arith.cmpi slt, %54, %57 : i32
                  %59 = memref.load %53[] : memref<i1>
                  %60 = arith.andi %58, %59 : i1
                  cf.cond_br %60, ^bb2, ^bb3
                ^bb2:  // pred: ^bb1
                  %61 = memref.load %53[] : memref<i1>
                  memref.store %61, %52[] : memref<i1>
                  %62 = memref.load %52[] : memref<i1>
                  scf.if %62 {
                    %66 = memref.load %4[] : memref<memref<?xf32>>
                    %67 = memref.load %0[] : memref<i32>
                    %68 = memref.load %2[] : memref<i32>
                    %69 = memref.load %56[%c0] : memref<1xi32>
                    %70 = arith.muli %34, %69 : i32
                    %71 = arith.addi %54, %70 : i32
                    %72 = memref.load %3[] : memref<i32>
                    %73 = arith.muli %15, %69 : i32
                    %74 = memref.load %36[%c0] : memref<1xi32>
                    %75 = arith.muli %73, %74 : i32
                    %76 = arith.addi %71, %75 : i32
                    %77 = arith.index_cast %76 : i32 to index
                    %78 = memref.load %5[] : memref<memref<?xf32>>
                    %79 = arith.subi %15, %c1_i32 : i32
                    %80 = arith.muli %79, %69 : i32
                    %81 = arith.muli %80, %74 : i32
                    %82 = arith.addi %71, %81 : i32
                    %83 = arith.index_cast %82 : i32 to index
                    %84 = arith.addi %83, %c0 : index
                    %85 = memref.load %arg0[%84] : memref<?xf32>
                    %86 = arith.addi %77, %c0 : index
                    memref.store %85, %arg2[%86] : memref<?xf32>
                  }
                  %63 = memref.load %53[] : memref<i1>
                  memref.store %63, %52[] : memref<i1>
                  %64 = memref.load %52[] : memref<i1>
                  %65 = scf.if %64 -> (i32) {
                    %66 = memref.load %0[] : memref<i32>
                    %67 = arith.addi %54, %c1_i32 : i32
                    memref.store %67, %0[] : memref<i32>
                    scf.yield %67 : i32
                  } else {
                    scf.yield %54 : i32
                  }
                  cf.br ^bb1(%65 : i32)
                ^bb3:  // pred: ^bb1
                  scf.yield %54 : i32
                }
                scf.yield %49 : i32
              } else {
                scf.yield %33 : i32
              }
              scf.yield %48 : i32
            } else {
              scf.yield %33 : i32
            }
            %44 = memref.load %32[] : memref<i1>
            memref.store %44, %31[] : memref<i1>
            %45 = memref.load %31[] : memref<i1>
            %46 = scf.if %45 -> (i32) {
              %47 = memref.load %2[] : memref<i32>
              %48 = arith.addi %34, %c1_i32 : i32
              memref.store %48, %2[] : memref<i32>
              scf.yield %48 : i32
            } else {
              scf.yield %34 : i32
            }
            cf.br ^bb1(%43, %46 : i32, i32)
          ^bb3:  // pred: ^bb1
            scf.yield %33, %34 : i32, i32
          }
          scf.yield %28#0, %28#1 : i32, i32
        } else {
          scf.yield %13, %14 : i32, i32
        }
        scf.yield %27#0, %27#1 : i32, i32
      } else {
        scf.yield %13, %14 : i32, i32
      }
      %23 = memref.load %12[] : memref<i1>
      memref.store %23, %11[] : memref<i1>
      %24 = memref.load %11[] : memref<i1>
      %25 = scf.if %24 -> (i32) {
        %26 = memref.load %3[] : memref<i32>
        %27 = arith.subi %15, %c1_i32 : i32
        memref.store %27, %3[] : memref<i32>
        scf.yield %27 : i32
      } else {
        scf.yield %15 : i32
      }
      cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
  scf.yield

 replaced mlir-asm-printer: Verifying operation: builtin.module
%8 = memref.load %6[] : memref<i1> with mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.execute_region {
    %9 = memref.load %6[] : memref<i1>
    %10 = scf.if %9 -> (i32) {
      %26 = memref.get_global @kbm3 : memref<1xi32>
      %27 = memref.load %26[%c0] : memref<1xi32>
      memref.store %27, %3[] : memref<i32>
      scf.yield %27 : i32
    } else {
      scf.yield %1 : i32
    }
    %11 = memref.alloca() : memref<i1>
    %12 = memref.alloca() : memref<i1>
    memref.store %true, %12[] : memref<i1>
    cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
  ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
    %16 = memref.load %3[] : memref<i32>
    %17 = arith.cmpi sgt, %15, %c0_i32 : i32
    %18 = memref.load %12[] : memref<i1>
    %19 = arith.andi %17, %18 : i1
    cf.cond_br %19, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %20 = memref.load %12[] : memref<i1>
    memref.store %20, %11[] : memref<i1>
    %21 = memref.load %11[] : memref<i1>
    %22:2 = scf.if %21 -> (i32, i32) {
      %26 = memref.load %11[] : memref<i1>
      %27:2 = scf.if %26 -> (i32, i32) {
        %28:2 = scf.execute_region -> (i32, i32) {
          %29 = memref.load %11[] : memref<i1>
          %30 = scf.if %29 -> (i32) {
            memref.store %c0_i32, %2[] : memref<i32>
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %14 : i32
          }
          %31 = memref.alloca() : memref<i1>
          %32 = memref.alloca() : memref<i1>
          memref.store %true, %32[] : memref<i1>
          cf.br ^bb1(%13, %30 : i32, i32)
        ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
          %35 = memref.load %2[] : memref<i32>
          %36 = memref.get_global @jm : memref<1xi32>
          %37 = memref.load %36[%c0] : memref<1xi32>
          %38 = arith.cmpi slt, %34, %37 : i32
          %39 = memref.load %32[] : memref<i1>
          %40 = arith.andi %38, %39 : i1
          cf.cond_br %40, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %41 = memref.load %32[] : memref<i1>
          memref.store %41, %31[] : memref<i1>
          %42 = memref.load %31[] : memref<i1>
          %43 = scf.if %42 -> (i32) {
            %47 = memref.load %31[] : memref<i1>
            %48 = scf.if %47 -> (i32) {
              %49 = scf.execute_region -> i32 {
                %50 = memref.load %31[] : memref<i1>
                %51 = scf.if %50 -> (i32) {
                  memref.store %c0_i32, %0[] : memref<i32>
                  scf.yield %c0_i32 : i32
                } else {
                  scf.yield %33 : i32
                }
                %52 = memref.alloca() : memref<i1>
                %53 = memref.alloca() : memref<i1>
                memref.store %true, %53[] : memref<i1>
                cf.br ^bb1(%51 : i32)
              ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                %55 = memref.load %0[] : memref<i32>
                %56 = memref.get_global @im : memref<1xi32>
                %57 = memref.load %56[%c0] : memref<1xi32>
                %58 = arith.cmpi slt, %54, %57 : i32
                %59 = memref.load %53[] : memref<i1>
                %60 = arith.andi %58, %59 : i1
                cf.cond_br %60, ^bb2, ^bb3
              ^bb2:  // pred: ^bb1
                %61 = memref.load %53[] : memref<i1>
                memref.store %61, %52[] : memref<i1>
                %62 = memref.load %52[] : memref<i1>
                scf.if %62 {
                  %66 = memref.load %4[] : memref<memref<?xf32>>
                  %67 = memref.load %0[] : memref<i32>
                  %68 = memref.load %2[] : memref<i32>
                  %69 = memref.load %56[%c0] : memref<1xi32>
                  %70 = arith.muli %34, %69 : i32
                  %71 = arith.addi %54, %70 : i32
                  %72 = memref.load %3[] : memref<i32>
                  %73 = arith.muli %15, %69 : i32
                  %74 = memref.load %36[%c0] : memref<1xi32>
                  %75 = arith.muli %73, %74 : i32
                  %76 = arith.addi %71, %75 : i32
                  %77 = arith.index_cast %76 : i32 to index
                  %78 = memref.load %5[] : memref<memref<?xf32>>
                  %79 = arith.subi %15, %c1_i32 : i32
                  %80 = arith.muli %79, %69 : i32
                  %81 = arith.muli %80, %74 : i32
                  %82 = arith.addi %71, %81 : i32
                  %83 = arith.index_cast %82 : i32 to index
                  %84 = arith.addi %83, %c0 : index
                  %85 = memref.load %arg0[%84] : memref<?xf32>
                  %86 = arith.addi %77, %c0 : index
                  memref.store %85, %arg2[%86] : memref<?xf32>
                }
                %63 = memref.load %53[] : memref<i1>
                memref.store %63, %52[] : memref<i1>
                %64 = memref.load %52[] : memref<i1>
                %65 = scf.if %64 -> (i32) {
                  %66 = memref.load %0[] : memref<i32>
                  %67 = arith.addi %54, %c1_i32 : i32
                  memref.store %67, %0[] : memref<i32>
                  scf.yield %67 : i32
                } else {
                  scf.yield %54 : i32
                }
                cf.br ^bb1(%65 : i32)
              ^bb3:  // pred: ^bb1
                scf.yield %54 : i32
              }
              scf.yield %49 : i32
            } else {
              scf.yield %33 : i32
            }
            scf.yield %48 : i32
          } else {
            scf.yield %33 : i32
          }
          %44 = memref.load %32[] : memref<i1>
          memref.store %44, %31[] : memref<i1>
          %45 = memref.load %31[] : memref<i1>
          %46 = scf.if %45 -> (i32) {
            %47 = memref.load %2[] : memref<i32>
            %48 = arith.addi %34, %c1_i32 : i32
            memref.store %48, %2[] : memref<i32>
            scf.yield %48 : i32
          } else {
            scf.yield %34 : i32
          }
          cf.br ^bb1(%43, %46 : i32, i32)
        ^bb3:  // pred: ^bb1
          scf.yield %33, %34 : i32, i32
        }
        scf.yield %28#0, %28#1 : i32, i32
      } else {
        scf.yield %13, %14 : i32, i32
      }
      scf.yield %27#0, %27#1 : i32, i32
    } else {
      scf.yield %13, %14 : i32, i32
    }
    %23 = memref.load %12[] : memref<i1>
    memref.store %23, %11[] : memref<i1>
    %24 = memref.load %11[] : memref<i1>
    %25 = scf.if %24 -> (i32) {
      %26 = memref.load %3[] : memref<i32>
      %27 = arith.subi %15, %c1_i32 : i32
      memref.store %27, %3[] : memref<i32>
      scf.yield %27 : i32
    } else {
      scf.yield %15 : i32
    }
    cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
  ^bb3:  // pred: ^bb1
    scf.yield
  }
  scf.yield


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %9 = memref.load %6[] : memref<i1>
  %10 = scf.if %9 -> (i32) {
    %26 = memref.get_global @kbm3 : memref<1xi32>
    %27 = memref.load %26[%c0] : memref<1xi32>
    memref.store %27, %3[] : memref<i32>
    scf.yield %27 : i32
  } else {
    scf.yield %1 : i32
  }
  %11 = memref.alloca() : memref<i1>
  %12 = memref.alloca() : memref<i1>
  memref.store %true, %12[] : memref<i1>
  cf.br ^bb1(%1, %1, %10 : i32, i32, i32)

 replaced mlir-asm-printer: Verifying operation: builtin.module
%9 = memref.load %6[] : memref<i1> with mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.get_global @kbm3 : memref<1xi32>
  %27 = memref.load %26[%c0] : memref<1xi32>
  memref.store %27, %3[] : memref<i32>
  scf.yield %27 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.get_global @kbm3 : memref<1xi32>
  %27 = memref.load %26[%c0] : memref<1xi32>
  memref.store %27, %3[] : memref<i32>
  scf.yield %27 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %1 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %1 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %9 = memref.load %6[] : memref<i1>
  %10 = scf.if %true -> (i32) {
    %26 = memref.get_global @kbm3 : memref<1xi32>
    %27 = memref.load %26[%c0] : memref<1xi32>
    memref.store %27, %3[] : memref<i32>
    scf.yield %27 : i32
  } else {
    scf.yield %1 : i32
  }
  %11 = memref.alloca() : memref<i1>
  %12 = memref.alloca() : memref<i1>
  memref.store %true, %12[] : memref<i1>
  cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
  %16 = memref.load %3[] : memref<i32>
  %17 = arith.cmpi sgt, %15, %c0_i32 : i32
  %18 = memref.load %12[] : memref<i1>
  %19 = arith.andi %17, %18 : i1
  cf.cond_br %19, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
  %16 = memref.load %3[] : memref<i32>
  %17 = arith.cmpi sgt, %15, %c0_i32 : i32
  %18 = memref.load %12[] : memref<i1>
  %19 = arith.andi %17, %18 : i1
  cf.cond_br %19, ^bb2, ^bb3
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %20 = memref.load %12[] : memref<i1>
  memref.store %20, %11[] : memref<i1>
  %21 = memref.load %11[] : memref<i1>
  %22:2 = scf.if %21 -> (i32, i32) {
    %26 = memref.load %11[] : memref<i1>
    %27:2 = scf.if %26 -> (i32, i32) {
      %28:2 = scf.execute_region -> (i32, i32) {
        %29 = memref.load %11[] : memref<i1>
        %30 = scf.if %29 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %14 : i32
        }
        %31 = memref.alloca() : memref<i1>
        %32 = memref.alloca() : memref<i1>
        memref.store %true, %32[] : memref<i1>
        cf.br ^bb1(%13, %30 : i32, i32)
      ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
        %35 = memref.load %2[] : memref<i32>
        %36 = memref.get_global @jm : memref<1xi32>
        %37 = memref.load %36[%c0] : memref<1xi32>
        %38 = arith.cmpi slt, %34, %37 : i32
        %39 = memref.load %32[] : memref<i1>
        %40 = arith.andi %38, %39 : i1
        cf.cond_br %40, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %41 = memref.load %32[] : memref<i1>
        memref.store %41, %31[] : memref<i1>
        %42 = memref.load %31[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %47 = memref.load %31[] : memref<i1>
          %48 = scf.if %47 -> (i32) {
            %49 = scf.execute_region -> i32 {
              %50 = memref.load %31[] : memref<i1>
              %51 = scf.if %50 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %33 : i32
              }
              %52 = memref.alloca() : memref<i1>
              %53 = memref.alloca() : memref<i1>
              memref.store %true, %53[] : memref<i1>
              cf.br ^bb1(%51 : i32)
            ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
              %55 = memref.load %0[] : memref<i32>
              %56 = memref.get_global @im : memref<1xi32>
              %57 = memref.load %56[%c0] : memref<1xi32>
              %58 = arith.cmpi slt, %54, %57 : i32
              %59 = memref.load %53[] : memref<i1>
              %60 = arith.andi %58, %59 : i1
              cf.cond_br %60, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %61 = memref.load %53[] : memref<i1>
              memref.store %61, %52[] : memref<i1>
              %62 = memref.load %52[] : memref<i1>
              scf.if %62 {
                %66 = memref.load %4[] : memref<memref<?xf32>>
                %67 = memref.load %0[] : memref<i32>
                %68 = memref.load %2[] : memref<i32>
                %69 = memref.load %56[%c0] : memref<1xi32>
                %70 = arith.muli %34, %69 : i32
                %71 = arith.addi %54, %70 : i32
                %72 = memref.load %3[] : memref<i32>
                %73 = arith.muli %15, %69 : i32
                %74 = memref.load %36[%c0] : memref<1xi32>
                %75 = arith.muli %73, %74 : i32
                %76 = arith.addi %71, %75 : i32
                %77 = arith.index_cast %76 : i32 to index
                %78 = memref.load %5[] : memref<memref<?xf32>>
                %79 = arith.subi %15, %c1_i32 : i32
                %80 = arith.muli %79, %69 : i32
                %81 = arith.muli %80, %74 : i32
                %82 = arith.addi %71, %81 : i32
                %83 = arith.index_cast %82 : i32 to index
                %84 = arith.addi %83, %c0 : index
                %85 = memref.load %arg0[%84] : memref<?xf32>
                %86 = arith.addi %77, %c0 : index
                memref.store %85, %arg2[%86] : memref<?xf32>
              }
              %63 = memref.load %53[] : memref<i1>
              memref.store %63, %52[] : memref<i1>
              %64 = memref.load %52[] : memref<i1>
              %65 = scf.if %64 -> (i32) {
                %66 = memref.load %0[] : memref<i32>
                %67 = arith.addi %54, %c1_i32 : i32
                memref.store %67, %0[] : memref<i32>
                scf.yield %67 : i32
              } else {
                scf.yield %54 : i32
              }
              cf.br ^bb1(%65 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %54 : i32
            }
            scf.yield %49 : i32
          } else {
            scf.yield %33 : i32
          }
          scf.yield %48 : i32
        } else {
          scf.yield %33 : i32
        }
        %44 = memref.load %32[] : memref<i1>
        memref.store %44, %31[] : memref<i1>
        %45 = memref.load %31[] : memref<i1>
        %46 = scf.if %45 -> (i32) {
          %47 = memref.load %2[] : memref<i32>
          %48 = arith.addi %34, %c1_i32 : i32
          memref.store %48, %2[] : memref<i32>
          scf.yield %48 : i32
        } else {
          scf.yield %34 : i32
        }
        cf.br ^bb1(%43, %46 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %33, %34 : i32, i32
      }
      scf.yield %28#0, %28#1 : i32, i32
    } else {
      scf.yield %13, %14 : i32, i32
    }
    scf.yield %27#0, %27#1 : i32, i32
  } else {
    scf.yield %13, %14 : i32, i32
  }
  %23 = memref.load %12[] : memref<i1>
  memref.store %23, %11[] : memref<i1>
  %24 = memref.load %11[] : memref<i1>
  %25 = scf.if %24 -> (i32) {
    %26 = memref.load %3[] : memref<i32>
    %27 = arith.subi %15, %c1_i32 : i32
    memref.store %27, %3[] : memref<i32>
    scf.yield %27 : i32
  } else {
    scf.yield %15 : i32
  }
  cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.load %11[] : memref<i1>
  %27:2 = scf.if %26 -> (i32, i32) {
    %28:2 = scf.execute_region -> (i32, i32) {
      %29 = memref.load %11[] : memref<i1>
      %30 = scf.if %29 -> (i32) {
        memref.store %c0_i32, %2[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %14 : i32
      }
      %31 = memref.alloca() : memref<i1>
      %32 = memref.alloca() : memref<i1>
      memref.store %true, %32[] : memref<i1>
      cf.br ^bb1(%13, %30 : i32, i32)
    ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
      %35 = memref.load %2[] : memref<i32>
      %36 = memref.get_global @jm : memref<1xi32>
      %37 = memref.load %36[%c0] : memref<1xi32>
      %38 = arith.cmpi slt, %34, %37 : i32
      %39 = memref.load %32[] : memref<i1>
      %40 = arith.andi %38, %39 : i1
      cf.cond_br %40, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %41 = memref.load %32[] : memref<i1>
      memref.store %41, %31[] : memref<i1>
      %42 = memref.load %31[] : memref<i1>
      %43 = scf.if %42 -> (i32) {
        %47 = memref.load %31[] : memref<i1>
        %48 = scf.if %47 -> (i32) {
          %49 = scf.execute_region -> i32 {
            %50 = memref.load %31[] : memref<i1>
            %51 = scf.if %50 -> (i32) {
              memref.store %c0_i32, %0[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %33 : i32
            }
            %52 = memref.alloca() : memref<i1>
            %53 = memref.alloca() : memref<i1>
            memref.store %true, %53[] : memref<i1>
            cf.br ^bb1(%51 : i32)
          ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
            %55 = memref.load %0[] : memref<i32>
            %56 = memref.get_global @im : memref<1xi32>
            %57 = memref.load %56[%c0] : memref<1xi32>
            %58 = arith.cmpi slt, %54, %57 : i32
            %59 = memref.load %53[] : memref<i1>
            %60 = arith.andi %58, %59 : i1
            cf.cond_br %60, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %61 = memref.load %53[] : memref<i1>
            memref.store %61, %52[] : memref<i1>
            %62 = memref.load %52[] : memref<i1>
            scf.if %62 {
              %66 = memref.load %4[] : memref<memref<?xf32>>
              %67 = memref.load %0[] : memref<i32>
              %68 = memref.load %2[] : memref<i32>
              %69 = memref.load %56[%c0] : memref<1xi32>
              %70 = arith.muli %34, %69 : i32
              %71 = arith.addi %54, %70 : i32
              %72 = memref.load %3[] : memref<i32>
              %73 = arith.muli %15, %69 : i32
              %74 = memref.load %36[%c0] : memref<1xi32>
              %75 = arith.muli %73, %74 : i32
              %76 = arith.addi %71, %75 : i32
              %77 = arith.index_cast %76 : i32 to index
              %78 = memref.load %5[] : memref<memref<?xf32>>
              %79 = arith.subi %15, %c1_i32 : i32
              %80 = arith.muli %79, %69 : i32
              %81 = arith.muli %80, %74 : i32
              %82 = arith.addi %71, %81 : i32
              %83 = arith.index_cast %82 : i32 to index
              %84 = arith.addi %83, %c0 : index
              %85 = memref.load %arg0[%84] : memref<?xf32>
              %86 = arith.addi %77, %c0 : index
              memref.store %85, %arg2[%86] : memref<?xf32>
            }
            %63 = memref.load %53[] : memref<i1>
            memref.store %63, %52[] : memref<i1>
            %64 = memref.load %52[] : memref<i1>
            %65 = scf.if %64 -> (i32) {
              %66 = memref.load %0[] : memref<i32>
              %67 = arith.addi %54, %c1_i32 : i32
              memref.store %67, %0[] : memref<i32>
              scf.yield %67 : i32
            } else {
              scf.yield %54 : i32
            }
            cf.br ^bb1(%65 : i32)
          ^bb3:  // pred: ^bb1
            scf.yield %54 : i32
          }
          scf.yield %49 : i32
        } else {
          scf.yield %33 : i32
        }
        scf.yield %48 : i32
      } else {
        scf.yield %33 : i32
      }
      %44 = memref.load %32[] : memref<i1>
      memref.store %44, %31[] : memref<i1>
      %45 = memref.load %31[] : memref<i1>
      %46 = scf.if %45 -> (i32) {
        %47 = memref.load %2[] : memref<i32>
        %48 = arith.addi %34, %c1_i32 : i32
        memref.store %48, %2[] : memref<i32>
        scf.yield %48 : i32
      } else {
        scf.yield %34 : i32
      }
      cf.br ^bb1(%43, %46 : i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield %33, %34 : i32, i32
    }
    scf.yield %28#0, %28#1 : i32, i32
  } else {
    scf.yield %13, %14 : i32, i32
  }
  scf.yield %27#0, %27#1 : i32, i32


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %28:2 = scf.execute_region -> (i32, i32) {
    %29 = memref.load %11[] : memref<i1>
    %30 = scf.if %29 -> (i32) {
      memref.store %c0_i32, %2[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %14 : i32
    }
    %31 = memref.alloca() : memref<i1>
    %32 = memref.alloca() : memref<i1>
    memref.store %true, %32[] : memref<i1>
    cf.br ^bb1(%13, %30 : i32, i32)
  ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
    %35 = memref.load %2[] : memref<i32>
    %36 = memref.get_global @jm : memref<1xi32>
    %37 = memref.load %36[%c0] : memref<1xi32>
    %38 = arith.cmpi slt, %34, %37 : i32
    %39 = memref.load %32[] : memref<i1>
    %40 = arith.andi %38, %39 : i1
    cf.cond_br %40, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %41 = memref.load %32[] : memref<i1>
    memref.store %41, %31[] : memref<i1>
    %42 = memref.load %31[] : memref<i1>
    %43 = scf.if %42 -> (i32) {
      %47 = memref.load %31[] : memref<i1>
      %48 = scf.if %47 -> (i32) {
        %49 = scf.execute_region -> i32 {
          %50 = memref.load %31[] : memref<i1>
          %51 = scf.if %50 -> (i32) {
            memref.store %c0_i32, %0[] : memref<i32>
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %33 : i32
          }
          %52 = memref.alloca() : memref<i1>
          %53 = memref.alloca() : memref<i1>
          memref.store %true, %53[] : memref<i1>
          cf.br ^bb1(%51 : i32)
        ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
          %55 = memref.load %0[] : memref<i32>
          %56 = memref.get_global @im : memref<1xi32>
          %57 = memref.load %56[%c0] : memref<1xi32>
          %58 = arith.cmpi slt, %54, %57 : i32
          %59 = memref.load %53[] : memref<i1>
          %60 = arith.andi %58, %59 : i1
          cf.cond_br %60, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %61 = memref.load %53[] : memref<i1>
          memref.store %61, %52[] : memref<i1>
          %62 = memref.load %52[] : memref<i1>
          scf.if %62 {
            %66 = memref.load %4[] : memref<memref<?xf32>>
            %67 = memref.load %0[] : memref<i32>
            %68 = memref.load %2[] : memref<i32>
            %69 = memref.load %56[%c0] : memref<1xi32>
            %70 = arith.muli %34, %69 : i32
            %71 = arith.addi %54, %70 : i32
            %72 = memref.load %3[] : memref<i32>
            %73 = arith.muli %15, %69 : i32
            %74 = memref.load %36[%c0] : memref<1xi32>
            %75 = arith.muli %73, %74 : i32
            %76 = arith.addi %71, %75 : i32
            %77 = arith.index_cast %76 : i32 to index
            %78 = memref.load %5[] : memref<memref<?xf32>>
            %79 = arith.subi %15, %c1_i32 : i32
            %80 = arith.muli %79, %69 : i32
            %81 = arith.muli %80, %74 : i32
            %82 = arith.addi %71, %81 : i32
            %83 = arith.index_cast %82 : i32 to index
            %84 = arith.addi %83, %c0 : index
            %85 = memref.load %arg0[%84] : memref<?xf32>
            %86 = arith.addi %77, %c0 : index
            memref.store %85, %arg2[%86] : memref<?xf32>
          }
          %63 = memref.load %53[] : memref<i1>
          memref.store %63, %52[] : memref<i1>
          %64 = memref.load %52[] : memref<i1>
          %65 = scf.if %64 -> (i32) {
            %66 = memref.load %0[] : memref<i32>
            %67 = arith.addi %54, %c1_i32 : i32
            memref.store %67, %0[] : memref<i32>
            scf.yield %67 : i32
          } else {
            scf.yield %54 : i32
          }
          cf.br ^bb1(%65 : i32)
        ^bb3:  // pred: ^bb1
          scf.yield %54 : i32
        }
        scf.yield %49 : i32
      } else {
        scf.yield %33 : i32
      }
      scf.yield %48 : i32
    } else {
      scf.yield %33 : i32
    }
    %44 = memref.load %32[] : memref<i1>
    memref.store %44, %31[] : memref<i1>
    %45 = memref.load %31[] : memref<i1>
    %46 = scf.if %45 -> (i32) {
      %47 = memref.load %2[] : memref<i32>
      %48 = arith.addi %34, %c1_i32 : i32
      memref.store %48, %2[] : memref<i32>
      scf.yield %48 : i32
    } else {
      scf.yield %34 : i32
    }
    cf.br ^bb1(%43, %46 : i32, i32)
  ^bb3:  // pred: ^bb1
    scf.yield %33, %34 : i32, i32
  }
  scf.yield %28#0, %28#1 : i32, i32


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %29 = memref.load %11[] : memref<i1>
  %30 = scf.if %29 -> (i32) {
    memref.store %c0_i32, %2[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %14 : i32
  }
  %31 = memref.alloca() : memref<i1>
  %32 = memref.alloca() : memref<i1>
  memref.store %true, %32[] : memref<i1>
  cf.br ^bb1(%13, %30 : i32, i32)


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %2[] : memref<i32>
  scf.yield %c0_i32 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %2[] : memref<i32>
  scf.yield %c0_i32 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %14 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %14 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %29 = memref.load %11[] : memref<i1>
  %30 = scf.if %29 -> (i32) {
    memref.store %c0_i32, %2[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %14 : i32
  }
  %31 = memref.alloca() : memref<i1>
  %32 = memref.alloca() : memref<i1>
  memref.store %true, %32[] : memref<i1>
  cf.br ^bb1(%13, %30 : i32, i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
  %35 = memref.load %2[] : memref<i32>
  %36 = memref.get_global @jm : memref<1xi32>
  %37 = memref.load %36[%c0] : memref<1xi32>
  %38 = arith.cmpi slt, %34, %37 : i32
  %39 = memref.load %32[] : memref<i1>
  %40 = arith.andi %38, %39 : i1
  cf.cond_br %40, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
  %35 = memref.load %2[] : memref<i32>
  %36 = memref.get_global @jm : memref<1xi32>
  %37 = memref.load %36[%c0] : memref<1xi32>
  %38 = arith.cmpi slt, %34, %37 : i32
  %39 = memref.load %32[] : memref<i1>
  %40 = arith.andi %38, %39 : i1
  cf.cond_br %40, ^bb2, ^bb3
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %41, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %42 -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %47 -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %50 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %59 : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %61, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %62 {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %63, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %64 -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %44, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %45 -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %31[] : memref<i1>
  %48 = scf.if %47 -> (i32) {
    %49 = scf.execute_region -> i32 {
      %50 = memref.load %31[] : memref<i1>
      %51 = scf.if %50 -> (i32) {
        memref.store %c0_i32, %0[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %33 : i32
      }
      %52 = memref.alloca() : memref<i1>
      %53 = memref.alloca() : memref<i1>
      memref.store %true, %53[] : memref<i1>
      cf.br ^bb1(%51 : i32)
    ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
      %55 = memref.load %0[] : memref<i32>
      %56 = memref.get_global @im : memref<1xi32>
      %57 = memref.load %56[%c0] : memref<1xi32>
      %58 = arith.cmpi slt, %54, %57 : i32
      %59 = memref.load %53[] : memref<i1>
      %60 = arith.andi %58, %59 : i1
      cf.cond_br %60, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %61 = memref.load %53[] : memref<i1>
      memref.store %61, %52[] : memref<i1>
      %62 = memref.load %52[] : memref<i1>
      scf.if %62 {
        %66 = memref.load %4[] : memref<memref<?xf32>>
        %67 = memref.load %0[] : memref<i32>
        %68 = memref.load %2[] : memref<i32>
        %69 = memref.load %56[%c0] : memref<1xi32>
        %70 = arith.muli %34, %69 : i32
        %71 = arith.addi %54, %70 : i32
        %72 = memref.load %3[] : memref<i32>
        %73 = arith.muli %15, %69 : i32
        %74 = memref.load %36[%c0] : memref<1xi32>
        %75 = arith.muli %73, %74 : i32
        %76 = arith.addi %71, %75 : i32
        %77 = arith.index_cast %76 : i32 to index
        %78 = memref.load %5[] : memref<memref<?xf32>>
        %79 = arith.subi %15, %c1_i32 : i32
        %80 = arith.muli %79, %69 : i32
        %81 = arith.muli %80, %74 : i32
        %82 = arith.addi %71, %81 : i32
        %83 = arith.index_cast %82 : i32 to index
        %84 = arith.addi %83, %c0 : index
        %85 = memref.load %arg0[%84] : memref<?xf32>
        %86 = arith.addi %77, %c0 : index
        memref.store %85, %arg2[%86] : memref<?xf32>
      }
      %63 = memref.load %53[] : memref<i1>
      memref.store %63, %52[] : memref<i1>
      %64 = memref.load %52[] : memref<i1>
      %65 = scf.if %64 -> (i32) {
        %66 = memref.load %0[] : memref<i32>
        %67 = arith.addi %54, %c1_i32 : i32
        memref.store %67, %0[] : memref<i32>
        scf.yield %67 : i32
      } else {
        scf.yield %54 : i32
      }
      cf.br ^bb1(%65 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %54 : i32
    }
    scf.yield %49 : i32
  } else {
    scf.yield %33 : i32
  }
  scf.yield %48 : i32


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %49 = scf.execute_region -> i32 {
    %50 = memref.load %31[] : memref<i1>
    %51 = scf.if %50 -> (i32) {
      memref.store %c0_i32, %0[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %33 : i32
    }
    %52 = memref.alloca() : memref<i1>
    %53 = memref.alloca() : memref<i1>
    memref.store %true, %53[] : memref<i1>
    cf.br ^bb1(%51 : i32)
  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
    %55 = memref.load %0[] : memref<i32>
    %56 = memref.get_global @im : memref<1xi32>
    %57 = memref.load %56[%c0] : memref<1xi32>
    %58 = arith.cmpi slt, %54, %57 : i32
    %59 = memref.load %53[] : memref<i1>
    %60 = arith.andi %58, %59 : i1
    cf.cond_br %60, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %61 = memref.load %53[] : memref<i1>
    memref.store %61, %52[] : memref<i1>
    %62 = memref.load %52[] : memref<i1>
    scf.if %62 {
      %66 = memref.load %4[] : memref<memref<?xf32>>
      %67 = memref.load %0[] : memref<i32>
      %68 = memref.load %2[] : memref<i32>
      %69 = memref.load %56[%c0] : memref<1xi32>
      %70 = arith.muli %34, %69 : i32
      %71 = arith.addi %54, %70 : i32
      %72 = memref.load %3[] : memref<i32>
      %73 = arith.muli %15, %69 : i32
      %74 = memref.load %36[%c0] : memref<1xi32>
      %75 = arith.muli %73, %74 : i32
      %76 = arith.addi %71, %75 : i32
      %77 = arith.index_cast %76 : i32 to index
      %78 = memref.load %5[] : memref<memref<?xf32>>
      %79 = arith.subi %15, %c1_i32 : i32
      %80 = arith.muli %79, %69 : i32
      %81 = arith.muli %80, %74 : i32
      %82 = arith.addi %71, %81 : i32
      %83 = arith.index_cast %82 : i32 to index
      %84 = arith.addi %83, %c0 : index
      %85 = memref.load %arg0[%84] : memref<?xf32>
      %86 = arith.addi %77, %c0 : index
      memref.store %85, %arg2[%86] : memref<?xf32>
    }
    %63 = memref.load %53[] : memref<i1>
    memref.store %63, %52[] : memref<i1>
    %64 = memref.load %52[] : memref<i1>
    %65 = scf.if %64 -> (i32) {
      %66 = memref.load %0[] : memref<i32>
      %67 = arith.addi %54, %c1_i32 : i32
      memref.store %67, %0[] : memref<i32>
      scf.yield %67 : i32
    } else {
      scf.yield %54 : i32
    }
    cf.br ^bb1(%65 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %54 : i32
  }
  scf.yield %49 : i32


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %50 = memref.load %31[] : memref<i1>
  %51 = scf.if %50 -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %33 : i32
  }
  %52 = memref.alloca() : memref<i1>
  %53 = memref.alloca() : memref<i1>
  memref.store %true, %53[] : memref<i1>
  cf.br ^bb1(%51 : i32)


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield %c0_i32 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield %c0_i32 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %50 = memref.load %31[] : memref<i1>
  %51 = scf.if %50 -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %33 : i32
  }
  %52 = memref.alloca() : memref<i1>
  %53 = memref.alloca() : memref<i1>
  memref.store %true, %53[] : memref<i1>
  cf.br ^bb1(%51 : i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %59 : i1
  cf.cond_br %60, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %59 : i1
  cf.cond_br %60, ^bb2, ^bb3
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %61, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %62 {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %63, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %64 -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
  scf.yield
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %0[] : memref<i32>
  %67 = arith.addi %54, %c1_i32 : i32
  memref.store %67, %0[] : memref<i32>
  scf.yield %67 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %0[] : memref<i32>
  %67 = arith.addi %54, %c1_i32 : i32
  memref.store %67, %0[] : memref<i32>
  scf.yield %67 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %54 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %54 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %61, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %62 {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %63, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %64 -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %49 = scf.execute_region -> i32 {
    %50 = memref.load %31[] : memref<i1>
    %51 = scf.if %50 -> (i32) {
      memref.store %c0_i32, %0[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %33 : i32
    }
    %52 = memref.alloca() : memref<i1>
    %53 = memref.alloca() : memref<i1>
    memref.store %true, %53[] : memref<i1>
    cf.br ^bb1(%51 : i32)
  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
    %55 = memref.load %0[] : memref<i32>
    %56 = memref.get_global @im : memref<1xi32>
    %57 = memref.load %56[%c0] : memref<1xi32>
    %58 = arith.cmpi slt, %54, %57 : i32
    %59 = memref.load %53[] : memref<i1>
    %60 = arith.andi %58, %59 : i1
    cf.cond_br %60, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %61 = memref.load %53[] : memref<i1>
    memref.store %61, %52[] : memref<i1>
    %62 = memref.load %52[] : memref<i1>
    scf.if %62 {
      %66 = memref.load %4[] : memref<memref<?xf32>>
      %67 = memref.load %0[] : memref<i32>
      %68 = memref.load %2[] : memref<i32>
      %69 = memref.load %56[%c0] : memref<1xi32>
      %70 = arith.muli %34, %69 : i32
      %71 = arith.addi %54, %70 : i32
      %72 = memref.load %3[] : memref<i32>
      %73 = arith.muli %15, %69 : i32
      %74 = memref.load %36[%c0] : memref<1xi32>
      %75 = arith.muli %73, %74 : i32
      %76 = arith.addi %71, %75 : i32
      %77 = arith.index_cast %76 : i32 to index
      %78 = memref.load %5[] : memref<memref<?xf32>>
      %79 = arith.subi %15, %c1_i32 : i32
      %80 = arith.muli %79, %69 : i32
      %81 = arith.muli %80, %74 : i32
      %82 = arith.addi %71, %81 : i32
      %83 = arith.index_cast %82 : i32 to index
      %84 = arith.addi %83, %c0 : index
      %85 = memref.load %arg0[%84] : memref<?xf32>
      %86 = arith.addi %77, %c0 : index
      memref.store %85, %arg2[%86] : memref<?xf32>
    }
    %63 = memref.load %53[] : memref<i1>
    memref.store %63, %52[] : memref<i1>
    %64 = memref.load %52[] : memref<i1>
    %65 = scf.if %64 -> (i32) {
      %66 = memref.load %0[] : memref<i32>
      %67 = arith.addi %54, %c1_i32 : i32
      memref.store %67, %0[] : memref<i32>
      scf.yield %67 : i32
    } else {
      scf.yield %54 : i32
    }
    cf.br ^bb1(%65 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %54 : i32
  }
  scf.yield %49 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %31[] : memref<i1>
  %48 = scf.if %47 -> (i32) {
    %49 = scf.execute_region -> i32 {
      %50 = memref.load %31[] : memref<i1>
      %51 = scf.if %50 -> (i32) {
        memref.store %c0_i32, %0[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %33 : i32
      }
      %52 = memref.alloca() : memref<i1>
      %53 = memref.alloca() : memref<i1>
      memref.store %true, %53[] : memref<i1>
      cf.br ^bb1(%51 : i32)
    ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
      %55 = memref.load %0[] : memref<i32>
      %56 = memref.get_global @im : memref<1xi32>
      %57 = memref.load %56[%c0] : memref<1xi32>
      %58 = arith.cmpi slt, %54, %57 : i32
      %59 = memref.load %53[] : memref<i1>
      %60 = arith.andi %58, %59 : i1
      cf.cond_br %60, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %61 = memref.load %53[] : memref<i1>
      memref.store %61, %52[] : memref<i1>
      %62 = memref.load %52[] : memref<i1>
      scf.if %62 {
        %66 = memref.load %4[] : memref<memref<?xf32>>
        %67 = memref.load %0[] : memref<i32>
        %68 = memref.load %2[] : memref<i32>
        %69 = memref.load %56[%c0] : memref<1xi32>
        %70 = arith.muli %34, %69 : i32
        %71 = arith.addi %54, %70 : i32
        %72 = memref.load %3[] : memref<i32>
        %73 = arith.muli %15, %69 : i32
        %74 = memref.load %36[%c0] : memref<1xi32>
        %75 = arith.muli %73, %74 : i32
        %76 = arith.addi %71, %75 : i32
        %77 = arith.index_cast %76 : i32 to index
        %78 = memref.load %5[] : memref<memref<?xf32>>
        %79 = arith.subi %15, %c1_i32 : i32
        %80 = arith.muli %79, %69 : i32
        %81 = arith.muli %80, %74 : i32
        %82 = arith.addi %71, %81 : i32
        %83 = arith.index_cast %82 : i32 to index
        %84 = arith.addi %83, %c0 : index
        %85 = memref.load %arg0[%84] : memref<?xf32>
        %86 = arith.addi %77, %c0 : index
        memref.store %85, %arg2[%86] : memref<?xf32>
      }
      %63 = memref.load %53[] : memref<i1>
      memref.store %63, %52[] : memref<i1>
      %64 = memref.load %52[] : memref<i1>
      %65 = scf.if %64 -> (i32) {
        %66 = memref.load %0[] : memref<i32>
        %67 = arith.addi %54, %c1_i32 : i32
        memref.store %67, %0[] : memref<i32>
        scf.yield %67 : i32
      } else {
        scf.yield %54 : i32
      }
      cf.br ^bb1(%65 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %54 : i32
    }
    scf.yield %49 : i32
  } else {
    scf.yield %33 : i32
  }
  scf.yield %48 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %2[] : memref<i32>
  %48 = arith.addi %34, %c1_i32 : i32
  memref.store %48, %2[] : memref<i32>
  scf.yield %48 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %2[] : memref<i32>
  %48 = arith.addi %34, %c1_i32 : i32
  memref.store %48, %2[] : memref<i32>
  scf.yield %48 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %34 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %34 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %41, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %42 -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %47 -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %50 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %59 : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %61, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %62 {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %63, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %64 -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %44, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %45 -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %33, %34 : i32, i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %33, %34 : i32, i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %28:2 = scf.execute_region -> (i32, i32) {
    %29 = memref.load %11[] : memref<i1>
    %30 = scf.if %29 -> (i32) {
      memref.store %c0_i32, %2[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %14 : i32
    }
    %31 = memref.alloca() : memref<i1>
    %32 = memref.alloca() : memref<i1>
    memref.store %true, %32[] : memref<i1>
    cf.br ^bb1(%13, %30 : i32, i32)
  ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
    %35 = memref.load %2[] : memref<i32>
    %36 = memref.get_global @jm : memref<1xi32>
    %37 = memref.load %36[%c0] : memref<1xi32>
    %38 = arith.cmpi slt, %34, %37 : i32
    %39 = memref.load %32[] : memref<i1>
    %40 = arith.andi %38, %39 : i1
    cf.cond_br %40, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %41 = memref.load %32[] : memref<i1>
    memref.store %41, %31[] : memref<i1>
    %42 = memref.load %31[] : memref<i1>
    %43 = scf.if %42 -> (i32) {
      %47 = memref.load %31[] : memref<i1>
      %48 = scf.if %47 -> (i32) {
        %49 = scf.execute_region -> i32 {
          %50 = memref.load %31[] : memref<i1>
          %51 = scf.if %50 -> (i32) {
            memref.store %c0_i32, %0[] : memref<i32>
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %33 : i32
          }
          %52 = memref.alloca() : memref<i1>
          %53 = memref.alloca() : memref<i1>
          memref.store %true, %53[] : memref<i1>
          cf.br ^bb1(%51 : i32)
        ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
          %55 = memref.load %0[] : memref<i32>
          %56 = memref.get_global @im : memref<1xi32>
          %57 = memref.load %56[%c0] : memref<1xi32>
          %58 = arith.cmpi slt, %54, %57 : i32
          %59 = memref.load %53[] : memref<i1>
          %60 = arith.andi %58, %59 : i1
          cf.cond_br %60, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %61 = memref.load %53[] : memref<i1>
          memref.store %61, %52[] : memref<i1>
          %62 = memref.load %52[] : memref<i1>
          scf.if %62 {
            %66 = memref.load %4[] : memref<memref<?xf32>>
            %67 = memref.load %0[] : memref<i32>
            %68 = memref.load %2[] : memref<i32>
            %69 = memref.load %56[%c0] : memref<1xi32>
            %70 = arith.muli %34, %69 : i32
            %71 = arith.addi %54, %70 : i32
            %72 = memref.load %3[] : memref<i32>
            %73 = arith.muli %15, %69 : i32
            %74 = memref.load %36[%c0] : memref<1xi32>
            %75 = arith.muli %73, %74 : i32
            %76 = arith.addi %71, %75 : i32
            %77 = arith.index_cast %76 : i32 to index
            %78 = memref.load %5[] : memref<memref<?xf32>>
            %79 = arith.subi %15, %c1_i32 : i32
            %80 = arith.muli %79, %69 : i32
            %81 = arith.muli %80, %74 : i32
            %82 = arith.addi %71, %81 : i32
            %83 = arith.index_cast %82 : i32 to index
            %84 = arith.addi %83, %c0 : index
            %85 = memref.load %arg0[%84] : memref<?xf32>
            %86 = arith.addi %77, %c0 : index
            memref.store %85, %arg2[%86] : memref<?xf32>
          }
          %63 = memref.load %53[] : memref<i1>
          memref.store %63, %52[] : memref<i1>
          %64 = memref.load %52[] : memref<i1>
          %65 = scf.if %64 -> (i32) {
            %66 = memref.load %0[] : memref<i32>
            %67 = arith.addi %54, %c1_i32 : i32
            memref.store %67, %0[] : memref<i32>
            scf.yield %67 : i32
          } else {
            scf.yield %54 : i32
          }
          cf.br ^bb1(%65 : i32)
        ^bb3:  // pred: ^bb1
          scf.yield %54 : i32
        }
        scf.yield %49 : i32
      } else {
        scf.yield %33 : i32
      }
      scf.yield %48 : i32
    } else {
      scf.yield %33 : i32
    }
    %44 = memref.load %32[] : memref<i1>
    memref.store %44, %31[] : memref<i1>
    %45 = memref.load %31[] : memref<i1>
    %46 = scf.if %45 -> (i32) {
      %47 = memref.load %2[] : memref<i32>
      %48 = arith.addi %34, %c1_i32 : i32
      memref.store %48, %2[] : memref<i32>
      scf.yield %48 : i32
    } else {
      scf.yield %34 : i32
    }
    cf.br ^bb1(%43, %46 : i32, i32)
  ^bb3:  // pred: ^bb1
    scf.yield %33, %34 : i32, i32
  }
  scf.yield %28#0, %28#1 : i32, i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %13, %14 : i32, i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %13, %14 : i32, i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.load %11[] : memref<i1>
  %27:2 = scf.if %26 -> (i32, i32) {
    %28:2 = scf.execute_region -> (i32, i32) {
      %29 = memref.load %11[] : memref<i1>
      %30 = scf.if %29 -> (i32) {
        memref.store %c0_i32, %2[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %14 : i32
      }
      %31 = memref.alloca() : memref<i1>
      %32 = memref.alloca() : memref<i1>
      memref.store %true, %32[] : memref<i1>
      cf.br ^bb1(%13, %30 : i32, i32)
    ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
      %35 = memref.load %2[] : memref<i32>
      %36 = memref.get_global @jm : memref<1xi32>
      %37 = memref.load %36[%c0] : memref<1xi32>
      %38 = arith.cmpi slt, %34, %37 : i32
      %39 = memref.load %32[] : memref<i1>
      %40 = arith.andi %38, %39 : i1
      cf.cond_br %40, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %41 = memref.load %32[] : memref<i1>
      memref.store %41, %31[] : memref<i1>
      %42 = memref.load %31[] : memref<i1>
      %43 = scf.if %42 -> (i32) {
        %47 = memref.load %31[] : memref<i1>
        %48 = scf.if %47 -> (i32) {
          %49 = scf.execute_region -> i32 {
            %50 = memref.load %31[] : memref<i1>
            %51 = scf.if %50 -> (i32) {
              memref.store %c0_i32, %0[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %33 : i32
            }
            %52 = memref.alloca() : memref<i1>
            %53 = memref.alloca() : memref<i1>
            memref.store %true, %53[] : memref<i1>
            cf.br ^bb1(%51 : i32)
          ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
            %55 = memref.load %0[] : memref<i32>
            %56 = memref.get_global @im : memref<1xi32>
            %57 = memref.load %56[%c0] : memref<1xi32>
            %58 = arith.cmpi slt, %54, %57 : i32
            %59 = memref.load %53[] : memref<i1>
            %60 = arith.andi %58, %59 : i1
            cf.cond_br %60, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %61 = memref.load %53[] : memref<i1>
            memref.store %61, %52[] : memref<i1>
            %62 = memref.load %52[] : memref<i1>
            scf.if %62 {
              %66 = memref.load %4[] : memref<memref<?xf32>>
              %67 = memref.load %0[] : memref<i32>
              %68 = memref.load %2[] : memref<i32>
              %69 = memref.load %56[%c0] : memref<1xi32>
              %70 = arith.muli %34, %69 : i32
              %71 = arith.addi %54, %70 : i32
              %72 = memref.load %3[] : memref<i32>
              %73 = arith.muli %15, %69 : i32
              %74 = memref.load %36[%c0] : memref<1xi32>
              %75 = arith.muli %73, %74 : i32
              %76 = arith.addi %71, %75 : i32
              %77 = arith.index_cast %76 : i32 to index
              %78 = memref.load %5[] : memref<memref<?xf32>>
              %79 = arith.subi %15, %c1_i32 : i32
              %80 = arith.muli %79, %69 : i32
              %81 = arith.muli %80, %74 : i32
              %82 = arith.addi %71, %81 : i32
              %83 = arith.index_cast %82 : i32 to index
              %84 = arith.addi %83, %c0 : index
              %85 = memref.load %arg0[%84] : memref<?xf32>
              %86 = arith.addi %77, %c0 : index
              memref.store %85, %arg2[%86] : memref<?xf32>
            }
            %63 = memref.load %53[] : memref<i1>
            memref.store %63, %52[] : memref<i1>
            %64 = memref.load %52[] : memref<i1>
            %65 = scf.if %64 -> (i32) {
              %66 = memref.load %0[] : memref<i32>
              %67 = arith.addi %54, %c1_i32 : i32
              memref.store %67, %0[] : memref<i32>
              scf.yield %67 : i32
            } else {
              scf.yield %54 : i32
            }
            cf.br ^bb1(%65 : i32)
          ^bb3:  // pred: ^bb1
            scf.yield %54 : i32
          }
          scf.yield %49 : i32
        } else {
          scf.yield %33 : i32
        }
        scf.yield %48 : i32
      } else {
        scf.yield %33 : i32
      }
      %44 = memref.load %32[] : memref<i1>
      memref.store %44, %31[] : memref<i1>
      %45 = memref.load %31[] : memref<i1>
      %46 = scf.if %45 -> (i32) {
        %47 = memref.load %2[] : memref<i32>
        %48 = arith.addi %34, %c1_i32 : i32
        memref.store %48, %2[] : memref<i32>
        scf.yield %48 : i32
      } else {
        scf.yield %34 : i32
      }
      cf.br ^bb1(%43, %46 : i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield %33, %34 : i32, i32
    }
    scf.yield %28#0, %28#1 : i32, i32
  } else {
    scf.yield %13, %14 : i32, i32
  }
  scf.yield %27#0, %27#1 : i32, i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %13, %14 : i32, i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %13, %14 : i32, i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.load %3[] : memref<i32>
  %27 = arith.subi %15, %c1_i32 : i32
  memref.store %27, %3[] : memref<i32>
  scf.yield %27 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.load %3[] : memref<i32>
  %27 = arith.subi %15, %c1_i32 : i32
  memref.store %27, %3[] : memref<i32>
  scf.yield %27 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %15 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %15 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %20 = memref.load %12[] : memref<i1>
  memref.store %20, %11[] : memref<i1>
  %21 = memref.load %11[] : memref<i1>
  %22:2 = scf.if %21 -> (i32, i32) {
    %26 = memref.load %11[] : memref<i1>
    %27:2 = scf.if %26 -> (i32, i32) {
      %28:2 = scf.execute_region -> (i32, i32) {
        %29 = memref.load %11[] : memref<i1>
        %30 = scf.if %29 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %14 : i32
        }
        %31 = memref.alloca() : memref<i1>
        %32 = memref.alloca() : memref<i1>
        memref.store %true, %32[] : memref<i1>
        cf.br ^bb1(%13, %30 : i32, i32)
      ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
        %35 = memref.load %2[] : memref<i32>
        %36 = memref.get_global @jm : memref<1xi32>
        %37 = memref.load %36[%c0] : memref<1xi32>
        %38 = arith.cmpi slt, %34, %37 : i32
        %39 = memref.load %32[] : memref<i1>
        %40 = arith.andi %38, %39 : i1
        cf.cond_br %40, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %41 = memref.load %32[] : memref<i1>
        memref.store %41, %31[] : memref<i1>
        %42 = memref.load %31[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %47 = memref.load %31[] : memref<i1>
          %48 = scf.if %47 -> (i32) {
            %49 = scf.execute_region -> i32 {
              %50 = memref.load %31[] : memref<i1>
              %51 = scf.if %50 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %33 : i32
              }
              %52 = memref.alloca() : memref<i1>
              %53 = memref.alloca() : memref<i1>
              memref.store %true, %53[] : memref<i1>
              cf.br ^bb1(%51 : i32)
            ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
              %55 = memref.load %0[] : memref<i32>
              %56 = memref.get_global @im : memref<1xi32>
              %57 = memref.load %56[%c0] : memref<1xi32>
              %58 = arith.cmpi slt, %54, %57 : i32
              %59 = memref.load %53[] : memref<i1>
              %60 = arith.andi %58, %59 : i1
              cf.cond_br %60, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %61 = memref.load %53[] : memref<i1>
              memref.store %61, %52[] : memref<i1>
              %62 = memref.load %52[] : memref<i1>
              scf.if %62 {
                %66 = memref.load %4[] : memref<memref<?xf32>>
                %67 = memref.load %0[] : memref<i32>
                %68 = memref.load %2[] : memref<i32>
                %69 = memref.load %56[%c0] : memref<1xi32>
                %70 = arith.muli %34, %69 : i32
                %71 = arith.addi %54, %70 : i32
                %72 = memref.load %3[] : memref<i32>
                %73 = arith.muli %15, %69 : i32
                %74 = memref.load %36[%c0] : memref<1xi32>
                %75 = arith.muli %73, %74 : i32
                %76 = arith.addi %71, %75 : i32
                %77 = arith.index_cast %76 : i32 to index
                %78 = memref.load %5[] : memref<memref<?xf32>>
                %79 = arith.subi %15, %c1_i32 : i32
                %80 = arith.muli %79, %69 : i32
                %81 = arith.muli %80, %74 : i32
                %82 = arith.addi %71, %81 : i32
                %83 = arith.index_cast %82 : i32 to index
                %84 = arith.addi %83, %c0 : index
                %85 = memref.load %arg0[%84] : memref<?xf32>
                %86 = arith.addi %77, %c0 : index
                memref.store %85, %arg2[%86] : memref<?xf32>
              }
              %63 = memref.load %53[] : memref<i1>
              memref.store %63, %52[] : memref<i1>
              %64 = memref.load %52[] : memref<i1>
              %65 = scf.if %64 -> (i32) {
                %66 = memref.load %0[] : memref<i32>
                %67 = arith.addi %54, %c1_i32 : i32
                memref.store %67, %0[] : memref<i32>
                scf.yield %67 : i32
              } else {
                scf.yield %54 : i32
              }
              cf.br ^bb1(%65 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %54 : i32
            }
            scf.yield %49 : i32
          } else {
            scf.yield %33 : i32
          }
          scf.yield %48 : i32
        } else {
          scf.yield %33 : i32
        }
        %44 = memref.load %32[] : memref<i1>
        memref.store %44, %31[] : memref<i1>
        %45 = memref.load %31[] : memref<i1>
        %46 = scf.if %45 -> (i32) {
          %47 = memref.load %2[] : memref<i32>
          %48 = arith.addi %34, %c1_i32 : i32
          memref.store %48, %2[] : memref<i32>
          scf.yield %48 : i32
        } else {
          scf.yield %34 : i32
        }
        cf.br ^bb1(%43, %46 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %33, %34 : i32, i32
      }
      scf.yield %28#0, %28#1 : i32, i32
    } else {
      scf.yield %13, %14 : i32, i32
    }
    scf.yield %27#0, %27#1 : i32, i32
  } else {
    scf.yield %13, %14 : i32, i32
  }
  %23 = memref.load %12[] : memref<i1>
  memref.store %23, %11[] : memref<i1>
  %24 = memref.load %11[] : memref<i1>
  %25 = scf.if %24 -> (i32) {
    %26 = memref.load %3[] : memref<i32>
    %27 = arith.subi %15, %c1_i32 : i32
    memref.store %27, %3[] : memref<i32>
    scf.yield %27 : i32
  } else {
    scf.yield %15 : i32
  }
  cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.execute_region {
    %9 = memref.load %6[] : memref<i1>
    %10 = scf.if %true -> (i32) {
      %26 = memref.get_global @kbm3 : memref<1xi32>
      %27 = memref.load %26[%c0] : memref<1xi32>
      memref.store %27, %3[] : memref<i32>
      scf.yield %27 : i32
    } else {
      scf.yield %1 : i32
    }
    %11 = memref.alloca() : memref<i1>
    %12 = memref.alloca() : memref<i1>
    memref.store %true, %12[] : memref<i1>
    cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
  ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
    %16 = memref.load %3[] : memref<i32>
    %17 = arith.cmpi sgt, %15, %c0_i32 : i32
    %18 = memref.load %12[] : memref<i1>
    %19 = arith.andi %17, %18 : i1
    cf.cond_br %19, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %20 = memref.load %12[] : memref<i1>
    memref.store %20, %11[] : memref<i1>
    %21 = memref.load %11[] : memref<i1>
    %22:2 = scf.if %21 -> (i32, i32) {
      %26 = memref.load %11[] : memref<i1>
      %27:2 = scf.if %26 -> (i32, i32) {
        %28:2 = scf.execute_region -> (i32, i32) {
          %29 = memref.load %11[] : memref<i1>
          %30 = scf.if %29 -> (i32) {
            memref.store %c0_i32, %2[] : memref<i32>
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %14 : i32
          }
          %31 = memref.alloca() : memref<i1>
          %32 = memref.alloca() : memref<i1>
          memref.store %true, %32[] : memref<i1>
          cf.br ^bb1(%13, %30 : i32, i32)
        ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
          %35 = memref.load %2[] : memref<i32>
          %36 = memref.get_global @jm : memref<1xi32>
          %37 = memref.load %36[%c0] : memref<1xi32>
          %38 = arith.cmpi slt, %34, %37 : i32
          %39 = memref.load %32[] : memref<i1>
          %40 = arith.andi %38, %39 : i1
          cf.cond_br %40, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %41 = memref.load %32[] : memref<i1>
          memref.store %41, %31[] : memref<i1>
          %42 = memref.load %31[] : memref<i1>
          %43 = scf.if %42 -> (i32) {
            %47 = memref.load %31[] : memref<i1>
            %48 = scf.if %47 -> (i32) {
              %49 = scf.execute_region -> i32 {
                %50 = memref.load %31[] : memref<i1>
                %51 = scf.if %50 -> (i32) {
                  memref.store %c0_i32, %0[] : memref<i32>
                  scf.yield %c0_i32 : i32
                } else {
                  scf.yield %33 : i32
                }
                %52 = memref.alloca() : memref<i1>
                %53 = memref.alloca() : memref<i1>
                memref.store %true, %53[] : memref<i1>
                cf.br ^bb1(%51 : i32)
              ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                %55 = memref.load %0[] : memref<i32>
                %56 = memref.get_global @im : memref<1xi32>
                %57 = memref.load %56[%c0] : memref<1xi32>
                %58 = arith.cmpi slt, %54, %57 : i32
                %59 = memref.load %53[] : memref<i1>
                %60 = arith.andi %58, %59 : i1
                cf.cond_br %60, ^bb2, ^bb3
              ^bb2:  // pred: ^bb1
                %61 = memref.load %53[] : memref<i1>
                memref.store %61, %52[] : memref<i1>
                %62 = memref.load %52[] : memref<i1>
                scf.if %62 {
                  %66 = memref.load %4[] : memref<memref<?xf32>>
                  %67 = memref.load %0[] : memref<i32>
                  %68 = memref.load %2[] : memref<i32>
                  %69 = memref.load %56[%c0] : memref<1xi32>
                  %70 = arith.muli %34, %69 : i32
                  %71 = arith.addi %54, %70 : i32
                  %72 = memref.load %3[] : memref<i32>
                  %73 = arith.muli %15, %69 : i32
                  %74 = memref.load %36[%c0] : memref<1xi32>
                  %75 = arith.muli %73, %74 : i32
                  %76 = arith.addi %71, %75 : i32
                  %77 = arith.index_cast %76 : i32 to index
                  %78 = memref.load %5[] : memref<memref<?xf32>>
                  %79 = arith.subi %15, %c1_i32 : i32
                  %80 = arith.muli %79, %69 : i32
                  %81 = arith.muli %80, %74 : i32
                  %82 = arith.addi %71, %81 : i32
                  %83 = arith.index_cast %82 : i32 to index
                  %84 = arith.addi %83, %c0 : index
                  %85 = memref.load %arg0[%84] : memref<?xf32>
                  %86 = arith.addi %77, %c0 : index
                  memref.store %85, %arg2[%86] : memref<?xf32>
                }
                %63 = memref.load %53[] : memref<i1>
                memref.store %63, %52[] : memref<i1>
                %64 = memref.load %52[] : memref<i1>
                %65 = scf.if %64 -> (i32) {
                  %66 = memref.load %0[] : memref<i32>
                  %67 = arith.addi %54, %c1_i32 : i32
                  memref.store %67, %0[] : memref<i32>
                  scf.yield %67 : i32
                } else {
                  scf.yield %54 : i32
                }
                cf.br ^bb1(%65 : i32)
              ^bb3:  // pred: ^bb1
                scf.yield %54 : i32
              }
              scf.yield %49 : i32
            } else {
              scf.yield %33 : i32
            }
            scf.yield %48 : i32
          } else {
            scf.yield %33 : i32
          }
          %44 = memref.load %32[] : memref<i1>
          memref.store %44, %31[] : memref<i1>
          %45 = memref.load %31[] : memref<i1>
          %46 = scf.if %45 -> (i32) {
            %47 = memref.load %2[] : memref<i32>
            %48 = arith.addi %34, %c1_i32 : i32
            memref.store %48, %2[] : memref<i32>
            scf.yield %48 : i32
          } else {
            scf.yield %34 : i32
          }
          cf.br ^bb1(%43, %46 : i32, i32)
        ^bb3:  // pred: ^bb1
          scf.yield %33, %34 : i32, i32
        }
        scf.yield %28#0, %28#1 : i32, i32
      } else {
        scf.yield %13, %14 : i32, i32
      }
      scf.yield %27#0, %27#1 : i32, i32
    } else {
      scf.yield %13, %14 : i32, i32
    }
    %23 = memref.load %12[] : memref<i1>
    memref.store %23, %11[] : memref<i1>
    %24 = memref.load %11[] : memref<i1>
    %25 = scf.if %24 -> (i32) {
      %26 = memref.load %3[] : memref<i32>
      %27 = arith.subi %15, %c1_i32 : i32
      memref.store %27, %3[] : memref<i32>
      scf.yield %27 : i32
    } else {
      scf.yield %15 : i32
    }
    cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
  ^bb3:  // pred: ^bb1
    scf.yield
  }
  scf.yield
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %8 = memref.load %6[] : memref<i1>
  scf.if %true {
    scf.execute_region {
      %9 = memref.load %6[] : memref<i1>
      %10 = scf.if %true -> (i32) {
        %26 = memref.get_global @kbm3 : memref<1xi32>
        %27 = memref.load %26[%c0] : memref<1xi32>
        memref.store %27, %3[] : memref<i32>
        scf.yield %27 : i32
      } else {
        scf.yield %1 : i32
      }
      %11 = memref.alloca() : memref<i1>
      %12 = memref.alloca() : memref<i1>
      memref.store %true, %12[] : memref<i1>
      cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
    ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
      %16 = memref.load %3[] : memref<i32>
      %17 = arith.cmpi sgt, %15, %c0_i32 : i32
      %18 = memref.load %12[] : memref<i1>
      %19 = arith.andi %17, %18 : i1
      cf.cond_br %19, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %20 = memref.load %12[] : memref<i1>
      memref.store %20, %11[] : memref<i1>
      %21 = memref.load %11[] : memref<i1>
      %22:2 = scf.if %21 -> (i32, i32) {
        %26 = memref.load %11[] : memref<i1>
        %27:2 = scf.if %26 -> (i32, i32) {
          %28:2 = scf.execute_region -> (i32, i32) {
            %29 = memref.load %11[] : memref<i1>
            %30 = scf.if %29 -> (i32) {
              memref.store %c0_i32, %2[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %14 : i32
            }
            %31 = memref.alloca() : memref<i1>
            %32 = memref.alloca() : memref<i1>
            memref.store %true, %32[] : memref<i1>
            cf.br ^bb1(%13, %30 : i32, i32)
          ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
            %35 = memref.load %2[] : memref<i32>
            %36 = memref.get_global @jm : memref<1xi32>
            %37 = memref.load %36[%c0] : memref<1xi32>
            %38 = arith.cmpi slt, %34, %37 : i32
            %39 = memref.load %32[] : memref<i1>
            %40 = arith.andi %38, %39 : i1
            cf.cond_br %40, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %41 = memref.load %32[] : memref<i1>
            memref.store %41, %31[] : memref<i1>
            %42 = memref.load %31[] : memref<i1>
            %43 = scf.if %42 -> (i32) {
              %47 = memref.load %31[] : memref<i1>
              %48 = scf.if %47 -> (i32) {
                %49 = scf.execute_region -> i32 {
                  %50 = memref.load %31[] : memref<i1>
                  %51 = scf.if %50 -> (i32) {
                    memref.store %c0_i32, %0[] : memref<i32>
                    scf.yield %c0_i32 : i32
                  } else {
                    scf.yield %33 : i32
                  }
                  %52 = memref.alloca() : memref<i1>
                  %53 = memref.alloca() : memref<i1>
                  memref.store %true, %53[] : memref<i1>
                  cf.br ^bb1(%51 : i32)
                ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                  %55 = memref.load %0[] : memref<i32>
                  %56 = memref.get_global @im : memref<1xi32>
                  %57 = memref.load %56[%c0] : memref<1xi32>
                  %58 = arith.cmpi slt, %54, %57 : i32
                  %59 = memref.load %53[] : memref<i1>
                  %60 = arith.andi %58, %59 : i1
                  cf.cond_br %60, ^bb2, ^bb3
                ^bb2:  // pred: ^bb1
                  %61 = memref.load %53[] : memref<i1>
                  memref.store %61, %52[] : memref<i1>
                  %62 = memref.load %52[] : memref<i1>
                  scf.if %62 {
                    %66 = memref.load %4[] : memref<memref<?xf32>>
                    %67 = memref.load %0[] : memref<i32>
                    %68 = memref.load %2[] : memref<i32>
                    %69 = memref.load %56[%c0] : memref<1xi32>
                    %70 = arith.muli %34, %69 : i32
                    %71 = arith.addi %54, %70 : i32
                    %72 = memref.load %3[] : memref<i32>
                    %73 = arith.muli %15, %69 : i32
                    %74 = memref.load %36[%c0] : memref<1xi32>
                    %75 = arith.muli %73, %74 : i32
                    %76 = arith.addi %71, %75 : i32
                    %77 = arith.index_cast %76 : i32 to index
                    %78 = memref.load %5[] : memref<memref<?xf32>>
                    %79 = arith.subi %15, %c1_i32 : i32
                    %80 = arith.muli %79, %69 : i32
                    %81 = arith.muli %80, %74 : i32
                    %82 = arith.addi %71, %81 : i32
                    %83 = arith.index_cast %82 : i32 to index
                    %84 = arith.addi %83, %c0 : index
                    %85 = memref.load %arg0[%84] : memref<?xf32>
                    %86 = arith.addi %77, %c0 : index
                    memref.store %85, %arg2[%86] : memref<?xf32>
                  }
                  %63 = memref.load %53[] : memref<i1>
                  memref.store %63, %52[] : memref<i1>
                  %64 = memref.load %52[] : memref<i1>
                  %65 = scf.if %64 -> (i32) {
                    %66 = memref.load %0[] : memref<i32>
                    %67 = arith.addi %54, %c1_i32 : i32
                    memref.store %67, %0[] : memref<i32>
                    scf.yield %67 : i32
                  } else {
                    scf.yield %54 : i32
                  }
                  cf.br ^bb1(%65 : i32)
                ^bb3:  // pred: ^bb1
                  scf.yield %54 : i32
                }
                scf.yield %49 : i32
              } else {
                scf.yield %33 : i32
              }
              scf.yield %48 : i32
            } else {
              scf.yield %33 : i32
            }
            %44 = memref.load %32[] : memref<i1>
            memref.store %44, %31[] : memref<i1>
            %45 = memref.load %31[] : memref<i1>
            %46 = scf.if %45 -> (i32) {
              %47 = memref.load %2[] : memref<i32>
              %48 = arith.addi %34, %c1_i32 : i32
              memref.store %48, %2[] : memref<i32>
              scf.yield %48 : i32
            } else {
              scf.yield %34 : i32
            }
            cf.br ^bb1(%43, %46 : i32, i32)
          ^bb3:  // pred: ^bb1
            scf.yield %33, %34 : i32, i32
          }
          scf.yield %28#0, %28#1 : i32, i32
        } else {
          scf.yield %13, %14 : i32, i32
        }
        scf.yield %27#0, %27#1 : i32, i32
      } else {
        scf.yield %13, %14 : i32, i32
      }
      %23 = memref.load %12[] : memref<i1>
      memref.store %23, %11[] : memref<i1>
      %24 = memref.load %11[] : memref<i1>
      %25 = scf.if %24 -> (i32) {
        %26 = memref.load %3[] : memref<i32>
        %27 = arith.subi %15, %c1_i32 : i32
        memref.store %27, %3[] : memref<i32>
        scf.yield %27 : i32
      } else {
        scf.yield %15 : i32
      }
      cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
  scf.yield
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32):
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %true {
    %8 = memref.load %6[] : memref<i1>
    scf.if %true {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        %10 = scf.if %true -> (i32) {
          %26 = memref.get_global @kbm3 : memref<1xi32>
          %27 = memref.load %26[%c0] : memref<1xi32>
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %1 : i32
        }
        %11 = memref.alloca() : memref<i1>
        %12 = memref.alloca() : memref<i1>
        memref.store %true, %12[] : memref<i1>
        cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
      ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
        %16 = memref.load %3[] : memref<i32>
        %17 = arith.cmpi sgt, %15, %c0_i32 : i32
        %18 = memref.load %12[] : memref<i1>
        %19 = arith.andi %17, %18 : i1
        cf.cond_br %19, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %20 = memref.load %12[] : memref<i1>
        memref.store %20, %11[] : memref<i1>
        %21 = memref.load %11[] : memref<i1>
        %22:2 = scf.if %21 -> (i32, i32) {
          %26 = memref.load %11[] : memref<i1>
          %27:2 = scf.if %26 -> (i32, i32) {
            %28:2 = scf.execute_region -> (i32, i32) {
              %29 = memref.load %11[] : memref<i1>
              %30 = scf.if %29 -> (i32) {
                memref.store %c0_i32, %2[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %14 : i32
              }
              %31 = memref.alloca() : memref<i1>
              %32 = memref.alloca() : memref<i1>
              memref.store %true, %32[] : memref<i1>
              cf.br ^bb1(%13, %30 : i32, i32)
            ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
              %35 = memref.load %2[] : memref<i32>
              %36 = memref.get_global @jm : memref<1xi32>
              %37 = memref.load %36[%c0] : memref<1xi32>
              %38 = arith.cmpi slt, %34, %37 : i32
              %39 = memref.load %32[] : memref<i1>
              %40 = arith.andi %38, %39 : i1
              cf.cond_br %40, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %41 = memref.load %32[] : memref<i1>
              memref.store %41, %31[] : memref<i1>
              %42 = memref.load %31[] : memref<i1>
              %43 = scf.if %42 -> (i32) {
                %47 = memref.load %31[] : memref<i1>
                %48 = scf.if %47 -> (i32) {
                  %49 = scf.execute_region -> i32 {
                    %50 = memref.load %31[] : memref<i1>
                    %51 = scf.if %50 -> (i32) {
                      memref.store %c0_i32, %0[] : memref<i32>
                      scf.yield %c0_i32 : i32
                    } else {
                      scf.yield %33 : i32
                    }
                    %52 = memref.alloca() : memref<i1>
                    %53 = memref.alloca() : memref<i1>
                    memref.store %true, %53[] : memref<i1>
                    cf.br ^bb1(%51 : i32)
                  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                    %55 = memref.load %0[] : memref<i32>
                    %56 = memref.get_global @im : memref<1xi32>
                    %57 = memref.load %56[%c0] : memref<1xi32>
                    %58 = arith.cmpi slt, %54, %57 : i32
                    %59 = memref.load %53[] : memref<i1>
                    %60 = arith.andi %58, %59 : i1
                    cf.cond_br %60, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %61 = memref.load %53[] : memref<i1>
                    memref.store %61, %52[] : memref<i1>
                    %62 = memref.load %52[] : memref<i1>
                    scf.if %62 {
                      %66 = memref.load %4[] : memref<memref<?xf32>>
                      %67 = memref.load %0[] : memref<i32>
                      %68 = memref.load %2[] : memref<i32>
                      %69 = memref.load %56[%c0] : memref<1xi32>
                      %70 = arith.muli %34, %69 : i32
                      %71 = arith.addi %54, %70 : i32
                      %72 = memref.load %3[] : memref<i32>
                      %73 = arith.muli %15, %69 : i32
                      %74 = memref.load %36[%c0] : memref<1xi32>
                      %75 = arith.muli %73, %74 : i32
                      %76 = arith.addi %71, %75 : i32
                      %77 = arith.index_cast %76 : i32 to index
                      %78 = memref.load %5[] : memref<memref<?xf32>>
                      %79 = arith.subi %15, %c1_i32 : i32
                      %80 = arith.muli %79, %69 : i32
                      %81 = arith.muli %80, %74 : i32
                      %82 = arith.addi %71, %81 : i32
                      %83 = arith.index_cast %82 : i32 to index
                      %84 = arith.addi %83, %c0 : index
                      %85 = memref.load %arg0[%84] : memref<?xf32>
                      %86 = arith.addi %77, %c0 : index
                      memref.store %85, %arg2[%86] : memref<?xf32>
                    }
                    %63 = memref.load %53[] : memref<i1>
                    memref.store %63, %52[] : memref<i1>
                    %64 = memref.load %52[] : memref<i1>
                    %65 = scf.if %64 -> (i32) {
                      %66 = memref.load %0[] : memref<i32>
                      %67 = arith.addi %54, %c1_i32 : i32
                      memref.store %67, %0[] : memref<i32>
                      scf.yield %67 : i32
                    } else {
                      scf.yield %54 : i32
                    }
                    cf.br ^bb1(%65 : i32)
                  ^bb3:  // pred: ^bb1
                    scf.yield %54 : i32
                  }
                  scf.yield %49 : i32
                } else {
                  scf.yield %33 : i32
                }
                scf.yield %48 : i32
              } else {
                scf.yield %33 : i32
              }
              %44 = memref.load %32[] : memref<i1>
              memref.store %44, %31[] : memref<i1>
              %45 = memref.load %31[] : memref<i1>
              %46 = scf.if %45 -> (i32) {
                %47 = memref.load %2[] : memref<i32>
                %48 = arith.addi %34, %c1_i32 : i32
                memref.store %48, %2[] : memref<i32>
                scf.yield %48 : i32
              } else {
                scf.yield %34 : i32
              }
              cf.br ^bb1(%43, %46 : i32, i32)
            ^bb3:  // pred: ^bb1
              scf.yield %33, %34 : i32, i32
            }
            scf.yield %28#0, %28#1 : i32, i32
          } else {
            scf.yield %13, %14 : i32, i32
          }
          scf.yield %27#0, %27#1 : i32, i32
        } else {
          scf.yield %13, %14 : i32, i32
        }
        %23 = memref.load %12[] : memref<i1>
        memref.store %23, %11[] : memref<i1>
        %24 = memref.load %11[] : memref<i1>
        %25 = scf.if %24 -> (i32) {
          %26 = memref.load %3[] : memref<i32>
          %27 = arith.subi %15, %c1_i32 : i32
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %15 : i32
        }
        cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  func.return
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%11 = memref.alloca() : memref<i1>
 + forwarding vec to promote {} of mlir-asm-printer: Verifying operation: builtin.module
%11 = memref.alloca() : memref<i1>
Begin forwarding store of mlir-asm-printer: Verifying operation: builtin.module
%11 = memref.alloca() : memref<i1> to load
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %true {
    %8 = memref.load %6[] : memref<i1>
    scf.if %true {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        %10 = scf.if %true -> (i32) {
          %26 = memref.get_global @kbm3 : memref<1xi32>
          %27 = memref.load %26[%c0] : memref<1xi32>
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %1 : i32
        }
        %11 = memref.alloca() : memref<i1>
        %12 = memref.alloca() : memref<i1>
        memref.store %true, %12[] : memref<i1>
        cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
      ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
        %16 = memref.load %3[] : memref<i32>
        %17 = arith.cmpi sgt, %15, %c0_i32 : i32
        %18 = memref.load %12[] : memref<i1>
        %19 = arith.andi %17, %18 : i1
        cf.cond_br %19, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %20 = memref.load %12[] : memref<i1>
        memref.store %20, %11[] : memref<i1>
        %21 = memref.load %11[] : memref<i1>
        %22:2 = scf.if %21 -> (i32, i32) {
          %26 = memref.load %11[] : memref<i1>
          %27:2 = scf.if %26 -> (i32, i32) {
            %28:2 = scf.execute_region -> (i32, i32) {
              %29 = memref.load %11[] : memref<i1>
              %30 = scf.if %29 -> (i32) {
                memref.store %c0_i32, %2[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %14 : i32
              }
              %31 = memref.alloca() : memref<i1>
              %32 = memref.alloca() : memref<i1>
              memref.store %true, %32[] : memref<i1>
              cf.br ^bb1(%13, %30 : i32, i32)
            ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
              %35 = memref.load %2[] : memref<i32>
              %36 = memref.get_global @jm : memref<1xi32>
              %37 = memref.load %36[%c0] : memref<1xi32>
              %38 = arith.cmpi slt, %34, %37 : i32
              %39 = memref.load %32[] : memref<i1>
              %40 = arith.andi %38, %39 : i1
              cf.cond_br %40, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %41 = memref.load %32[] : memref<i1>
              memref.store %41, %31[] : memref<i1>
              %42 = memref.load %31[] : memref<i1>
              %43 = scf.if %42 -> (i32) {
                %47 = memref.load %31[] : memref<i1>
                %48 = scf.if %47 -> (i32) {
                  %49 = scf.execute_region -> i32 {
                    %50 = memref.load %31[] : memref<i1>
                    %51 = scf.if %50 -> (i32) {
                      memref.store %c0_i32, %0[] : memref<i32>
                      scf.yield %c0_i32 : i32
                    } else {
                      scf.yield %33 : i32
                    }
                    %52 = memref.alloca() : memref<i1>
                    %53 = memref.alloca() : memref<i1>
                    memref.store %true, %53[] : memref<i1>
                    cf.br ^bb1(%51 : i32)
                  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                    %55 = memref.load %0[] : memref<i32>
                    %56 = memref.get_global @im : memref<1xi32>
                    %57 = memref.load %56[%c0] : memref<1xi32>
                    %58 = arith.cmpi slt, %54, %57 : i32
                    %59 = memref.load %53[] : memref<i1>
                    %60 = arith.andi %58, %59 : i1
                    cf.cond_br %60, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %61 = memref.load %53[] : memref<i1>
                    memref.store %61, %52[] : memref<i1>
                    %62 = memref.load %52[] : memref<i1>
                    scf.if %62 {
                      %66 = memref.load %4[] : memref<memref<?xf32>>
                      %67 = memref.load %0[] : memref<i32>
                      %68 = memref.load %2[] : memref<i32>
                      %69 = memref.load %56[%c0] : memref<1xi32>
                      %70 = arith.muli %34, %69 : i32
                      %71 = arith.addi %54, %70 : i32
                      %72 = memref.load %3[] : memref<i32>
                      %73 = arith.muli %15, %69 : i32
                      %74 = memref.load %36[%c0] : memref<1xi32>
                      %75 = arith.muli %73, %74 : i32
                      %76 = arith.addi %71, %75 : i32
                      %77 = arith.index_cast %76 : i32 to index
                      %78 = memref.load %5[] : memref<memref<?xf32>>
                      %79 = arith.subi %15, %c1_i32 : i32
                      %80 = arith.muli %79, %69 : i32
                      %81 = arith.muli %80, %74 : i32
                      %82 = arith.addi %71, %81 : i32
                      %83 = arith.index_cast %82 : i32 to index
                      %84 = arith.addi %83, %c0 : index
                      %85 = memref.load %arg0[%84] : memref<?xf32>
                      %86 = arith.addi %77, %c0 : index
                      memref.store %85, %arg2[%86] : memref<?xf32>
                    }
                    %63 = memref.load %53[] : memref<i1>
                    memref.store %63, %52[] : memref<i1>
                    %64 = memref.load %52[] : memref<i1>
                    %65 = scf.if %64 -> (i32) {
                      %66 = memref.load %0[] : memref<i32>
                      %67 = arith.addi %54, %c1_i32 : i32
                      memref.store %67, %0[] : memref<i32>
                      scf.yield %67 : i32
                    } else {
                      scf.yield %54 : i32
                    }
                    cf.br ^bb1(%65 : i32)
                  ^bb3:  // pred: ^bb1
                    scf.yield %54 : i32
                  }
                  scf.yield %49 : i32
                } else {
                  scf.yield %33 : i32
                }
                scf.yield %48 : i32
              } else {
                scf.yield %33 : i32
              }
              %44 = memref.load %32[] : memref<i1>
              memref.store %44, %31[] : memref<i1>
              %45 = memref.load %31[] : memref<i1>
              %46 = scf.if %45 -> (i32) {
                %47 = memref.load %2[] : memref<i32>
                %48 = arith.addi %34, %c1_i32 : i32
                memref.store %48, %2[] : memref<i32>
                scf.yield %48 : i32
              } else {
                scf.yield %34 : i32
              }
              cf.br ^bb1(%43, %46 : i32, i32)
            ^bb3:  // pred: ^bb1
              scf.yield %33, %34 : i32, i32
            }
            scf.yield %28#0, %28#1 : i32, i32
          } else {
            scf.yield %13, %14 : i32, i32
          }
          scf.yield %27#0, %27#1 : i32, i32
        } else {
          scf.yield %13, %14 : i32, i32
        }
        %23 = memref.load %12[] : memref<i1>
        memref.store %23, %11[] : memref<i1>
        %24 = memref.load %11[] : memref<i1>
        %25 = scf.if %24 -> (i32) {
          %26 = memref.load %3[] : memref<i32>
          %27 = arith.subi %15, %c1_i32 : i32
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %15 : i32
        }
        cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}
Matching Load: mlir-asm-printer: Verifying operation: func.func
%24 = memref.load %11[] : memref<i1>
Matching Store: mlir-asm-printer: Verifying operation: func.func
memref.store %23, %11[] : memref<i1>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%29 = memref.load %11[] : memref<i1>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%26 = memref.load %11[] : memref<i1>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%21 = memref.load %11[] : memref<i1>
Matching Store: mlir-asm-printer: Verifying operation: func.func
memref.store %20, %11[] : memref<i1>
 storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %23, %11[] : memref<i1>
 storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %20, %11[] : memref<i1>
 initial storing block: 0x7fbd98167b50
 derived storing block: 0x7fbd981669f0
 initial storing block: 0x7fbd98167b50
 derived storing block: 0x7fbd981669f0
 initial storing block: 0x7fbd981669f0
 derived storing block: 0x7fbd98166740
 initial storing block: 0x7fbd981669f0
 derived storing block: 0x7fbd98166740
 initial storing block: 0x7fbd98166740
 derived storing block: 0x7fbd98164100
 initial storing block: 0x7fbd98166740
 derived storing block: 0x7fbd98164100
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %9 = memref.load %6[] : memref<i1>
  %10 = scf.if %true -> (i32) {
    %26 = memref.get_global @kbm3 : memref<1xi32>
    %27 = memref.load %26[%c0] : memref<1xi32>
    memref.store %27, %3[] : memref<i32>
    scf.yield %27 : i32
  } else {
    scf.yield %1 : i32
  }
  %11 = memref.alloca() : memref<i1>
  %12 = memref.alloca() : memref<i1>
  memref.store %true, %12[] : memref<i1>
  cf.br ^bb1(%1, %1, %10 : i32, i32, i32)


starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.get_global @kbm3 : memref<1xi32>
  %27 = memref.load %26[%c0] : memref<1xi32>
  memref.store %27, %3[] : memref<i32>
  scf.yield %27 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.get_global @kbm3 : memref<1xi32>
  %27 = memref.load %26[%c0] : memref<1xi32>
  memref.store %27, %3[] : memref<i32>
  scf.yield %27 : i32
 with val:<overwritten>

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %1 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %1 : i32
 with val:<overwritten>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %9 = memref.load %6[] : memref<i1>
  %10 = scf.if %true -> (i32) {
    %26 = memref.get_global @kbm3 : memref<1xi32>
    %27 = memref.load %26[%c0] : memref<1xi32>
    memref.store %27, %3[] : memref<i32>
    scf.yield %27 : i32
  } else {
    scf.yield %1 : i32
  }
  %11 = memref.alloca() : memref<i1>
  %12 = memref.alloca() : memref<i1>
  memref.store %true, %12[] : memref<i1>
  cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
 with val:<overwritten>

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
  %16 = memref.load %3[] : memref<i32>
  %17 = arith.cmpi sgt, %15, %c0_i32 : i32
  %18 = memref.load %12[] : memref<i1>
  %19 = arith.andi %17, %18 : i1
  cf.cond_br %19, ^bb2, ^bb3

mlir-asm-printer: Verifying operation: builtin.module
^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
  %16 = memref.load %3[] : memref<i32>
  %17 = arith.cmpi sgt, %15, %c0_i32 : i32
  %18 = memref.load %12[] : memref<i1>
  %19 = arith.andi %17, %18 : i1
  cf.cond_br %19, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
  %16 = memref.load %3[] : memref<i32>
  %17 = arith.cmpi sgt, %15, %c0_i32 : i32
  %18 = memref.load %12[] : memref<i1>
  %19 = arith.andi %17, %18 : i1
  cf.cond_br %19, ^bb2, ^bb3
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
  %16 = memref.load %3[] : memref<i32>
  %17 = arith.cmpi sgt, %15, %c0_i32 : i32
  %18 = memref.load %12[] : memref<i1>
  %19 = arith.andi %17, %18 : i1
  cf.cond_br %19, ^bb2, ^bb3


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield

mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %20 = memref.load %12[] : memref<i1>
  memref.store %20, %11[] : memref<i1>
  %21 = memref.load %11[] : memref<i1>
  %22:2 = scf.if %21 -> (i32, i32) {
    %26 = memref.load %11[] : memref<i1>
    %27:2 = scf.if %26 -> (i32, i32) {
      %28:2 = scf.execute_region -> (i32, i32) {
        %29 = memref.load %11[] : memref<i1>
        %30 = scf.if %29 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %14 : i32
        }
        %31 = memref.alloca() : memref<i1>
        %32 = memref.alloca() : memref<i1>
        memref.store %true, %32[] : memref<i1>
        cf.br ^bb1(%13, %30 : i32, i32)
      ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
        %35 = memref.load %2[] : memref<i32>
        %36 = memref.get_global @jm : memref<1xi32>
        %37 = memref.load %36[%c0] : memref<1xi32>
        %38 = arith.cmpi slt, %34, %37 : i32
        %39 = memref.load %32[] : memref<i1>
        %40 = arith.andi %38, %39 : i1
        cf.cond_br %40, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %41 = memref.load %32[] : memref<i1>
        memref.store %41, %31[] : memref<i1>
        %42 = memref.load %31[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %47 = memref.load %31[] : memref<i1>
          %48 = scf.if %47 -> (i32) {
            %49 = scf.execute_region -> i32 {
              %50 = memref.load %31[] : memref<i1>
              %51 = scf.if %50 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %33 : i32
              }
              %52 = memref.alloca() : memref<i1>
              %53 = memref.alloca() : memref<i1>
              memref.store %true, %53[] : memref<i1>
              cf.br ^bb1(%51 : i32)
            ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
              %55 = memref.load %0[] : memref<i32>
              %56 = memref.get_global @im : memref<1xi32>
              %57 = memref.load %56[%c0] : memref<1xi32>
              %58 = arith.cmpi slt, %54, %57 : i32
              %59 = memref.load %53[] : memref<i1>
              %60 = arith.andi %58, %59 : i1
              cf.cond_br %60, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %61 = memref.load %53[] : memref<i1>
              memref.store %61, %52[] : memref<i1>
              %62 = memref.load %52[] : memref<i1>
              scf.if %62 {
                %66 = memref.load %4[] : memref<memref<?xf32>>
                %67 = memref.load %0[] : memref<i32>
                %68 = memref.load %2[] : memref<i32>
                %69 = memref.load %56[%c0] : memref<1xi32>
                %70 = arith.muli %34, %69 : i32
                %71 = arith.addi %54, %70 : i32
                %72 = memref.load %3[] : memref<i32>
                %73 = arith.muli %15, %69 : i32
                %74 = memref.load %36[%c0] : memref<1xi32>
                %75 = arith.muli %73, %74 : i32
                %76 = arith.addi %71, %75 : i32
                %77 = arith.index_cast %76 : i32 to index
                %78 = memref.load %5[] : memref<memref<?xf32>>
                %79 = arith.subi %15, %c1_i32 : i32
                %80 = arith.muli %79, %69 : i32
                %81 = arith.muli %80, %74 : i32
                %82 = arith.addi %71, %81 : i32
                %83 = arith.index_cast %82 : i32 to index
                %84 = arith.addi %83, %c0 : index
                %85 = memref.load %arg0[%84] : memref<?xf32>
                %86 = arith.addi %77, %c0 : index
                memref.store %85, %arg2[%86] : memref<?xf32>
              }
              %63 = memref.load %53[] : memref<i1>
              memref.store %63, %52[] : memref<i1>
              %64 = memref.load %52[] : memref<i1>
              %65 = scf.if %64 -> (i32) {
                %66 = memref.load %0[] : memref<i32>
                %67 = arith.addi %54, %c1_i32 : i32
                memref.store %67, %0[] : memref<i32>
                scf.yield %67 : i32
              } else {
                scf.yield %54 : i32
              }
              cf.br ^bb1(%65 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %54 : i32
            }
            scf.yield %49 : i32
          } else {
            scf.yield %33 : i32
          }
          scf.yield %48 : i32
        } else {
          scf.yield %33 : i32
        }
        %44 = memref.load %32[] : memref<i1>
        memref.store %44, %31[] : memref<i1>
        %45 = memref.load %31[] : memref<i1>
        %46 = scf.if %45 -> (i32) {
          %47 = memref.load %2[] : memref<i32>
          %48 = arith.addi %34, %c1_i32 : i32
          memref.store %48, %2[] : memref<i32>
          scf.yield %48 : i32
        } else {
          scf.yield %34 : i32
        }
        cf.br ^bb1(%43, %46 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %33, %34 : i32, i32
      }
      scf.yield %28#0, %28#1 : i32, i32
    } else {
      scf.yield %13, %14 : i32, i32
    }
    scf.yield %27#0, %27#1 : i32, i32
  } else {
    scf.yield %13, %14 : i32, i32
  }
  %23 = memref.load %12[] : memref<i1>
  memref.store %23, %11[] : memref<i1>
  %24 = memref.load %11[] : memref<i1>
  %25 = scf.if %24 -> (i32) {
    %26 = memref.load %3[] : memref<i32>
    %27 = arith.subi %15, %c1_i32 : i32
    memref.store %27, %3[] : memref<i32>
    scf.yield %27 : i32
  } else {
    scf.yield %15 : i32
  }
  cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %20 = memref.load %12[] : memref<i1>
  memref.store %20, %11[] : memref<i1>
  %21 = memref.load %11[] : memref<i1>
  %22:2 = scf.if %21 -> (i32, i32) {
    %26 = memref.load %11[] : memref<i1>
    %27:2 = scf.if %26 -> (i32, i32) {
      %28:2 = scf.execute_region -> (i32, i32) {
        %29 = memref.load %11[] : memref<i1>
        %30 = scf.if %29 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %14 : i32
        }
        %31 = memref.alloca() : memref<i1>
        %32 = memref.alloca() : memref<i1>
        memref.store %true, %32[] : memref<i1>
        cf.br ^bb1(%13, %30 : i32, i32)
      ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
        %35 = memref.load %2[] : memref<i32>
        %36 = memref.get_global @jm : memref<1xi32>
        %37 = memref.load %36[%c0] : memref<1xi32>
        %38 = arith.cmpi slt, %34, %37 : i32
        %39 = memref.load %32[] : memref<i1>
        %40 = arith.andi %38, %39 : i1
        cf.cond_br %40, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %41 = memref.load %32[] : memref<i1>
        memref.store %41, %31[] : memref<i1>
        %42 = memref.load %31[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %47 = memref.load %31[] : memref<i1>
          %48 = scf.if %47 -> (i32) {
            %49 = scf.execute_region -> i32 {
              %50 = memref.load %31[] : memref<i1>
              %51 = scf.if %50 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %33 : i32
              }
              %52 = memref.alloca() : memref<i1>
              %53 = memref.alloca() : memref<i1>
              memref.store %true, %53[] : memref<i1>
              cf.br ^bb1(%51 : i32)
            ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
              %55 = memref.load %0[] : memref<i32>
              %56 = memref.get_global @im : memref<1xi32>
              %57 = memref.load %56[%c0] : memref<1xi32>
              %58 = arith.cmpi slt, %54, %57 : i32
              %59 = memref.load %53[] : memref<i1>
              %60 = arith.andi %58, %59 : i1
              cf.cond_br %60, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %61 = memref.load %53[] : memref<i1>
              memref.store %61, %52[] : memref<i1>
              %62 = memref.load %52[] : memref<i1>
              scf.if %62 {
                %66 = memref.load %4[] : memref<memref<?xf32>>
                %67 = memref.load %0[] : memref<i32>
                %68 = memref.load %2[] : memref<i32>
                %69 = memref.load %56[%c0] : memref<1xi32>
                %70 = arith.muli %34, %69 : i32
                %71 = arith.addi %54, %70 : i32
                %72 = memref.load %3[] : memref<i32>
                %73 = arith.muli %15, %69 : i32
                %74 = memref.load %36[%c0] : memref<1xi32>
                %75 = arith.muli %73, %74 : i32
                %76 = arith.addi %71, %75 : i32
                %77 = arith.index_cast %76 : i32 to index
                %78 = memref.load %5[] : memref<memref<?xf32>>
                %79 = arith.subi %15, %c1_i32 : i32
                %80 = arith.muli %79, %69 : i32
                %81 = arith.muli %80, %74 : i32
                %82 = arith.addi %71, %81 : i32
                %83 = arith.index_cast %82 : i32 to index
                %84 = arith.addi %83, %c0 : index
                %85 = memref.load %arg0[%84] : memref<?xf32>
                %86 = arith.addi %77, %c0 : index
                memref.store %85, %arg2[%86] : memref<?xf32>
              }
              %63 = memref.load %53[] : memref<i1>
              memref.store %63, %52[] : memref<i1>
              %64 = memref.load %52[] : memref<i1>
              %65 = scf.if %64 -> (i32) {
                %66 = memref.load %0[] : memref<i32>
                %67 = arith.addi %54, %c1_i32 : i32
                memref.store %67, %0[] : memref<i32>
                scf.yield %67 : i32
              } else {
                scf.yield %54 : i32
              }
              cf.br ^bb1(%65 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %54 : i32
            }
            scf.yield %49 : i32
          } else {
            scf.yield %33 : i32
          }
          scf.yield %48 : i32
        } else {
          scf.yield %33 : i32
        }
        %44 = memref.load %32[] : memref<i1>
        memref.store %44, %31[] : memref<i1>
        %45 = memref.load %31[] : memref<i1>
        %46 = scf.if %45 -> (i32) {
          %47 = memref.load %2[] : memref<i32>
          %48 = arith.addi %34, %c1_i32 : i32
          memref.store %48, %2[] : memref<i32>
          scf.yield %48 : i32
        } else {
          scf.yield %34 : i32
        }
        cf.br ^bb1(%43, %46 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %33, %34 : i32, i32
      }
      scf.yield %28#0, %28#1 : i32, i32
    } else {
      scf.yield %13, %14 : i32, i32
    }
    scf.yield %27#0, %27#1 : i32, i32
  } else {
    scf.yield %13, %14 : i32, i32
  }
  %23 = memref.load %12[] : memref<i1>
  memref.store %23, %11[] : memref<i1>
  %24 = memref.load %11[] : memref<i1>
  %25 = scf.if %24 -> (i32) {
    %26 = memref.load %3[] : memref<i32>
    %27 = arith.subi %15, %c1_i32 : i32
    memref.store %27, %3[] : memref<i32>
    scf.yield %27 : i32
  } else {
    scf.yield %15 : i32
  }
  cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)

 replaced mlir-asm-printer: Verifying operation: builtin.module
%21 = memref.load %11[] : memref<i1> with mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.load %11[] : memref<i1>
  %27:2 = scf.if %26 -> (i32, i32) {
    %28:2 = scf.execute_region -> (i32, i32) {
      %29 = memref.load %11[] : memref<i1>
      %30 = scf.if %29 -> (i32) {
        memref.store %c0_i32, %2[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %14 : i32
      }
      %31 = memref.alloca() : memref<i1>
      %32 = memref.alloca() : memref<i1>
      memref.store %true, %32[] : memref<i1>
      cf.br ^bb1(%13, %30 : i32, i32)
    ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
      %35 = memref.load %2[] : memref<i32>
      %36 = memref.get_global @jm : memref<1xi32>
      %37 = memref.load %36[%c0] : memref<1xi32>
      %38 = arith.cmpi slt, %34, %37 : i32
      %39 = memref.load %32[] : memref<i1>
      %40 = arith.andi %38, %39 : i1
      cf.cond_br %40, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %41 = memref.load %32[] : memref<i1>
      memref.store %41, %31[] : memref<i1>
      %42 = memref.load %31[] : memref<i1>
      %43 = scf.if %42 -> (i32) {
        %47 = memref.load %31[] : memref<i1>
        %48 = scf.if %47 -> (i32) {
          %49 = scf.execute_region -> i32 {
            %50 = memref.load %31[] : memref<i1>
            %51 = scf.if %50 -> (i32) {
              memref.store %c0_i32, %0[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %33 : i32
            }
            %52 = memref.alloca() : memref<i1>
            %53 = memref.alloca() : memref<i1>
            memref.store %true, %53[] : memref<i1>
            cf.br ^bb1(%51 : i32)
          ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
            %55 = memref.load %0[] : memref<i32>
            %56 = memref.get_global @im : memref<1xi32>
            %57 = memref.load %56[%c0] : memref<1xi32>
            %58 = arith.cmpi slt, %54, %57 : i32
            %59 = memref.load %53[] : memref<i1>
            %60 = arith.andi %58, %59 : i1
            cf.cond_br %60, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %61 = memref.load %53[] : memref<i1>
            memref.store %61, %52[] : memref<i1>
            %62 = memref.load %52[] : memref<i1>
            scf.if %62 {
              %66 = memref.load %4[] : memref<memref<?xf32>>
              %67 = memref.load %0[] : memref<i32>
              %68 = memref.load %2[] : memref<i32>
              %69 = memref.load %56[%c0] : memref<1xi32>
              %70 = arith.muli %34, %69 : i32
              %71 = arith.addi %54, %70 : i32
              %72 = memref.load %3[] : memref<i32>
              %73 = arith.muli %15, %69 : i32
              %74 = memref.load %36[%c0] : memref<1xi32>
              %75 = arith.muli %73, %74 : i32
              %76 = arith.addi %71, %75 : i32
              %77 = arith.index_cast %76 : i32 to index
              %78 = memref.load %5[] : memref<memref<?xf32>>
              %79 = arith.subi %15, %c1_i32 : i32
              %80 = arith.muli %79, %69 : i32
              %81 = arith.muli %80, %74 : i32
              %82 = arith.addi %71, %81 : i32
              %83 = arith.index_cast %82 : i32 to index
              %84 = arith.addi %83, %c0 : index
              %85 = memref.load %arg0[%84] : memref<?xf32>
              %86 = arith.addi %77, %c0 : index
              memref.store %85, %arg2[%86] : memref<?xf32>
            }
            %63 = memref.load %53[] : memref<i1>
            memref.store %63, %52[] : memref<i1>
            %64 = memref.load %52[] : memref<i1>
            %65 = scf.if %64 -> (i32) {
              %66 = memref.load %0[] : memref<i32>
              %67 = arith.addi %54, %c1_i32 : i32
              memref.store %67, %0[] : memref<i32>
              scf.yield %67 : i32
            } else {
              scf.yield %54 : i32
            }
            cf.br ^bb1(%65 : i32)
          ^bb3:  // pred: ^bb1
            scf.yield %54 : i32
          }
          scf.yield %49 : i32
        } else {
          scf.yield %33 : i32
        }
        scf.yield %48 : i32
      } else {
        scf.yield %33 : i32
      }
      %44 = memref.load %32[] : memref<i1>
      memref.store %44, %31[] : memref<i1>
      %45 = memref.load %31[] : memref<i1>
      %46 = scf.if %45 -> (i32) {
        %47 = memref.load %2[] : memref<i32>
        %48 = arith.addi %34, %c1_i32 : i32
        memref.store %48, %2[] : memref<i32>
        scf.yield %48 : i32
      } else {
        scf.yield %34 : i32
      }
      cf.br ^bb1(%43, %46 : i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield %33, %34 : i32, i32
    }
    scf.yield %28#0, %28#1 : i32, i32
  } else {
    scf.yield %13, %14 : i32, i32
  }
  scf.yield %27#0, %27#1 : i32, i32

 replaced mlir-asm-printer: Verifying operation: builtin.module
%26 = memref.load %11[] : memref<i1> with mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %28:2 = scf.execute_region -> (i32, i32) {
    %29 = memref.load %11[] : memref<i1>
    %30 = scf.if %29 -> (i32) {
      memref.store %c0_i32, %2[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %14 : i32
    }
    %31 = memref.alloca() : memref<i1>
    %32 = memref.alloca() : memref<i1>
    memref.store %true, %32[] : memref<i1>
    cf.br ^bb1(%13, %30 : i32, i32)
  ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
    %35 = memref.load %2[] : memref<i32>
    %36 = memref.get_global @jm : memref<1xi32>
    %37 = memref.load %36[%c0] : memref<1xi32>
    %38 = arith.cmpi slt, %34, %37 : i32
    %39 = memref.load %32[] : memref<i1>
    %40 = arith.andi %38, %39 : i1
    cf.cond_br %40, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %41 = memref.load %32[] : memref<i1>
    memref.store %41, %31[] : memref<i1>
    %42 = memref.load %31[] : memref<i1>
    %43 = scf.if %42 -> (i32) {
      %47 = memref.load %31[] : memref<i1>
      %48 = scf.if %47 -> (i32) {
        %49 = scf.execute_region -> i32 {
          %50 = memref.load %31[] : memref<i1>
          %51 = scf.if %50 -> (i32) {
            memref.store %c0_i32, %0[] : memref<i32>
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %33 : i32
          }
          %52 = memref.alloca() : memref<i1>
          %53 = memref.alloca() : memref<i1>
          memref.store %true, %53[] : memref<i1>
          cf.br ^bb1(%51 : i32)
        ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
          %55 = memref.load %0[] : memref<i32>
          %56 = memref.get_global @im : memref<1xi32>
          %57 = memref.load %56[%c0] : memref<1xi32>
          %58 = arith.cmpi slt, %54, %57 : i32
          %59 = memref.load %53[] : memref<i1>
          %60 = arith.andi %58, %59 : i1
          cf.cond_br %60, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %61 = memref.load %53[] : memref<i1>
          memref.store %61, %52[] : memref<i1>
          %62 = memref.load %52[] : memref<i1>
          scf.if %62 {
            %66 = memref.load %4[] : memref<memref<?xf32>>
            %67 = memref.load %0[] : memref<i32>
            %68 = memref.load %2[] : memref<i32>
            %69 = memref.load %56[%c0] : memref<1xi32>
            %70 = arith.muli %34, %69 : i32
            %71 = arith.addi %54, %70 : i32
            %72 = memref.load %3[] : memref<i32>
            %73 = arith.muli %15, %69 : i32
            %74 = memref.load %36[%c0] : memref<1xi32>
            %75 = arith.muli %73, %74 : i32
            %76 = arith.addi %71, %75 : i32
            %77 = arith.index_cast %76 : i32 to index
            %78 = memref.load %5[] : memref<memref<?xf32>>
            %79 = arith.subi %15, %c1_i32 : i32
            %80 = arith.muli %79, %69 : i32
            %81 = arith.muli %80, %74 : i32
            %82 = arith.addi %71, %81 : i32
            %83 = arith.index_cast %82 : i32 to index
            %84 = arith.addi %83, %c0 : index
            %85 = memref.load %arg0[%84] : memref<?xf32>
            %86 = arith.addi %77, %c0 : index
            memref.store %85, %arg2[%86] : memref<?xf32>
          }
          %63 = memref.load %53[] : memref<i1>
          memref.store %63, %52[] : memref<i1>
          %64 = memref.load %52[] : memref<i1>
          %65 = scf.if %64 -> (i32) {
            %66 = memref.load %0[] : memref<i32>
            %67 = arith.addi %54, %c1_i32 : i32
            memref.store %67, %0[] : memref<i32>
            scf.yield %67 : i32
          } else {
            scf.yield %54 : i32
          }
          cf.br ^bb1(%65 : i32)
        ^bb3:  // pred: ^bb1
          scf.yield %54 : i32
        }
        scf.yield %49 : i32
      } else {
        scf.yield %33 : i32
      }
      scf.yield %48 : i32
    } else {
      scf.yield %33 : i32
    }
    %44 = memref.load %32[] : memref<i1>
    memref.store %44, %31[] : memref<i1>
    %45 = memref.load %31[] : memref<i1>
    %46 = scf.if %45 -> (i32) {
      %47 = memref.load %2[] : memref<i32>
      %48 = arith.addi %34, %c1_i32 : i32
      memref.store %48, %2[] : memref<i32>
      scf.yield %48 : i32
    } else {
      scf.yield %34 : i32
    }
    cf.br ^bb1(%43, %46 : i32, i32)
  ^bb3:  // pred: ^bb1
    scf.yield %33, %34 : i32, i32
  }
  scf.yield %28#0, %28#1 : i32, i32


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %29 = memref.load %11[] : memref<i1>
  %30 = scf.if %29 -> (i32) {
    memref.store %c0_i32, %2[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %14 : i32
  }
  %31 = memref.alloca() : memref<i1>
  %32 = memref.alloca() : memref<i1>
  memref.store %true, %32[] : memref<i1>
  cf.br ^bb1(%13, %30 : i32, i32)

 replaced mlir-asm-printer: Verifying operation: builtin.module
%29 = memref.load %11[] : memref<i1> with mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %2[] : memref<i32>
  scf.yield %c0_i32 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %2[] : memref<i32>
  scf.yield %c0_i32 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %14 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %14 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %29 = memref.load %11[] : memref<i1>
  %30 = scf.if %20 -> (i32) {
    memref.store %c0_i32, %2[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %14 : i32
  }
  %31 = memref.alloca() : memref<i1>
  %32 = memref.alloca() : memref<i1>
  memref.store %true, %32[] : memref<i1>
  cf.br ^bb1(%13, %30 : i32, i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
  %35 = memref.load %2[] : memref<i32>
  %36 = memref.get_global @jm : memref<1xi32>
  %37 = memref.load %36[%c0] : memref<1xi32>
  %38 = arith.cmpi slt, %34, %37 : i32
  %39 = memref.load %32[] : memref<i1>
  %40 = arith.andi %38, %39 : i1
  cf.cond_br %40, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
  %35 = memref.load %2[] : memref<i32>
  %36 = memref.get_global @jm : memref<1xi32>
  %37 = memref.load %36[%c0] : memref<1xi32>
  %38 = arith.cmpi slt, %34, %37 : i32
  %39 = memref.load %32[] : memref<i1>
  %40 = arith.andi %38, %39 : i1
  cf.cond_br %40, ^bb2, ^bb3
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %41, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %42 -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %47 -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %50 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %59 : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %61, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %62 {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %63, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %64 -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %44, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %45 -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %31[] : memref<i1>
  %48 = scf.if %47 -> (i32) {
    %49 = scf.execute_region -> i32 {
      %50 = memref.load %31[] : memref<i1>
      %51 = scf.if %50 -> (i32) {
        memref.store %c0_i32, %0[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %33 : i32
      }
      %52 = memref.alloca() : memref<i1>
      %53 = memref.alloca() : memref<i1>
      memref.store %true, %53[] : memref<i1>
      cf.br ^bb1(%51 : i32)
    ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
      %55 = memref.load %0[] : memref<i32>
      %56 = memref.get_global @im : memref<1xi32>
      %57 = memref.load %56[%c0] : memref<1xi32>
      %58 = arith.cmpi slt, %54, %57 : i32
      %59 = memref.load %53[] : memref<i1>
      %60 = arith.andi %58, %59 : i1
      cf.cond_br %60, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %61 = memref.load %53[] : memref<i1>
      memref.store %61, %52[] : memref<i1>
      %62 = memref.load %52[] : memref<i1>
      scf.if %62 {
        %66 = memref.load %4[] : memref<memref<?xf32>>
        %67 = memref.load %0[] : memref<i32>
        %68 = memref.load %2[] : memref<i32>
        %69 = memref.load %56[%c0] : memref<1xi32>
        %70 = arith.muli %34, %69 : i32
        %71 = arith.addi %54, %70 : i32
        %72 = memref.load %3[] : memref<i32>
        %73 = arith.muli %15, %69 : i32
        %74 = memref.load %36[%c0] : memref<1xi32>
        %75 = arith.muli %73, %74 : i32
        %76 = arith.addi %71, %75 : i32
        %77 = arith.index_cast %76 : i32 to index
        %78 = memref.load %5[] : memref<memref<?xf32>>
        %79 = arith.subi %15, %c1_i32 : i32
        %80 = arith.muli %79, %69 : i32
        %81 = arith.muli %80, %74 : i32
        %82 = arith.addi %71, %81 : i32
        %83 = arith.index_cast %82 : i32 to index
        %84 = arith.addi %83, %c0 : index
        %85 = memref.load %arg0[%84] : memref<?xf32>
        %86 = arith.addi %77, %c0 : index
        memref.store %85, %arg2[%86] : memref<?xf32>
      }
      %63 = memref.load %53[] : memref<i1>
      memref.store %63, %52[] : memref<i1>
      %64 = memref.load %52[] : memref<i1>
      %65 = scf.if %64 -> (i32) {
        %66 = memref.load %0[] : memref<i32>
        %67 = arith.addi %54, %c1_i32 : i32
        memref.store %67, %0[] : memref<i32>
        scf.yield %67 : i32
      } else {
        scf.yield %54 : i32
      }
      cf.br ^bb1(%65 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %54 : i32
    }
    scf.yield %49 : i32
  } else {
    scf.yield %33 : i32
  }
  scf.yield %48 : i32


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %49 = scf.execute_region -> i32 {
    %50 = memref.load %31[] : memref<i1>
    %51 = scf.if %50 -> (i32) {
      memref.store %c0_i32, %0[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %33 : i32
    }
    %52 = memref.alloca() : memref<i1>
    %53 = memref.alloca() : memref<i1>
    memref.store %true, %53[] : memref<i1>
    cf.br ^bb1(%51 : i32)
  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
    %55 = memref.load %0[] : memref<i32>
    %56 = memref.get_global @im : memref<1xi32>
    %57 = memref.load %56[%c0] : memref<1xi32>
    %58 = arith.cmpi slt, %54, %57 : i32
    %59 = memref.load %53[] : memref<i1>
    %60 = arith.andi %58, %59 : i1
    cf.cond_br %60, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %61 = memref.load %53[] : memref<i1>
    memref.store %61, %52[] : memref<i1>
    %62 = memref.load %52[] : memref<i1>
    scf.if %62 {
      %66 = memref.load %4[] : memref<memref<?xf32>>
      %67 = memref.load %0[] : memref<i32>
      %68 = memref.load %2[] : memref<i32>
      %69 = memref.load %56[%c0] : memref<1xi32>
      %70 = arith.muli %34, %69 : i32
      %71 = arith.addi %54, %70 : i32
      %72 = memref.load %3[] : memref<i32>
      %73 = arith.muli %15, %69 : i32
      %74 = memref.load %36[%c0] : memref<1xi32>
      %75 = arith.muli %73, %74 : i32
      %76 = arith.addi %71, %75 : i32
      %77 = arith.index_cast %76 : i32 to index
      %78 = memref.load %5[] : memref<memref<?xf32>>
      %79 = arith.subi %15, %c1_i32 : i32
      %80 = arith.muli %79, %69 : i32
      %81 = arith.muli %80, %74 : i32
      %82 = arith.addi %71, %81 : i32
      %83 = arith.index_cast %82 : i32 to index
      %84 = arith.addi %83, %c0 : index
      %85 = memref.load %arg0[%84] : memref<?xf32>
      %86 = arith.addi %77, %c0 : index
      memref.store %85, %arg2[%86] : memref<?xf32>
    }
    %63 = memref.load %53[] : memref<i1>
    memref.store %63, %52[] : memref<i1>
    %64 = memref.load %52[] : memref<i1>
    %65 = scf.if %64 -> (i32) {
      %66 = memref.load %0[] : memref<i32>
      %67 = arith.addi %54, %c1_i32 : i32
      memref.store %67, %0[] : memref<i32>
      scf.yield %67 : i32
    } else {
      scf.yield %54 : i32
    }
    cf.br ^bb1(%65 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %54 : i32
  }
  scf.yield %49 : i32


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %50 = memref.load %31[] : memref<i1>
  %51 = scf.if %50 -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %33 : i32
  }
  %52 = memref.alloca() : memref<i1>
  %53 = memref.alloca() : memref<i1>
  memref.store %true, %53[] : memref<i1>
  cf.br ^bb1(%51 : i32)


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield %c0_i32 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield %c0_i32 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %50 = memref.load %31[] : memref<i1>
  %51 = scf.if %50 -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %33 : i32
  }
  %52 = memref.alloca() : memref<i1>
  %53 = memref.alloca() : memref<i1>
  memref.store %true, %53[] : memref<i1>
  cf.br ^bb1(%51 : i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %59 : i1
  cf.cond_br %60, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %59 : i1
  cf.cond_br %60, ^bb2, ^bb3
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %61, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %62 {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %63, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %64 -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
  scf.yield
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %0[] : memref<i32>
  %67 = arith.addi %54, %c1_i32 : i32
  memref.store %67, %0[] : memref<i32>
  scf.yield %67 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %0[] : memref<i32>
  %67 = arith.addi %54, %c1_i32 : i32
  memref.store %67, %0[] : memref<i32>
  scf.yield %67 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %54 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %54 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %61, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %62 {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %63, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %64 -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %49 = scf.execute_region -> i32 {
    %50 = memref.load %31[] : memref<i1>
    %51 = scf.if %50 -> (i32) {
      memref.store %c0_i32, %0[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %33 : i32
    }
    %52 = memref.alloca() : memref<i1>
    %53 = memref.alloca() : memref<i1>
    memref.store %true, %53[] : memref<i1>
    cf.br ^bb1(%51 : i32)
  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
    %55 = memref.load %0[] : memref<i32>
    %56 = memref.get_global @im : memref<1xi32>
    %57 = memref.load %56[%c0] : memref<1xi32>
    %58 = arith.cmpi slt, %54, %57 : i32
    %59 = memref.load %53[] : memref<i1>
    %60 = arith.andi %58, %59 : i1
    cf.cond_br %60, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %61 = memref.load %53[] : memref<i1>
    memref.store %61, %52[] : memref<i1>
    %62 = memref.load %52[] : memref<i1>
    scf.if %62 {
      %66 = memref.load %4[] : memref<memref<?xf32>>
      %67 = memref.load %0[] : memref<i32>
      %68 = memref.load %2[] : memref<i32>
      %69 = memref.load %56[%c0] : memref<1xi32>
      %70 = arith.muli %34, %69 : i32
      %71 = arith.addi %54, %70 : i32
      %72 = memref.load %3[] : memref<i32>
      %73 = arith.muli %15, %69 : i32
      %74 = memref.load %36[%c0] : memref<1xi32>
      %75 = arith.muli %73, %74 : i32
      %76 = arith.addi %71, %75 : i32
      %77 = arith.index_cast %76 : i32 to index
      %78 = memref.load %5[] : memref<memref<?xf32>>
      %79 = arith.subi %15, %c1_i32 : i32
      %80 = arith.muli %79, %69 : i32
      %81 = arith.muli %80, %74 : i32
      %82 = arith.addi %71, %81 : i32
      %83 = arith.index_cast %82 : i32 to index
      %84 = arith.addi %83, %c0 : index
      %85 = memref.load %arg0[%84] : memref<?xf32>
      %86 = arith.addi %77, %c0 : index
      memref.store %85, %arg2[%86] : memref<?xf32>
    }
    %63 = memref.load %53[] : memref<i1>
    memref.store %63, %52[] : memref<i1>
    %64 = memref.load %52[] : memref<i1>
    %65 = scf.if %64 -> (i32) {
      %66 = memref.load %0[] : memref<i32>
      %67 = arith.addi %54, %c1_i32 : i32
      memref.store %67, %0[] : memref<i32>
      scf.yield %67 : i32
    } else {
      scf.yield %54 : i32
    }
    cf.br ^bb1(%65 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %54 : i32
  }
  scf.yield %49 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %31[] : memref<i1>
  %48 = scf.if %47 -> (i32) {
    %49 = scf.execute_region -> i32 {
      %50 = memref.load %31[] : memref<i1>
      %51 = scf.if %50 -> (i32) {
        memref.store %c0_i32, %0[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %33 : i32
      }
      %52 = memref.alloca() : memref<i1>
      %53 = memref.alloca() : memref<i1>
      memref.store %true, %53[] : memref<i1>
      cf.br ^bb1(%51 : i32)
    ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
      %55 = memref.load %0[] : memref<i32>
      %56 = memref.get_global @im : memref<1xi32>
      %57 = memref.load %56[%c0] : memref<1xi32>
      %58 = arith.cmpi slt, %54, %57 : i32
      %59 = memref.load %53[] : memref<i1>
      %60 = arith.andi %58, %59 : i1
      cf.cond_br %60, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %61 = memref.load %53[] : memref<i1>
      memref.store %61, %52[] : memref<i1>
      %62 = memref.load %52[] : memref<i1>
      scf.if %62 {
        %66 = memref.load %4[] : memref<memref<?xf32>>
        %67 = memref.load %0[] : memref<i32>
        %68 = memref.load %2[] : memref<i32>
        %69 = memref.load %56[%c0] : memref<1xi32>
        %70 = arith.muli %34, %69 : i32
        %71 = arith.addi %54, %70 : i32
        %72 = memref.load %3[] : memref<i32>
        %73 = arith.muli %15, %69 : i32
        %74 = memref.load %36[%c0] : memref<1xi32>
        %75 = arith.muli %73, %74 : i32
        %76 = arith.addi %71, %75 : i32
        %77 = arith.index_cast %76 : i32 to index
        %78 = memref.load %5[] : memref<memref<?xf32>>
        %79 = arith.subi %15, %c1_i32 : i32
        %80 = arith.muli %79, %69 : i32
        %81 = arith.muli %80, %74 : i32
        %82 = arith.addi %71, %81 : i32
        %83 = arith.index_cast %82 : i32 to index
        %84 = arith.addi %83, %c0 : index
        %85 = memref.load %arg0[%84] : memref<?xf32>
        %86 = arith.addi %77, %c0 : index
        memref.store %85, %arg2[%86] : memref<?xf32>
      }
      %63 = memref.load %53[] : memref<i1>
      memref.store %63, %52[] : memref<i1>
      %64 = memref.load %52[] : memref<i1>
      %65 = scf.if %64 -> (i32) {
        %66 = memref.load %0[] : memref<i32>
        %67 = arith.addi %54, %c1_i32 : i32
        memref.store %67, %0[] : memref<i32>
        scf.yield %67 : i32
      } else {
        scf.yield %54 : i32
      }
      cf.br ^bb1(%65 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %54 : i32
    }
    scf.yield %49 : i32
  } else {
    scf.yield %33 : i32
  }
  scf.yield %48 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %2[] : memref<i32>
  %48 = arith.addi %34, %c1_i32 : i32
  memref.store %48, %2[] : memref<i32>
  scf.yield %48 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %2[] : memref<i32>
  %48 = arith.addi %34, %c1_i32 : i32
  memref.store %48, %2[] : memref<i32>
  scf.yield %48 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %34 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %34 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %41, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %42 -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %47 -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %50 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %59 : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %61, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %62 {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %63, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %64 -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %44, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %45 -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %33, %34 : i32, i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %33, %34 : i32, i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %28:2 = scf.execute_region -> (i32, i32) {
    %29 = memref.load %11[] : memref<i1>
    %30 = scf.if %20 -> (i32) {
      memref.store %c0_i32, %2[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %14 : i32
    }
    %31 = memref.alloca() : memref<i1>
    %32 = memref.alloca() : memref<i1>
    memref.store %true, %32[] : memref<i1>
    cf.br ^bb1(%13, %30 : i32, i32)
  ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
    %35 = memref.load %2[] : memref<i32>
    %36 = memref.get_global @jm : memref<1xi32>
    %37 = memref.load %36[%c0] : memref<1xi32>
    %38 = arith.cmpi slt, %34, %37 : i32
    %39 = memref.load %32[] : memref<i1>
    %40 = arith.andi %38, %39 : i1
    cf.cond_br %40, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %41 = memref.load %32[] : memref<i1>
    memref.store %41, %31[] : memref<i1>
    %42 = memref.load %31[] : memref<i1>
    %43 = scf.if %42 -> (i32) {
      %47 = memref.load %31[] : memref<i1>
      %48 = scf.if %47 -> (i32) {
        %49 = scf.execute_region -> i32 {
          %50 = memref.load %31[] : memref<i1>
          %51 = scf.if %50 -> (i32) {
            memref.store %c0_i32, %0[] : memref<i32>
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %33 : i32
          }
          %52 = memref.alloca() : memref<i1>
          %53 = memref.alloca() : memref<i1>
          memref.store %true, %53[] : memref<i1>
          cf.br ^bb1(%51 : i32)
        ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
          %55 = memref.load %0[] : memref<i32>
          %56 = memref.get_global @im : memref<1xi32>
          %57 = memref.load %56[%c0] : memref<1xi32>
          %58 = arith.cmpi slt, %54, %57 : i32
          %59 = memref.load %53[] : memref<i1>
          %60 = arith.andi %58, %59 : i1
          cf.cond_br %60, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %61 = memref.load %53[] : memref<i1>
          memref.store %61, %52[] : memref<i1>
          %62 = memref.load %52[] : memref<i1>
          scf.if %62 {
            %66 = memref.load %4[] : memref<memref<?xf32>>
            %67 = memref.load %0[] : memref<i32>
            %68 = memref.load %2[] : memref<i32>
            %69 = memref.load %56[%c0] : memref<1xi32>
            %70 = arith.muli %34, %69 : i32
            %71 = arith.addi %54, %70 : i32
            %72 = memref.load %3[] : memref<i32>
            %73 = arith.muli %15, %69 : i32
            %74 = memref.load %36[%c0] : memref<1xi32>
            %75 = arith.muli %73, %74 : i32
            %76 = arith.addi %71, %75 : i32
            %77 = arith.index_cast %76 : i32 to index
            %78 = memref.load %5[] : memref<memref<?xf32>>
            %79 = arith.subi %15, %c1_i32 : i32
            %80 = arith.muli %79, %69 : i32
            %81 = arith.muli %80, %74 : i32
            %82 = arith.addi %71, %81 : i32
            %83 = arith.index_cast %82 : i32 to index
            %84 = arith.addi %83, %c0 : index
            %85 = memref.load %arg0[%84] : memref<?xf32>
            %86 = arith.addi %77, %c0 : index
            memref.store %85, %arg2[%86] : memref<?xf32>
          }
          %63 = memref.load %53[] : memref<i1>
          memref.store %63, %52[] : memref<i1>
          %64 = memref.load %52[] : memref<i1>
          %65 = scf.if %64 -> (i32) {
            %66 = memref.load %0[] : memref<i32>
            %67 = arith.addi %54, %c1_i32 : i32
            memref.store %67, %0[] : memref<i32>
            scf.yield %67 : i32
          } else {
            scf.yield %54 : i32
          }
          cf.br ^bb1(%65 : i32)
        ^bb3:  // pred: ^bb1
          scf.yield %54 : i32
        }
        scf.yield %49 : i32
      } else {
        scf.yield %33 : i32
      }
      scf.yield %48 : i32
    } else {
      scf.yield %33 : i32
    }
    %44 = memref.load %32[] : memref<i1>
    memref.store %44, %31[] : memref<i1>
    %45 = memref.load %31[] : memref<i1>
    %46 = scf.if %45 -> (i32) {
      %47 = memref.load %2[] : memref<i32>
      %48 = arith.addi %34, %c1_i32 : i32
      memref.store %48, %2[] : memref<i32>
      scf.yield %48 : i32
    } else {
      scf.yield %34 : i32
    }
    cf.br ^bb1(%43, %46 : i32, i32)
  ^bb3:  // pred: ^bb1
    scf.yield %33, %34 : i32, i32
  }
  scf.yield %28#0, %28#1 : i32, i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %13, %14 : i32, i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %13, %14 : i32, i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.load %11[] : memref<i1>
  %27:2 = scf.if %20 -> (i32, i32) {
    %28:2 = scf.execute_region -> (i32, i32) {
      %29 = memref.load %11[] : memref<i1>
      %30 = scf.if %20 -> (i32) {
        memref.store %c0_i32, %2[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %14 : i32
      }
      %31 = memref.alloca() : memref<i1>
      %32 = memref.alloca() : memref<i1>
      memref.store %true, %32[] : memref<i1>
      cf.br ^bb1(%13, %30 : i32, i32)
    ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
      %35 = memref.load %2[] : memref<i32>
      %36 = memref.get_global @jm : memref<1xi32>
      %37 = memref.load %36[%c0] : memref<1xi32>
      %38 = arith.cmpi slt, %34, %37 : i32
      %39 = memref.load %32[] : memref<i1>
      %40 = arith.andi %38, %39 : i1
      cf.cond_br %40, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %41 = memref.load %32[] : memref<i1>
      memref.store %41, %31[] : memref<i1>
      %42 = memref.load %31[] : memref<i1>
      %43 = scf.if %42 -> (i32) {
        %47 = memref.load %31[] : memref<i1>
        %48 = scf.if %47 -> (i32) {
          %49 = scf.execute_region -> i32 {
            %50 = memref.load %31[] : memref<i1>
            %51 = scf.if %50 -> (i32) {
              memref.store %c0_i32, %0[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %33 : i32
            }
            %52 = memref.alloca() : memref<i1>
            %53 = memref.alloca() : memref<i1>
            memref.store %true, %53[] : memref<i1>
            cf.br ^bb1(%51 : i32)
          ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
            %55 = memref.load %0[] : memref<i32>
            %56 = memref.get_global @im : memref<1xi32>
            %57 = memref.load %56[%c0] : memref<1xi32>
            %58 = arith.cmpi slt, %54, %57 : i32
            %59 = memref.load %53[] : memref<i1>
            %60 = arith.andi %58, %59 : i1
            cf.cond_br %60, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %61 = memref.load %53[] : memref<i1>
            memref.store %61, %52[] : memref<i1>
            %62 = memref.load %52[] : memref<i1>
            scf.if %62 {
              %66 = memref.load %4[] : memref<memref<?xf32>>
              %67 = memref.load %0[] : memref<i32>
              %68 = memref.load %2[] : memref<i32>
              %69 = memref.load %56[%c0] : memref<1xi32>
              %70 = arith.muli %34, %69 : i32
              %71 = arith.addi %54, %70 : i32
              %72 = memref.load %3[] : memref<i32>
              %73 = arith.muli %15, %69 : i32
              %74 = memref.load %36[%c0] : memref<1xi32>
              %75 = arith.muli %73, %74 : i32
              %76 = arith.addi %71, %75 : i32
              %77 = arith.index_cast %76 : i32 to index
              %78 = memref.load %5[] : memref<memref<?xf32>>
              %79 = arith.subi %15, %c1_i32 : i32
              %80 = arith.muli %79, %69 : i32
              %81 = arith.muli %80, %74 : i32
              %82 = arith.addi %71, %81 : i32
              %83 = arith.index_cast %82 : i32 to index
              %84 = arith.addi %83, %c0 : index
              %85 = memref.load %arg0[%84] : memref<?xf32>
              %86 = arith.addi %77, %c0 : index
              memref.store %85, %arg2[%86] : memref<?xf32>
            }
            %63 = memref.load %53[] : memref<i1>
            memref.store %63, %52[] : memref<i1>
            %64 = memref.load %52[] : memref<i1>
            %65 = scf.if %64 -> (i32) {
              %66 = memref.load %0[] : memref<i32>
              %67 = arith.addi %54, %c1_i32 : i32
              memref.store %67, %0[] : memref<i32>
              scf.yield %67 : i32
            } else {
              scf.yield %54 : i32
            }
            cf.br ^bb1(%65 : i32)
          ^bb3:  // pred: ^bb1
            scf.yield %54 : i32
          }
          scf.yield %49 : i32
        } else {
          scf.yield %33 : i32
        }
        scf.yield %48 : i32
      } else {
        scf.yield %33 : i32
      }
      %44 = memref.load %32[] : memref<i1>
      memref.store %44, %31[] : memref<i1>
      %45 = memref.load %31[] : memref<i1>
      %46 = scf.if %45 -> (i32) {
        %47 = memref.load %2[] : memref<i32>
        %48 = arith.addi %34, %c1_i32 : i32
        memref.store %48, %2[] : memref<i32>
        scf.yield %48 : i32
      } else {
        scf.yield %34 : i32
      }
      cf.br ^bb1(%43, %46 : i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield %33, %34 : i32, i32
    }
    scf.yield %28#0, %28#1 : i32, i32
  } else {
    scf.yield %13, %14 : i32, i32
  }
  scf.yield %27#0, %27#1 : i32, i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %13, %14 : i32, i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %13, %14 : i32, i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
 replaced mlir-asm-printer: Verifying operation: builtin.module
%24 = memref.load %11[] : memref<i1> with mlir-asm-printer: Verifying operation: builtin.module
%23 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%23 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.load %3[] : memref<i32>
  %27 = arith.subi %15, %c1_i32 : i32
  memref.store %27, %3[] : memref<i32>
  scf.yield %27 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.load %3[] : memref<i32>
  %27 = arith.subi %15, %c1_i32 : i32
  memref.store %27, %3[] : memref<i32>
  scf.yield %27 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%23 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%23 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %15 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %15 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%23 = memref.load %12[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %20 = memref.load %12[] : memref<i1>
  memref.store %20, %11[] : memref<i1>
  %21 = memref.load %11[] : memref<i1>
  %22:2 = scf.if %20 -> (i32, i32) {
    %26 = memref.load %11[] : memref<i1>
    %27:2 = scf.if %20 -> (i32, i32) {
      %28:2 = scf.execute_region -> (i32, i32) {
        %29 = memref.load %11[] : memref<i1>
        %30 = scf.if %20 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %14 : i32
        }
        %31 = memref.alloca() : memref<i1>
        %32 = memref.alloca() : memref<i1>
        memref.store %true, %32[] : memref<i1>
        cf.br ^bb1(%13, %30 : i32, i32)
      ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
        %35 = memref.load %2[] : memref<i32>
        %36 = memref.get_global @jm : memref<1xi32>
        %37 = memref.load %36[%c0] : memref<1xi32>
        %38 = arith.cmpi slt, %34, %37 : i32
        %39 = memref.load %32[] : memref<i1>
        %40 = arith.andi %38, %39 : i1
        cf.cond_br %40, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %41 = memref.load %32[] : memref<i1>
        memref.store %41, %31[] : memref<i1>
        %42 = memref.load %31[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %47 = memref.load %31[] : memref<i1>
          %48 = scf.if %47 -> (i32) {
            %49 = scf.execute_region -> i32 {
              %50 = memref.load %31[] : memref<i1>
              %51 = scf.if %50 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %33 : i32
              }
              %52 = memref.alloca() : memref<i1>
              %53 = memref.alloca() : memref<i1>
              memref.store %true, %53[] : memref<i1>
              cf.br ^bb1(%51 : i32)
            ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
              %55 = memref.load %0[] : memref<i32>
              %56 = memref.get_global @im : memref<1xi32>
              %57 = memref.load %56[%c0] : memref<1xi32>
              %58 = arith.cmpi slt, %54, %57 : i32
              %59 = memref.load %53[] : memref<i1>
              %60 = arith.andi %58, %59 : i1
              cf.cond_br %60, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %61 = memref.load %53[] : memref<i1>
              memref.store %61, %52[] : memref<i1>
              %62 = memref.load %52[] : memref<i1>
              scf.if %62 {
                %66 = memref.load %4[] : memref<memref<?xf32>>
                %67 = memref.load %0[] : memref<i32>
                %68 = memref.load %2[] : memref<i32>
                %69 = memref.load %56[%c0] : memref<1xi32>
                %70 = arith.muli %34, %69 : i32
                %71 = arith.addi %54, %70 : i32
                %72 = memref.load %3[] : memref<i32>
                %73 = arith.muli %15, %69 : i32
                %74 = memref.load %36[%c0] : memref<1xi32>
                %75 = arith.muli %73, %74 : i32
                %76 = arith.addi %71, %75 : i32
                %77 = arith.index_cast %76 : i32 to index
                %78 = memref.load %5[] : memref<memref<?xf32>>
                %79 = arith.subi %15, %c1_i32 : i32
                %80 = arith.muli %79, %69 : i32
                %81 = arith.muli %80, %74 : i32
                %82 = arith.addi %71, %81 : i32
                %83 = arith.index_cast %82 : i32 to index
                %84 = arith.addi %83, %c0 : index
                %85 = memref.load %arg0[%84] : memref<?xf32>
                %86 = arith.addi %77, %c0 : index
                memref.store %85, %arg2[%86] : memref<?xf32>
              }
              %63 = memref.load %53[] : memref<i1>
              memref.store %63, %52[] : memref<i1>
              %64 = memref.load %52[] : memref<i1>
              %65 = scf.if %64 -> (i32) {
                %66 = memref.load %0[] : memref<i32>
                %67 = arith.addi %54, %c1_i32 : i32
                memref.store %67, %0[] : memref<i32>
                scf.yield %67 : i32
              } else {
                scf.yield %54 : i32
              }
              cf.br ^bb1(%65 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %54 : i32
            }
            scf.yield %49 : i32
          } else {
            scf.yield %33 : i32
          }
          scf.yield %48 : i32
        } else {
          scf.yield %33 : i32
        }
        %44 = memref.load %32[] : memref<i1>
        memref.store %44, %31[] : memref<i1>
        %45 = memref.load %31[] : memref<i1>
        %46 = scf.if %45 -> (i32) {
          %47 = memref.load %2[] : memref<i32>
          %48 = arith.addi %34, %c1_i32 : i32
          memref.store %48, %2[] : memref<i32>
          scf.yield %48 : i32
        } else {
          scf.yield %34 : i32
        }
        cf.br ^bb1(%43, %46 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %33, %34 : i32, i32
      }
      scf.yield %28#0, %28#1 : i32, i32
    } else {
      scf.yield %13, %14 : i32, i32
    }
    scf.yield %27#0, %27#1 : i32, i32
  } else {
    scf.yield %13, %14 : i32, i32
  }
  %23 = memref.load %12[] : memref<i1>
  memref.store %23, %11[] : memref<i1>
  %24 = memref.load %11[] : memref<i1>
  %25 = scf.if %23 -> (i32) {
    %26 = memref.load %3[] : memref<i32>
    %27 = arith.subi %15, %c1_i32 : i32
    memref.store %27, %3[] : memref<i32>
    scf.yield %27 : i32
  } else {
    scf.yield %15 : i32
  }
  cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%23 = memref.load %12[] : memref<i1>
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%12 = memref.alloca() : memref<i1>
 + forwarding vec to promote {} of mlir-asm-printer: Verifying operation: builtin.module
%12 = memref.alloca() : memref<i1>
Begin forwarding store of mlir-asm-printer: Verifying operation: builtin.module
%12 = memref.alloca() : memref<i1> to load
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %true {
    %8 = memref.load %6[] : memref<i1>
    scf.if %true {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        %10 = scf.if %true -> (i32) {
          %26 = memref.get_global @kbm3 : memref<1xi32>
          %27 = memref.load %26[%c0] : memref<1xi32>
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %1 : i32
        }
        %11 = memref.alloca() : memref<i1>
        %12 = memref.alloca() : memref<i1>
        memref.store %true, %12[] : memref<i1>
        cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
      ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
        %16 = memref.load %3[] : memref<i32>
        %17 = arith.cmpi sgt, %15, %c0_i32 : i32
        %18 = memref.load %12[] : memref<i1>
        %19 = arith.andi %17, %18 : i1
        cf.cond_br %19, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %20 = memref.load %12[] : memref<i1>
        memref.store %20, %11[] : memref<i1>
        %21 = memref.load %11[] : memref<i1>
        %22:2 = scf.if %20 -> (i32, i32) {
          %26 = memref.load %11[] : memref<i1>
          %27:2 = scf.if %20 -> (i32, i32) {
            %28:2 = scf.execute_region -> (i32, i32) {
              %29 = memref.load %11[] : memref<i1>
              %30 = scf.if %20 -> (i32) {
                memref.store %c0_i32, %2[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %14 : i32
              }
              %31 = memref.alloca() : memref<i1>
              %32 = memref.alloca() : memref<i1>
              memref.store %true, %32[] : memref<i1>
              cf.br ^bb1(%13, %30 : i32, i32)
            ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
              %35 = memref.load %2[] : memref<i32>
              %36 = memref.get_global @jm : memref<1xi32>
              %37 = memref.load %36[%c0] : memref<1xi32>
              %38 = arith.cmpi slt, %34, %37 : i32
              %39 = memref.load %32[] : memref<i1>
              %40 = arith.andi %38, %39 : i1
              cf.cond_br %40, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %41 = memref.load %32[] : memref<i1>
              memref.store %41, %31[] : memref<i1>
              %42 = memref.load %31[] : memref<i1>
              %43 = scf.if %42 -> (i32) {
                %47 = memref.load %31[] : memref<i1>
                %48 = scf.if %47 -> (i32) {
                  %49 = scf.execute_region -> i32 {
                    %50 = memref.load %31[] : memref<i1>
                    %51 = scf.if %50 -> (i32) {
                      memref.store %c0_i32, %0[] : memref<i32>
                      scf.yield %c0_i32 : i32
                    } else {
                      scf.yield %33 : i32
                    }
                    %52 = memref.alloca() : memref<i1>
                    %53 = memref.alloca() : memref<i1>
                    memref.store %true, %53[] : memref<i1>
                    cf.br ^bb1(%51 : i32)
                  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                    %55 = memref.load %0[] : memref<i32>
                    %56 = memref.get_global @im : memref<1xi32>
                    %57 = memref.load %56[%c0] : memref<1xi32>
                    %58 = arith.cmpi slt, %54, %57 : i32
                    %59 = memref.load %53[] : memref<i1>
                    %60 = arith.andi %58, %59 : i1
                    cf.cond_br %60, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %61 = memref.load %53[] : memref<i1>
                    memref.store %61, %52[] : memref<i1>
                    %62 = memref.load %52[] : memref<i1>
                    scf.if %62 {
                      %66 = memref.load %4[] : memref<memref<?xf32>>
                      %67 = memref.load %0[] : memref<i32>
                      %68 = memref.load %2[] : memref<i32>
                      %69 = memref.load %56[%c0] : memref<1xi32>
                      %70 = arith.muli %34, %69 : i32
                      %71 = arith.addi %54, %70 : i32
                      %72 = memref.load %3[] : memref<i32>
                      %73 = arith.muli %15, %69 : i32
                      %74 = memref.load %36[%c0] : memref<1xi32>
                      %75 = arith.muli %73, %74 : i32
                      %76 = arith.addi %71, %75 : i32
                      %77 = arith.index_cast %76 : i32 to index
                      %78 = memref.load %5[] : memref<memref<?xf32>>
                      %79 = arith.subi %15, %c1_i32 : i32
                      %80 = arith.muli %79, %69 : i32
                      %81 = arith.muli %80, %74 : i32
                      %82 = arith.addi %71, %81 : i32
                      %83 = arith.index_cast %82 : i32 to index
                      %84 = arith.addi %83, %c0 : index
                      %85 = memref.load %arg0[%84] : memref<?xf32>
                      %86 = arith.addi %77, %c0 : index
                      memref.store %85, %arg2[%86] : memref<?xf32>
                    }
                    %63 = memref.load %53[] : memref<i1>
                    memref.store %63, %52[] : memref<i1>
                    %64 = memref.load %52[] : memref<i1>
                    %65 = scf.if %64 -> (i32) {
                      %66 = memref.load %0[] : memref<i32>
                      %67 = arith.addi %54, %c1_i32 : i32
                      memref.store %67, %0[] : memref<i32>
                      scf.yield %67 : i32
                    } else {
                      scf.yield %54 : i32
                    }
                    cf.br ^bb1(%65 : i32)
                  ^bb3:  // pred: ^bb1
                    scf.yield %54 : i32
                  }
                  scf.yield %49 : i32
                } else {
                  scf.yield %33 : i32
                }
                scf.yield %48 : i32
              } else {
                scf.yield %33 : i32
              }
              %44 = memref.load %32[] : memref<i1>
              memref.store %44, %31[] : memref<i1>
              %45 = memref.load %31[] : memref<i1>
              %46 = scf.if %45 -> (i32) {
                %47 = memref.load %2[] : memref<i32>
                %48 = arith.addi %34, %c1_i32 : i32
                memref.store %48, %2[] : memref<i32>
                scf.yield %48 : i32
              } else {
                scf.yield %34 : i32
              }
              cf.br ^bb1(%43, %46 : i32, i32)
            ^bb3:  // pred: ^bb1
              scf.yield %33, %34 : i32, i32
            }
            scf.yield %28#0, %28#1 : i32, i32
          } else {
            scf.yield %13, %14 : i32, i32
          }
          scf.yield %27#0, %27#1 : i32, i32
        } else {
          scf.yield %13, %14 : i32, i32
        }
        %23 = memref.load %12[] : memref<i1>
        memref.store %23, %11[] : memref<i1>
        %24 = memref.load %11[] : memref<i1>
        %25 = scf.if %23 -> (i32) {
          %26 = memref.load %3[] : memref<i32>
          %27 = arith.subi %15, %c1_i32 : i32
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %15 : i32
        }
        cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}
Matching Load: mlir-asm-printer: Verifying operation: func.func
%23 = memref.load %12[] : memref<i1>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%20 = memref.load %12[] : memref<i1>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%18 = memref.load %12[] : memref<i1>
Matching Store: mlir-asm-printer: Verifying operation: func.func
memref.store %true, %12[] : memref<i1>
 storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %true, %12[] : memref<i1>
 initial storing block: 0x7fbd98166b90
 derived storing block: 0x7fbd981669f0
 initial storing block: 0x7fbd981669f0
 derived storing block: 0x7fbd98166740
 initial storing block: 0x7fbd98166740
 derived storing block: 0x7fbd98164100
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %9 = memref.load %6[] : memref<i1>
  %10 = scf.if %true -> (i32) {
    %26 = memref.get_global @kbm3 : memref<1xi32>
    %27 = memref.load %26[%c0] : memref<1xi32>
    memref.store %27, %3[] : memref<i32>
    scf.yield %27 : i32
  } else {
    scf.yield %1 : i32
  }
  %11 = memref.alloca() : memref<i1>
  %12 = memref.alloca() : memref<i1>
  memref.store %true, %12[] : memref<i1>
  cf.br ^bb1(%1, %1, %10 : i32, i32, i32)


starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.get_global @kbm3 : memref<1xi32>
  %27 = memref.load %26[%c0] : memref<1xi32>
  memref.store %27, %3[] : memref<i32>
  scf.yield %27 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.get_global @kbm3 : memref<1xi32>
  %27 = memref.load %26[%c0] : memref<1xi32>
  memref.store %27, %3[] : memref<i32>
  scf.yield %27 : i32
 with val:<overwritten>

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %1 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %1 : i32
 with val:<overwritten>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %9 = memref.load %6[] : memref<i1>
  %10 = scf.if %true -> (i32) {
    %26 = memref.get_global @kbm3 : memref<1xi32>
    %27 = memref.load %26[%c0] : memref<1xi32>
    memref.store %27, %3[] : memref<i32>
    scf.yield %27 : i32
  } else {
    scf.yield %1 : i32
  }
  %11 = memref.alloca() : memref<i1>
  %12 = memref.alloca() : memref<i1>
  memref.store %true, %12[] : memref<i1>
  cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
  %16 = memref.load %3[] : memref<i32>
  %17 = arith.cmpi sgt, %15, %c0_i32 : i32
  %18 = memref.load %12[] : memref<i1>
  %19 = arith.andi %17, %18 : i1
  cf.cond_br %19, ^bb2, ^bb3

mlir-asm-printer: Verifying operation: builtin.module
^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
  %16 = memref.load %3[] : memref<i32>
  %17 = arith.cmpi sgt, %15, %c0_i32 : i32
  %18 = memref.load %12[] : memref<i1>
  %19 = arith.andi %17, %18 : i1
  cf.cond_br %19, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
  %16 = memref.load %3[] : memref<i32>
  %17 = arith.cmpi sgt, %15, %c0_i32 : i32
  %18 = memref.load %12[] : memref<i1>
  %19 = arith.andi %17, %18 : i1
  cf.cond_br %19, ^bb2, ^bb3
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%18 = memref.load %12[] : memref<i1>

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield

mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %20 = memref.load %12[] : memref<i1>
  memref.store %20, %11[] : memref<i1>
  %21 = memref.load %11[] : memref<i1>
  %22:2 = scf.if %20 -> (i32, i32) {
    %26 = memref.load %11[] : memref<i1>
    %27:2 = scf.if %20 -> (i32, i32) {
      %28:2 = scf.execute_region -> (i32, i32) {
        %29 = memref.load %11[] : memref<i1>
        %30 = scf.if %20 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %14 : i32
        }
        %31 = memref.alloca() : memref<i1>
        %32 = memref.alloca() : memref<i1>
        memref.store %true, %32[] : memref<i1>
        cf.br ^bb1(%13, %30 : i32, i32)
      ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
        %35 = memref.load %2[] : memref<i32>
        %36 = memref.get_global @jm : memref<1xi32>
        %37 = memref.load %36[%c0] : memref<1xi32>
        %38 = arith.cmpi slt, %34, %37 : i32
        %39 = memref.load %32[] : memref<i1>
        %40 = arith.andi %38, %39 : i1
        cf.cond_br %40, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %41 = memref.load %32[] : memref<i1>
        memref.store %41, %31[] : memref<i1>
        %42 = memref.load %31[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %47 = memref.load %31[] : memref<i1>
          %48 = scf.if %47 -> (i32) {
            %49 = scf.execute_region -> i32 {
              %50 = memref.load %31[] : memref<i1>
              %51 = scf.if %50 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %33 : i32
              }
              %52 = memref.alloca() : memref<i1>
              %53 = memref.alloca() : memref<i1>
              memref.store %true, %53[] : memref<i1>
              cf.br ^bb1(%51 : i32)
            ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
              %55 = memref.load %0[] : memref<i32>
              %56 = memref.get_global @im : memref<1xi32>
              %57 = memref.load %56[%c0] : memref<1xi32>
              %58 = arith.cmpi slt, %54, %57 : i32
              %59 = memref.load %53[] : memref<i1>
              %60 = arith.andi %58, %59 : i1
              cf.cond_br %60, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %61 = memref.load %53[] : memref<i1>
              memref.store %61, %52[] : memref<i1>
              %62 = memref.load %52[] : memref<i1>
              scf.if %62 {
                %66 = memref.load %4[] : memref<memref<?xf32>>
                %67 = memref.load %0[] : memref<i32>
                %68 = memref.load %2[] : memref<i32>
                %69 = memref.load %56[%c0] : memref<1xi32>
                %70 = arith.muli %34, %69 : i32
                %71 = arith.addi %54, %70 : i32
                %72 = memref.load %3[] : memref<i32>
                %73 = arith.muli %15, %69 : i32
                %74 = memref.load %36[%c0] : memref<1xi32>
                %75 = arith.muli %73, %74 : i32
                %76 = arith.addi %71, %75 : i32
                %77 = arith.index_cast %76 : i32 to index
                %78 = memref.load %5[] : memref<memref<?xf32>>
                %79 = arith.subi %15, %c1_i32 : i32
                %80 = arith.muli %79, %69 : i32
                %81 = arith.muli %80, %74 : i32
                %82 = arith.addi %71, %81 : i32
                %83 = arith.index_cast %82 : i32 to index
                %84 = arith.addi %83, %c0 : index
                %85 = memref.load %arg0[%84] : memref<?xf32>
                %86 = arith.addi %77, %c0 : index
                memref.store %85, %arg2[%86] : memref<?xf32>
              }
              %63 = memref.load %53[] : memref<i1>
              memref.store %63, %52[] : memref<i1>
              %64 = memref.load %52[] : memref<i1>
              %65 = scf.if %64 -> (i32) {
                %66 = memref.load %0[] : memref<i32>
                %67 = arith.addi %54, %c1_i32 : i32
                memref.store %67, %0[] : memref<i32>
                scf.yield %67 : i32
              } else {
                scf.yield %54 : i32
              }
              cf.br ^bb1(%65 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %54 : i32
            }
            scf.yield %49 : i32
          } else {
            scf.yield %33 : i32
          }
          scf.yield %48 : i32
        } else {
          scf.yield %33 : i32
        }
        %44 = memref.load %32[] : memref<i1>
        memref.store %44, %31[] : memref<i1>
        %45 = memref.load %31[] : memref<i1>
        %46 = scf.if %45 -> (i32) {
          %47 = memref.load %2[] : memref<i32>
          %48 = arith.addi %34, %c1_i32 : i32
          memref.store %48, %2[] : memref<i32>
          scf.yield %48 : i32
        } else {
          scf.yield %34 : i32
        }
        cf.br ^bb1(%43, %46 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %33, %34 : i32, i32
      }
      scf.yield %28#0, %28#1 : i32, i32
    } else {
      scf.yield %13, %14 : i32, i32
    }
    scf.yield %27#0, %27#1 : i32, i32
  } else {
    scf.yield %13, %14 : i32, i32
  }
  %23 = memref.load %12[] : memref<i1>
  memref.store %23, %11[] : memref<i1>
  %24 = memref.load %11[] : memref<i1>
  %25 = scf.if %23 -> (i32) {
    %26 = memref.load %3[] : memref<i32>
    %27 = arith.subi %15, %c1_i32 : i32
    memref.store %27, %3[] : memref<i32>
    scf.yield %27 : i32
  } else {
    scf.yield %15 : i32
  }
  cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %20 = memref.load %12[] : memref<i1>
  memref.store %20, %11[] : memref<i1>
  %21 = memref.load %11[] : memref<i1>
  %22:2 = scf.if %20 -> (i32, i32) {
    %26 = memref.load %11[] : memref<i1>
    %27:2 = scf.if %20 -> (i32, i32) {
      %28:2 = scf.execute_region -> (i32, i32) {
        %29 = memref.load %11[] : memref<i1>
        %30 = scf.if %20 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %14 : i32
        }
        %31 = memref.alloca() : memref<i1>
        %32 = memref.alloca() : memref<i1>
        memref.store %true, %32[] : memref<i1>
        cf.br ^bb1(%13, %30 : i32, i32)
      ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
        %35 = memref.load %2[] : memref<i32>
        %36 = memref.get_global @jm : memref<1xi32>
        %37 = memref.load %36[%c0] : memref<1xi32>
        %38 = arith.cmpi slt, %34, %37 : i32
        %39 = memref.load %32[] : memref<i1>
        %40 = arith.andi %38, %39 : i1
        cf.cond_br %40, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %41 = memref.load %32[] : memref<i1>
        memref.store %41, %31[] : memref<i1>
        %42 = memref.load %31[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %47 = memref.load %31[] : memref<i1>
          %48 = scf.if %47 -> (i32) {
            %49 = scf.execute_region -> i32 {
              %50 = memref.load %31[] : memref<i1>
              %51 = scf.if %50 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %33 : i32
              }
              %52 = memref.alloca() : memref<i1>
              %53 = memref.alloca() : memref<i1>
              memref.store %true, %53[] : memref<i1>
              cf.br ^bb1(%51 : i32)
            ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
              %55 = memref.load %0[] : memref<i32>
              %56 = memref.get_global @im : memref<1xi32>
              %57 = memref.load %56[%c0] : memref<1xi32>
              %58 = arith.cmpi slt, %54, %57 : i32
              %59 = memref.load %53[] : memref<i1>
              %60 = arith.andi %58, %59 : i1
              cf.cond_br %60, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %61 = memref.load %53[] : memref<i1>
              memref.store %61, %52[] : memref<i1>
              %62 = memref.load %52[] : memref<i1>
              scf.if %62 {
                %66 = memref.load %4[] : memref<memref<?xf32>>
                %67 = memref.load %0[] : memref<i32>
                %68 = memref.load %2[] : memref<i32>
                %69 = memref.load %56[%c0] : memref<1xi32>
                %70 = arith.muli %34, %69 : i32
                %71 = arith.addi %54, %70 : i32
                %72 = memref.load %3[] : memref<i32>
                %73 = arith.muli %15, %69 : i32
                %74 = memref.load %36[%c0] : memref<1xi32>
                %75 = arith.muli %73, %74 : i32
                %76 = arith.addi %71, %75 : i32
                %77 = arith.index_cast %76 : i32 to index
                %78 = memref.load %5[] : memref<memref<?xf32>>
                %79 = arith.subi %15, %c1_i32 : i32
                %80 = arith.muli %79, %69 : i32
                %81 = arith.muli %80, %74 : i32
                %82 = arith.addi %71, %81 : i32
                %83 = arith.index_cast %82 : i32 to index
                %84 = arith.addi %83, %c0 : index
                %85 = memref.load %arg0[%84] : memref<?xf32>
                %86 = arith.addi %77, %c0 : index
                memref.store %85, %arg2[%86] : memref<?xf32>
              }
              %63 = memref.load %53[] : memref<i1>
              memref.store %63, %52[] : memref<i1>
              %64 = memref.load %52[] : memref<i1>
              %65 = scf.if %64 -> (i32) {
                %66 = memref.load %0[] : memref<i32>
                %67 = arith.addi %54, %c1_i32 : i32
                memref.store %67, %0[] : memref<i32>
                scf.yield %67 : i32
              } else {
                scf.yield %54 : i32
              }
              cf.br ^bb1(%65 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %54 : i32
            }
            scf.yield %49 : i32
          } else {
            scf.yield %33 : i32
          }
          scf.yield %48 : i32
        } else {
          scf.yield %33 : i32
        }
        %44 = memref.load %32[] : memref<i1>
        memref.store %44, %31[] : memref<i1>
        %45 = memref.load %31[] : memref<i1>
        %46 = scf.if %45 -> (i32) {
          %47 = memref.load %2[] : memref<i32>
          %48 = arith.addi %34, %c1_i32 : i32
          memref.store %48, %2[] : memref<i32>
          scf.yield %48 : i32
        } else {
          scf.yield %34 : i32
        }
        cf.br ^bb1(%43, %46 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %33, %34 : i32, i32
      }
      scf.yield %28#0, %28#1 : i32, i32
    } else {
      scf.yield %13, %14 : i32, i32
    }
    scf.yield %27#0, %27#1 : i32, i32
  } else {
    scf.yield %13, %14 : i32, i32
  }
  %23 = memref.load %12[] : memref<i1>
  memref.store %23, %11[] : memref<i1>
  %24 = memref.load %11[] : memref<i1>
  %25 = scf.if %23 -> (i32) {
    %26 = memref.load %3[] : memref<i32>
    %27 = arith.subi %15, %c1_i32 : i32
    memref.store %27, %3[] : memref<i32>
    scf.yield %27 : i32
  } else {
    scf.yield %15 : i32
  }
  cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.load %11[] : memref<i1>
  %27:2 = scf.if %20 -> (i32, i32) {
    %28:2 = scf.execute_region -> (i32, i32) {
      %29 = memref.load %11[] : memref<i1>
      %30 = scf.if %20 -> (i32) {
        memref.store %c0_i32, %2[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %14 : i32
      }
      %31 = memref.alloca() : memref<i1>
      %32 = memref.alloca() : memref<i1>
      memref.store %true, %32[] : memref<i1>
      cf.br ^bb1(%13, %30 : i32, i32)
    ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
      %35 = memref.load %2[] : memref<i32>
      %36 = memref.get_global @jm : memref<1xi32>
      %37 = memref.load %36[%c0] : memref<1xi32>
      %38 = arith.cmpi slt, %34, %37 : i32
      %39 = memref.load %32[] : memref<i1>
      %40 = arith.andi %38, %39 : i1
      cf.cond_br %40, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %41 = memref.load %32[] : memref<i1>
      memref.store %41, %31[] : memref<i1>
      %42 = memref.load %31[] : memref<i1>
      %43 = scf.if %42 -> (i32) {
        %47 = memref.load %31[] : memref<i1>
        %48 = scf.if %47 -> (i32) {
          %49 = scf.execute_region -> i32 {
            %50 = memref.load %31[] : memref<i1>
            %51 = scf.if %50 -> (i32) {
              memref.store %c0_i32, %0[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %33 : i32
            }
            %52 = memref.alloca() : memref<i1>
            %53 = memref.alloca() : memref<i1>
            memref.store %true, %53[] : memref<i1>
            cf.br ^bb1(%51 : i32)
          ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
            %55 = memref.load %0[] : memref<i32>
            %56 = memref.get_global @im : memref<1xi32>
            %57 = memref.load %56[%c0] : memref<1xi32>
            %58 = arith.cmpi slt, %54, %57 : i32
            %59 = memref.load %53[] : memref<i1>
            %60 = arith.andi %58, %59 : i1
            cf.cond_br %60, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %61 = memref.load %53[] : memref<i1>
            memref.store %61, %52[] : memref<i1>
            %62 = memref.load %52[] : memref<i1>
            scf.if %62 {
              %66 = memref.load %4[] : memref<memref<?xf32>>
              %67 = memref.load %0[] : memref<i32>
              %68 = memref.load %2[] : memref<i32>
              %69 = memref.load %56[%c0] : memref<1xi32>
              %70 = arith.muli %34, %69 : i32
              %71 = arith.addi %54, %70 : i32
              %72 = memref.load %3[] : memref<i32>
              %73 = arith.muli %15, %69 : i32
              %74 = memref.load %36[%c0] : memref<1xi32>
              %75 = arith.muli %73, %74 : i32
              %76 = arith.addi %71, %75 : i32
              %77 = arith.index_cast %76 : i32 to index
              %78 = memref.load %5[] : memref<memref<?xf32>>
              %79 = arith.subi %15, %c1_i32 : i32
              %80 = arith.muli %79, %69 : i32
              %81 = arith.muli %80, %74 : i32
              %82 = arith.addi %71, %81 : i32
              %83 = arith.index_cast %82 : i32 to index
              %84 = arith.addi %83, %c0 : index
              %85 = memref.load %arg0[%84] : memref<?xf32>
              %86 = arith.addi %77, %c0 : index
              memref.store %85, %arg2[%86] : memref<?xf32>
            }
            %63 = memref.load %53[] : memref<i1>
            memref.store %63, %52[] : memref<i1>
            %64 = memref.load %52[] : memref<i1>
            %65 = scf.if %64 -> (i32) {
              %66 = memref.load %0[] : memref<i32>
              %67 = arith.addi %54, %c1_i32 : i32
              memref.store %67, %0[] : memref<i32>
              scf.yield %67 : i32
            } else {
              scf.yield %54 : i32
            }
            cf.br ^bb1(%65 : i32)
          ^bb3:  // pred: ^bb1
            scf.yield %54 : i32
          }
          scf.yield %49 : i32
        } else {
          scf.yield %33 : i32
        }
        scf.yield %48 : i32
      } else {
        scf.yield %33 : i32
      }
      %44 = memref.load %32[] : memref<i1>
      memref.store %44, %31[] : memref<i1>
      %45 = memref.load %31[] : memref<i1>
      %46 = scf.if %45 -> (i32) {
        %47 = memref.load %2[] : memref<i32>
        %48 = arith.addi %34, %c1_i32 : i32
        memref.store %48, %2[] : memref<i32>
        scf.yield %48 : i32
      } else {
        scf.yield %34 : i32
      }
      cf.br ^bb1(%43, %46 : i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield %33, %34 : i32, i32
    }
    scf.yield %28#0, %28#1 : i32, i32
  } else {
    scf.yield %13, %14 : i32, i32
  }
  scf.yield %27#0, %27#1 : i32, i32


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %28:2 = scf.execute_region -> (i32, i32) {
    %29 = memref.load %11[] : memref<i1>
    %30 = scf.if %20 -> (i32) {
      memref.store %c0_i32, %2[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %14 : i32
    }
    %31 = memref.alloca() : memref<i1>
    %32 = memref.alloca() : memref<i1>
    memref.store %true, %32[] : memref<i1>
    cf.br ^bb1(%13, %30 : i32, i32)
  ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
    %35 = memref.load %2[] : memref<i32>
    %36 = memref.get_global @jm : memref<1xi32>
    %37 = memref.load %36[%c0] : memref<1xi32>
    %38 = arith.cmpi slt, %34, %37 : i32
    %39 = memref.load %32[] : memref<i1>
    %40 = arith.andi %38, %39 : i1
    cf.cond_br %40, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %41 = memref.load %32[] : memref<i1>
    memref.store %41, %31[] : memref<i1>
    %42 = memref.load %31[] : memref<i1>
    %43 = scf.if %42 -> (i32) {
      %47 = memref.load %31[] : memref<i1>
      %48 = scf.if %47 -> (i32) {
        %49 = scf.execute_region -> i32 {
          %50 = memref.load %31[] : memref<i1>
          %51 = scf.if %50 -> (i32) {
            memref.store %c0_i32, %0[] : memref<i32>
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %33 : i32
          }
          %52 = memref.alloca() : memref<i1>
          %53 = memref.alloca() : memref<i1>
          memref.store %true, %53[] : memref<i1>
          cf.br ^bb1(%51 : i32)
        ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
          %55 = memref.load %0[] : memref<i32>
          %56 = memref.get_global @im : memref<1xi32>
          %57 = memref.load %56[%c0] : memref<1xi32>
          %58 = arith.cmpi slt, %54, %57 : i32
          %59 = memref.load %53[] : memref<i1>
          %60 = arith.andi %58, %59 : i1
          cf.cond_br %60, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %61 = memref.load %53[] : memref<i1>
          memref.store %61, %52[] : memref<i1>
          %62 = memref.load %52[] : memref<i1>
          scf.if %62 {
            %66 = memref.load %4[] : memref<memref<?xf32>>
            %67 = memref.load %0[] : memref<i32>
            %68 = memref.load %2[] : memref<i32>
            %69 = memref.load %56[%c0] : memref<1xi32>
            %70 = arith.muli %34, %69 : i32
            %71 = arith.addi %54, %70 : i32
            %72 = memref.load %3[] : memref<i32>
            %73 = arith.muli %15, %69 : i32
            %74 = memref.load %36[%c0] : memref<1xi32>
            %75 = arith.muli %73, %74 : i32
            %76 = arith.addi %71, %75 : i32
            %77 = arith.index_cast %76 : i32 to index
            %78 = memref.load %5[] : memref<memref<?xf32>>
            %79 = arith.subi %15, %c1_i32 : i32
            %80 = arith.muli %79, %69 : i32
            %81 = arith.muli %80, %74 : i32
            %82 = arith.addi %71, %81 : i32
            %83 = arith.index_cast %82 : i32 to index
            %84 = arith.addi %83, %c0 : index
            %85 = memref.load %arg0[%84] : memref<?xf32>
            %86 = arith.addi %77, %c0 : index
            memref.store %85, %arg2[%86] : memref<?xf32>
          }
          %63 = memref.load %53[] : memref<i1>
          memref.store %63, %52[] : memref<i1>
          %64 = memref.load %52[] : memref<i1>
          %65 = scf.if %64 -> (i32) {
            %66 = memref.load %0[] : memref<i32>
            %67 = arith.addi %54, %c1_i32 : i32
            memref.store %67, %0[] : memref<i32>
            scf.yield %67 : i32
          } else {
            scf.yield %54 : i32
          }
          cf.br ^bb1(%65 : i32)
        ^bb3:  // pred: ^bb1
          scf.yield %54 : i32
        }
        scf.yield %49 : i32
      } else {
        scf.yield %33 : i32
      }
      scf.yield %48 : i32
    } else {
      scf.yield %33 : i32
    }
    %44 = memref.load %32[] : memref<i1>
    memref.store %44, %31[] : memref<i1>
    %45 = memref.load %31[] : memref<i1>
    %46 = scf.if %45 -> (i32) {
      %47 = memref.load %2[] : memref<i32>
      %48 = arith.addi %34, %c1_i32 : i32
      memref.store %48, %2[] : memref<i32>
      scf.yield %48 : i32
    } else {
      scf.yield %34 : i32
    }
    cf.br ^bb1(%43, %46 : i32, i32)
  ^bb3:  // pred: ^bb1
    scf.yield %33, %34 : i32, i32
  }
  scf.yield %28#0, %28#1 : i32, i32


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %29 = memref.load %11[] : memref<i1>
  %30 = scf.if %20 -> (i32) {
    memref.store %c0_i32, %2[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %14 : i32
  }
  %31 = memref.alloca() : memref<i1>
  %32 = memref.alloca() : memref<i1>
  memref.store %true, %32[] : memref<i1>
  cf.br ^bb1(%13, %30 : i32, i32)


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %2[] : memref<i32>
  scf.yield %c0_i32 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %2[] : memref<i32>
  scf.yield %c0_i32 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %14 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %14 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %29 = memref.load %11[] : memref<i1>
  %30 = scf.if %20 -> (i32) {
    memref.store %c0_i32, %2[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %14 : i32
  }
  %31 = memref.alloca() : memref<i1>
  %32 = memref.alloca() : memref<i1>
  memref.store %true, %32[] : memref<i1>
  cf.br ^bb1(%13, %30 : i32, i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
  %35 = memref.load %2[] : memref<i32>
  %36 = memref.get_global @jm : memref<1xi32>
  %37 = memref.load %36[%c0] : memref<1xi32>
  %38 = arith.cmpi slt, %34, %37 : i32
  %39 = memref.load %32[] : memref<i1>
  %40 = arith.andi %38, %39 : i1
  cf.cond_br %40, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
  %35 = memref.load %2[] : memref<i32>
  %36 = memref.get_global @jm : memref<1xi32>
  %37 = memref.load %36[%c0] : memref<1xi32>
  %38 = arith.cmpi slt, %34, %37 : i32
  %39 = memref.load %32[] : memref<i1>
  %40 = arith.andi %38, %39 : i1
  cf.cond_br %40, ^bb2, ^bb3
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %41, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %42 -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %47 -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %50 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %59 : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %61, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %62 {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %63, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %64 -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %44, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %45 -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %31[] : memref<i1>
  %48 = scf.if %47 -> (i32) {
    %49 = scf.execute_region -> i32 {
      %50 = memref.load %31[] : memref<i1>
      %51 = scf.if %50 -> (i32) {
        memref.store %c0_i32, %0[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %33 : i32
      }
      %52 = memref.alloca() : memref<i1>
      %53 = memref.alloca() : memref<i1>
      memref.store %true, %53[] : memref<i1>
      cf.br ^bb1(%51 : i32)
    ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
      %55 = memref.load %0[] : memref<i32>
      %56 = memref.get_global @im : memref<1xi32>
      %57 = memref.load %56[%c0] : memref<1xi32>
      %58 = arith.cmpi slt, %54, %57 : i32
      %59 = memref.load %53[] : memref<i1>
      %60 = arith.andi %58, %59 : i1
      cf.cond_br %60, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %61 = memref.load %53[] : memref<i1>
      memref.store %61, %52[] : memref<i1>
      %62 = memref.load %52[] : memref<i1>
      scf.if %62 {
        %66 = memref.load %4[] : memref<memref<?xf32>>
        %67 = memref.load %0[] : memref<i32>
        %68 = memref.load %2[] : memref<i32>
        %69 = memref.load %56[%c0] : memref<1xi32>
        %70 = arith.muli %34, %69 : i32
        %71 = arith.addi %54, %70 : i32
        %72 = memref.load %3[] : memref<i32>
        %73 = arith.muli %15, %69 : i32
        %74 = memref.load %36[%c0] : memref<1xi32>
        %75 = arith.muli %73, %74 : i32
        %76 = arith.addi %71, %75 : i32
        %77 = arith.index_cast %76 : i32 to index
        %78 = memref.load %5[] : memref<memref<?xf32>>
        %79 = arith.subi %15, %c1_i32 : i32
        %80 = arith.muli %79, %69 : i32
        %81 = arith.muli %80, %74 : i32
        %82 = arith.addi %71, %81 : i32
        %83 = arith.index_cast %82 : i32 to index
        %84 = arith.addi %83, %c0 : index
        %85 = memref.load %arg0[%84] : memref<?xf32>
        %86 = arith.addi %77, %c0 : index
        memref.store %85, %arg2[%86] : memref<?xf32>
      }
      %63 = memref.load %53[] : memref<i1>
      memref.store %63, %52[] : memref<i1>
      %64 = memref.load %52[] : memref<i1>
      %65 = scf.if %64 -> (i32) {
        %66 = memref.load %0[] : memref<i32>
        %67 = arith.addi %54, %c1_i32 : i32
        memref.store %67, %0[] : memref<i32>
        scf.yield %67 : i32
      } else {
        scf.yield %54 : i32
      }
      cf.br ^bb1(%65 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %54 : i32
    }
    scf.yield %49 : i32
  } else {
    scf.yield %33 : i32
  }
  scf.yield %48 : i32


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %49 = scf.execute_region -> i32 {
    %50 = memref.load %31[] : memref<i1>
    %51 = scf.if %50 -> (i32) {
      memref.store %c0_i32, %0[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %33 : i32
    }
    %52 = memref.alloca() : memref<i1>
    %53 = memref.alloca() : memref<i1>
    memref.store %true, %53[] : memref<i1>
    cf.br ^bb1(%51 : i32)
  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
    %55 = memref.load %0[] : memref<i32>
    %56 = memref.get_global @im : memref<1xi32>
    %57 = memref.load %56[%c0] : memref<1xi32>
    %58 = arith.cmpi slt, %54, %57 : i32
    %59 = memref.load %53[] : memref<i1>
    %60 = arith.andi %58, %59 : i1
    cf.cond_br %60, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %61 = memref.load %53[] : memref<i1>
    memref.store %61, %52[] : memref<i1>
    %62 = memref.load %52[] : memref<i1>
    scf.if %62 {
      %66 = memref.load %4[] : memref<memref<?xf32>>
      %67 = memref.load %0[] : memref<i32>
      %68 = memref.load %2[] : memref<i32>
      %69 = memref.load %56[%c0] : memref<1xi32>
      %70 = arith.muli %34, %69 : i32
      %71 = arith.addi %54, %70 : i32
      %72 = memref.load %3[] : memref<i32>
      %73 = arith.muli %15, %69 : i32
      %74 = memref.load %36[%c0] : memref<1xi32>
      %75 = arith.muli %73, %74 : i32
      %76 = arith.addi %71, %75 : i32
      %77 = arith.index_cast %76 : i32 to index
      %78 = memref.load %5[] : memref<memref<?xf32>>
      %79 = arith.subi %15, %c1_i32 : i32
      %80 = arith.muli %79, %69 : i32
      %81 = arith.muli %80, %74 : i32
      %82 = arith.addi %71, %81 : i32
      %83 = arith.index_cast %82 : i32 to index
      %84 = arith.addi %83, %c0 : index
      %85 = memref.load %arg0[%84] : memref<?xf32>
      %86 = arith.addi %77, %c0 : index
      memref.store %85, %arg2[%86] : memref<?xf32>
    }
    %63 = memref.load %53[] : memref<i1>
    memref.store %63, %52[] : memref<i1>
    %64 = memref.load %52[] : memref<i1>
    %65 = scf.if %64 -> (i32) {
      %66 = memref.load %0[] : memref<i32>
      %67 = arith.addi %54, %c1_i32 : i32
      memref.store %67, %0[] : memref<i32>
      scf.yield %67 : i32
    } else {
      scf.yield %54 : i32
    }
    cf.br ^bb1(%65 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %54 : i32
  }
  scf.yield %49 : i32


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %50 = memref.load %31[] : memref<i1>
  %51 = scf.if %50 -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %33 : i32
  }
  %52 = memref.alloca() : memref<i1>
  %53 = memref.alloca() : memref<i1>
  memref.store %true, %53[] : memref<i1>
  cf.br ^bb1(%51 : i32)


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield %c0_i32 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield %c0_i32 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %50 = memref.load %31[] : memref<i1>
  %51 = scf.if %50 -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %33 : i32
  }
  %52 = memref.alloca() : memref<i1>
  %53 = memref.alloca() : memref<i1>
  memref.store %true, %53[] : memref<i1>
  cf.br ^bb1(%51 : i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %59 : i1
  cf.cond_br %60, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %59 : i1
  cf.cond_br %60, ^bb2, ^bb3
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %61, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %62 {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %63, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %64 -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
  scf.yield
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %0[] : memref<i32>
  %67 = arith.addi %54, %c1_i32 : i32
  memref.store %67, %0[] : memref<i32>
  scf.yield %67 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %0[] : memref<i32>
  %67 = arith.addi %54, %c1_i32 : i32
  memref.store %67, %0[] : memref<i32>
  scf.yield %67 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %54 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %54 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %61, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %62 {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %63, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %64 -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %49 = scf.execute_region -> i32 {
    %50 = memref.load %31[] : memref<i1>
    %51 = scf.if %50 -> (i32) {
      memref.store %c0_i32, %0[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %33 : i32
    }
    %52 = memref.alloca() : memref<i1>
    %53 = memref.alloca() : memref<i1>
    memref.store %true, %53[] : memref<i1>
    cf.br ^bb1(%51 : i32)
  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
    %55 = memref.load %0[] : memref<i32>
    %56 = memref.get_global @im : memref<1xi32>
    %57 = memref.load %56[%c0] : memref<1xi32>
    %58 = arith.cmpi slt, %54, %57 : i32
    %59 = memref.load %53[] : memref<i1>
    %60 = arith.andi %58, %59 : i1
    cf.cond_br %60, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %61 = memref.load %53[] : memref<i1>
    memref.store %61, %52[] : memref<i1>
    %62 = memref.load %52[] : memref<i1>
    scf.if %62 {
      %66 = memref.load %4[] : memref<memref<?xf32>>
      %67 = memref.load %0[] : memref<i32>
      %68 = memref.load %2[] : memref<i32>
      %69 = memref.load %56[%c0] : memref<1xi32>
      %70 = arith.muli %34, %69 : i32
      %71 = arith.addi %54, %70 : i32
      %72 = memref.load %3[] : memref<i32>
      %73 = arith.muli %15, %69 : i32
      %74 = memref.load %36[%c0] : memref<1xi32>
      %75 = arith.muli %73, %74 : i32
      %76 = arith.addi %71, %75 : i32
      %77 = arith.index_cast %76 : i32 to index
      %78 = memref.load %5[] : memref<memref<?xf32>>
      %79 = arith.subi %15, %c1_i32 : i32
      %80 = arith.muli %79, %69 : i32
      %81 = arith.muli %80, %74 : i32
      %82 = arith.addi %71, %81 : i32
      %83 = arith.index_cast %82 : i32 to index
      %84 = arith.addi %83, %c0 : index
      %85 = memref.load %arg0[%84] : memref<?xf32>
      %86 = arith.addi %77, %c0 : index
      memref.store %85, %arg2[%86] : memref<?xf32>
    }
    %63 = memref.load %53[] : memref<i1>
    memref.store %63, %52[] : memref<i1>
    %64 = memref.load %52[] : memref<i1>
    %65 = scf.if %64 -> (i32) {
      %66 = memref.load %0[] : memref<i32>
      %67 = arith.addi %54, %c1_i32 : i32
      memref.store %67, %0[] : memref<i32>
      scf.yield %67 : i32
    } else {
      scf.yield %54 : i32
    }
    cf.br ^bb1(%65 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %54 : i32
  }
  scf.yield %49 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %31[] : memref<i1>
  %48 = scf.if %47 -> (i32) {
    %49 = scf.execute_region -> i32 {
      %50 = memref.load %31[] : memref<i1>
      %51 = scf.if %50 -> (i32) {
        memref.store %c0_i32, %0[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %33 : i32
      }
      %52 = memref.alloca() : memref<i1>
      %53 = memref.alloca() : memref<i1>
      memref.store %true, %53[] : memref<i1>
      cf.br ^bb1(%51 : i32)
    ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
      %55 = memref.load %0[] : memref<i32>
      %56 = memref.get_global @im : memref<1xi32>
      %57 = memref.load %56[%c0] : memref<1xi32>
      %58 = arith.cmpi slt, %54, %57 : i32
      %59 = memref.load %53[] : memref<i1>
      %60 = arith.andi %58, %59 : i1
      cf.cond_br %60, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %61 = memref.load %53[] : memref<i1>
      memref.store %61, %52[] : memref<i1>
      %62 = memref.load %52[] : memref<i1>
      scf.if %62 {
        %66 = memref.load %4[] : memref<memref<?xf32>>
        %67 = memref.load %0[] : memref<i32>
        %68 = memref.load %2[] : memref<i32>
        %69 = memref.load %56[%c0] : memref<1xi32>
        %70 = arith.muli %34, %69 : i32
        %71 = arith.addi %54, %70 : i32
        %72 = memref.load %3[] : memref<i32>
        %73 = arith.muli %15, %69 : i32
        %74 = memref.load %36[%c0] : memref<1xi32>
        %75 = arith.muli %73, %74 : i32
        %76 = arith.addi %71, %75 : i32
        %77 = arith.index_cast %76 : i32 to index
        %78 = memref.load %5[] : memref<memref<?xf32>>
        %79 = arith.subi %15, %c1_i32 : i32
        %80 = arith.muli %79, %69 : i32
        %81 = arith.muli %80, %74 : i32
        %82 = arith.addi %71, %81 : i32
        %83 = arith.index_cast %82 : i32 to index
        %84 = arith.addi %83, %c0 : index
        %85 = memref.load %arg0[%84] : memref<?xf32>
        %86 = arith.addi %77, %c0 : index
        memref.store %85, %arg2[%86] : memref<?xf32>
      }
      %63 = memref.load %53[] : memref<i1>
      memref.store %63, %52[] : memref<i1>
      %64 = memref.load %52[] : memref<i1>
      %65 = scf.if %64 -> (i32) {
        %66 = memref.load %0[] : memref<i32>
        %67 = arith.addi %54, %c1_i32 : i32
        memref.store %67, %0[] : memref<i32>
        scf.yield %67 : i32
      } else {
        scf.yield %54 : i32
      }
      cf.br ^bb1(%65 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %54 : i32
    }
    scf.yield %49 : i32
  } else {
    scf.yield %33 : i32
  }
  scf.yield %48 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %2[] : memref<i32>
  %48 = arith.addi %34, %c1_i32 : i32
  memref.store %48, %2[] : memref<i32>
  scf.yield %48 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %2[] : memref<i32>
  %48 = arith.addi %34, %c1_i32 : i32
  memref.store %48, %2[] : memref<i32>
  scf.yield %48 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %34 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %34 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %41, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %42 -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %47 -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %50 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %59 : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %61, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %62 {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %63, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %64 -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %44, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %45 -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %33, %34 : i32, i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %33, %34 : i32, i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %28:2 = scf.execute_region -> (i32, i32) {
    %29 = memref.load %11[] : memref<i1>
    %30 = scf.if %20 -> (i32) {
      memref.store %c0_i32, %2[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %14 : i32
    }
    %31 = memref.alloca() : memref<i1>
    %32 = memref.alloca() : memref<i1>
    memref.store %true, %32[] : memref<i1>
    cf.br ^bb1(%13, %30 : i32, i32)
  ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
    %35 = memref.load %2[] : memref<i32>
    %36 = memref.get_global @jm : memref<1xi32>
    %37 = memref.load %36[%c0] : memref<1xi32>
    %38 = arith.cmpi slt, %34, %37 : i32
    %39 = memref.load %32[] : memref<i1>
    %40 = arith.andi %38, %39 : i1
    cf.cond_br %40, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %41 = memref.load %32[] : memref<i1>
    memref.store %41, %31[] : memref<i1>
    %42 = memref.load %31[] : memref<i1>
    %43 = scf.if %42 -> (i32) {
      %47 = memref.load %31[] : memref<i1>
      %48 = scf.if %47 -> (i32) {
        %49 = scf.execute_region -> i32 {
          %50 = memref.load %31[] : memref<i1>
          %51 = scf.if %50 -> (i32) {
            memref.store %c0_i32, %0[] : memref<i32>
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %33 : i32
          }
          %52 = memref.alloca() : memref<i1>
          %53 = memref.alloca() : memref<i1>
          memref.store %true, %53[] : memref<i1>
          cf.br ^bb1(%51 : i32)
        ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
          %55 = memref.load %0[] : memref<i32>
          %56 = memref.get_global @im : memref<1xi32>
          %57 = memref.load %56[%c0] : memref<1xi32>
          %58 = arith.cmpi slt, %54, %57 : i32
          %59 = memref.load %53[] : memref<i1>
          %60 = arith.andi %58, %59 : i1
          cf.cond_br %60, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %61 = memref.load %53[] : memref<i1>
          memref.store %61, %52[] : memref<i1>
          %62 = memref.load %52[] : memref<i1>
          scf.if %62 {
            %66 = memref.load %4[] : memref<memref<?xf32>>
            %67 = memref.load %0[] : memref<i32>
            %68 = memref.load %2[] : memref<i32>
            %69 = memref.load %56[%c0] : memref<1xi32>
            %70 = arith.muli %34, %69 : i32
            %71 = arith.addi %54, %70 : i32
            %72 = memref.load %3[] : memref<i32>
            %73 = arith.muli %15, %69 : i32
            %74 = memref.load %36[%c0] : memref<1xi32>
            %75 = arith.muli %73, %74 : i32
            %76 = arith.addi %71, %75 : i32
            %77 = arith.index_cast %76 : i32 to index
            %78 = memref.load %5[] : memref<memref<?xf32>>
            %79 = arith.subi %15, %c1_i32 : i32
            %80 = arith.muli %79, %69 : i32
            %81 = arith.muli %80, %74 : i32
            %82 = arith.addi %71, %81 : i32
            %83 = arith.index_cast %82 : i32 to index
            %84 = arith.addi %83, %c0 : index
            %85 = memref.load %arg0[%84] : memref<?xf32>
            %86 = arith.addi %77, %c0 : index
            memref.store %85, %arg2[%86] : memref<?xf32>
          }
          %63 = memref.load %53[] : memref<i1>
          memref.store %63, %52[] : memref<i1>
          %64 = memref.load %52[] : memref<i1>
          %65 = scf.if %64 -> (i32) {
            %66 = memref.load %0[] : memref<i32>
            %67 = arith.addi %54, %c1_i32 : i32
            memref.store %67, %0[] : memref<i32>
            scf.yield %67 : i32
          } else {
            scf.yield %54 : i32
          }
          cf.br ^bb1(%65 : i32)
        ^bb3:  // pred: ^bb1
          scf.yield %54 : i32
        }
        scf.yield %49 : i32
      } else {
        scf.yield %33 : i32
      }
      scf.yield %48 : i32
    } else {
      scf.yield %33 : i32
    }
    %44 = memref.load %32[] : memref<i1>
    memref.store %44, %31[] : memref<i1>
    %45 = memref.load %31[] : memref<i1>
    %46 = scf.if %45 -> (i32) {
      %47 = memref.load %2[] : memref<i32>
      %48 = arith.addi %34, %c1_i32 : i32
      memref.store %48, %2[] : memref<i32>
      scf.yield %48 : i32
    } else {
      scf.yield %34 : i32
    }
    cf.br ^bb1(%43, %46 : i32, i32)
  ^bb3:  // pred: ^bb1
    scf.yield %33, %34 : i32, i32
  }
  scf.yield %28#0, %28#1 : i32, i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %13, %14 : i32, i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %13, %14 : i32, i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.load %11[] : memref<i1>
  %27:2 = scf.if %20 -> (i32, i32) {
    %28:2 = scf.execute_region -> (i32, i32) {
      %29 = memref.load %11[] : memref<i1>
      %30 = scf.if %20 -> (i32) {
        memref.store %c0_i32, %2[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %14 : i32
      }
      %31 = memref.alloca() : memref<i1>
      %32 = memref.alloca() : memref<i1>
      memref.store %true, %32[] : memref<i1>
      cf.br ^bb1(%13, %30 : i32, i32)
    ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
      %35 = memref.load %2[] : memref<i32>
      %36 = memref.get_global @jm : memref<1xi32>
      %37 = memref.load %36[%c0] : memref<1xi32>
      %38 = arith.cmpi slt, %34, %37 : i32
      %39 = memref.load %32[] : memref<i1>
      %40 = arith.andi %38, %39 : i1
      cf.cond_br %40, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %41 = memref.load %32[] : memref<i1>
      memref.store %41, %31[] : memref<i1>
      %42 = memref.load %31[] : memref<i1>
      %43 = scf.if %42 -> (i32) {
        %47 = memref.load %31[] : memref<i1>
        %48 = scf.if %47 -> (i32) {
          %49 = scf.execute_region -> i32 {
            %50 = memref.load %31[] : memref<i1>
            %51 = scf.if %50 -> (i32) {
              memref.store %c0_i32, %0[] : memref<i32>
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %33 : i32
            }
            %52 = memref.alloca() : memref<i1>
            %53 = memref.alloca() : memref<i1>
            memref.store %true, %53[] : memref<i1>
            cf.br ^bb1(%51 : i32)
          ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
            %55 = memref.load %0[] : memref<i32>
            %56 = memref.get_global @im : memref<1xi32>
            %57 = memref.load %56[%c0] : memref<1xi32>
            %58 = arith.cmpi slt, %54, %57 : i32
            %59 = memref.load %53[] : memref<i1>
            %60 = arith.andi %58, %59 : i1
            cf.cond_br %60, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %61 = memref.load %53[] : memref<i1>
            memref.store %61, %52[] : memref<i1>
            %62 = memref.load %52[] : memref<i1>
            scf.if %62 {
              %66 = memref.load %4[] : memref<memref<?xf32>>
              %67 = memref.load %0[] : memref<i32>
              %68 = memref.load %2[] : memref<i32>
              %69 = memref.load %56[%c0] : memref<1xi32>
              %70 = arith.muli %34, %69 : i32
              %71 = arith.addi %54, %70 : i32
              %72 = memref.load %3[] : memref<i32>
              %73 = arith.muli %15, %69 : i32
              %74 = memref.load %36[%c0] : memref<1xi32>
              %75 = arith.muli %73, %74 : i32
              %76 = arith.addi %71, %75 : i32
              %77 = arith.index_cast %76 : i32 to index
              %78 = memref.load %5[] : memref<memref<?xf32>>
              %79 = arith.subi %15, %c1_i32 : i32
              %80 = arith.muli %79, %69 : i32
              %81 = arith.muli %80, %74 : i32
              %82 = arith.addi %71, %81 : i32
              %83 = arith.index_cast %82 : i32 to index
              %84 = arith.addi %83, %c0 : index
              %85 = memref.load %arg0[%84] : memref<?xf32>
              %86 = arith.addi %77, %c0 : index
              memref.store %85, %arg2[%86] : memref<?xf32>
            }
            %63 = memref.load %53[] : memref<i1>
            memref.store %63, %52[] : memref<i1>
            %64 = memref.load %52[] : memref<i1>
            %65 = scf.if %64 -> (i32) {
              %66 = memref.load %0[] : memref<i32>
              %67 = arith.addi %54, %c1_i32 : i32
              memref.store %67, %0[] : memref<i32>
              scf.yield %67 : i32
            } else {
              scf.yield %54 : i32
            }
            cf.br ^bb1(%65 : i32)
          ^bb3:  // pred: ^bb1
            scf.yield %54 : i32
          }
          scf.yield %49 : i32
        } else {
          scf.yield %33 : i32
        }
        scf.yield %48 : i32
      } else {
        scf.yield %33 : i32
      }
      %44 = memref.load %32[] : memref<i1>
      memref.store %44, %31[] : memref<i1>
      %45 = memref.load %31[] : memref<i1>
      %46 = scf.if %45 -> (i32) {
        %47 = memref.load %2[] : memref<i32>
        %48 = arith.addi %34, %c1_i32 : i32
        memref.store %48, %2[] : memref<i32>
        scf.yield %48 : i32
      } else {
        scf.yield %34 : i32
      }
      cf.br ^bb1(%43, %46 : i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield %33, %34 : i32, i32
    }
    scf.yield %28#0, %28#1 : i32, i32
  } else {
    scf.yield %13, %14 : i32, i32
  }
  scf.yield %27#0, %27#1 : i32, i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %13, %14 : i32, i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %13, %14 : i32, i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
 replaced mlir-asm-printer: Verifying operation: builtin.module
%23 = memref.load %12[] : memref<i1> with mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.load %3[] : memref<i32>
  %27 = arith.subi %15, %c1_i32 : i32
  memref.store %27, %3[] : memref<i32>
  scf.yield %27 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %26 = memref.load %3[] : memref<i32>
  %27 = arith.subi %15, %c1_i32 : i32
  memref.store %27, %3[] : memref<i32>
  scf.yield %27 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %15 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %15 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %20 = memref.load %12[] : memref<i1>
  memref.store %20, %11[] : memref<i1>
  %21 = memref.load %11[] : memref<i1>
  %22:2 = scf.if %20 -> (i32, i32) {
    %26 = memref.load %11[] : memref<i1>
    %27:2 = scf.if %20 -> (i32, i32) {
      %28:2 = scf.execute_region -> (i32, i32) {
        %29 = memref.load %11[] : memref<i1>
        %30 = scf.if %20 -> (i32) {
          memref.store %c0_i32, %2[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %14 : i32
        }
        %31 = memref.alloca() : memref<i1>
        %32 = memref.alloca() : memref<i1>
        memref.store %true, %32[] : memref<i1>
        cf.br ^bb1(%13, %30 : i32, i32)
      ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
        %35 = memref.load %2[] : memref<i32>
        %36 = memref.get_global @jm : memref<1xi32>
        %37 = memref.load %36[%c0] : memref<1xi32>
        %38 = arith.cmpi slt, %34, %37 : i32
        %39 = memref.load %32[] : memref<i1>
        %40 = arith.andi %38, %39 : i1
        cf.cond_br %40, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %41 = memref.load %32[] : memref<i1>
        memref.store %41, %31[] : memref<i1>
        %42 = memref.load %31[] : memref<i1>
        %43 = scf.if %42 -> (i32) {
          %47 = memref.load %31[] : memref<i1>
          %48 = scf.if %47 -> (i32) {
            %49 = scf.execute_region -> i32 {
              %50 = memref.load %31[] : memref<i1>
              %51 = scf.if %50 -> (i32) {
                memref.store %c0_i32, %0[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %33 : i32
              }
              %52 = memref.alloca() : memref<i1>
              %53 = memref.alloca() : memref<i1>
              memref.store %true, %53[] : memref<i1>
              cf.br ^bb1(%51 : i32)
            ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
              %55 = memref.load %0[] : memref<i32>
              %56 = memref.get_global @im : memref<1xi32>
              %57 = memref.load %56[%c0] : memref<1xi32>
              %58 = arith.cmpi slt, %54, %57 : i32
              %59 = memref.load %53[] : memref<i1>
              %60 = arith.andi %58, %59 : i1
              cf.cond_br %60, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %61 = memref.load %53[] : memref<i1>
              memref.store %61, %52[] : memref<i1>
              %62 = memref.load %52[] : memref<i1>
              scf.if %62 {
                %66 = memref.load %4[] : memref<memref<?xf32>>
                %67 = memref.load %0[] : memref<i32>
                %68 = memref.load %2[] : memref<i32>
                %69 = memref.load %56[%c0] : memref<1xi32>
                %70 = arith.muli %34, %69 : i32
                %71 = arith.addi %54, %70 : i32
                %72 = memref.load %3[] : memref<i32>
                %73 = arith.muli %15, %69 : i32
                %74 = memref.load %36[%c0] : memref<1xi32>
                %75 = arith.muli %73, %74 : i32
                %76 = arith.addi %71, %75 : i32
                %77 = arith.index_cast %76 : i32 to index
                %78 = memref.load %5[] : memref<memref<?xf32>>
                %79 = arith.subi %15, %c1_i32 : i32
                %80 = arith.muli %79, %69 : i32
                %81 = arith.muli %80, %74 : i32
                %82 = arith.addi %71, %81 : i32
                %83 = arith.index_cast %82 : i32 to index
                %84 = arith.addi %83, %c0 : index
                %85 = memref.load %arg0[%84] : memref<?xf32>
                %86 = arith.addi %77, %c0 : index
                memref.store %85, %arg2[%86] : memref<?xf32>
              }
              %63 = memref.load %53[] : memref<i1>
              memref.store %63, %52[] : memref<i1>
              %64 = memref.load %52[] : memref<i1>
              %65 = scf.if %64 -> (i32) {
                %66 = memref.load %0[] : memref<i32>
                %67 = arith.addi %54, %c1_i32 : i32
                memref.store %67, %0[] : memref<i32>
                scf.yield %67 : i32
              } else {
                scf.yield %54 : i32
              }
              cf.br ^bb1(%65 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %54 : i32
            }
            scf.yield %49 : i32
          } else {
            scf.yield %33 : i32
          }
          scf.yield %48 : i32
        } else {
          scf.yield %33 : i32
        }
        %44 = memref.load %32[] : memref<i1>
        memref.store %44, %31[] : memref<i1>
        %45 = memref.load %31[] : memref<i1>
        %46 = scf.if %45 -> (i32) {
          %47 = memref.load %2[] : memref<i32>
          %48 = arith.addi %34, %c1_i32 : i32
          memref.store %48, %2[] : memref<i32>
          scf.yield %48 : i32
        } else {
          scf.yield %34 : i32
        }
        cf.br ^bb1(%43, %46 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %33, %34 : i32, i32
      }
      scf.yield %28#0, %28#1 : i32, i32
    } else {
      scf.yield %13, %14 : i32, i32
    }
    scf.yield %27#0, %27#1 : i32, i32
  } else {
    scf.yield %13, %14 : i32, i32
  }
  %23 = memref.load %12[] : memref<i1>
  memref.store %20, %11[] : memref<i1>
  %24 = memref.load %11[] : memref<i1>
  %25 = scf.if %20 -> (i32) {
    %26 = memref.load %3[] : memref<i32>
    %27 = arith.subi %15, %c1_i32 : i32
    memref.store %27, %3[] : memref<i32>
    scf.yield %27 : i32
  } else {
    scf.yield %15 : i32
  }
  cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%20 = memref.load %12[] : memref<i1>
 replaced mlir-asm-printer: Verifying operation: builtin.module
branch has 3 operands for successor #0, but target block has 4
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%23 = "memref.load"(%16) : (memref<i1>) -> i1 with <block argument> of type 'i1' at index: 3
 replaced mlir-asm-printer: Verifying operation: builtin.module
branch has 3 operands for successor #0, but target block has 4
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%26 = "memref.load"(%16) : (memref<i1>) -> i1 with <block argument> of type 'i1' at index: 0
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%31 = memref.alloca() : memref<i1>
 + forwarding vec to promote {} of mlir-asm-printer: Verifying operation: builtin.module
%31 = memref.alloca() : memref<i1>
Begin forwarding store of mlir-asm-printer: Verifying operation: builtin.module
%31 = memref.alloca() : memref<i1> to load
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %true {
    %8 = memref.load %6[] : memref<i1>
    scf.if %true {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        %10 = scf.if %true -> (i32) {
          %26 = memref.get_global @kbm3 : memref<1xi32>
          %27 = memref.load %26[%c0] : memref<1xi32>
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %1 : i32
        }
        %11 = memref.alloca() : memref<i1>
        %12 = memref.alloca() : memref<i1>
        memref.store %true, %12[] : memref<i1>
        cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
      ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
        %16 = memref.load %3[] : memref<i32>
        %17 = arith.cmpi sgt, %15, %c0_i32 : i32
        %18 = memref.load %12[] : memref<i1>
        %19 = arith.andi %17, %true : i1
        cf.cond_br %19, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %20 = memref.load %12[] : memref<i1>
        memref.store %true, %11[] : memref<i1>
        %21 = memref.load %11[] : memref<i1>
        %22:2 = scf.if %true -> (i32, i32) {
          %26 = memref.load %11[] : memref<i1>
          %27:2 = scf.if %true -> (i32, i32) {
            %28:2 = scf.execute_region -> (i32, i32) {
              %29 = memref.load %11[] : memref<i1>
              %30 = scf.if %true -> (i32) {
                memref.store %c0_i32, %2[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %14 : i32
              }
              %31 = memref.alloca() : memref<i1>
              %32 = memref.alloca() : memref<i1>
              memref.store %true, %32[] : memref<i1>
              cf.br ^bb1(%13, %30 : i32, i32)
            ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
              %35 = memref.load %2[] : memref<i32>
              %36 = memref.get_global @jm : memref<1xi32>
              %37 = memref.load %36[%c0] : memref<1xi32>
              %38 = arith.cmpi slt, %34, %37 : i32
              %39 = memref.load %32[] : memref<i1>
              %40 = arith.andi %38, %39 : i1
              cf.cond_br %40, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %41 = memref.load %32[] : memref<i1>
              memref.store %41, %31[] : memref<i1>
              %42 = memref.load %31[] : memref<i1>
              %43 = scf.if %42 -> (i32) {
                %47 = memref.load %31[] : memref<i1>
                %48 = scf.if %47 -> (i32) {
                  %49 = scf.execute_region -> i32 {
                    %50 = memref.load %31[] : memref<i1>
                    %51 = scf.if %50 -> (i32) {
                      memref.store %c0_i32, %0[] : memref<i32>
                      scf.yield %c0_i32 : i32
                    } else {
                      scf.yield %33 : i32
                    }
                    %52 = memref.alloca() : memref<i1>
                    %53 = memref.alloca() : memref<i1>
                    memref.store %true, %53[] : memref<i1>
                    cf.br ^bb1(%51 : i32)
                  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                    %55 = memref.load %0[] : memref<i32>
                    %56 = memref.get_global @im : memref<1xi32>
                    %57 = memref.load %56[%c0] : memref<1xi32>
                    %58 = arith.cmpi slt, %54, %57 : i32
                    %59 = memref.load %53[] : memref<i1>
                    %60 = arith.andi %58, %59 : i1
                    cf.cond_br %60, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %61 = memref.load %53[] : memref<i1>
                    memref.store %61, %52[] : memref<i1>
                    %62 = memref.load %52[] : memref<i1>
                    scf.if %62 {
                      %66 = memref.load %4[] : memref<memref<?xf32>>
                      %67 = memref.load %0[] : memref<i32>
                      %68 = memref.load %2[] : memref<i32>
                      %69 = memref.load %56[%c0] : memref<1xi32>
                      %70 = arith.muli %34, %69 : i32
                      %71 = arith.addi %54, %70 : i32
                      %72 = memref.load %3[] : memref<i32>
                      %73 = arith.muli %15, %69 : i32
                      %74 = memref.load %36[%c0] : memref<1xi32>
                      %75 = arith.muli %73, %74 : i32
                      %76 = arith.addi %71, %75 : i32
                      %77 = arith.index_cast %76 : i32 to index
                      %78 = memref.load %5[] : memref<memref<?xf32>>
                      %79 = arith.subi %15, %c1_i32 : i32
                      %80 = arith.muli %79, %69 : i32
                      %81 = arith.muli %80, %74 : i32
                      %82 = arith.addi %71, %81 : i32
                      %83 = arith.index_cast %82 : i32 to index
                      %84 = arith.addi %83, %c0 : index
                      %85 = memref.load %arg0[%84] : memref<?xf32>
                      %86 = arith.addi %77, %c0 : index
                      memref.store %85, %arg2[%86] : memref<?xf32>
                    }
                    %63 = memref.load %53[] : memref<i1>
                    memref.store %63, %52[] : memref<i1>
                    %64 = memref.load %52[] : memref<i1>
                    %65 = scf.if %64 -> (i32) {
                      %66 = memref.load %0[] : memref<i32>
                      %67 = arith.addi %54, %c1_i32 : i32
                      memref.store %67, %0[] : memref<i32>
                      scf.yield %67 : i32
                    } else {
                      scf.yield %54 : i32
                    }
                    cf.br ^bb1(%65 : i32)
                  ^bb3:  // pred: ^bb1
                    scf.yield %54 : i32
                  }
                  scf.yield %49 : i32
                } else {
                  scf.yield %33 : i32
                }
                scf.yield %48 : i32
              } else {
                scf.yield %33 : i32
              }
              %44 = memref.load %32[] : memref<i1>
              memref.store %44, %31[] : memref<i1>
              %45 = memref.load %31[] : memref<i1>
              %46 = scf.if %45 -> (i32) {
                %47 = memref.load %2[] : memref<i32>
                %48 = arith.addi %34, %c1_i32 : i32
                memref.store %48, %2[] : memref<i32>
                scf.yield %48 : i32
              } else {
                scf.yield %34 : i32
              }
              cf.br ^bb1(%43, %46 : i32, i32)
            ^bb3:  // pred: ^bb1
              scf.yield %33, %34 : i32, i32
            }
            scf.yield %28#0, %28#1 : i32, i32
          } else {
            scf.yield %13, %14 : i32, i32
          }
          scf.yield %27#0, %27#1 : i32, i32
        } else {
          scf.yield %13, %14 : i32, i32
        }
        %23 = memref.load %12[] : memref<i1>
        memref.store %true, %11[] : memref<i1>
        %24 = memref.load %11[] : memref<i1>
        %25 = scf.if %true -> (i32) {
          %26 = memref.load %3[] : memref<i32>
          %27 = arith.subi %15, %c1_i32 : i32
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %15 : i32
        }
        cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}
Matching Load: mlir-asm-printer: Verifying operation: func.func
%45 = memref.load %31[] : memref<i1>
Matching Store: mlir-asm-printer: Verifying operation: func.func
memref.store %44, %31[] : memref<i1>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%50 = memref.load %31[] : memref<i1>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%47 = memref.load %31[] : memref<i1>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%42 = memref.load %31[] : memref<i1>
Matching Store: mlir-asm-printer: Verifying operation: func.func
memref.store %41, %31[] : memref<i1>
 storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %44, %31[] : memref<i1>
 storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %41, %31[] : memref<i1>
 initial storing block: 0x7fbd98169610
 derived storing block: 0x7fbd98168a80
 initial storing block: 0x7fbd98169610
 derived storing block: 0x7fbd98168a80
 initial storing block: 0x7fbd98168a80
 derived storing block: 0x7fbd981687d0
 initial storing block: 0x7fbd98168a80
 derived storing block: 0x7fbd981687d0
 initial storing block: 0x7fbd981687d0
 derived storing block: 0x7fbd98167b50
 initial storing block: 0x7fbd981687d0
 derived storing block: 0x7fbd98167b50
 initial storing block: 0x7fbd98167b50
 derived storing block: 0x7fbd981669f0
 initial storing block: 0x7fbd98167b50
 derived storing block: 0x7fbd981669f0
 initial storing block: 0x7fbd981669f0
 derived storing block: 0x7fbd98166740
 initial storing block: 0x7fbd981669f0
 derived storing block: 0x7fbd98166740
 initial storing block: 0x7fbd98166740
 derived storing block: 0x7fbd98164100
 initial storing block: 0x7fbd98166740
 derived storing block: 0x7fbd98164100
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %29 = memref.load %11[] : memref<i1>
  %30 = scf.if %true -> (i32) {
    memref.store %c0_i32, %2[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %14 : i32
  }
  %31 = memref.alloca() : memref<i1>
  %32 = memref.alloca() : memref<i1>
  memref.store %true, %32[] : memref<i1>
  cf.br ^bb1(%13, %30 : i32, i32)


starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %2[] : memref<i32>
  scf.yield %c0_i32 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %2[] : memref<i32>
  scf.yield %c0_i32 : i32
 with val:<overwritten>

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %14 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %14 : i32
 with val:<overwritten>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %29 = memref.load %11[] : memref<i1>
  %30 = scf.if %true -> (i32) {
    memref.store %c0_i32, %2[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %14 : i32
  }
  %31 = memref.alloca() : memref<i1>
  %32 = memref.alloca() : memref<i1>
  memref.store %true, %32[] : memref<i1>
  cf.br ^bb1(%13, %30 : i32, i32)
 with val:<overwritten>

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
  %35 = memref.load %2[] : memref<i32>
  %36 = memref.get_global @jm : memref<1xi32>
  %37 = memref.load %36[%c0] : memref<1xi32>
  %38 = arith.cmpi slt, %34, %37 : i32
  %39 = memref.load %32[] : memref<i1>
  %40 = arith.andi %38, %39 : i1
  cf.cond_br %40, ^bb2, ^bb3

mlir-asm-printer: Verifying operation: builtin.module
^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
  %35 = memref.load %2[] : memref<i32>
  %36 = memref.get_global @jm : memref<1xi32>
  %37 = memref.load %36[%c0] : memref<1xi32>
  %38 = arith.cmpi slt, %34, %37 : i32
  %39 = memref.load %32[] : memref<i1>
  %40 = arith.andi %38, %39 : i1
  cf.cond_br %40, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
  %35 = memref.load %2[] : memref<i32>
  %36 = memref.get_global @jm : memref<1xi32>
  %37 = memref.load %36[%c0] : memref<1xi32>
  %38 = arith.cmpi slt, %34, %37 : i32
  %39 = memref.load %32[] : memref<i1>
  %40 = arith.andi %38, %39 : i1
  cf.cond_br %40, ^bb2, ^bb3
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
  %35 = memref.load %2[] : memref<i32>
  %36 = memref.get_global @jm : memref<1xi32>
  %37 = memref.load %36[%c0] : memref<1xi32>
  %38 = arith.cmpi slt, %34, %37 : i32
  %39 = memref.load %32[] : memref<i1>
  %40 = arith.andi %38, %39 : i1
  cf.cond_br %40, ^bb2, ^bb3


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %33, %34 : i32, i32

mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %33, %34 : i32, i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %33, %34 : i32, i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %33, %34 : i32, i32


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %41, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %42 -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %47 -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %50 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %59 : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %61, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %62 {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %63, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %64 -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %44, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %45 -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %41, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %42 -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %47 -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %50 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %59 : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %61, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %62 {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %63, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %64 -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %44, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %45 -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)

 replaced mlir-asm-printer: Verifying operation: builtin.module
%42 = memref.load %31[] : memref<i1> with mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %31[] : memref<i1>
  %48 = scf.if %47 -> (i32) {
    %49 = scf.execute_region -> i32 {
      %50 = memref.load %31[] : memref<i1>
      %51 = scf.if %50 -> (i32) {
        memref.store %c0_i32, %0[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %33 : i32
      }
      %52 = memref.alloca() : memref<i1>
      %53 = memref.alloca() : memref<i1>
      memref.store %true, %53[] : memref<i1>
      cf.br ^bb1(%51 : i32)
    ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
      %55 = memref.load %0[] : memref<i32>
      %56 = memref.get_global @im : memref<1xi32>
      %57 = memref.load %56[%c0] : memref<1xi32>
      %58 = arith.cmpi slt, %54, %57 : i32
      %59 = memref.load %53[] : memref<i1>
      %60 = arith.andi %58, %59 : i1
      cf.cond_br %60, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %61 = memref.load %53[] : memref<i1>
      memref.store %61, %52[] : memref<i1>
      %62 = memref.load %52[] : memref<i1>
      scf.if %62 {
        %66 = memref.load %4[] : memref<memref<?xf32>>
        %67 = memref.load %0[] : memref<i32>
        %68 = memref.load %2[] : memref<i32>
        %69 = memref.load %56[%c0] : memref<1xi32>
        %70 = arith.muli %34, %69 : i32
        %71 = arith.addi %54, %70 : i32
        %72 = memref.load %3[] : memref<i32>
        %73 = arith.muli %15, %69 : i32
        %74 = memref.load %36[%c0] : memref<1xi32>
        %75 = arith.muli %73, %74 : i32
        %76 = arith.addi %71, %75 : i32
        %77 = arith.index_cast %76 : i32 to index
        %78 = memref.load %5[] : memref<memref<?xf32>>
        %79 = arith.subi %15, %c1_i32 : i32
        %80 = arith.muli %79, %69 : i32
        %81 = arith.muli %80, %74 : i32
        %82 = arith.addi %71, %81 : i32
        %83 = arith.index_cast %82 : i32 to index
        %84 = arith.addi %83, %c0 : index
        %85 = memref.load %arg0[%84] : memref<?xf32>
        %86 = arith.addi %77, %c0 : index
        memref.store %85, %arg2[%86] : memref<?xf32>
      }
      %63 = memref.load %53[] : memref<i1>
      memref.store %63, %52[] : memref<i1>
      %64 = memref.load %52[] : memref<i1>
      %65 = scf.if %64 -> (i32) {
        %66 = memref.load %0[] : memref<i32>
        %67 = arith.addi %54, %c1_i32 : i32
        memref.store %67, %0[] : memref<i32>
        scf.yield %67 : i32
      } else {
        scf.yield %54 : i32
      }
      cf.br ^bb1(%65 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %54 : i32
    }
    scf.yield %49 : i32
  } else {
    scf.yield %33 : i32
  }
  scf.yield %48 : i32

 replaced mlir-asm-printer: Verifying operation: builtin.module
%47 = memref.load %31[] : memref<i1> with mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %49 = scf.execute_region -> i32 {
    %50 = memref.load %31[] : memref<i1>
    %51 = scf.if %50 -> (i32) {
      memref.store %c0_i32, %0[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %33 : i32
    }
    %52 = memref.alloca() : memref<i1>
    %53 = memref.alloca() : memref<i1>
    memref.store %true, %53[] : memref<i1>
    cf.br ^bb1(%51 : i32)
  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
    %55 = memref.load %0[] : memref<i32>
    %56 = memref.get_global @im : memref<1xi32>
    %57 = memref.load %56[%c0] : memref<1xi32>
    %58 = arith.cmpi slt, %54, %57 : i32
    %59 = memref.load %53[] : memref<i1>
    %60 = arith.andi %58, %59 : i1
    cf.cond_br %60, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %61 = memref.load %53[] : memref<i1>
    memref.store %61, %52[] : memref<i1>
    %62 = memref.load %52[] : memref<i1>
    scf.if %62 {
      %66 = memref.load %4[] : memref<memref<?xf32>>
      %67 = memref.load %0[] : memref<i32>
      %68 = memref.load %2[] : memref<i32>
      %69 = memref.load %56[%c0] : memref<1xi32>
      %70 = arith.muli %34, %69 : i32
      %71 = arith.addi %54, %70 : i32
      %72 = memref.load %3[] : memref<i32>
      %73 = arith.muli %15, %69 : i32
      %74 = memref.load %36[%c0] : memref<1xi32>
      %75 = arith.muli %73, %74 : i32
      %76 = arith.addi %71, %75 : i32
      %77 = arith.index_cast %76 : i32 to index
      %78 = memref.load %5[] : memref<memref<?xf32>>
      %79 = arith.subi %15, %c1_i32 : i32
      %80 = arith.muli %79, %69 : i32
      %81 = arith.muli %80, %74 : i32
      %82 = arith.addi %71, %81 : i32
      %83 = arith.index_cast %82 : i32 to index
      %84 = arith.addi %83, %c0 : index
      %85 = memref.load %arg0[%84] : memref<?xf32>
      %86 = arith.addi %77, %c0 : index
      memref.store %85, %arg2[%86] : memref<?xf32>
    }
    %63 = memref.load %53[] : memref<i1>
    memref.store %63, %52[] : memref<i1>
    %64 = memref.load %52[] : memref<i1>
    %65 = scf.if %64 -> (i32) {
      %66 = memref.load %0[] : memref<i32>
      %67 = arith.addi %54, %c1_i32 : i32
      memref.store %67, %0[] : memref<i32>
      scf.yield %67 : i32
    } else {
      scf.yield %54 : i32
    }
    cf.br ^bb1(%65 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %54 : i32
  }
  scf.yield %49 : i32


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %50 = memref.load %31[] : memref<i1>
  %51 = scf.if %50 -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %33 : i32
  }
  %52 = memref.alloca() : memref<i1>
  %53 = memref.alloca() : memref<i1>
  memref.store %true, %53[] : memref<i1>
  cf.br ^bb1(%51 : i32)

 replaced mlir-asm-printer: Verifying operation: builtin.module
%50 = memref.load %31[] : memref<i1> with mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield %c0_i32 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield %c0_i32 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %50 = memref.load %31[] : memref<i1>
  %51 = scf.if %41 -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %33 : i32
  }
  %52 = memref.alloca() : memref<i1>
  %53 = memref.alloca() : memref<i1>
  memref.store %true, %53[] : memref<i1>
  cf.br ^bb1(%51 : i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %59 : i1
  cf.cond_br %60, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %59 : i1
  cf.cond_br %60, ^bb2, ^bb3
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %61, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %62 {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %63, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %64 -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
  scf.yield
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %0[] : memref<i32>
  %67 = arith.addi %54, %c1_i32 : i32
  memref.store %67, %0[] : memref<i32>
  scf.yield %67 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %0[] : memref<i32>
  %67 = arith.addi %54, %c1_i32 : i32
  memref.store %67, %0[] : memref<i32>
  scf.yield %67 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %54 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %54 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %61, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %62 {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %63, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %64 -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %49 = scf.execute_region -> i32 {
    %50 = memref.load %31[] : memref<i1>
    %51 = scf.if %41 -> (i32) {
      memref.store %c0_i32, %0[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %33 : i32
    }
    %52 = memref.alloca() : memref<i1>
    %53 = memref.alloca() : memref<i1>
    memref.store %true, %53[] : memref<i1>
    cf.br ^bb1(%51 : i32)
  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
    %55 = memref.load %0[] : memref<i32>
    %56 = memref.get_global @im : memref<1xi32>
    %57 = memref.load %56[%c0] : memref<1xi32>
    %58 = arith.cmpi slt, %54, %57 : i32
    %59 = memref.load %53[] : memref<i1>
    %60 = arith.andi %58, %59 : i1
    cf.cond_br %60, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %61 = memref.load %53[] : memref<i1>
    memref.store %61, %52[] : memref<i1>
    %62 = memref.load %52[] : memref<i1>
    scf.if %62 {
      %66 = memref.load %4[] : memref<memref<?xf32>>
      %67 = memref.load %0[] : memref<i32>
      %68 = memref.load %2[] : memref<i32>
      %69 = memref.load %56[%c0] : memref<1xi32>
      %70 = arith.muli %34, %69 : i32
      %71 = arith.addi %54, %70 : i32
      %72 = memref.load %3[] : memref<i32>
      %73 = arith.muli %15, %69 : i32
      %74 = memref.load %36[%c0] : memref<1xi32>
      %75 = arith.muli %73, %74 : i32
      %76 = arith.addi %71, %75 : i32
      %77 = arith.index_cast %76 : i32 to index
      %78 = memref.load %5[] : memref<memref<?xf32>>
      %79 = arith.subi %15, %c1_i32 : i32
      %80 = arith.muli %79, %69 : i32
      %81 = arith.muli %80, %74 : i32
      %82 = arith.addi %71, %81 : i32
      %83 = arith.index_cast %82 : i32 to index
      %84 = arith.addi %83, %c0 : index
      %85 = memref.load %arg0[%84] : memref<?xf32>
      %86 = arith.addi %77, %c0 : index
      memref.store %85, %arg2[%86] : memref<?xf32>
    }
    %63 = memref.load %53[] : memref<i1>
    memref.store %63, %52[] : memref<i1>
    %64 = memref.load %52[] : memref<i1>
    %65 = scf.if %64 -> (i32) {
      %66 = memref.load %0[] : memref<i32>
      %67 = arith.addi %54, %c1_i32 : i32
      memref.store %67, %0[] : memref<i32>
      scf.yield %67 : i32
    } else {
      scf.yield %54 : i32
    }
    cf.br ^bb1(%65 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %54 : i32
  }
  scf.yield %49 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %31[] : memref<i1>
  %48 = scf.if %41 -> (i32) {
    %49 = scf.execute_region -> i32 {
      %50 = memref.load %31[] : memref<i1>
      %51 = scf.if %41 -> (i32) {
        memref.store %c0_i32, %0[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %33 : i32
      }
      %52 = memref.alloca() : memref<i1>
      %53 = memref.alloca() : memref<i1>
      memref.store %true, %53[] : memref<i1>
      cf.br ^bb1(%51 : i32)
    ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
      %55 = memref.load %0[] : memref<i32>
      %56 = memref.get_global @im : memref<1xi32>
      %57 = memref.load %56[%c0] : memref<1xi32>
      %58 = arith.cmpi slt, %54, %57 : i32
      %59 = memref.load %53[] : memref<i1>
      %60 = arith.andi %58, %59 : i1
      cf.cond_br %60, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %61 = memref.load %53[] : memref<i1>
      memref.store %61, %52[] : memref<i1>
      %62 = memref.load %52[] : memref<i1>
      scf.if %62 {
        %66 = memref.load %4[] : memref<memref<?xf32>>
        %67 = memref.load %0[] : memref<i32>
        %68 = memref.load %2[] : memref<i32>
        %69 = memref.load %56[%c0] : memref<1xi32>
        %70 = arith.muli %34, %69 : i32
        %71 = arith.addi %54, %70 : i32
        %72 = memref.load %3[] : memref<i32>
        %73 = arith.muli %15, %69 : i32
        %74 = memref.load %36[%c0] : memref<1xi32>
        %75 = arith.muli %73, %74 : i32
        %76 = arith.addi %71, %75 : i32
        %77 = arith.index_cast %76 : i32 to index
        %78 = memref.load %5[] : memref<memref<?xf32>>
        %79 = arith.subi %15, %c1_i32 : i32
        %80 = arith.muli %79, %69 : i32
        %81 = arith.muli %80, %74 : i32
        %82 = arith.addi %71, %81 : i32
        %83 = arith.index_cast %82 : i32 to index
        %84 = arith.addi %83, %c0 : index
        %85 = memref.load %arg0[%84] : memref<?xf32>
        %86 = arith.addi %77, %c0 : index
        memref.store %85, %arg2[%86] : memref<?xf32>
      }
      %63 = memref.load %53[] : memref<i1>
      memref.store %63, %52[] : memref<i1>
      %64 = memref.load %52[] : memref<i1>
      %65 = scf.if %64 -> (i32) {
        %66 = memref.load %0[] : memref<i32>
        %67 = arith.addi %54, %c1_i32 : i32
        memref.store %67, %0[] : memref<i32>
        scf.yield %67 : i32
      } else {
        scf.yield %54 : i32
      }
      cf.br ^bb1(%65 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %54 : i32
    }
    scf.yield %49 : i32
  } else {
    scf.yield %33 : i32
  }
  scf.yield %48 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
 replaced mlir-asm-printer: Verifying operation: builtin.module
%45 = memref.load %31[] : memref<i1> with mlir-asm-printer: Verifying operation: builtin.module
%44 = memref.load %32[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%44 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %2[] : memref<i32>
  %48 = arith.addi %34, %c1_i32 : i32
  memref.store %48, %2[] : memref<i32>
  scf.yield %48 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %2[] : memref<i32>
  %48 = arith.addi %34, %c1_i32 : i32
  memref.store %48, %2[] : memref<i32>
  scf.yield %48 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%44 = memref.load %32[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%44 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %34 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %34 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%44 = memref.load %32[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %41, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %41 -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %41 -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %41 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %59 : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %61, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %62 {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %63, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %64 -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %44, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %44 -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%44 = memref.load %32[] : memref<i1>
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%32 = memref.alloca() : memref<i1>
 + forwarding vec to promote {} of mlir-asm-printer: Verifying operation: builtin.module
%32 = memref.alloca() : memref<i1>
Begin forwarding store of mlir-asm-printer: Verifying operation: builtin.module
%32 = memref.alloca() : memref<i1> to load
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %true {
    %8 = memref.load %6[] : memref<i1>
    scf.if %true {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        %10 = scf.if %true -> (i32) {
          %26 = memref.get_global @kbm3 : memref<1xi32>
          %27 = memref.load %26[%c0] : memref<1xi32>
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %1 : i32
        }
        %11 = memref.alloca() : memref<i1>
        %12 = memref.alloca() : memref<i1>
        memref.store %true, %12[] : memref<i1>
        cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
      ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
        %16 = memref.load %3[] : memref<i32>
        %17 = arith.cmpi sgt, %15, %c0_i32 : i32
        %18 = memref.load %12[] : memref<i1>
        %19 = arith.andi %17, %true : i1
        cf.cond_br %19, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %20 = memref.load %12[] : memref<i1>
        memref.store %true, %11[] : memref<i1>
        %21 = memref.load %11[] : memref<i1>
        %22:2 = scf.if %true -> (i32, i32) {
          %26 = memref.load %11[] : memref<i1>
          %27:2 = scf.if %true -> (i32, i32) {
            %28:2 = scf.execute_region -> (i32, i32) {
              %29 = memref.load %11[] : memref<i1>
              %30 = scf.if %true -> (i32) {
                memref.store %c0_i32, %2[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %14 : i32
              }
              %31 = memref.alloca() : memref<i1>
              %32 = memref.alloca() : memref<i1>
              memref.store %true, %32[] : memref<i1>
              cf.br ^bb1(%13, %30 : i32, i32)
            ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
              %35 = memref.load %2[] : memref<i32>
              %36 = memref.get_global @jm : memref<1xi32>
              %37 = memref.load %36[%c0] : memref<1xi32>
              %38 = arith.cmpi slt, %34, %37 : i32
              %39 = memref.load %32[] : memref<i1>
              %40 = arith.andi %38, %39 : i1
              cf.cond_br %40, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %41 = memref.load %32[] : memref<i1>
              memref.store %41, %31[] : memref<i1>
              %42 = memref.load %31[] : memref<i1>
              %43 = scf.if %41 -> (i32) {
                %47 = memref.load %31[] : memref<i1>
                %48 = scf.if %41 -> (i32) {
                  %49 = scf.execute_region -> i32 {
                    %50 = memref.load %31[] : memref<i1>
                    %51 = scf.if %41 -> (i32) {
                      memref.store %c0_i32, %0[] : memref<i32>
                      scf.yield %c0_i32 : i32
                    } else {
                      scf.yield %33 : i32
                    }
                    %52 = memref.alloca() : memref<i1>
                    %53 = memref.alloca() : memref<i1>
                    memref.store %true, %53[] : memref<i1>
                    cf.br ^bb1(%51 : i32)
                  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                    %55 = memref.load %0[] : memref<i32>
                    %56 = memref.get_global @im : memref<1xi32>
                    %57 = memref.load %56[%c0] : memref<1xi32>
                    %58 = arith.cmpi slt, %54, %57 : i32
                    %59 = memref.load %53[] : memref<i1>
                    %60 = arith.andi %58, %59 : i1
                    cf.cond_br %60, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %61 = memref.load %53[] : memref<i1>
                    memref.store %61, %52[] : memref<i1>
                    %62 = memref.load %52[] : memref<i1>
                    scf.if %62 {
                      %66 = memref.load %4[] : memref<memref<?xf32>>
                      %67 = memref.load %0[] : memref<i32>
                      %68 = memref.load %2[] : memref<i32>
                      %69 = memref.load %56[%c0] : memref<1xi32>
                      %70 = arith.muli %34, %69 : i32
                      %71 = arith.addi %54, %70 : i32
                      %72 = memref.load %3[] : memref<i32>
                      %73 = arith.muli %15, %69 : i32
                      %74 = memref.load %36[%c0] : memref<1xi32>
                      %75 = arith.muli %73, %74 : i32
                      %76 = arith.addi %71, %75 : i32
                      %77 = arith.index_cast %76 : i32 to index
                      %78 = memref.load %5[] : memref<memref<?xf32>>
                      %79 = arith.subi %15, %c1_i32 : i32
                      %80 = arith.muli %79, %69 : i32
                      %81 = arith.muli %80, %74 : i32
                      %82 = arith.addi %71, %81 : i32
                      %83 = arith.index_cast %82 : i32 to index
                      %84 = arith.addi %83, %c0 : index
                      %85 = memref.load %arg0[%84] : memref<?xf32>
                      %86 = arith.addi %77, %c0 : index
                      memref.store %85, %arg2[%86] : memref<?xf32>
                    }
                    %63 = memref.load %53[] : memref<i1>
                    memref.store %63, %52[] : memref<i1>
                    %64 = memref.load %52[] : memref<i1>
                    %65 = scf.if %64 -> (i32) {
                      %66 = memref.load %0[] : memref<i32>
                      %67 = arith.addi %54, %c1_i32 : i32
                      memref.store %67, %0[] : memref<i32>
                      scf.yield %67 : i32
                    } else {
                      scf.yield %54 : i32
                    }
                    cf.br ^bb1(%65 : i32)
                  ^bb3:  // pred: ^bb1
                    scf.yield %54 : i32
                  }
                  scf.yield %49 : i32
                } else {
                  scf.yield %33 : i32
                }
                scf.yield %48 : i32
              } else {
                scf.yield %33 : i32
              }
              %44 = memref.load %32[] : memref<i1>
              memref.store %44, %31[] : memref<i1>
              %45 = memref.load %31[] : memref<i1>
              %46 = scf.if %44 -> (i32) {
                %47 = memref.load %2[] : memref<i32>
                %48 = arith.addi %34, %c1_i32 : i32
                memref.store %48, %2[] : memref<i32>
                scf.yield %48 : i32
              } else {
                scf.yield %34 : i32
              }
              cf.br ^bb1(%43, %46 : i32, i32)
            ^bb3:  // pred: ^bb1
              scf.yield %33, %34 : i32, i32
            }
            scf.yield %28#0, %28#1 : i32, i32
          } else {
            scf.yield %13, %14 : i32, i32
          }
          scf.yield %27#0, %27#1 : i32, i32
        } else {
          scf.yield %13, %14 : i32, i32
        }
        %23 = memref.load %12[] : memref<i1>
        memref.store %true, %11[] : memref<i1>
        %24 = memref.load %11[] : memref<i1>
        %25 = scf.if %true -> (i32) {
          %26 = memref.load %3[] : memref<i32>
          %27 = arith.subi %15, %c1_i32 : i32
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %15 : i32
        }
        cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}
Matching Load: mlir-asm-printer: Verifying operation: func.func
%44 = memref.load %32[] : memref<i1>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%41 = memref.load %32[] : memref<i1>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%39 = memref.load %32[] : memref<i1>
Matching Store: mlir-asm-printer: Verifying operation: func.func
memref.store %true, %32[] : memref<i1>
 storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %true, %32[] : memref<i1>
 initial storing block: 0x7fbd98168c20
 derived storing block: 0x7fbd98168a80
 initial storing block: 0x7fbd98168a80
 derived storing block: 0x7fbd981687d0
 initial storing block: 0x7fbd981687d0
 derived storing block: 0x7fbd98167b50
 initial storing block: 0x7fbd98167b50
 derived storing block: 0x7fbd981669f0
 initial storing block: 0x7fbd981669f0
 derived storing block: 0x7fbd98166740
 initial storing block: 0x7fbd98166740
 derived storing block: 0x7fbd98164100
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %29 = memref.load %11[] : memref<i1>
  %30 = scf.if %true -> (i32) {
    memref.store %c0_i32, %2[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %14 : i32
  }
  %31 = memref.alloca() : memref<i1>
  %32 = memref.alloca() : memref<i1>
  memref.store %true, %32[] : memref<i1>
  cf.br ^bb1(%13, %30 : i32, i32)


starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %2[] : memref<i32>
  scf.yield %c0_i32 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %2[] : memref<i32>
  scf.yield %c0_i32 : i32
 with val:<overwritten>

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %14 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %14 : i32
 with val:<overwritten>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %29 = memref.load %11[] : memref<i1>
  %30 = scf.if %true -> (i32) {
    memref.store %c0_i32, %2[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %14 : i32
  }
  %31 = memref.alloca() : memref<i1>
  %32 = memref.alloca() : memref<i1>
  memref.store %true, %32[] : memref<i1>
  cf.br ^bb1(%13, %30 : i32, i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
  %35 = memref.load %2[] : memref<i32>
  %36 = memref.get_global @jm : memref<1xi32>
  %37 = memref.load %36[%c0] : memref<1xi32>
  %38 = arith.cmpi slt, %34, %37 : i32
  %39 = memref.load %32[] : memref<i1>
  %40 = arith.andi %38, %39 : i1
  cf.cond_br %40, ^bb2, ^bb3

mlir-asm-printer: Verifying operation: builtin.module
^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
  %35 = memref.load %2[] : memref<i32>
  %36 = memref.get_global @jm : memref<1xi32>
  %37 = memref.load %36[%c0] : memref<1xi32>
  %38 = arith.cmpi slt, %34, %37 : i32
  %39 = memref.load %32[] : memref<i1>
  %40 = arith.andi %38, %39 : i1
  cf.cond_br %40, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
  %35 = memref.load %2[] : memref<i32>
  %36 = memref.get_global @jm : memref<1xi32>
  %37 = memref.load %36[%c0] : memref<1xi32>
  %38 = arith.cmpi slt, %34, %37 : i32
  %39 = memref.load %32[] : memref<i1>
  %40 = arith.andi %38, %39 : i1
  cf.cond_br %40, ^bb2, ^bb3
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%39 = memref.load %32[] : memref<i1>

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %33, %34 : i32, i32

mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %33, %34 : i32, i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %33, %34 : i32, i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %33, %34 : i32, i32


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %41, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %41 -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %41 -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %41 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %59 : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %61, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %62 {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %63, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %64 -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %44, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %44 -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %41, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %41 -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %41 -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %41 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %59 : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %61, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %62 {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %63, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %64 -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %44, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %44 -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %31[] : memref<i1>
  %48 = scf.if %41 -> (i32) {
    %49 = scf.execute_region -> i32 {
      %50 = memref.load %31[] : memref<i1>
      %51 = scf.if %41 -> (i32) {
        memref.store %c0_i32, %0[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %33 : i32
      }
      %52 = memref.alloca() : memref<i1>
      %53 = memref.alloca() : memref<i1>
      memref.store %true, %53[] : memref<i1>
      cf.br ^bb1(%51 : i32)
    ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
      %55 = memref.load %0[] : memref<i32>
      %56 = memref.get_global @im : memref<1xi32>
      %57 = memref.load %56[%c0] : memref<1xi32>
      %58 = arith.cmpi slt, %54, %57 : i32
      %59 = memref.load %53[] : memref<i1>
      %60 = arith.andi %58, %59 : i1
      cf.cond_br %60, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %61 = memref.load %53[] : memref<i1>
      memref.store %61, %52[] : memref<i1>
      %62 = memref.load %52[] : memref<i1>
      scf.if %62 {
        %66 = memref.load %4[] : memref<memref<?xf32>>
        %67 = memref.load %0[] : memref<i32>
        %68 = memref.load %2[] : memref<i32>
        %69 = memref.load %56[%c0] : memref<1xi32>
        %70 = arith.muli %34, %69 : i32
        %71 = arith.addi %54, %70 : i32
        %72 = memref.load %3[] : memref<i32>
        %73 = arith.muli %15, %69 : i32
        %74 = memref.load %36[%c0] : memref<1xi32>
        %75 = arith.muli %73, %74 : i32
        %76 = arith.addi %71, %75 : i32
        %77 = arith.index_cast %76 : i32 to index
        %78 = memref.load %5[] : memref<memref<?xf32>>
        %79 = arith.subi %15, %c1_i32 : i32
        %80 = arith.muli %79, %69 : i32
        %81 = arith.muli %80, %74 : i32
        %82 = arith.addi %71, %81 : i32
        %83 = arith.index_cast %82 : i32 to index
        %84 = arith.addi %83, %c0 : index
        %85 = memref.load %arg0[%84] : memref<?xf32>
        %86 = arith.addi %77, %c0 : index
        memref.store %85, %arg2[%86] : memref<?xf32>
      }
      %63 = memref.load %53[] : memref<i1>
      memref.store %63, %52[] : memref<i1>
      %64 = memref.load %52[] : memref<i1>
      %65 = scf.if %64 -> (i32) {
        %66 = memref.load %0[] : memref<i32>
        %67 = arith.addi %54, %c1_i32 : i32
        memref.store %67, %0[] : memref<i32>
        scf.yield %67 : i32
      } else {
        scf.yield %54 : i32
      }
      cf.br ^bb1(%65 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %54 : i32
    }
    scf.yield %49 : i32
  } else {
    scf.yield %33 : i32
  }
  scf.yield %48 : i32


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %49 = scf.execute_region -> i32 {
    %50 = memref.load %31[] : memref<i1>
    %51 = scf.if %41 -> (i32) {
      memref.store %c0_i32, %0[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %33 : i32
    }
    %52 = memref.alloca() : memref<i1>
    %53 = memref.alloca() : memref<i1>
    memref.store %true, %53[] : memref<i1>
    cf.br ^bb1(%51 : i32)
  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
    %55 = memref.load %0[] : memref<i32>
    %56 = memref.get_global @im : memref<1xi32>
    %57 = memref.load %56[%c0] : memref<1xi32>
    %58 = arith.cmpi slt, %54, %57 : i32
    %59 = memref.load %53[] : memref<i1>
    %60 = arith.andi %58, %59 : i1
    cf.cond_br %60, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %61 = memref.load %53[] : memref<i1>
    memref.store %61, %52[] : memref<i1>
    %62 = memref.load %52[] : memref<i1>
    scf.if %62 {
      %66 = memref.load %4[] : memref<memref<?xf32>>
      %67 = memref.load %0[] : memref<i32>
      %68 = memref.load %2[] : memref<i32>
      %69 = memref.load %56[%c0] : memref<1xi32>
      %70 = arith.muli %34, %69 : i32
      %71 = arith.addi %54, %70 : i32
      %72 = memref.load %3[] : memref<i32>
      %73 = arith.muli %15, %69 : i32
      %74 = memref.load %36[%c0] : memref<1xi32>
      %75 = arith.muli %73, %74 : i32
      %76 = arith.addi %71, %75 : i32
      %77 = arith.index_cast %76 : i32 to index
      %78 = memref.load %5[] : memref<memref<?xf32>>
      %79 = arith.subi %15, %c1_i32 : i32
      %80 = arith.muli %79, %69 : i32
      %81 = arith.muli %80, %74 : i32
      %82 = arith.addi %71, %81 : i32
      %83 = arith.index_cast %82 : i32 to index
      %84 = arith.addi %83, %c0 : index
      %85 = memref.load %arg0[%84] : memref<?xf32>
      %86 = arith.addi %77, %c0 : index
      memref.store %85, %arg2[%86] : memref<?xf32>
    }
    %63 = memref.load %53[] : memref<i1>
    memref.store %63, %52[] : memref<i1>
    %64 = memref.load %52[] : memref<i1>
    %65 = scf.if %64 -> (i32) {
      %66 = memref.load %0[] : memref<i32>
      %67 = arith.addi %54, %c1_i32 : i32
      memref.store %67, %0[] : memref<i32>
      scf.yield %67 : i32
    } else {
      scf.yield %54 : i32
    }
    cf.br ^bb1(%65 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %54 : i32
  }
  scf.yield %49 : i32


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %50 = memref.load %31[] : memref<i1>
  %51 = scf.if %41 -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %33 : i32
  }
  %52 = memref.alloca() : memref<i1>
  %53 = memref.alloca() : memref<i1>
  memref.store %true, %53[] : memref<i1>
  cf.br ^bb1(%51 : i32)


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield %c0_i32 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield %c0_i32 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %50 = memref.load %31[] : memref<i1>
  %51 = scf.if %41 -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %33 : i32
  }
  %52 = memref.alloca() : memref<i1>
  %53 = memref.alloca() : memref<i1>
  memref.store %true, %53[] : memref<i1>
  cf.br ^bb1(%51 : i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %59 : i1
  cf.cond_br %60, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %59 : i1
  cf.cond_br %60, ^bb2, ^bb3
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %61, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %62 {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %63, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %64 -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
  scf.yield
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %0[] : memref<i32>
  %67 = arith.addi %54, %c1_i32 : i32
  memref.store %67, %0[] : memref<i32>
  scf.yield %67 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %0[] : memref<i32>
  %67 = arith.addi %54, %c1_i32 : i32
  memref.store %67, %0[] : memref<i32>
  scf.yield %67 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %54 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %54 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %61, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %62 {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %63, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %64 -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %49 = scf.execute_region -> i32 {
    %50 = memref.load %31[] : memref<i1>
    %51 = scf.if %41 -> (i32) {
      memref.store %c0_i32, %0[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %33 : i32
    }
    %52 = memref.alloca() : memref<i1>
    %53 = memref.alloca() : memref<i1>
    memref.store %true, %53[] : memref<i1>
    cf.br ^bb1(%51 : i32)
  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
    %55 = memref.load %0[] : memref<i32>
    %56 = memref.get_global @im : memref<1xi32>
    %57 = memref.load %56[%c0] : memref<1xi32>
    %58 = arith.cmpi slt, %54, %57 : i32
    %59 = memref.load %53[] : memref<i1>
    %60 = arith.andi %58, %59 : i1
    cf.cond_br %60, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %61 = memref.load %53[] : memref<i1>
    memref.store %61, %52[] : memref<i1>
    %62 = memref.load %52[] : memref<i1>
    scf.if %62 {
      %66 = memref.load %4[] : memref<memref<?xf32>>
      %67 = memref.load %0[] : memref<i32>
      %68 = memref.load %2[] : memref<i32>
      %69 = memref.load %56[%c0] : memref<1xi32>
      %70 = arith.muli %34, %69 : i32
      %71 = arith.addi %54, %70 : i32
      %72 = memref.load %3[] : memref<i32>
      %73 = arith.muli %15, %69 : i32
      %74 = memref.load %36[%c0] : memref<1xi32>
      %75 = arith.muli %73, %74 : i32
      %76 = arith.addi %71, %75 : i32
      %77 = arith.index_cast %76 : i32 to index
      %78 = memref.load %5[] : memref<memref<?xf32>>
      %79 = arith.subi %15, %c1_i32 : i32
      %80 = arith.muli %79, %69 : i32
      %81 = arith.muli %80, %74 : i32
      %82 = arith.addi %71, %81 : i32
      %83 = arith.index_cast %82 : i32 to index
      %84 = arith.addi %83, %c0 : index
      %85 = memref.load %arg0[%84] : memref<?xf32>
      %86 = arith.addi %77, %c0 : index
      memref.store %85, %arg2[%86] : memref<?xf32>
    }
    %63 = memref.load %53[] : memref<i1>
    memref.store %63, %52[] : memref<i1>
    %64 = memref.load %52[] : memref<i1>
    %65 = scf.if %64 -> (i32) {
      %66 = memref.load %0[] : memref<i32>
      %67 = arith.addi %54, %c1_i32 : i32
      memref.store %67, %0[] : memref<i32>
      scf.yield %67 : i32
    } else {
      scf.yield %54 : i32
    }
    cf.br ^bb1(%65 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %54 : i32
  }
  scf.yield %49 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %31[] : memref<i1>
  %48 = scf.if %41 -> (i32) {
    %49 = scf.execute_region -> i32 {
      %50 = memref.load %31[] : memref<i1>
      %51 = scf.if %41 -> (i32) {
        memref.store %c0_i32, %0[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %33 : i32
      }
      %52 = memref.alloca() : memref<i1>
      %53 = memref.alloca() : memref<i1>
      memref.store %true, %53[] : memref<i1>
      cf.br ^bb1(%51 : i32)
    ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
      %55 = memref.load %0[] : memref<i32>
      %56 = memref.get_global @im : memref<1xi32>
      %57 = memref.load %56[%c0] : memref<1xi32>
      %58 = arith.cmpi slt, %54, %57 : i32
      %59 = memref.load %53[] : memref<i1>
      %60 = arith.andi %58, %59 : i1
      cf.cond_br %60, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %61 = memref.load %53[] : memref<i1>
      memref.store %61, %52[] : memref<i1>
      %62 = memref.load %52[] : memref<i1>
      scf.if %62 {
        %66 = memref.load %4[] : memref<memref<?xf32>>
        %67 = memref.load %0[] : memref<i32>
        %68 = memref.load %2[] : memref<i32>
        %69 = memref.load %56[%c0] : memref<1xi32>
        %70 = arith.muli %34, %69 : i32
        %71 = arith.addi %54, %70 : i32
        %72 = memref.load %3[] : memref<i32>
        %73 = arith.muli %15, %69 : i32
        %74 = memref.load %36[%c0] : memref<1xi32>
        %75 = arith.muli %73, %74 : i32
        %76 = arith.addi %71, %75 : i32
        %77 = arith.index_cast %76 : i32 to index
        %78 = memref.load %5[] : memref<memref<?xf32>>
        %79 = arith.subi %15, %c1_i32 : i32
        %80 = arith.muli %79, %69 : i32
        %81 = arith.muli %80, %74 : i32
        %82 = arith.addi %71, %81 : i32
        %83 = arith.index_cast %82 : i32 to index
        %84 = arith.addi %83, %c0 : index
        %85 = memref.load %arg0[%84] : memref<?xf32>
        %86 = arith.addi %77, %c0 : index
        memref.store %85, %arg2[%86] : memref<?xf32>
      }
      %63 = memref.load %53[] : memref<i1>
      memref.store %63, %52[] : memref<i1>
      %64 = memref.load %52[] : memref<i1>
      %65 = scf.if %64 -> (i32) {
        %66 = memref.load %0[] : memref<i32>
        %67 = arith.addi %54, %c1_i32 : i32
        memref.store %67, %0[] : memref<i32>
        scf.yield %67 : i32
      } else {
        scf.yield %54 : i32
      }
      cf.br ^bb1(%65 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %54 : i32
    }
    scf.yield %49 : i32
  } else {
    scf.yield %33 : i32
  }
  scf.yield %48 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
 replaced mlir-asm-printer: Verifying operation: builtin.module
%44 = memref.load %32[] : memref<i1> with mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %2[] : memref<i32>
  %48 = arith.addi %34, %c1_i32 : i32
  memref.store %48, %2[] : memref<i32>
  scf.yield %48 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %2[] : memref<i32>
  %48 = arith.addi %34, %c1_i32 : i32
  memref.store %48, %2[] : memref<i32>
  scf.yield %48 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %34 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %34 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %41, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %41 -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %41 -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %41 -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %59 : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %61, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %62 {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %63, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %64 -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %41, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %41 -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%41 = memref.load %32[] : memref<i1>
 replaced mlir-asm-printer: Verifying operation: builtin.module
branch has 2 operands for successor #0, but target block has 3
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%44 = "memref.load"(%36) : (memref<i1>) -> i1 with <block argument> of type 'i1' at index: 2
 replaced mlir-asm-printer: Verifying operation: builtin.module
branch has 2 operands for successor #0, but target block has 3
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%47 = "memref.load"(%36) : (memref<i1>) -> i1 with <block argument> of type 'i1' at index: 0
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%52 = memref.alloca() : memref<i1>
 + forwarding vec to promote {} of mlir-asm-printer: Verifying operation: builtin.module
%52 = memref.alloca() : memref<i1>
Begin forwarding store of mlir-asm-printer: Verifying operation: builtin.module
%52 = memref.alloca() : memref<i1> to load
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %true {
    %8 = memref.load %6[] : memref<i1>
    scf.if %true {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        %10 = scf.if %true -> (i32) {
          %26 = memref.get_global @kbm3 : memref<1xi32>
          %27 = memref.load %26[%c0] : memref<1xi32>
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %1 : i32
        }
        %11 = memref.alloca() : memref<i1>
        %12 = memref.alloca() : memref<i1>
        memref.store %true, %12[] : memref<i1>
        cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
      ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
        %16 = memref.load %3[] : memref<i32>
        %17 = arith.cmpi sgt, %15, %c0_i32 : i32
        %18 = memref.load %12[] : memref<i1>
        %19 = arith.andi %17, %true : i1
        cf.cond_br %19, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %20 = memref.load %12[] : memref<i1>
        memref.store %true, %11[] : memref<i1>
        %21 = memref.load %11[] : memref<i1>
        %22:2 = scf.if %true -> (i32, i32) {
          %26 = memref.load %11[] : memref<i1>
          %27:2 = scf.if %true -> (i32, i32) {
            %28:2 = scf.execute_region -> (i32, i32) {
              %29 = memref.load %11[] : memref<i1>
              %30 = scf.if %true -> (i32) {
                memref.store %c0_i32, %2[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %14 : i32
              }
              %31 = memref.alloca() : memref<i1>
              %32 = memref.alloca() : memref<i1>
              memref.store %true, %32[] : memref<i1>
              cf.br ^bb1(%13, %30 : i32, i32)
            ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
              %35 = memref.load %2[] : memref<i32>
              %36 = memref.get_global @jm : memref<1xi32>
              %37 = memref.load %36[%c0] : memref<1xi32>
              %38 = arith.cmpi slt, %34, %37 : i32
              %39 = memref.load %32[] : memref<i1>
              %40 = arith.andi %38, %true : i1
              cf.cond_br %40, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %41 = memref.load %32[] : memref<i1>
              memref.store %true, %31[] : memref<i1>
              %42 = memref.load %31[] : memref<i1>
              %43 = scf.if %true -> (i32) {
                %47 = memref.load %31[] : memref<i1>
                %48 = scf.if %true -> (i32) {
                  %49 = scf.execute_region -> i32 {
                    %50 = memref.load %31[] : memref<i1>
                    %51 = scf.if %true -> (i32) {
                      memref.store %c0_i32, %0[] : memref<i32>
                      scf.yield %c0_i32 : i32
                    } else {
                      scf.yield %33 : i32
                    }
                    %52 = memref.alloca() : memref<i1>
                    %53 = memref.alloca() : memref<i1>
                    memref.store %true, %53[] : memref<i1>
                    cf.br ^bb1(%51 : i32)
                  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                    %55 = memref.load %0[] : memref<i32>
                    %56 = memref.get_global @im : memref<1xi32>
                    %57 = memref.load %56[%c0] : memref<1xi32>
                    %58 = arith.cmpi slt, %54, %57 : i32
                    %59 = memref.load %53[] : memref<i1>
                    %60 = arith.andi %58, %59 : i1
                    cf.cond_br %60, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %61 = memref.load %53[] : memref<i1>
                    memref.store %61, %52[] : memref<i1>
                    %62 = memref.load %52[] : memref<i1>
                    scf.if %62 {
                      %66 = memref.load %4[] : memref<memref<?xf32>>
                      %67 = memref.load %0[] : memref<i32>
                      %68 = memref.load %2[] : memref<i32>
                      %69 = memref.load %56[%c0] : memref<1xi32>
                      %70 = arith.muli %34, %69 : i32
                      %71 = arith.addi %54, %70 : i32
                      %72 = memref.load %3[] : memref<i32>
                      %73 = arith.muli %15, %69 : i32
                      %74 = memref.load %36[%c0] : memref<1xi32>
                      %75 = arith.muli %73, %74 : i32
                      %76 = arith.addi %71, %75 : i32
                      %77 = arith.index_cast %76 : i32 to index
                      %78 = memref.load %5[] : memref<memref<?xf32>>
                      %79 = arith.subi %15, %c1_i32 : i32
                      %80 = arith.muli %79, %69 : i32
                      %81 = arith.muli %80, %74 : i32
                      %82 = arith.addi %71, %81 : i32
                      %83 = arith.index_cast %82 : i32 to index
                      %84 = arith.addi %83, %c0 : index
                      %85 = memref.load %arg0[%84] : memref<?xf32>
                      %86 = arith.addi %77, %c0 : index
                      memref.store %85, %arg2[%86] : memref<?xf32>
                    }
                    %63 = memref.load %53[] : memref<i1>
                    memref.store %63, %52[] : memref<i1>
                    %64 = memref.load %52[] : memref<i1>
                    %65 = scf.if %64 -> (i32) {
                      %66 = memref.load %0[] : memref<i32>
                      %67 = arith.addi %54, %c1_i32 : i32
                      memref.store %67, %0[] : memref<i32>
                      scf.yield %67 : i32
                    } else {
                      scf.yield %54 : i32
                    }
                    cf.br ^bb1(%65 : i32)
                  ^bb3:  // pred: ^bb1
                    scf.yield %54 : i32
                  }
                  scf.yield %49 : i32
                } else {
                  scf.yield %33 : i32
                }
                scf.yield %48 : i32
              } else {
                scf.yield %33 : i32
              }
              %44 = memref.load %32[] : memref<i1>
              memref.store %true, %31[] : memref<i1>
              %45 = memref.load %31[] : memref<i1>
              %46 = scf.if %true -> (i32) {
                %47 = memref.load %2[] : memref<i32>
                %48 = arith.addi %34, %c1_i32 : i32
                memref.store %48, %2[] : memref<i32>
                scf.yield %48 : i32
              } else {
                scf.yield %34 : i32
              }
              cf.br ^bb1(%43, %46 : i32, i32)
            ^bb3:  // pred: ^bb1
              scf.yield %33, %34 : i32, i32
            }
            scf.yield %28#0, %28#1 : i32, i32
          } else {
            scf.yield %13, %14 : i32, i32
          }
          scf.yield %27#0, %27#1 : i32, i32
        } else {
          scf.yield %13, %14 : i32, i32
        }
        %23 = memref.load %12[] : memref<i1>
        memref.store %true, %11[] : memref<i1>
        %24 = memref.load %11[] : memref<i1>
        %25 = scf.if %true -> (i32) {
          %26 = memref.load %3[] : memref<i32>
          %27 = arith.subi %15, %c1_i32 : i32
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %15 : i32
        }
        cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}
Matching Load: mlir-asm-printer: Verifying operation: func.func
%64 = memref.load %52[] : memref<i1>
Matching Store: mlir-asm-printer: Verifying operation: func.func
memref.store %63, %52[] : memref<i1>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%62 = memref.load %52[] : memref<i1>
Matching Store: mlir-asm-printer: Verifying operation: func.func
memref.store %61, %52[] : memref<i1>
 storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %61, %52[] : memref<i1>
 storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %63, %52[] : memref<i1>
 initial storing block: 0x7fbd9816b230
 derived storing block: 0x7fbd9816a540
 initial storing block: 0x7fbd9816b230
 derived storing block: 0x7fbd9816a540
 initial storing block: 0x7fbd9816a540
 derived storing block: 0x7fbd9816a2b0
 initial storing block: 0x7fbd9816a540
 derived storing block: 0x7fbd9816a2b0
 initial storing block: 0x7fbd9816a2b0
 derived storing block: 0x7fbd98169610
 initial storing block: 0x7fbd9816a2b0
 derived storing block: 0x7fbd98169610
 initial storing block: 0x7fbd98169610
 derived storing block: 0x7fbd98168a80
 initial storing block: 0x7fbd98169610
 derived storing block: 0x7fbd98168a80
 initial storing block: 0x7fbd98168a80
 derived storing block: 0x7fbd981687d0
 initial storing block: 0x7fbd98168a80
 derived storing block: 0x7fbd981687d0
 initial storing block: 0x7fbd981687d0
 derived storing block: 0x7fbd98167b50
 initial storing block: 0x7fbd981687d0
 derived storing block: 0x7fbd98167b50
 initial storing block: 0x7fbd98167b50
 derived storing block: 0x7fbd981669f0
 initial storing block: 0x7fbd98167b50
 derived storing block: 0x7fbd981669f0
 initial storing block: 0x7fbd981669f0
 derived storing block: 0x7fbd98166740
 initial storing block: 0x7fbd981669f0
 derived storing block: 0x7fbd98166740
 initial storing block: 0x7fbd98166740
 derived storing block: 0x7fbd98164100
 initial storing block: 0x7fbd98166740
 derived storing block: 0x7fbd98164100
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %50 = memref.load %31[] : memref<i1>
  %51 = scf.if %true -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %33 : i32
  }
  %52 = memref.alloca() : memref<i1>
  %53 = memref.alloca() : memref<i1>
  memref.store %true, %53[] : memref<i1>
  cf.br ^bb1(%51 : i32)


starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield %c0_i32 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield %c0_i32 : i32
 with val:<overwritten>

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:<overwritten>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %50 = memref.load %31[] : memref<i1>
  %51 = scf.if %true -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %33 : i32
  }
  %52 = memref.alloca() : memref<i1>
  %53 = memref.alloca() : memref<i1>
  memref.store %true, %53[] : memref<i1>
  cf.br ^bb1(%51 : i32)
 with val:<overwritten>

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %59 : i1
  cf.cond_br %60, ^bb2, ^bb3

mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %59 : i1
  cf.cond_br %60, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %59 : i1
  cf.cond_br %60, ^bb2, ^bb3
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %59 : i1
  cf.cond_br %60, ^bb2, ^bb3


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32

mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %61, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %62 {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %63, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %64 -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %61, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %62 {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %63, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %64 -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)

 replaced mlir-asm-printer: Verifying operation: builtin.module
%62 = memref.load %52[] : memref<i1> with mlir-asm-printer: Verifying operation: builtin.module
%61 = memref.load %53[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%61 = memref.load %53[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
  scf.yield
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%61 = memref.load %53[] : memref<i1>
 replaced mlir-asm-printer: Verifying operation: builtin.module
%64 = memref.load %52[] : memref<i1> with mlir-asm-printer: Verifying operation: builtin.module
%63 = memref.load %53[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%63 = memref.load %53[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %0[] : memref<i32>
  %67 = arith.addi %54, %c1_i32 : i32
  memref.store %67, %0[] : memref<i32>
  scf.yield %67 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %0[] : memref<i32>
  %67 = arith.addi %54, %c1_i32 : i32
  memref.store %67, %0[] : memref<i32>
  scf.yield %67 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%63 = memref.load %53[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%63 = memref.load %53[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %54 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %54 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%63 = memref.load %53[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %61, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %61 {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %63, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %63 -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%63 = memref.load %53[] : memref<i1>
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%53 = memref.alloca() : memref<i1>
 + forwarding vec to promote {} of mlir-asm-printer: Verifying operation: builtin.module
%53 = memref.alloca() : memref<i1>
Begin forwarding store of mlir-asm-printer: Verifying operation: builtin.module
%53 = memref.alloca() : memref<i1> to load
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %true {
    %8 = memref.load %6[] : memref<i1>
    scf.if %true {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        %10 = scf.if %true -> (i32) {
          %26 = memref.get_global @kbm3 : memref<1xi32>
          %27 = memref.load %26[%c0] : memref<1xi32>
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %1 : i32
        }
        %11 = memref.alloca() : memref<i1>
        %12 = memref.alloca() : memref<i1>
        memref.store %true, %12[] : memref<i1>
        cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
      ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
        %16 = memref.load %3[] : memref<i32>
        %17 = arith.cmpi sgt, %15, %c0_i32 : i32
        %18 = memref.load %12[] : memref<i1>
        %19 = arith.andi %17, %true : i1
        cf.cond_br %19, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %20 = memref.load %12[] : memref<i1>
        memref.store %true, %11[] : memref<i1>
        %21 = memref.load %11[] : memref<i1>
        %22:2 = scf.if %true -> (i32, i32) {
          %26 = memref.load %11[] : memref<i1>
          %27:2 = scf.if %true -> (i32, i32) {
            %28:2 = scf.execute_region -> (i32, i32) {
              %29 = memref.load %11[] : memref<i1>
              %30 = scf.if %true -> (i32) {
                memref.store %c0_i32, %2[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %14 : i32
              }
              %31 = memref.alloca() : memref<i1>
              %32 = memref.alloca() : memref<i1>
              memref.store %true, %32[] : memref<i1>
              cf.br ^bb1(%13, %30 : i32, i32)
            ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
              %35 = memref.load %2[] : memref<i32>
              %36 = memref.get_global @jm : memref<1xi32>
              %37 = memref.load %36[%c0] : memref<1xi32>
              %38 = arith.cmpi slt, %34, %37 : i32
              %39 = memref.load %32[] : memref<i1>
              %40 = arith.andi %38, %true : i1
              cf.cond_br %40, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %41 = memref.load %32[] : memref<i1>
              memref.store %true, %31[] : memref<i1>
              %42 = memref.load %31[] : memref<i1>
              %43 = scf.if %true -> (i32) {
                %47 = memref.load %31[] : memref<i1>
                %48 = scf.if %true -> (i32) {
                  %49 = scf.execute_region -> i32 {
                    %50 = memref.load %31[] : memref<i1>
                    %51 = scf.if %true -> (i32) {
                      memref.store %c0_i32, %0[] : memref<i32>
                      scf.yield %c0_i32 : i32
                    } else {
                      scf.yield %33 : i32
                    }
                    %52 = memref.alloca() : memref<i1>
                    %53 = memref.alloca() : memref<i1>
                    memref.store %true, %53[] : memref<i1>
                    cf.br ^bb1(%51 : i32)
                  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                    %55 = memref.load %0[] : memref<i32>
                    %56 = memref.get_global @im : memref<1xi32>
                    %57 = memref.load %56[%c0] : memref<1xi32>
                    %58 = arith.cmpi slt, %54, %57 : i32
                    %59 = memref.load %53[] : memref<i1>
                    %60 = arith.andi %58, %59 : i1
                    cf.cond_br %60, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %61 = memref.load %53[] : memref<i1>
                    memref.store %61, %52[] : memref<i1>
                    %62 = memref.load %52[] : memref<i1>
                    scf.if %61 {
                      %66 = memref.load %4[] : memref<memref<?xf32>>
                      %67 = memref.load %0[] : memref<i32>
                      %68 = memref.load %2[] : memref<i32>
                      %69 = memref.load %56[%c0] : memref<1xi32>
                      %70 = arith.muli %34, %69 : i32
                      %71 = arith.addi %54, %70 : i32
                      %72 = memref.load %3[] : memref<i32>
                      %73 = arith.muli %15, %69 : i32
                      %74 = memref.load %36[%c0] : memref<1xi32>
                      %75 = arith.muli %73, %74 : i32
                      %76 = arith.addi %71, %75 : i32
                      %77 = arith.index_cast %76 : i32 to index
                      %78 = memref.load %5[] : memref<memref<?xf32>>
                      %79 = arith.subi %15, %c1_i32 : i32
                      %80 = arith.muli %79, %69 : i32
                      %81 = arith.muli %80, %74 : i32
                      %82 = arith.addi %71, %81 : i32
                      %83 = arith.index_cast %82 : i32 to index
                      %84 = arith.addi %83, %c0 : index
                      %85 = memref.load %arg0[%84] : memref<?xf32>
                      %86 = arith.addi %77, %c0 : index
                      memref.store %85, %arg2[%86] : memref<?xf32>
                    }
                    %63 = memref.load %53[] : memref<i1>
                    memref.store %63, %52[] : memref<i1>
                    %64 = memref.load %52[] : memref<i1>
                    %65 = scf.if %63 -> (i32) {
                      %66 = memref.load %0[] : memref<i32>
                      %67 = arith.addi %54, %c1_i32 : i32
                      memref.store %67, %0[] : memref<i32>
                      scf.yield %67 : i32
                    } else {
                      scf.yield %54 : i32
                    }
                    cf.br ^bb1(%65 : i32)
                  ^bb3:  // pred: ^bb1
                    scf.yield %54 : i32
                  }
                  scf.yield %49 : i32
                } else {
                  scf.yield %33 : i32
                }
                scf.yield %48 : i32
              } else {
                scf.yield %33 : i32
              }
              %44 = memref.load %32[] : memref<i1>
              memref.store %true, %31[] : memref<i1>
              %45 = memref.load %31[] : memref<i1>
              %46 = scf.if %true -> (i32) {
                %47 = memref.load %2[] : memref<i32>
                %48 = arith.addi %34, %c1_i32 : i32
                memref.store %48, %2[] : memref<i32>
                scf.yield %48 : i32
              } else {
                scf.yield %34 : i32
              }
              cf.br ^bb1(%43, %46 : i32, i32)
            ^bb3:  // pred: ^bb1
              scf.yield %33, %34 : i32, i32
            }
            scf.yield %28#0, %28#1 : i32, i32
          } else {
            scf.yield %13, %14 : i32, i32
          }
          scf.yield %27#0, %27#1 : i32, i32
        } else {
          scf.yield %13, %14 : i32, i32
        }
        %23 = memref.load %12[] : memref<i1>
        memref.store %true, %11[] : memref<i1>
        %24 = memref.load %11[] : memref<i1>
        %25 = scf.if %true -> (i32) {
          %26 = memref.load %3[] : memref<i32>
          %27 = arith.subi %15, %c1_i32 : i32
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %15 : i32
        }
        cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}
Matching Load: mlir-asm-printer: Verifying operation: func.func
%63 = memref.load %53[] : memref<i1>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%61 = memref.load %53[] : memref<i1>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%59 = memref.load %53[] : memref<i1>
Matching Store: mlir-asm-printer: Verifying operation: func.func
memref.store %true, %53[] : memref<i1>
 storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %true, %53[] : memref<i1>
 initial storing block: 0x7fbd9816a6e0
 derived storing block: 0x7fbd9816a540
 initial storing block: 0x7fbd9816a540
 derived storing block: 0x7fbd9816a2b0
 initial storing block: 0x7fbd9816a2b0
 derived storing block: 0x7fbd98169610
 initial storing block: 0x7fbd98169610
 derived storing block: 0x7fbd98168a80
 initial storing block: 0x7fbd98168a80
 derived storing block: 0x7fbd981687d0
 initial storing block: 0x7fbd981687d0
 derived storing block: 0x7fbd98167b50
 initial storing block: 0x7fbd98167b50
 derived storing block: 0x7fbd981669f0
 initial storing block: 0x7fbd981669f0
 derived storing block: 0x7fbd98166740
 initial storing block: 0x7fbd98166740
 derived storing block: 0x7fbd98164100
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %50 = memref.load %31[] : memref<i1>
  %51 = scf.if %true -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %33 : i32
  }
  %52 = memref.alloca() : memref<i1>
  %53 = memref.alloca() : memref<i1>
  memref.store %true, %53[] : memref<i1>
  cf.br ^bb1(%51 : i32)


starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield %c0_i32 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield %c0_i32 : i32
 with val:<overwritten>

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:<overwritten>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %50 = memref.load %31[] : memref<i1>
  %51 = scf.if %true -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %33 : i32
  }
  %52 = memref.alloca() : memref<i1>
  %53 = memref.alloca() : memref<i1>
  memref.store %true, %53[] : memref<i1>
  cf.br ^bb1(%51 : i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%true = arith.constant true

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %59 : i1
  cf.cond_br %60, ^bb2, ^bb3

mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %59 : i1
  cf.cond_br %60, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %59 : i1
  cf.cond_br %60, ^bb2, ^bb3
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%59 = memref.load %53[] : memref<i1>

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32

mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %61, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %61 {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %63, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %63 -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %61, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %61 {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %63, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %63 -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)


starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%61 = memref.load %53[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
  scf.yield

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
  scf.yield
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%61 = memref.load %53[] : memref<i1>
 replaced mlir-asm-printer: Verifying operation: builtin.module
%63 = memref.load %53[] : memref<i1> with mlir-asm-printer: Verifying operation: builtin.module
%61 = memref.load %53[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%61 = memref.load %53[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %0[] : memref<i32>
  %67 = arith.addi %54, %c1_i32 : i32
  memref.store %67, %0[] : memref<i32>
  scf.yield %67 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %0[] : memref<i32>
  %67 = arith.addi %54, %c1_i32 : i32
  memref.store %67, %0[] : memref<i32>
  scf.yield %67 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%61 = memref.load %53[] : memref<i1>

starting block: lastVal=val:mlir-asm-printer: Verifying operation: builtin.module
%61 = memref.load %53[] : memref<i1>
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %54 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %54 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%61 = memref.load %53[] : memref<i1>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %61, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %61 {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %61, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %61 -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%61 = memref.load %53[] : memref<i1>
 replaced mlir-asm-printer: Verifying operation: builtin.module
branch has 1 operands for successor #0, but target block has 2
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%64 = "memref.load"(%57) : (memref<i1>) -> i1 with <block argument> of type 'i1' at index: 1
 replaced mlir-asm-printer: Verifying operation: builtin.module
branch has 1 operands for successor #0, but target block has 2
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%67 = "memref.load"(%57) : (memref<i1>) -> i1 with <block argument> of type 'i1' at index: 0
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%26 = memref.get_global @kbm3 : memref<1xi32>
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%36 = memref.get_global @jm : memref<1xi32>
 + forwarding vec to promote {0,} of mlir-asm-printer: Verifying operation: builtin.module
%36 = memref.get_global @jm : memref<1xi32>
Begin forwarding store of mlir-asm-printer: Verifying operation: builtin.module
%36 = memref.get_global @jm : memref<1xi32> to load
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %true {
    %8 = memref.load %6[] : memref<i1>
    scf.if %true {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        %10 = scf.if %true -> (i32) {
          %26 = memref.get_global @kbm3 : memref<1xi32>
          %27 = memref.load %26[%c0] : memref<1xi32>
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %1 : i32
        }
        %11 = memref.alloca() : memref<i1>
        %12 = memref.alloca() : memref<i1>
        memref.store %true, %12[] : memref<i1>
        cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
      ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
        %16 = memref.load %3[] : memref<i32>
        %17 = arith.cmpi sgt, %15, %c0_i32 : i32
        %18 = memref.load %12[] : memref<i1>
        %19 = arith.andi %17, %true : i1
        cf.cond_br %19, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %20 = memref.load %12[] : memref<i1>
        memref.store %true, %11[] : memref<i1>
        %21 = memref.load %11[] : memref<i1>
        %22:2 = scf.if %true -> (i32, i32) {
          %26 = memref.load %11[] : memref<i1>
          %27:2 = scf.if %true -> (i32, i32) {
            %28:2 = scf.execute_region -> (i32, i32) {
              %29 = memref.load %11[] : memref<i1>
              %30 = scf.if %true -> (i32) {
                memref.store %c0_i32, %2[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %14 : i32
              }
              %31 = memref.alloca() : memref<i1>
              %32 = memref.alloca() : memref<i1>
              memref.store %true, %32[] : memref<i1>
              cf.br ^bb1(%13, %30 : i32, i32)
            ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
              %35 = memref.load %2[] : memref<i32>
              %36 = memref.get_global @jm : memref<1xi32>
              %37 = memref.load %36[%c0] : memref<1xi32>
              %38 = arith.cmpi slt, %34, %37 : i32
              %39 = memref.load %32[] : memref<i1>
              %40 = arith.andi %38, %true : i1
              cf.cond_br %40, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %41 = memref.load %32[] : memref<i1>
              memref.store %true, %31[] : memref<i1>
              %42 = memref.load %31[] : memref<i1>
              %43 = scf.if %true -> (i32) {
                %47 = memref.load %31[] : memref<i1>
                %48 = scf.if %true -> (i32) {
                  %49 = scf.execute_region -> i32 {
                    %50 = memref.load %31[] : memref<i1>
                    %51 = scf.if %true -> (i32) {
                      memref.store %c0_i32, %0[] : memref<i32>
                      scf.yield %c0_i32 : i32
                    } else {
                      scf.yield %33 : i32
                    }
                    %52 = memref.alloca() : memref<i1>
                    %53 = memref.alloca() : memref<i1>
                    memref.store %true, %53[] : memref<i1>
                    cf.br ^bb1(%51 : i32)
                  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                    %55 = memref.load %0[] : memref<i32>
                    %56 = memref.get_global @im : memref<1xi32>
                    %57 = memref.load %56[%c0] : memref<1xi32>
                    %58 = arith.cmpi slt, %54, %57 : i32
                    %59 = memref.load %53[] : memref<i1>
                    %60 = arith.andi %58, %true : i1
                    cf.cond_br %60, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %61 = memref.load %53[] : memref<i1>
                    memref.store %true, %52[] : memref<i1>
                    %62 = memref.load %52[] : memref<i1>
                    scf.if %true {
                      %66 = memref.load %4[] : memref<memref<?xf32>>
                      %67 = memref.load %0[] : memref<i32>
                      %68 = memref.load %2[] : memref<i32>
                      %69 = memref.load %56[%c0] : memref<1xi32>
                      %70 = arith.muli %34, %69 : i32
                      %71 = arith.addi %54, %70 : i32
                      %72 = memref.load %3[] : memref<i32>
                      %73 = arith.muli %15, %69 : i32
                      %74 = memref.load %36[%c0] : memref<1xi32>
                      %75 = arith.muli %73, %74 : i32
                      %76 = arith.addi %71, %75 : i32
                      %77 = arith.index_cast %76 : i32 to index
                      %78 = memref.load %5[] : memref<memref<?xf32>>
                      %79 = arith.subi %15, %c1_i32 : i32
                      %80 = arith.muli %79, %69 : i32
                      %81 = arith.muli %80, %74 : i32
                      %82 = arith.addi %71, %81 : i32
                      %83 = arith.index_cast %82 : i32 to index
                      %84 = arith.addi %83, %c0 : index
                      %85 = memref.load %arg0[%84] : memref<?xf32>
                      %86 = arith.addi %77, %c0 : index
                      memref.store %85, %arg2[%86] : memref<?xf32>
                    }
                    %63 = memref.load %53[] : memref<i1>
                    memref.store %true, %52[] : memref<i1>
                    %64 = memref.load %52[] : memref<i1>
                    %65 = scf.if %true -> (i32) {
                      %66 = memref.load %0[] : memref<i32>
                      %67 = arith.addi %54, %c1_i32 : i32
                      memref.store %67, %0[] : memref<i32>
                      scf.yield %67 : i32
                    } else {
                      scf.yield %54 : i32
                    }
                    cf.br ^bb1(%65 : i32)
                  ^bb3:  // pred: ^bb1
                    scf.yield %54 : i32
                  }
                  scf.yield %49 : i32
                } else {
                  scf.yield %33 : i32
                }
                scf.yield %48 : i32
              } else {
                scf.yield %33 : i32
              }
              %44 = memref.load %32[] : memref<i1>
              memref.store %true, %31[] : memref<i1>
              %45 = memref.load %31[] : memref<i1>
              %46 = scf.if %true -> (i32) {
                %47 = memref.load %2[] : memref<i32>
                %48 = arith.addi %34, %c1_i32 : i32
                memref.store %48, %2[] : memref<i32>
                scf.yield %48 : i32
              } else {
                scf.yield %34 : i32
              }
              cf.br ^bb1(%43, %46 : i32, i32)
            ^bb3:  // pred: ^bb1
              scf.yield %33, %34 : i32, i32
            }
            scf.yield %28#0, %28#1 : i32, i32
          } else {
            scf.yield %13, %14 : i32, i32
          }
          scf.yield %27#0, %27#1 : i32, i32
        } else {
          scf.yield %13, %14 : i32, i32
        }
        %23 = memref.load %12[] : memref<i1>
        memref.store %true, %11[] : memref<i1>
        %24 = memref.load %11[] : memref<i1>
        %25 = scf.if %true -> (i32) {
          %26 = memref.load %3[] : memref<i32>
          %27 = arith.subi %15, %c1_i32 : i32
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %15 : i32
        }
        cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}
Matching Load: mlir-asm-printer: Verifying operation: func.func
%37 = memref.load %36[%c0] : memref<1xi32>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%74 = memref.load %36[%c0] : memref<1xi32>
Potential Op ith Effect: mlir-asm-printer: Verifying operation: func.func
memref.store %85, %arg2[%86] : memref<?xf32>
Potential Op ith Effect: mlir-asm-printer: Verifying operation: func.func
%49 = scf.execute_region -> i32 {
  %50 = memref.load %31[] : memref<i1>
  %51 = scf.if %true -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %33 : i32
  }
  %52 = memref.alloca() : memref<i1>
  %53 = memref.alloca() : memref<i1>
  memref.store %true, %53[] : memref<i1>
  cf.br ^bb1(%51 : i32)
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %true : i1
  cf.cond_br %60, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %true {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %true -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)
^bb3:  // pred: ^bb1
  scf.yield %54 : i32
}
Potential Op ith Effect: mlir-asm-printer: Verifying operation: func.func
%28:2 = scf.execute_region -> (i32, i32) {
  %29 = memref.load %11[] : memref<i1>
  %30 = scf.if %true -> (i32) {
    memref.store %c0_i32, %2[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %14 : i32
  }
  %31 = memref.alloca() : memref<i1>
  %32 = memref.alloca() : memref<i1>
  memref.store %true, %32[] : memref<i1>
  cf.br ^bb1(%13, %30 : i32, i32)
^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
  %35 = memref.load %2[] : memref<i32>
  %36 = memref.get_global @jm : memref<1xi32>
  %37 = memref.load %36[%c0] : memref<1xi32>
  %38 = arith.cmpi slt, %34, %37 : i32
  %39 = memref.load %32[] : memref<i1>
  %40 = arith.andi %38, %true : i1
  cf.cond_br %40, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %true -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %true -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %true -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %true : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %true {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %true -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %true -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)
^bb3:  // pred: ^bb1
  scf.yield %33, %34 : i32, i32
}
 aliasing storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %85, %arg2[%86] : memref<?xf32>
 aliasing storing operation: mlir-asm-printer: Verifying operation: func.func
%49 = scf.execute_region -> i32 {
  %50 = memref.load %31[] : memref<i1>
  %51 = scf.if %true -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %33 : i32
  }
  %52 = memref.alloca() : memref<i1>
  %53 = memref.alloca() : memref<i1>
  memref.store %true, %53[] : memref<i1>
  cf.br ^bb1(%51 : i32)
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %true : i1
  cf.cond_br %60, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %true {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %true -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)
^bb3:  // pred: ^bb1
  scf.yield %54 : i32
}
 aliasing storing operation: mlir-asm-printer: Verifying operation: func.func
%28:2 = scf.execute_region -> (i32, i32) {
  %29 = memref.load %11[] : memref<i1>
  %30 = scf.if %true -> (i32) {
    memref.store %c0_i32, %2[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %14 : i32
  }
  %31 = memref.alloca() : memref<i1>
  %32 = memref.alloca() : memref<i1>
  memref.store %true, %32[] : memref<i1>
  cf.br ^bb1(%13, %30 : i32, i32)
^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
  %35 = memref.load %2[] : memref<i32>
  %36 = memref.get_global @jm : memref<1xi32>
  %37 = memref.load %36[%c0] : memref<1xi32>
  %38 = arith.cmpi slt, %34, %37 : i32
  %39 = memref.load %32[] : memref<i1>
  %40 = arith.andi %38, %true : i1
  cf.cond_br %40, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %true -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %true -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %true -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %true : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %true {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %true -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %true -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)
^bb3:  // pred: ^bb1
  scf.yield %33, %34 : i32, i32
}
 initial storing block: 0x7fbd9816bd20
 derived storing block: 0x7fbd9816b230
 initial storing block: 0x7fbd9816a540
 derived storing block: 0x7fbd9816a2b0
 initial storing block: 0x7fbd98168a80
 derived storing block: 0x7fbd981687d0
 initial storing block: 0x7fbd9816b230
 derived storing block: 0x7fbd9816a540
 initial storing block: 0x7fbd9816a2b0
 derived storing block: 0x7fbd98169610
 initial storing block: 0x7fbd981687d0
 derived storing block: 0x7fbd98167b50
 initial storing block: 0x7fbd9816a540
 derived storing block: 0x7fbd9816a2b0
 initial storing block: 0x7fbd98169610
 derived storing block: 0x7fbd98168a80
 initial storing block: 0x7fbd98167b50
 derived storing block: 0x7fbd981669f0
 initial storing block: 0x7fbd9816a2b0
 derived storing block: 0x7fbd98169610
 initial storing block: 0x7fbd98168a80
 derived storing block: 0x7fbd981687d0
 initial storing block: 0x7fbd981669f0
 derived storing block: 0x7fbd98166740
 initial storing block: 0x7fbd98169610
 derived storing block: 0x7fbd98168a80
 initial storing block: 0x7fbd981687d0
 derived storing block: 0x7fbd98167b50
 initial storing block: 0x7fbd98166740
 derived storing block: 0x7fbd98164100
 initial storing block: 0x7fbd98168a80
 derived storing block: 0x7fbd981687d0
 initial storing block: 0x7fbd98167b50
 derived storing block: 0x7fbd981669f0
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd981687d0
 derived storing block: 0x7fbd98167b50
 initial storing block: 0x7fbd981669f0
 derived storing block: 0x7fbd98166740
 initial storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd98167b50
 derived storing block: 0x7fbd981669f0
 initial storing block: 0x7fbd98166740
 derived storing block: 0x7fbd98164100
 initial storing block: 0x7fbd981669f0
 derived storing block: 0x7fbd98166740
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd98166740
 derived storing block: 0x7fbd98164100
 initial storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
  %35 = memref.load %2[] : memref<i32>
  %36 = memref.get_global @jm : memref<1xi32>
  %37 = memref.load %36[%c0] : memref<1xi32>
  %38 = arith.cmpi slt, %34, %37 : i32
  %39 = memref.load %32[] : memref<i1>
  %40 = arith.andi %38, %true : i1
  cf.cond_br %40, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
  %35 = memref.load %2[] : memref<i32>
  %36 = memref.get_global @jm : memref<1xi32>
  %37 = memref.load %36[%c0] : memref<1xi32>
  %38 = arith.cmpi slt, %34, %37 : i32
  %39 = memref.load %32[] : memref<i1>
  %40 = arith.andi %38, %true : i1
  cf.cond_br %40, ^bb2, ^bb3
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%37 = memref.load %36[%c0] : memref<1xi32>

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %33, %34 : i32, i32

mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %33, %34 : i32, i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %33, %34 : i32, i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %33, %34 : i32, i32


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %true -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %true -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %true -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %true : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %true {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %true -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %true -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %true -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %true -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %true -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %true : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %true {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %true -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %true -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %true -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %true -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %true -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %true : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %true {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %true -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %true -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %31[] : memref<i1>
  %48 = scf.if %true -> (i32) {
    %49 = scf.execute_region -> i32 {
      %50 = memref.load %31[] : memref<i1>
      %51 = scf.if %true -> (i32) {
        memref.store %c0_i32, %0[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %33 : i32
      }
      %52 = memref.alloca() : memref<i1>
      %53 = memref.alloca() : memref<i1>
      memref.store %true, %53[] : memref<i1>
      cf.br ^bb1(%51 : i32)
    ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
      %55 = memref.load %0[] : memref<i32>
      %56 = memref.get_global @im : memref<1xi32>
      %57 = memref.load %56[%c0] : memref<1xi32>
      %58 = arith.cmpi slt, %54, %57 : i32
      %59 = memref.load %53[] : memref<i1>
      %60 = arith.andi %58, %true : i1
      cf.cond_br %60, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %61 = memref.load %53[] : memref<i1>
      memref.store %true, %52[] : memref<i1>
      %62 = memref.load %52[] : memref<i1>
      scf.if %true {
        %66 = memref.load %4[] : memref<memref<?xf32>>
        %67 = memref.load %0[] : memref<i32>
        %68 = memref.load %2[] : memref<i32>
        %69 = memref.load %56[%c0] : memref<1xi32>
        %70 = arith.muli %34, %69 : i32
        %71 = arith.addi %54, %70 : i32
        %72 = memref.load %3[] : memref<i32>
        %73 = arith.muli %15, %69 : i32
        %74 = memref.load %36[%c0] : memref<1xi32>
        %75 = arith.muli %73, %74 : i32
        %76 = arith.addi %71, %75 : i32
        %77 = arith.index_cast %76 : i32 to index
        %78 = memref.load %5[] : memref<memref<?xf32>>
        %79 = arith.subi %15, %c1_i32 : i32
        %80 = arith.muli %79, %69 : i32
        %81 = arith.muli %80, %74 : i32
        %82 = arith.addi %71, %81 : i32
        %83 = arith.index_cast %82 : i32 to index
        %84 = arith.addi %83, %c0 : index
        %85 = memref.load %arg0[%84] : memref<?xf32>
        %86 = arith.addi %77, %c0 : index
        memref.store %85, %arg2[%86] : memref<?xf32>
      }
      %63 = memref.load %53[] : memref<i1>
      memref.store %true, %52[] : memref<i1>
      %64 = memref.load %52[] : memref<i1>
      %65 = scf.if %true -> (i32) {
        %66 = memref.load %0[] : memref<i32>
        %67 = arith.addi %54, %c1_i32 : i32
        memref.store %67, %0[] : memref<i32>
        scf.yield %67 : i32
      } else {
        scf.yield %54 : i32
      }
      cf.br ^bb1(%65 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %54 : i32
    }
    scf.yield %49 : i32
  } else {
    scf.yield %33 : i32
  }
  scf.yield %48 : i32


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %true -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %true -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %true -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %true : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %true {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %true -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %true -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %49 = scf.execute_region -> i32 {
    %50 = memref.load %31[] : memref<i1>
    %51 = scf.if %true -> (i32) {
      memref.store %c0_i32, %0[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %33 : i32
    }
    %52 = memref.alloca() : memref<i1>
    %53 = memref.alloca() : memref<i1>
    memref.store %true, %53[] : memref<i1>
    cf.br ^bb1(%51 : i32)
  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
    %55 = memref.load %0[] : memref<i32>
    %56 = memref.get_global @im : memref<1xi32>
    %57 = memref.load %56[%c0] : memref<1xi32>
    %58 = arith.cmpi slt, %54, %57 : i32
    %59 = memref.load %53[] : memref<i1>
    %60 = arith.andi %58, %true : i1
    cf.cond_br %60, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %61 = memref.load %53[] : memref<i1>
    memref.store %true, %52[] : memref<i1>
    %62 = memref.load %52[] : memref<i1>
    scf.if %true {
      %66 = memref.load %4[] : memref<memref<?xf32>>
      %67 = memref.load %0[] : memref<i32>
      %68 = memref.load %2[] : memref<i32>
      %69 = memref.load %56[%c0] : memref<1xi32>
      %70 = arith.muli %34, %69 : i32
      %71 = arith.addi %54, %70 : i32
      %72 = memref.load %3[] : memref<i32>
      %73 = arith.muli %15, %69 : i32
      %74 = memref.load %36[%c0] : memref<1xi32>
      %75 = arith.muli %73, %74 : i32
      %76 = arith.addi %71, %75 : i32
      %77 = arith.index_cast %76 : i32 to index
      %78 = memref.load %5[] : memref<memref<?xf32>>
      %79 = arith.subi %15, %c1_i32 : i32
      %80 = arith.muli %79, %69 : i32
      %81 = arith.muli %80, %74 : i32
      %82 = arith.addi %71, %81 : i32
      %83 = arith.index_cast %82 : i32 to index
      %84 = arith.addi %83, %c0 : index
      %85 = memref.load %arg0[%84] : memref<?xf32>
      %86 = arith.addi %77, %c0 : index
      memref.store %85, %arg2[%86] : memref<?xf32>
    }
    %63 = memref.load %53[] : memref<i1>
    memref.store %true, %52[] : memref<i1>
    %64 = memref.load %52[] : memref<i1>
    %65 = scf.if %true -> (i32) {
      %66 = memref.load %0[] : memref<i32>
      %67 = arith.addi %54, %c1_i32 : i32
      memref.store %67, %0[] : memref<i32>
      scf.yield %67 : i32
    } else {
      scf.yield %54 : i32
    }
    cf.br ^bb1(%65 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %54 : i32
  }
  scf.yield %49 : i32


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %true -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %true -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %true -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %true : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %true {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %true -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %true -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %50 = memref.load %31[] : memref<i1>
  %51 = scf.if %true -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %33 : i32
  }
  %52 = memref.alloca() : memref<i1>
  %53 = memref.alloca() : memref<i1>
  memref.store %true, %53[] : memref<i1>
  cf.br ^bb1(%51 : i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %true -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %true -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %true -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %true : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %true {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %true -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %true -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield %c0_i32 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  memref.store %c0_i32, %0[] : memref<i32>
  scf.yield %c0_i32 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %true -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %true -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %true -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %true : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %true {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %true -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %true -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %true -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %true -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %true -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %true : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %true {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %true -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %true -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %true -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %true -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %true -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %true : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %true {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %true -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %true -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %50 = memref.load %31[] : memref<i1>
  %51 = scf.if %true -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %33 : i32
  }
  %52 = memref.alloca() : memref<i1>
  %53 = memref.alloca() : memref<i1>
  memref.store %true, %53[] : memref<i1>
  cf.br ^bb1(%51 : i32)
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %true -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %true -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %true -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %true : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %true {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %true -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %true -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %true : i1
  cf.cond_br %60, ^bb2, ^bb3

mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %true : i1
  cf.cond_br %60, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %true : i1
  cf.cond_br %60, ^bb2, ^bb3
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %true : i1
  cf.cond_br %60, ^bb2, ^bb3


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %true {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %true -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %true {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %true -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %true {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %true -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
  scf.yield

erased store due to: mlir-asm-printer: Verifying operation: func.func
memref.store %85, %arg2[%86] : memref<?xf32>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
  scf.yield
 with val:<overwritten>

starting block: lastVal=ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %true {
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
}
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %0[] : memref<i32>
  %67 = arith.addi %54, %c1_i32 : i32
  memref.store %67, %0[] : memref<i32>
  scf.yield %67 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %0[] : memref<i32>
  %67 = arith.addi %54, %c1_i32 : i32
  memref.store %67, %0[] : memref<i32>
  scf.yield %67 : i32
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %true {
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
}

starting block: lastVal=ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %true {
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
}
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %54 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %54 : i32
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %true {
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
}
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %true {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %true -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %true {
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
}

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32

mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %49 = scf.execute_region -> i32 {
    %50 = memref.load %31[] : memref<i1>
    %51 = scf.if %true -> (i32) {
      memref.store %c0_i32, %0[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %33 : i32
    }
    %52 = memref.alloca() : memref<i1>
    %53 = memref.alloca() : memref<i1>
    memref.store %true, %53[] : memref<i1>
    cf.br ^bb1(%51 : i32)
  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
    %55 = memref.load %0[] : memref<i32>
    %56 = memref.get_global @im : memref<1xi32>
    %57 = memref.load %56[%c0] : memref<1xi32>
    %58 = arith.cmpi slt, %54, %57 : i32
    %59 = memref.load %53[] : memref<i1>
    %60 = arith.andi %58, %true : i1
    cf.cond_br %60, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %61 = memref.load %53[] : memref<i1>
    memref.store %true, %52[] : memref<i1>
    %62 = memref.load %52[] : memref<i1>
    scf.if %true {
      %66 = memref.load %4[] : memref<memref<?xf32>>
      %67 = memref.load %0[] : memref<i32>
      %68 = memref.load %2[] : memref<i32>
      %69 = memref.load %56[%c0] : memref<1xi32>
      %70 = arith.muli %34, %69 : i32
      %71 = arith.addi %54, %70 : i32
      %72 = memref.load %3[] : memref<i32>
      %73 = arith.muli %15, %69 : i32
      %74 = memref.load %36[%c0] : memref<1xi32>
      %75 = arith.muli %73, %74 : i32
      %76 = arith.addi %71, %75 : i32
      %77 = arith.index_cast %76 : i32 to index
      %78 = memref.load %5[] : memref<memref<?xf32>>
      %79 = arith.subi %15, %c1_i32 : i32
      %80 = arith.muli %79, %69 : i32
      %81 = arith.muli %80, %74 : i32
      %82 = arith.addi %71, %81 : i32
      %83 = arith.index_cast %82 : i32 to index
      %84 = arith.addi %83, %c0 : index
      %85 = memref.load %arg0[%84] : memref<?xf32>
      %86 = arith.addi %77, %c0 : index
      memref.store %85, %arg2[%86] : memref<?xf32>
    }
    %63 = memref.load %53[] : memref<i1>
    memref.store %true, %52[] : memref<i1>
    %64 = memref.load %52[] : memref<i1>
    %65 = scf.if %true -> (i32) {
      %66 = memref.load %0[] : memref<i32>
      %67 = arith.addi %54, %c1_i32 : i32
      memref.store %67, %0[] : memref<i32>
      scf.yield %67 : i32
    } else {
      scf.yield %54 : i32
    }
    cf.br ^bb1(%65 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %54 : i32
  }
  scf.yield %49 : i32
 with val:exOp:mlir-asm-printer: Verifying operation: func.func
%49 = scf.execute_region -> i32 {
  %50 = memref.load %31[] : memref<i1>
  %51 = scf.if %true -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %33 : i32
  }
  %52 = memref.alloca() : memref<i1>
  %53 = memref.alloca() : memref<i1>
  memref.store %true, %53[] : memref<i1>
  cf.br ^bb1(%51 : i32)
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %true : i1
  cf.cond_br %60, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %true {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %true -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)
^bb3:  // pred: ^bb1
  scf.yield %54 : i32
}

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %true -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %true -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %true -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %true : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %true {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %true -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %true -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %true -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %true -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %true -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %true : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %true {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %true -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %true -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %31[] : memref<i1>
  %48 = scf.if %true -> (i32) {
    %49 = scf.execute_region -> i32 {
      %50 = memref.load %31[] : memref<i1>
      %51 = scf.if %true -> (i32) {
        memref.store %c0_i32, %0[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %33 : i32
      }
      %52 = memref.alloca() : memref<i1>
      %53 = memref.alloca() : memref<i1>
      memref.store %true, %53[] : memref<i1>
      cf.br ^bb1(%51 : i32)
    ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
      %55 = memref.load %0[] : memref<i32>
      %56 = memref.get_global @im : memref<1xi32>
      %57 = memref.load %56[%c0] : memref<1xi32>
      %58 = arith.cmpi slt, %54, %57 : i32
      %59 = memref.load %53[] : memref<i1>
      %60 = arith.andi %58, %true : i1
      cf.cond_br %60, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %61 = memref.load %53[] : memref<i1>
      memref.store %true, %52[] : memref<i1>
      %62 = memref.load %52[] : memref<i1>
      scf.if %true {
        %66 = memref.load %4[] : memref<memref<?xf32>>
        %67 = memref.load %0[] : memref<i32>
        %68 = memref.load %2[] : memref<i32>
        %69 = memref.load %56[%c0] : memref<1xi32>
        %70 = arith.muli %34, %69 : i32
        %71 = arith.addi %54, %70 : i32
        %72 = memref.load %3[] : memref<i32>
        %73 = arith.muli %15, %69 : i32
        %74 = memref.load %36[%c0] : memref<1xi32>
        %75 = arith.muli %73, %74 : i32
        %76 = arith.addi %71, %75 : i32
        %77 = arith.index_cast %76 : i32 to index
        %78 = memref.load %5[] : memref<memref<?xf32>>
        %79 = arith.subi %15, %c1_i32 : i32
        %80 = arith.muli %79, %69 : i32
        %81 = arith.muli %80, %74 : i32
        %82 = arith.addi %71, %81 : i32
        %83 = arith.index_cast %82 : i32 to index
        %84 = arith.addi %83, %c0 : index
        %85 = memref.load %arg0[%84] : memref<?xf32>
        %86 = arith.addi %77, %c0 : index
        memref.store %85, %arg2[%86] : memref<?xf32>
      }
      %63 = memref.load %53[] : memref<i1>
      memref.store %true, %52[] : memref<i1>
      %64 = memref.load %52[] : memref<i1>
      %65 = scf.if %true -> (i32) {
        %66 = memref.load %0[] : memref<i32>
        %67 = arith.addi %54, %c1_i32 : i32
        memref.store %67, %0[] : memref<i32>
        scf.yield %67 : i32
      } else {
        scf.yield %54 : i32
      }
      cf.br ^bb1(%65 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %54 : i32
    }
    scf.yield %49 : i32
  } else {
    scf.yield %33 : i32
  }
  scf.yield %48 : i32
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
%48 = scf.if %true -> (i32) {
  %49 = scf.execute_region -> i32 {
    %50 = memref.load %31[] : memref<i1>
    %51 = scf.if %true -> (i32) {
      memref.store %c0_i32, %0[] : memref<i32>
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %33 : i32
    }
    %52 = memref.alloca() : memref<i1>
    %53 = memref.alloca() : memref<i1>
    memref.store %true, %53[] : memref<i1>
    cf.br ^bb1(%51 : i32)
  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
    %55 = memref.load %0[] : memref<i32>
    %56 = memref.get_global @im : memref<1xi32>
    %57 = memref.load %56[%c0] : memref<1xi32>
    %58 = arith.cmpi slt, %54, %57 : i32
    %59 = memref.load %53[] : memref<i1>
    %60 = arith.andi %58, %true : i1
    cf.cond_br %60, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %61 = memref.load %53[] : memref<i1>
    memref.store %true, %52[] : memref<i1>
    %62 = memref.load %52[] : memref<i1>
    scf.if %true {
      %66 = memref.load %4[] : memref<memref<?xf32>>
      %67 = memref.load %0[] : memref<i32>
      %68 = memref.load %2[] : memref<i32>
      %69 = memref.load %56[%c0] : memref<1xi32>
      %70 = arith.muli %34, %69 : i32
      %71 = arith.addi %54, %70 : i32
      %72 = memref.load %3[] : memref<i32>
      %73 = arith.muli %15, %69 : i32
      %74 = memref.load %36[%c0] : memref<1xi32>
      %75 = arith.muli %73, %74 : i32
      %76 = arith.addi %71, %75 : i32
      %77 = arith.index_cast %76 : i32 to index
      %78 = memref.load %5[] : memref<memref<?xf32>>
      %79 = arith.subi %15, %c1_i32 : i32
      %80 = arith.muli %79, %69 : i32
      %81 = arith.muli %80, %74 : i32
      %82 = arith.addi %71, %81 : i32
      %83 = arith.index_cast %82 : i32 to index
      %84 = arith.addi %83, %c0 : index
      %85 = memref.load %arg0[%84] : memref<?xf32>
      %86 = arith.addi %77, %c0 : index
      memref.store %85, %arg2[%86] : memref<?xf32>
    }
    %63 = memref.load %53[] : memref<i1>
    memref.store %true, %52[] : memref<i1>
    %64 = memref.load %52[] : memref<i1>
    %65 = scf.if %true -> (i32) {
      %66 = memref.load %0[] : memref<i32>
      %67 = arith.addi %54, %c1_i32 : i32
      memref.store %67, %0[] : memref<i32>
      scf.yield %67 : i32
    } else {
      scf.yield %54 : i32
    }
    cf.br ^bb1(%65 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %54 : i32
  }
  scf.yield %49 : i32
} else {
  scf.yield %33 : i32
}

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %true -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %true -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %true -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %true : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %true {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %true -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %true -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %33 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %true -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %true -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %true -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %true : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %true {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %true -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %true -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)


starting block: lastVal=ifOp:mlir-asm-printer: Verifying operation: func.func
%43 = scf.if %true -> (i32) {
  %47 = memref.load %31[] : memref<i1>
  %48 = scf.if %true -> (i32) {
    %49 = scf.execute_region -> i32 {
      %50 = memref.load %31[] : memref<i1>
      %51 = scf.if %true -> (i32) {
        memref.store %c0_i32, %0[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %33 : i32
      }
      %52 = memref.alloca() : memref<i1>
      %53 = memref.alloca() : memref<i1>
      memref.store %true, %53[] : memref<i1>
      cf.br ^bb1(%51 : i32)
    ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
      %55 = memref.load %0[] : memref<i32>
      %56 = memref.get_global @im : memref<1xi32>
      %57 = memref.load %56[%c0] : memref<1xi32>
      %58 = arith.cmpi slt, %54, %57 : i32
      %59 = memref.load %53[] : memref<i1>
      %60 = arith.andi %58, %true : i1
      cf.cond_br %60, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %61 = memref.load %53[] : memref<i1>
      memref.store %true, %52[] : memref<i1>
      %62 = memref.load %52[] : memref<i1>
      scf.if %true {
        %66 = memref.load %4[] : memref<memref<?xf32>>
        %67 = memref.load %0[] : memref<i32>
        %68 = memref.load %2[] : memref<i32>
        %69 = memref.load %56[%c0] : memref<1xi32>
        %70 = arith.muli %34, %69 : i32
        %71 = arith.addi %54, %70 : i32
        %72 = memref.load %3[] : memref<i32>
        %73 = arith.muli %15, %69 : i32
        %74 = memref.load %36[%c0] : memref<1xi32>
        %75 = arith.muli %73, %74 : i32
        %76 = arith.addi %71, %75 : i32
        %77 = arith.index_cast %76 : i32 to index
        %78 = memref.load %5[] : memref<memref<?xf32>>
        %79 = arith.subi %15, %c1_i32 : i32
        %80 = arith.muli %79, %69 : i32
        %81 = arith.muli %80, %74 : i32
        %82 = arith.addi %71, %81 : i32
        %83 = arith.index_cast %82 : i32 to index
        %84 = arith.addi %83, %c0 : index
        %85 = memref.load %arg0[%84] : memref<?xf32>
        %86 = arith.addi %77, %c0 : index
        memref.store %85, %arg2[%86] : memref<?xf32>
      }
      %63 = memref.load %53[] : memref<i1>
      memref.store %true, %52[] : memref<i1>
      %64 = memref.load %52[] : memref<i1>
      %65 = scf.if %true -> (i32) {
        %66 = memref.load %0[] : memref<i32>
        %67 = arith.addi %54, %c1_i32 : i32
        memref.store %67, %0[] : memref<i32>
        scf.yield %67 : i32
      } else {
        scf.yield %54 : i32
      }
      cf.br ^bb1(%65 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %54 : i32
    }
    scf.yield %49 : i32
  } else {
    scf.yield %33 : i32
  }
  scf.yield %48 : i32
} else {
  scf.yield %33 : i32
}
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %2[] : memref<i32>
  %48 = arith.addi %34, %c1_i32 : i32
  memref.store %48, %2[] : memref<i32>
  scf.yield %48 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %47 = memref.load %2[] : memref<i32>
  %48 = arith.addi %34, %c1_i32 : i32
  memref.store %48, %2[] : memref<i32>
  scf.yield %48 : i32
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
%43 = scf.if %true -> (i32) {
  %47 = memref.load %31[] : memref<i1>
  %48 = scf.if %true -> (i32) {
    %49 = scf.execute_region -> i32 {
      %50 = memref.load %31[] : memref<i1>
      %51 = scf.if %true -> (i32) {
        memref.store %c0_i32, %0[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %33 : i32
      }
      %52 = memref.alloca() : memref<i1>
      %53 = memref.alloca() : memref<i1>
      memref.store %true, %53[] : memref<i1>
      cf.br ^bb1(%51 : i32)
    ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
      %55 = memref.load %0[] : memref<i32>
      %56 = memref.get_global @im : memref<1xi32>
      %57 = memref.load %56[%c0] : memref<1xi32>
      %58 = arith.cmpi slt, %54, %57 : i32
      %59 = memref.load %53[] : memref<i1>
      %60 = arith.andi %58, %true : i1
      cf.cond_br %60, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %61 = memref.load %53[] : memref<i1>
      memref.store %true, %52[] : memref<i1>
      %62 = memref.load %52[] : memref<i1>
      scf.if %true {
        %66 = memref.load %4[] : memref<memref<?xf32>>
        %67 = memref.load %0[] : memref<i32>
        %68 = memref.load %2[] : memref<i32>
        %69 = memref.load %56[%c0] : memref<1xi32>
        %70 = arith.muli %34, %69 : i32
        %71 = arith.addi %54, %70 : i32
        %72 = memref.load %3[] : memref<i32>
        %73 = arith.muli %15, %69 : i32
        %74 = memref.load %36[%c0] : memref<1xi32>
        %75 = arith.muli %73, %74 : i32
        %76 = arith.addi %71, %75 : i32
        %77 = arith.index_cast %76 : i32 to index
        %78 = memref.load %5[] : memref<memref<?xf32>>
        %79 = arith.subi %15, %c1_i32 : i32
        %80 = arith.muli %79, %69 : i32
        %81 = arith.muli %80, %74 : i32
        %82 = arith.addi %71, %81 : i32
        %83 = arith.index_cast %82 : i32 to index
        %84 = arith.addi %83, %c0 : index
        %85 = memref.load %arg0[%84] : memref<?xf32>
        %86 = arith.addi %77, %c0 : index
        memref.store %85, %arg2[%86] : memref<?xf32>
      }
      %63 = memref.load %53[] : memref<i1>
      memref.store %true, %52[] : memref<i1>
      %64 = memref.load %52[] : memref<i1>
      %65 = scf.if %true -> (i32) {
        %66 = memref.load %0[] : memref<i32>
        %67 = arith.addi %54, %c1_i32 : i32
        memref.store %67, %0[] : memref<i32>
        scf.yield %67 : i32
      } else {
        scf.yield %54 : i32
      }
      cf.br ^bb1(%65 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %54 : i32
    }
    scf.yield %49 : i32
  } else {
    scf.yield %33 : i32
  }
  scf.yield %48 : i32
} else {
  scf.yield %33 : i32
}

starting block: lastVal=ifOp:mlir-asm-printer: Verifying operation: func.func
%43 = scf.if %true -> (i32) {
  %47 = memref.load %31[] : memref<i1>
  %48 = scf.if %true -> (i32) {
    %49 = scf.execute_region -> i32 {
      %50 = memref.load %31[] : memref<i1>
      %51 = scf.if %true -> (i32) {
        memref.store %c0_i32, %0[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %33 : i32
      }
      %52 = memref.alloca() : memref<i1>
      %53 = memref.alloca() : memref<i1>
      memref.store %true, %53[] : memref<i1>
      cf.br ^bb1(%51 : i32)
    ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
      %55 = memref.load %0[] : memref<i32>
      %56 = memref.get_global @im : memref<1xi32>
      %57 = memref.load %56[%c0] : memref<1xi32>
      %58 = arith.cmpi slt, %54, %57 : i32
      %59 = memref.load %53[] : memref<i1>
      %60 = arith.andi %58, %true : i1
      cf.cond_br %60, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %61 = memref.load %53[] : memref<i1>
      memref.store %true, %52[] : memref<i1>
      %62 = memref.load %52[] : memref<i1>
      scf.if %true {
        %66 = memref.load %4[] : memref<memref<?xf32>>
        %67 = memref.load %0[] : memref<i32>
        %68 = memref.load %2[] : memref<i32>
        %69 = memref.load %56[%c0] : memref<1xi32>
        %70 = arith.muli %34, %69 : i32
        %71 = arith.addi %54, %70 : i32
        %72 = memref.load %3[] : memref<i32>
        %73 = arith.muli %15, %69 : i32
        %74 = memref.load %36[%c0] : memref<1xi32>
        %75 = arith.muli %73, %74 : i32
        %76 = arith.addi %71, %75 : i32
        %77 = arith.index_cast %76 : i32 to index
        %78 = memref.load %5[] : memref<memref<?xf32>>
        %79 = arith.subi %15, %c1_i32 : i32
        %80 = arith.muli %79, %69 : i32
        %81 = arith.muli %80, %74 : i32
        %82 = arith.addi %71, %81 : i32
        %83 = arith.index_cast %82 : i32 to index
        %84 = arith.addi %83, %c0 : index
        %85 = memref.load %arg0[%84] : memref<?xf32>
        %86 = arith.addi %77, %c0 : index
        memref.store %85, %arg2[%86] : memref<?xf32>
      }
      %63 = memref.load %53[] : memref<i1>
      memref.store %true, %52[] : memref<i1>
      %64 = memref.load %52[] : memref<i1>
      %65 = scf.if %true -> (i32) {
        %66 = memref.load %0[] : memref<i32>
        %67 = arith.addi %54, %c1_i32 : i32
        memref.store %67, %0[] : memref<i32>
        scf.yield %67 : i32
      } else {
        scf.yield %54 : i32
      }
      cf.br ^bb1(%65 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %54 : i32
    }
    scf.yield %49 : i32
  } else {
    scf.yield %33 : i32
  }
  scf.yield %48 : i32
} else {
  scf.yield %33 : i32
}
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %34 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %34 : i32
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
%43 = scf.if %true -> (i32) {
  %47 = memref.load %31[] : memref<i1>
  %48 = scf.if %true -> (i32) {
    %49 = scf.execute_region -> i32 {
      %50 = memref.load %31[] : memref<i1>
      %51 = scf.if %true -> (i32) {
        memref.store %c0_i32, %0[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %33 : i32
      }
      %52 = memref.alloca() : memref<i1>
      %53 = memref.alloca() : memref<i1>
      memref.store %true, %53[] : memref<i1>
      cf.br ^bb1(%51 : i32)
    ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
      %55 = memref.load %0[] : memref<i32>
      %56 = memref.get_global @im : memref<1xi32>
      %57 = memref.load %56[%c0] : memref<1xi32>
      %58 = arith.cmpi slt, %54, %57 : i32
      %59 = memref.load %53[] : memref<i1>
      %60 = arith.andi %58, %true : i1
      cf.cond_br %60, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %61 = memref.load %53[] : memref<i1>
      memref.store %true, %52[] : memref<i1>
      %62 = memref.load %52[] : memref<i1>
      scf.if %true {
        %66 = memref.load %4[] : memref<memref<?xf32>>
        %67 = memref.load %0[] : memref<i32>
        %68 = memref.load %2[] : memref<i32>
        %69 = memref.load %56[%c0] : memref<1xi32>
        %70 = arith.muli %34, %69 : i32
        %71 = arith.addi %54, %70 : i32
        %72 = memref.load %3[] : memref<i32>
        %73 = arith.muli %15, %69 : i32
        %74 = memref.load %36[%c0] : memref<1xi32>
        %75 = arith.muli %73, %74 : i32
        %76 = arith.addi %71, %75 : i32
        %77 = arith.index_cast %76 : i32 to index
        %78 = memref.load %5[] : memref<memref<?xf32>>
        %79 = arith.subi %15, %c1_i32 : i32
        %80 = arith.muli %79, %69 : i32
        %81 = arith.muli %80, %74 : i32
        %82 = arith.addi %71, %81 : i32
        %83 = arith.index_cast %82 : i32 to index
        %84 = arith.addi %83, %c0 : index
        %85 = memref.load %arg0[%84] : memref<?xf32>
        %86 = arith.addi %77, %c0 : index
        memref.store %85, %arg2[%86] : memref<?xf32>
      }
      %63 = memref.load %53[] : memref<i1>
      memref.store %true, %52[] : memref<i1>
      %64 = memref.load %52[] : memref<i1>
      %65 = scf.if %true -> (i32) {
        %66 = memref.load %0[] : memref<i32>
        %67 = arith.addi %54, %c1_i32 : i32
        memref.store %67, %0[] : memref<i32>
        scf.yield %67 : i32
      } else {
        scf.yield %54 : i32
      }
      cf.br ^bb1(%65 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %54 : i32
    }
    scf.yield %49 : i32
  } else {
    scf.yield %33 : i32
  }
  scf.yield %48 : i32
} else {
  scf.yield %33 : i32
}
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %41 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %42 = memref.load %31[] : memref<i1>
  %43 = scf.if %true -> (i32) {
    %47 = memref.load %31[] : memref<i1>
    %48 = scf.if %true -> (i32) {
      %49 = scf.execute_region -> i32 {
        %50 = memref.load %31[] : memref<i1>
        %51 = scf.if %true -> (i32) {
          memref.store %c0_i32, %0[] : memref<i32>
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %33 : i32
        }
        %52 = memref.alloca() : memref<i1>
        %53 = memref.alloca() : memref<i1>
        memref.store %true, %53[] : memref<i1>
        cf.br ^bb1(%51 : i32)
      ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
        %55 = memref.load %0[] : memref<i32>
        %56 = memref.get_global @im : memref<1xi32>
        %57 = memref.load %56[%c0] : memref<1xi32>
        %58 = arith.cmpi slt, %54, %57 : i32
        %59 = memref.load %53[] : memref<i1>
        %60 = arith.andi %58, %true : i1
        cf.cond_br %60, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %61 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %62 = memref.load %52[] : memref<i1>
        scf.if %true {
          %66 = memref.load %4[] : memref<memref<?xf32>>
          %67 = memref.load %0[] : memref<i32>
          %68 = memref.load %2[] : memref<i32>
          %69 = memref.load %56[%c0] : memref<1xi32>
          %70 = arith.muli %34, %69 : i32
          %71 = arith.addi %54, %70 : i32
          %72 = memref.load %3[] : memref<i32>
          %73 = arith.muli %15, %69 : i32
          %74 = memref.load %36[%c0] : memref<1xi32>
          %75 = arith.muli %73, %74 : i32
          %76 = arith.addi %71, %75 : i32
          %77 = arith.index_cast %76 : i32 to index
          %78 = memref.load %5[] : memref<memref<?xf32>>
          %79 = arith.subi %15, %c1_i32 : i32
          %80 = arith.muli %79, %69 : i32
          %81 = arith.muli %80, %74 : i32
          %82 = arith.addi %71, %81 : i32
          %83 = arith.index_cast %82 : i32 to index
          %84 = arith.addi %83, %c0 : index
          %85 = memref.load %arg0[%84] : memref<?xf32>
          %86 = arith.addi %77, %c0 : index
          memref.store %85, %arg2[%86] : memref<?xf32>
        }
        %63 = memref.load %53[] : memref<i1>
        memref.store %true, %52[] : memref<i1>
        %64 = memref.load %52[] : memref<i1>
        %65 = scf.if %true -> (i32) {
          %66 = memref.load %0[] : memref<i32>
          %67 = arith.addi %54, %c1_i32 : i32
          memref.store %67, %0[] : memref<i32>
          scf.yield %67 : i32
        } else {
          scf.yield %54 : i32
        }
        cf.br ^bb1(%65 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %54 : i32
      }
      scf.yield %49 : i32
    } else {
      scf.yield %33 : i32
    }
    scf.yield %48 : i32
  } else {
    scf.yield %33 : i32
  }
  %44 = memref.load %32[] : memref<i1>
  memref.store %true, %31[] : memref<i1>
  %45 = memref.load %31[] : memref<i1>
  %46 = scf.if %true -> (i32) {
    %47 = memref.load %2[] : memref<i32>
    %48 = arith.addi %34, %c1_i32 : i32
    memref.store %48, %2[] : memref<i32>
    scf.yield %48 : i32
  } else {
    scf.yield %34 : i32
  }
  cf.br ^bb1(%43, %46 : i32, i32)
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
%43 = scf.if %true -> (i32) {
  %47 = memref.load %31[] : memref<i1>
  %48 = scf.if %true -> (i32) {
    %49 = scf.execute_region -> i32 {
      %50 = memref.load %31[] : memref<i1>
      %51 = scf.if %true -> (i32) {
        memref.store %c0_i32, %0[] : memref<i32>
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %33 : i32
      }
      %52 = memref.alloca() : memref<i1>
      %53 = memref.alloca() : memref<i1>
      memref.store %true, %53[] : memref<i1>
      cf.br ^bb1(%51 : i32)
    ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
      %55 = memref.load %0[] : memref<i32>
      %56 = memref.get_global @im : memref<1xi32>
      %57 = memref.load %56[%c0] : memref<1xi32>
      %58 = arith.cmpi slt, %54, %57 : i32
      %59 = memref.load %53[] : memref<i1>
      %60 = arith.andi %58, %true : i1
      cf.cond_br %60, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %61 = memref.load %53[] : memref<i1>
      memref.store %true, %52[] : memref<i1>
      %62 = memref.load %52[] : memref<i1>
      scf.if %true {
        %66 = memref.load %4[] : memref<memref<?xf32>>
        %67 = memref.load %0[] : memref<i32>
        %68 = memref.load %2[] : memref<i32>
        %69 = memref.load %56[%c0] : memref<1xi32>
        %70 = arith.muli %34, %69 : i32
        %71 = arith.addi %54, %70 : i32
        %72 = memref.load %3[] : memref<i32>
        %73 = arith.muli %15, %69 : i32
        %74 = memref.load %36[%c0] : memref<1xi32>
        %75 = arith.muli %73, %74 : i32
        %76 = arith.addi %71, %75 : i32
        %77 = arith.index_cast %76 : i32 to index
        %78 = memref.load %5[] : memref<memref<?xf32>>
        %79 = arith.subi %15, %c1_i32 : i32
        %80 = arith.muli %79, %69 : i32
        %81 = arith.muli %80, %74 : i32
        %82 = arith.addi %71, %81 : i32
        %83 = arith.index_cast %82 : i32 to index
        %84 = arith.addi %83, %c0 : index
        %85 = memref.load %arg0[%84] : memref<?xf32>
        %86 = arith.addi %77, %c0 : index
        memref.store %85, %arg2[%86] : memref<?xf32>
      }
      %63 = memref.load %53[] : memref<i1>
      memref.store %true, %52[] : memref<i1>
      %64 = memref.load %52[] : memref<i1>
      %65 = scf.if %true -> (i32) {
        %66 = memref.load %0[] : memref<i32>
        %67 = arith.addi %54, %c1_i32 : i32
        memref.store %67, %0[] : memref<i32>
        scf.yield %67 : i32
      } else {
        scf.yield %54 : i32
      }
      cf.br ^bb1(%65 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %54 : i32
    }
    scf.yield %49 : i32
  } else {
    scf.yield %33 : i32
  }
  scf.yield %48 : i32
} else {
  scf.yield %33 : i32
}
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%56 = memref.get_global @im : memref<1xi32>
 + forwarding vec to promote {0,} of mlir-asm-printer: Verifying operation: builtin.module
%56 = memref.get_global @im : memref<1xi32>
Begin forwarding store of mlir-asm-printer: Verifying operation: builtin.module
%56 = memref.get_global @im : memref<1xi32> to load
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.alloca() : memref<i32>
  %1 = llvm.mlir.undef : i32
  memref.store %1, %0[] : memref<i32>
  %2 = memref.alloca() : memref<i32>
  memref.store %1, %2[] : memref<i32>
  %3 = memref.alloca() : memref<i32>
  memref.store %1, %3[] : memref<i32>
  %4 = memref.alloca() : memref<memref<?xf32>>
  %5 = memref.alloca() : memref<memref<?xf32>>
  memref.store %arg0, %5[] : memref<memref<?xf32>>
  memref.store %arg2, %4[] : memref<memref<?xf32>>
  %6 = memref.alloca() : memref<i1>
  memref.store %true, %6[] : memref<i1>
  %7 = memref.load %6[] : memref<i1>
  scf.if %true {
    %8 = memref.load %6[] : memref<i1>
    scf.if %true {
      scf.execute_region {
        %9 = memref.load %6[] : memref<i1>
        %10 = scf.if %true -> (i32) {
          %26 = memref.get_global @kbm3 : memref<1xi32>
          %27 = memref.load %26[%c0] : memref<1xi32>
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %1 : i32
        }
        %11 = memref.alloca() : memref<i1>
        %12 = memref.alloca() : memref<i1>
        memref.store %true, %12[] : memref<i1>
        cf.br ^bb1(%1, %1, %10 : i32, i32, i32)
      ^bb1(%13: i32, %14: i32, %15: i32):  // 2 preds: ^bb0, ^bb2
        %16 = memref.load %3[] : memref<i32>
        %17 = arith.cmpi sgt, %15, %c0_i32 : i32
        %18 = memref.load %12[] : memref<i1>
        %19 = arith.andi %17, %true : i1
        cf.cond_br %19, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %20 = memref.load %12[] : memref<i1>
        memref.store %true, %11[] : memref<i1>
        %21 = memref.load %11[] : memref<i1>
        %22:2 = scf.if %true -> (i32, i32) {
          %26 = memref.load %11[] : memref<i1>
          %27:2 = scf.if %true -> (i32, i32) {
            %28:2 = scf.execute_region -> (i32, i32) {
              %29 = memref.load %11[] : memref<i1>
              %30 = scf.if %true -> (i32) {
                memref.store %c0_i32, %2[] : memref<i32>
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %14 : i32
              }
              %31 = memref.alloca() : memref<i1>
              %32 = memref.alloca() : memref<i1>
              memref.store %true, %32[] : memref<i1>
              cf.br ^bb1(%13, %30 : i32, i32)
            ^bb1(%33: i32, %34: i32):  // 2 preds: ^bb0, ^bb2
              %35 = memref.load %2[] : memref<i32>
              %36 = memref.get_global @jm : memref<1xi32>
              %37 = memref.load %36[%c0] : memref<1xi32>
              %38 = arith.cmpi slt, %34, %37 : i32
              %39 = memref.load %32[] : memref<i1>
              %40 = arith.andi %38, %true : i1
              cf.cond_br %40, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %41 = memref.load %32[] : memref<i1>
              memref.store %true, %31[] : memref<i1>
              %42 = memref.load %31[] : memref<i1>
              %43 = scf.if %true -> (i32) {
                %47 = memref.load %31[] : memref<i1>
                %48 = scf.if %true -> (i32) {
                  %49 = scf.execute_region -> i32 {
                    %50 = memref.load %31[] : memref<i1>
                    %51 = scf.if %true -> (i32) {
                      memref.store %c0_i32, %0[] : memref<i32>
                      scf.yield %c0_i32 : i32
                    } else {
                      scf.yield %33 : i32
                    }
                    %52 = memref.alloca() : memref<i1>
                    %53 = memref.alloca() : memref<i1>
                    memref.store %true, %53[] : memref<i1>
                    cf.br ^bb1(%51 : i32)
                  ^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
                    %55 = memref.load %0[] : memref<i32>
                    %56 = memref.get_global @im : memref<1xi32>
                    %57 = memref.load %56[%c0] : memref<1xi32>
                    %58 = arith.cmpi slt, %54, %57 : i32
                    %59 = memref.load %53[] : memref<i1>
                    %60 = arith.andi %58, %true : i1
                    cf.cond_br %60, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    %61 = memref.load %53[] : memref<i1>
                    memref.store %true, %52[] : memref<i1>
                    %62 = memref.load %52[] : memref<i1>
                    scf.if %true {
                      %66 = memref.load %4[] : memref<memref<?xf32>>
                      %67 = memref.load %0[] : memref<i32>
                      %68 = memref.load %2[] : memref<i32>
                      %69 = memref.load %56[%c0] : memref<1xi32>
                      %70 = arith.muli %34, %69 : i32
                      %71 = arith.addi %54, %70 : i32
                      %72 = memref.load %3[] : memref<i32>
                      %73 = arith.muli %15, %69 : i32
                      %74 = memref.load %36[%c0] : memref<1xi32>
                      %75 = arith.muli %73, %74 : i32
                      %76 = arith.addi %71, %75 : i32
                      %77 = arith.index_cast %76 : i32 to index
                      %78 = memref.load %5[] : memref<memref<?xf32>>
                      %79 = arith.subi %15, %c1_i32 : i32
                      %80 = arith.muli %79, %69 : i32
                      %81 = arith.muli %80, %74 : i32
                      %82 = arith.addi %71, %81 : i32
                      %83 = arith.index_cast %82 : i32 to index
                      %84 = arith.addi %83, %c0 : index
                      %85 = memref.load %arg0[%84] : memref<?xf32>
                      %86 = arith.addi %77, %c0 : index
                      memref.store %85, %arg2[%86] : memref<?xf32>
                    }
                    %63 = memref.load %53[] : memref<i1>
                    memref.store %true, %52[] : memref<i1>
                    %64 = memref.load %52[] : memref<i1>
                    %65 = scf.if %true -> (i32) {
                      %66 = memref.load %0[] : memref<i32>
                      %67 = arith.addi %54, %c1_i32 : i32
                      memref.store %67, %0[] : memref<i32>
                      scf.yield %67 : i32
                    } else {
                      scf.yield %54 : i32
                    }
                    cf.br ^bb1(%65 : i32)
                  ^bb3:  // pred: ^bb1
                    scf.yield %54 : i32
                  }
                  scf.yield %49 : i32
                } else {
                  scf.yield %33 : i32
                }
                scf.yield %48 : i32
              } else {
                scf.yield %33 : i32
              }
              %44 = memref.load %32[] : memref<i1>
              memref.store %true, %31[] : memref<i1>
              %45 = memref.load %31[] : memref<i1>
              %46 = scf.if %true -> (i32) {
                %47 = memref.load %2[] : memref<i32>
                %48 = arith.addi %34, %c1_i32 : i32
                memref.store %48, %2[] : memref<i32>
                scf.yield %48 : i32
              } else {
                scf.yield %34 : i32
              }
              cf.br ^bb1(%43, %46 : i32, i32)
            ^bb3:  // pred: ^bb1
              scf.yield %33, %34 : i32, i32
            }
            scf.yield %28#0, %28#1 : i32, i32
          } else {
            scf.yield %13, %14 : i32, i32
          }
          scf.yield %27#0, %27#1 : i32, i32
        } else {
          scf.yield %13, %14 : i32, i32
        }
        %23 = memref.load %12[] : memref<i1>
        memref.store %true, %11[] : memref<i1>
        %24 = memref.load %11[] : memref<i1>
        %25 = scf.if %true -> (i32) {
          %26 = memref.load %3[] : memref<i32>
          %27 = arith.subi %15, %c1_i32 : i32
          memref.store %27, %3[] : memref<i32>
          scf.yield %27 : i32
        } else {
          scf.yield %15 : i32
        }
        cf.br ^bb1(%22#0, %22#1, %25 : i32, i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}
Matching Load: mlir-asm-printer: Verifying operation: func.func
%57 = memref.load %56[%c0] : memref<1xi32>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%69 = memref.load %56[%c0] : memref<1xi32>
Potential Op ith Effect: mlir-asm-printer: Verifying operation: func.func
memref.store %85, %arg2[%86] : memref<?xf32>
Potential Op ith Effect: mlir-asm-printer: Verifying operation: func.func
%49 = scf.execute_region -> i32 {
  %50 = memref.load %31[] : memref<i1>
  %51 = scf.if %true -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %33 : i32
  }
  %52 = memref.alloca() : memref<i1>
  %53 = memref.alloca() : memref<i1>
  memref.store %true, %53[] : memref<i1>
  cf.br ^bb1(%51 : i32)
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %true : i1
  cf.cond_br %60, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %true {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %true -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)
^bb3:  // pred: ^bb1
  scf.yield %54 : i32
}
 aliasing storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %85, %arg2[%86] : memref<?xf32>
 aliasing storing operation: mlir-asm-printer: Verifying operation: func.func
%49 = scf.execute_region -> i32 {
  %50 = memref.load %31[] : memref<i1>
  %51 = scf.if %true -> (i32) {
    memref.store %c0_i32, %0[] : memref<i32>
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %33 : i32
  }
  %52 = memref.alloca() : memref<i1>
  %53 = memref.alloca() : memref<i1>
  memref.store %true, %53[] : memref<i1>
  cf.br ^bb1(%51 : i32)
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %true : i1
  cf.cond_br %60, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %true {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %true -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)
^bb3:  // pred: ^bb1
  scf.yield %54 : i32
}
 initial storing block: 0x7fbd9816bd20
 derived storing block: 0x7fbd9816b230
 initial storing block: 0x7fbd9816a540
 derived storing block: 0x7fbd9816a2b0
 initial storing block: 0x7fbd9816b230
 derived storing block: 0x7fbd9816a540
 initial storing block: 0x7fbd9816a2b0
 derived storing block: 0x7fbd98169610
 initial storing block: 0x7fbd9816a540
 derived storing block: 0x7fbd9816a2b0
 initial storing block: 0x7fbd98169610
 derived storing block: 0x7fbd98168a80
 initial storing block: 0x7fbd9816a2b0
 derived storing block: 0x7fbd98169610
 initial storing block: 0x7fbd98168a80
 derived storing block: 0x7fbd981687d0
 initial storing block: 0x7fbd98169610
 derived storing block: 0x7fbd98168a80
 initial storing block: 0x7fbd981687d0
 derived storing block: 0x7fbd98167b50
 initial storing block: 0x7fbd98168a80
 derived storing block: 0x7fbd981687d0
 initial storing block: 0x7fbd98167b50
 derived storing block: 0x7fbd981669f0
 initial storing block: 0x7fbd981687d0
 derived storing block: 0x7fbd98167b50
 initial storing block: 0x7fbd981669f0
 derived storing block: 0x7fbd98166740
 initial storing block: 0x7fbd98167b50
 derived storing block: 0x7fbd981669f0
 initial storing block: 0x7fbd98166740
 derived storing block: 0x7fbd98164100
 initial storing block: 0x7fbd981669f0
 derived storing block: 0x7fbd98166740
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd98166740
 derived storing block: 0x7fbd98164100
 initial storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %true : i1
  cf.cond_br %60, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%54: i32):  // 2 preds: ^bb0, ^bb2
  %55 = memref.load %0[] : memref<i32>
  %56 = memref.get_global @im : memref<1xi32>
  %57 = memref.load %56[%c0] : memref<1xi32>
  %58 = arith.cmpi slt, %54, %57 : i32
  %59 = memref.load %53[] : memref<i1>
  %60 = arith.andi %58, %true : i1
  cf.cond_br %60, ^bb2, ^bb3
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%57 = memref.load %56[%c0] : memref<1xi32>

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32

mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %54 : i32


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %true {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %true -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %true {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %true -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %true {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %true -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
  scf.yield

erased store due to: mlir-asm-printer: Verifying operation: func.func
memref.store %85, %arg2[%86] : memref<?xf32>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
  scf.yield
 with val:<overwritten>

starting block: lastVal=ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %true {
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
}
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %0[] : memref<i32>
  %67 = arith.addi %54, %c1_i32 : i32
  memref.store %67, %0[] : memref<i32>
  scf.yield %67 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %66 = memref.load %0[] : memref<i32>
  %67 = arith.addi %54, %c1_i32 : i32
  memref.store %67, %0[] : memref<i32>
  scf.yield %67 : i32
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %true {
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
}

starting block: lastVal=ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %true {
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
}
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %54 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %54 : i32
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %true {
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
}
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %61 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %62 = memref.load %52[] : memref<i1>
  scf.if %true {
    %66 = memref.load %4[] : memref<memref<?xf32>>
    %67 = memref.load %0[] : memref<i32>
    %68 = memref.load %2[] : memref<i32>
    %69 = memref.load %56[%c0] : memref<1xi32>
    %70 = arith.muli %34, %69 : i32
    %71 = arith.addi %54, %70 : i32
    %72 = memref.load %3[] : memref<i32>
    %73 = arith.muli %15, %69 : i32
    %74 = memref.load %36[%c0] : memref<1xi32>
    %75 = arith.muli %73, %74 : i32
    %76 = arith.addi %71, %75 : i32
    %77 = arith.index_cast %76 : i32 to index
    %78 = memref.load %5[] : memref<memref<?xf32>>
    %79 = arith.subi %15, %c1_i32 : i32
    %80 = arith.muli %79, %69 : i32
    %81 = arith.muli %80, %74 : i32
    %82 = arith.addi %71, %81 : i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = arith.addi %83, %c0 : index
    %85 = memref.load %arg0[%84] : memref<?xf32>
    %86 = arith.addi %77, %c0 : index
    memref.store %85, %arg2[%86] : memref<?xf32>
  }
  %63 = memref.load %53[] : memref<i1>
  memref.store %true, %52[] : memref<i1>
  %64 = memref.load %52[] : memref<i1>
  %65 = scf.if %true -> (i32) {
    %66 = memref.load %0[] : memref<i32>
    %67 = arith.addi %54, %c1_i32 : i32
    memref.store %67, %0[] : memref<i32>
    scf.yield %67 : i32
  } else {
    scf.yield %54 : i32
  }
  cf.br ^bb1(%65 : i32)
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %true {
  %66 = memref.load %4[] : memref<memref<?xf32>>
  %67 = memref.load %0[] : memref<i32>
  %68 = memref.load %2[] : memref<i32>
  %69 = memref.load %56[%c0] : memref<1xi32>
  %70 = arith.muli %34, %69 : i32
  %71 = arith.addi %54, %70 : i32
  %72 = memref.load %3[] : memref<i32>
  %73 = arith.muli %15, %69 : i32
  %74 = memref.load %36[%c0] : memref<1xi32>
  %75 = arith.muli %73, %74 : i32
  %76 = arith.addi %71, %75 : i32
  %77 = arith.index_cast %76 : i32 to index
  %78 = memref.load %5[] : memref<memref<?xf32>>
  %79 = arith.subi %15, %c1_i32 : i32
  %80 = arith.muli %79, %69 : i32
  %81 = arith.muli %80, %74 : i32
  %82 = arith.addi %71, %81 : i32
  %83 = arith.index_cast %82 : i32 to index
  %84 = arith.addi %83, %c0 : index
  %85 = memref.load %arg0[%84] : memref<?xf32>
  %86 = arith.addi %77, %c0 : index
  memref.store %85, %arg2[%86] : memref<?xf32>
}
 replaced mlir-asm-printer: Verifying operation: builtin.module
branch has 0 operands for successor #0, but target block has 1
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
%74 = "memref.load"(%60, %3) : (memref<1xi32>, index) -> i32 with <block argument> of type 'i32' at index: 0
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%9 = memref.get_global @kbm3 : memref<1xi32>
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%14 = memref.get_global @jm : memref<1xi32>
 + forwarding vec to promote {0,} of mlir-asm-printer: Verifying operation: builtin.module
%14 = memref.get_global @jm : memref<1xi32>
Begin forwarding store of mlir-asm-printer: Verifying operation: builtin.module
%14 = memref.get_global @jm : memref<1xi32> to load
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = llvm.mlir.undef : i32
  scf.if %true {
    scf.if %true {
      scf.execute_region {
        %1 = scf.if %true -> (i32) {
          %9 = memref.get_global @kbm3 : memref<1xi32>
          %10 = memref.load %9[%c0] : memref<1xi32>
          scf.yield %10 : i32
        } else {
          scf.yield %0 : i32
        }
        cf.br ^bb1(%0, %0, %1 : i32, i32, i32)
      ^bb1(%2: i32, %3: i32, %4: i32):  // 2 preds: ^bb0, ^bb2
        %5 = arith.cmpi sgt, %4, %c0_i32 : i32
        %6 = arith.andi %5, %true : i1
        cf.cond_br %6, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %7:2 = scf.if %true -> (i32, i32) {
          %9:2 = scf.if %true -> (i32, i32) {
            %10:2 = scf.execute_region -> (i32, i32) {
              %11 = scf.if %true -> (i32) {
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %3 : i32
              }
              cf.br ^bb1(%2, %11 : i32, i32)
            ^bb1(%12: i32, %13: i32):  // 2 preds: ^bb0, ^bb2
              %14 = memref.get_global @jm : memref<1xi32>
              %15 = memref.load %14[%c0] : memref<1xi32>
              %16 = arith.cmpi slt, %13, %15 : i32
              %17 = arith.andi %16, %true : i1
              cf.cond_br %17, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %18 = scf.if %true -> (i32) {
                %20 = scf.if %true -> (i32) {
                  %21 = scf.execute_region -> i32 {
                    %22 = scf.if %true -> (i32) {
                      scf.yield %c0_i32 : i32
                    } else {
                      scf.yield %12 : i32
                    }
                    cf.br ^bb1(%22 : i32)
                  ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
                    %24 = memref.get_global @im : memref<1xi32>
                    %25 = memref.load %24[%c0] : memref<1xi32>
                    %26 = arith.cmpi slt, %23, %25 : i32
                    %27 = arith.andi %26, %true : i1
                    cf.cond_br %27, ^bb2, ^bb3
                  ^bb2:  // pred: ^bb1
                    scf.if %true {
                      %29 = arith.muli %13, %25 : i32
                      %30 = arith.addi %23, %29 : i32
                      %31 = arith.muli %4, %25 : i32
                      %32 = memref.load %14[%c0] : memref<1xi32>
                      %33 = arith.muli %31, %32 : i32
                      %34 = arith.addi %30, %33 : i32
                      %35 = arith.index_cast %34 : i32 to index
                      %36 = arith.subi %4, %c1_i32 : i32
                      %37 = arith.muli %36, %25 : i32
                      %38 = arith.muli %37, %32 : i32
                      %39 = arith.addi %30, %38 : i32
                      %40 = arith.index_cast %39 : i32 to index
                      %41 = arith.addi %40, %c0 : index
                      %42 = memref.load %arg0[%41] : memref<?xf32>
                      %43 = arith.addi %35, %c0 : index
                      memref.store %42, %arg2[%43] : memref<?xf32>
                    }
                    %28 = scf.if %true -> (i32) {
                      %29 = arith.addi %23, %c1_i32 : i32
                      scf.yield %29 : i32
                    } else {
                      scf.yield %23 : i32
                    }
                    cf.br ^bb1(%28 : i32)
                  ^bb3:  // pred: ^bb1
                    scf.yield %23 : i32
                  }
                  scf.yield %21 : i32
                } else {
                  scf.yield %12 : i32
                }
                scf.yield %20 : i32
              } else {
                scf.yield %12 : i32
              }
              %19 = scf.if %true -> (i32) {
                %20 = arith.addi %13, %c1_i32 : i32
                scf.yield %20 : i32
              } else {
                scf.yield %13 : i32
              }
              cf.br ^bb1(%18, %19 : i32, i32)
            ^bb3:  // pred: ^bb1
              scf.yield %12, %13 : i32, i32
            }
            scf.yield %10#0, %10#1 : i32, i32
          } else {
            scf.yield %2, %3 : i32, i32
          }
          scf.yield %9#0, %9#1 : i32, i32
        } else {
          scf.yield %2, %3 : i32, i32
        }
        %8 = scf.if %true -> (i32) {
          %9 = arith.subi %4, %c1_i32 : i32
          scf.yield %9 : i32
        } else {
          scf.yield %4 : i32
        }
        cf.br ^bb1(%7#0, %7#1, %8 : i32, i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield
      }
    }
  }
  return
}
Matching Load: mlir-asm-printer: Verifying operation: func.func
%15 = memref.load %14[%c0] : memref<1xi32>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%32 = memref.load %14[%c0] : memref<1xi32>
Potential Op ith Effect: mlir-asm-printer: Verifying operation: func.func
memref.store %42, %arg2[%43] : memref<?xf32>
Potential Op ith Effect: mlir-asm-printer: Verifying operation: func.func
%21 = scf.execute_region -> i32 {
  %22 = scf.if %true -> (i32) {
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %12 : i32
  }
  cf.br ^bb1(%22 : i32)
^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
  %24 = memref.get_global @im : memref<1xi32>
  %25 = memref.load %24[%c0] : memref<1xi32>
  %26 = arith.cmpi slt, %23, %25 : i32
  %27 = arith.andi %26, %true : i1
  cf.cond_br %27, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  scf.if %true {
    %29 = arith.muli %13, %25 : i32
    %30 = arith.addi %23, %29 : i32
    %31 = arith.muli %4, %25 : i32
    %32 = memref.load %14[%c0] : memref<1xi32>
    %33 = arith.muli %31, %32 : i32
    %34 = arith.addi %30, %33 : i32
    %35 = arith.index_cast %34 : i32 to index
    %36 = arith.subi %4, %c1_i32 : i32
    %37 = arith.muli %36, %25 : i32
    %38 = arith.muli %37, %32 : i32
    %39 = arith.addi %30, %38 : i32
    %40 = arith.index_cast %39 : i32 to index
    %41 = arith.addi %40, %c0 : index
    %42 = memref.load %arg0[%41] : memref<?xf32>
    %43 = arith.addi %35, %c0 : index
    memref.store %42, %arg2[%43] : memref<?xf32>
  }
  %28 = scf.if %true -> (i32) {
    %29 = arith.addi %23, %c1_i32 : i32
    scf.yield %29 : i32
  } else {
    scf.yield %23 : i32
  }
  cf.br ^bb1(%28 : i32)
^bb3:  // pred: ^bb1
  scf.yield %23 : i32
}
Potential Op ith Effect: mlir-asm-printer: Verifying operation: func.func
%10:2 = scf.execute_region -> (i32, i32) {
  %11 = scf.if %true -> (i32) {
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %3 : i32
  }
  cf.br ^bb1(%2, %11 : i32, i32)
^bb1(%12: i32, %13: i32):  // 2 preds: ^bb0, ^bb2
  %14 = memref.get_global @jm : memref<1xi32>
  %15 = memref.load %14[%c0] : memref<1xi32>
  %16 = arith.cmpi slt, %13, %15 : i32
  %17 = arith.andi %16, %true : i1
  cf.cond_br %17, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %18 = scf.if %true -> (i32) {
    %20 = scf.if %true -> (i32) {
      %21 = scf.execute_region -> i32 {
        %22 = scf.if %true -> (i32) {
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %12 : i32
        }
        cf.br ^bb1(%22 : i32)
      ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
        %24 = memref.get_global @im : memref<1xi32>
        %25 = memref.load %24[%c0] : memref<1xi32>
        %26 = arith.cmpi slt, %23, %25 : i32
        %27 = arith.andi %26, %true : i1
        cf.cond_br %27, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        scf.if %true {
          %29 = arith.muli %13, %25 : i32
          %30 = arith.addi %23, %29 : i32
          %31 = arith.muli %4, %25 : i32
          %32 = memref.load %14[%c0] : memref<1xi32>
          %33 = arith.muli %31, %32 : i32
          %34 = arith.addi %30, %33 : i32
          %35 = arith.index_cast %34 : i32 to index
          %36 = arith.subi %4, %c1_i32 : i32
          %37 = arith.muli %36, %25 : i32
          %38 = arith.muli %37, %32 : i32
          %39 = arith.addi %30, %38 : i32
          %40 = arith.index_cast %39 : i32 to index
          %41 = arith.addi %40, %c0 : index
          %42 = memref.load %arg0[%41] : memref<?xf32>
          %43 = arith.addi %35, %c0 : index
          memref.store %42, %arg2[%43] : memref<?xf32>
        }
        %28 = scf.if %true -> (i32) {
          %29 = arith.addi %23, %c1_i32 : i32
          scf.yield %29 : i32
        } else {
          scf.yield %23 : i32
        }
        cf.br ^bb1(%28 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %23 : i32
      }
      scf.yield %21 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %20 : i32
  } else {
    scf.yield %12 : i32
  }
  %19 = scf.if %true -> (i32) {
    %20 = arith.addi %13, %c1_i32 : i32
    scf.yield %20 : i32
  } else {
    scf.yield %13 : i32
  }
  cf.br ^bb1(%18, %19 : i32, i32)
^bb3:  // pred: ^bb1
  scf.yield %12, %13 : i32, i32
}
 aliasing storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %42, %arg2[%43] : memref<?xf32>
 aliasing storing operation: mlir-asm-printer: Verifying operation: func.func
%21 = scf.execute_region -> i32 {
  %22 = scf.if %true -> (i32) {
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %12 : i32
  }
  cf.br ^bb1(%22 : i32)
^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
  %24 = memref.get_global @im : memref<1xi32>
  %25 = memref.load %24[%c0] : memref<1xi32>
  %26 = arith.cmpi slt, %23, %25 : i32
  %27 = arith.andi %26, %true : i1
  cf.cond_br %27, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  scf.if %true {
    %29 = arith.muli %13, %25 : i32
    %30 = arith.addi %23, %29 : i32
    %31 = arith.muli %4, %25 : i32
    %32 = memref.load %14[%c0] : memref<1xi32>
    %33 = arith.muli %31, %32 : i32
    %34 = arith.addi %30, %33 : i32
    %35 = arith.index_cast %34 : i32 to index
    %36 = arith.subi %4, %c1_i32 : i32
    %37 = arith.muli %36, %25 : i32
    %38 = arith.muli %37, %32 : i32
    %39 = arith.addi %30, %38 : i32
    %40 = arith.index_cast %39 : i32 to index
    %41 = arith.addi %40, %c0 : index
    %42 = memref.load %arg0[%41] : memref<?xf32>
    %43 = arith.addi %35, %c0 : index
    memref.store %42, %arg2[%43] : memref<?xf32>
  }
  %28 = scf.if %true -> (i32) {
    %29 = arith.addi %23, %c1_i32 : i32
    scf.yield %29 : i32
  } else {
    scf.yield %23 : i32
  }
  cf.br ^bb1(%28 : i32)
^bb3:  // pred: ^bb1
  scf.yield %23 : i32
}
 aliasing storing operation: mlir-asm-printer: Verifying operation: func.func
%10:2 = scf.execute_region -> (i32, i32) {
  %11 = scf.if %true -> (i32) {
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %3 : i32
  }
  cf.br ^bb1(%2, %11 : i32, i32)
^bb1(%12: i32, %13: i32):  // 2 preds: ^bb0, ^bb2
  %14 = memref.get_global @jm : memref<1xi32>
  %15 = memref.load %14[%c0] : memref<1xi32>
  %16 = arith.cmpi slt, %13, %15 : i32
  %17 = arith.andi %16, %true : i1
  cf.cond_br %17, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %18 = scf.if %true -> (i32) {
    %20 = scf.if %true -> (i32) {
      %21 = scf.execute_region -> i32 {
        %22 = scf.if %true -> (i32) {
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %12 : i32
        }
        cf.br ^bb1(%22 : i32)
      ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
        %24 = memref.get_global @im : memref<1xi32>
        %25 = memref.load %24[%c0] : memref<1xi32>
        %26 = arith.cmpi slt, %23, %25 : i32
        %27 = arith.andi %26, %true : i1
        cf.cond_br %27, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        scf.if %true {
          %29 = arith.muli %13, %25 : i32
          %30 = arith.addi %23, %29 : i32
          %31 = arith.muli %4, %25 : i32
          %32 = memref.load %14[%c0] : memref<1xi32>
          %33 = arith.muli %31, %32 : i32
          %34 = arith.addi %30, %33 : i32
          %35 = arith.index_cast %34 : i32 to index
          %36 = arith.subi %4, %c1_i32 : i32
          %37 = arith.muli %36, %25 : i32
          %38 = arith.muli %37, %32 : i32
          %39 = arith.addi %30, %38 : i32
          %40 = arith.index_cast %39 : i32 to index
          %41 = arith.addi %40, %c0 : index
          %42 = memref.load %arg0[%41] : memref<?xf32>
          %43 = arith.addi %35, %c0 : index
          memref.store %42, %arg2[%43] : memref<?xf32>
        }
        %28 = scf.if %true -> (i32) {
          %29 = arith.addi %23, %c1_i32 : i32
          scf.yield %29 : i32
        } else {
          scf.yield %23 : i32
        }
        cf.br ^bb1(%28 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %23 : i32
      }
      scf.yield %21 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %20 : i32
  } else {
    scf.yield %12 : i32
  }
  %19 = scf.if %true -> (i32) {
    %20 = arith.addi %13, %c1_i32 : i32
    scf.yield %20 : i32
  } else {
    scf.yield %13 : i32
  }
  cf.br ^bb1(%18, %19 : i32, i32)
^bb3:  // pred: ^bb1
  scf.yield %12, %13 : i32, i32
}
 initial storing block: 0x7fbd9816bd20
 derived storing block: 0x7fbd9816b230
 initial storing block: 0x7fbd9816a540
 derived storing block: 0x7fbd9816a2b0
 initial storing block: 0x7fbd98168a80
 derived storing block: 0x7fbd981687d0
 initial storing block: 0x7fbd9816b230
 derived storing block: 0x7fbd9816a540
 initial storing block: 0x7fbd9816a2b0
 derived storing block: 0x7fbd98169610
 initial storing block: 0x7fbd981687d0
 derived storing block: 0x7fbd98167b50
 initial storing block: 0x7fbd9816a540
 derived storing block: 0x7fbd9816a2b0
 initial storing block: 0x7fbd98169610
 derived storing block: 0x7fbd98168a80
 initial storing block: 0x7fbd98167b50
 derived storing block: 0x7fbd981669f0
 initial storing block: 0x7fbd9816a2b0
 derived storing block: 0x7fbd98169610
 initial storing block: 0x7fbd98168a80
 derived storing block: 0x7fbd981687d0
 initial storing block: 0x7fbd981669f0
 derived storing block: 0x7fbd98166740
 initial storing block: 0x7fbd98169610
 derived storing block: 0x7fbd98168a80
 initial storing block: 0x7fbd981687d0
 derived storing block: 0x7fbd98167b50
 initial storing block: 0x7fbd98166740
 derived storing block: 0x7fbd98164100
 initial storing block: 0x7fbd98168a80
 derived storing block: 0x7fbd981687d0
 initial storing block: 0x7fbd98167b50
 derived storing block: 0x7fbd981669f0
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd981687d0
 derived storing block: 0x7fbd98167b50
 initial storing block: 0x7fbd981669f0
 derived storing block: 0x7fbd98166740
 initial storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd98167b50
 derived storing block: 0x7fbd981669f0
 initial storing block: 0x7fbd98166740
 derived storing block: 0x7fbd98164100
 initial storing block: 0x7fbd981669f0
 derived storing block: 0x7fbd98166740
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd98166740
 derived storing block: 0x7fbd98164100
 initial storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb1(%12: i32, %13: i32):  // 2 preds: ^bb0, ^bb2
  %14 = memref.get_global @jm : memref<1xi32>
  %15 = memref.load %14[%c0] : memref<1xi32>
  %16 = arith.cmpi slt, %13, %15 : i32
  %17 = arith.andi %16, %true : i1
  cf.cond_br %17, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%12: i32, %13: i32):  // 2 preds: ^bb0, ^bb2
  %14 = memref.get_global @jm : memref<1xi32>
  %15 = memref.load %14[%c0] : memref<1xi32>
  %16 = arith.cmpi slt, %13, %15 : i32
  %17 = arith.andi %16, %true : i1
  cf.cond_br %17, ^bb2, ^bb3
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%15 = memref.load %14[%c0] : memref<1xi32>

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %12, %13 : i32, i32

mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %12, %13 : i32, i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %12, %13 : i32, i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %12, %13 : i32, i32


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = scf.if %true -> (i32) {
    %20 = scf.if %true -> (i32) {
      %21 = scf.execute_region -> i32 {
        %22 = scf.if %true -> (i32) {
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %12 : i32
        }
        cf.br ^bb1(%22 : i32)
      ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
        %24 = memref.get_global @im : memref<1xi32>
        %25 = memref.load %24[%c0] : memref<1xi32>
        %26 = arith.cmpi slt, %23, %25 : i32
        %27 = arith.andi %26, %true : i1
        cf.cond_br %27, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        scf.if %true {
          %29 = arith.muli %13, %25 : i32
          %30 = arith.addi %23, %29 : i32
          %31 = arith.muli %4, %25 : i32
          %32 = memref.load %14[%c0] : memref<1xi32>
          %33 = arith.muli %31, %32 : i32
          %34 = arith.addi %30, %33 : i32
          %35 = arith.index_cast %34 : i32 to index
          %36 = arith.subi %4, %c1_i32 : i32
          %37 = arith.muli %36, %25 : i32
          %38 = arith.muli %37, %32 : i32
          %39 = arith.addi %30, %38 : i32
          %40 = arith.index_cast %39 : i32 to index
          %41 = arith.addi %40, %c0 : index
          %42 = memref.load %arg0[%41] : memref<?xf32>
          %43 = arith.addi %35, %c0 : index
          memref.store %42, %arg2[%43] : memref<?xf32>
        }
        %28 = scf.if %true -> (i32) {
          %29 = arith.addi %23, %c1_i32 : i32
          scf.yield %29 : i32
        } else {
          scf.yield %23 : i32
        }
        cf.br ^bb1(%28 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %23 : i32
      }
      scf.yield %21 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %20 : i32
  } else {
    scf.yield %12 : i32
  }
  %19 = scf.if %true -> (i32) {
    %20 = arith.addi %13, %c1_i32 : i32
    scf.yield %20 : i32
  } else {
    scf.yield %13 : i32
  }
  cf.br ^bb1(%18, %19 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = scf.if %true -> (i32) {
    %20 = scf.if %true -> (i32) {
      %21 = scf.execute_region -> i32 {
        %22 = scf.if %true -> (i32) {
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %12 : i32
        }
        cf.br ^bb1(%22 : i32)
      ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
        %24 = memref.get_global @im : memref<1xi32>
        %25 = memref.load %24[%c0] : memref<1xi32>
        %26 = arith.cmpi slt, %23, %25 : i32
        %27 = arith.andi %26, %true : i1
        cf.cond_br %27, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        scf.if %true {
          %29 = arith.muli %13, %25 : i32
          %30 = arith.addi %23, %29 : i32
          %31 = arith.muli %4, %25 : i32
          %32 = memref.load %14[%c0] : memref<1xi32>
          %33 = arith.muli %31, %32 : i32
          %34 = arith.addi %30, %33 : i32
          %35 = arith.index_cast %34 : i32 to index
          %36 = arith.subi %4, %c1_i32 : i32
          %37 = arith.muli %36, %25 : i32
          %38 = arith.muli %37, %32 : i32
          %39 = arith.addi %30, %38 : i32
          %40 = arith.index_cast %39 : i32 to index
          %41 = arith.addi %40, %c0 : index
          %42 = memref.load %arg0[%41] : memref<?xf32>
          %43 = arith.addi %35, %c0 : index
          memref.store %42, %arg2[%43] : memref<?xf32>
        }
        %28 = scf.if %true -> (i32) {
          %29 = arith.addi %23, %c1_i32 : i32
          scf.yield %29 : i32
        } else {
          scf.yield %23 : i32
        }
        cf.br ^bb1(%28 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %23 : i32
      }
      scf.yield %21 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %20 : i32
  } else {
    scf.yield %12 : i32
  }
  %19 = scf.if %true -> (i32) {
    %20 = arith.addi %13, %c1_i32 : i32
    scf.yield %20 : i32
  } else {
    scf.yield %13 : i32
  }
  cf.br ^bb1(%18, %19 : i32, i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = scf.if %true -> (i32) {
    %20 = scf.if %true -> (i32) {
      %21 = scf.execute_region -> i32 {
        %22 = scf.if %true -> (i32) {
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %12 : i32
        }
        cf.br ^bb1(%22 : i32)
      ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
        %24 = memref.get_global @im : memref<1xi32>
        %25 = memref.load %24[%c0] : memref<1xi32>
        %26 = arith.cmpi slt, %23, %25 : i32
        %27 = arith.andi %26, %true : i1
        cf.cond_br %27, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        scf.if %true {
          %29 = arith.muli %13, %25 : i32
          %30 = arith.addi %23, %29 : i32
          %31 = arith.muli %4, %25 : i32
          %32 = memref.load %14[%c0] : memref<1xi32>
          %33 = arith.muli %31, %32 : i32
          %34 = arith.addi %30, %33 : i32
          %35 = arith.index_cast %34 : i32 to index
          %36 = arith.subi %4, %c1_i32 : i32
          %37 = arith.muli %36, %25 : i32
          %38 = arith.muli %37, %32 : i32
          %39 = arith.addi %30, %38 : i32
          %40 = arith.index_cast %39 : i32 to index
          %41 = arith.addi %40, %c0 : index
          %42 = memref.load %arg0[%41] : memref<?xf32>
          %43 = arith.addi %35, %c0 : index
          memref.store %42, %arg2[%43] : memref<?xf32>
        }
        %28 = scf.if %true -> (i32) {
          %29 = arith.addi %23, %c1_i32 : i32
          scf.yield %29 : i32
        } else {
          scf.yield %23 : i32
        }
        cf.br ^bb1(%28 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %23 : i32
      }
      scf.yield %21 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %20 : i32
  } else {
    scf.yield %12 : i32
  }
  %19 = scf.if %true -> (i32) {
    %20 = arith.addi %13, %c1_i32 : i32
    scf.yield %20 : i32
  } else {
    scf.yield %13 : i32
  }
  cf.br ^bb1(%18, %19 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %20 = scf.if %true -> (i32) {
    %21 = scf.execute_region -> i32 {
      %22 = scf.if %true -> (i32) {
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %12 : i32
      }
      cf.br ^bb1(%22 : i32)
    ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
      %24 = memref.get_global @im : memref<1xi32>
      %25 = memref.load %24[%c0] : memref<1xi32>
      %26 = arith.cmpi slt, %23, %25 : i32
      %27 = arith.andi %26, %true : i1
      cf.cond_br %27, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      scf.if %true {
        %29 = arith.muli %13, %25 : i32
        %30 = arith.addi %23, %29 : i32
        %31 = arith.muli %4, %25 : i32
        %32 = memref.load %14[%c0] : memref<1xi32>
        %33 = arith.muli %31, %32 : i32
        %34 = arith.addi %30, %33 : i32
        %35 = arith.index_cast %34 : i32 to index
        %36 = arith.subi %4, %c1_i32 : i32
        %37 = arith.muli %36, %25 : i32
        %38 = arith.muli %37, %32 : i32
        %39 = arith.addi %30, %38 : i32
        %40 = arith.index_cast %39 : i32 to index
        %41 = arith.addi %40, %c0 : index
        %42 = memref.load %arg0[%41] : memref<?xf32>
        %43 = arith.addi %35, %c0 : index
        memref.store %42, %arg2[%43] : memref<?xf32>
      }
      %28 = scf.if %true -> (i32) {
        %29 = arith.addi %23, %c1_i32 : i32
        scf.yield %29 : i32
      } else {
        scf.yield %23 : i32
      }
      cf.br ^bb1(%28 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %23 : i32
    }
    scf.yield %21 : i32
  } else {
    scf.yield %12 : i32
  }
  scf.yield %20 : i32


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = scf.if %true -> (i32) {
    %20 = scf.if %true -> (i32) {
      %21 = scf.execute_region -> i32 {
        %22 = scf.if %true -> (i32) {
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %12 : i32
        }
        cf.br ^bb1(%22 : i32)
      ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
        %24 = memref.get_global @im : memref<1xi32>
        %25 = memref.load %24[%c0] : memref<1xi32>
        %26 = arith.cmpi slt, %23, %25 : i32
        %27 = arith.andi %26, %true : i1
        cf.cond_br %27, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        scf.if %true {
          %29 = arith.muli %13, %25 : i32
          %30 = arith.addi %23, %29 : i32
          %31 = arith.muli %4, %25 : i32
          %32 = memref.load %14[%c0] : memref<1xi32>
          %33 = arith.muli %31, %32 : i32
          %34 = arith.addi %30, %33 : i32
          %35 = arith.index_cast %34 : i32 to index
          %36 = arith.subi %4, %c1_i32 : i32
          %37 = arith.muli %36, %25 : i32
          %38 = arith.muli %37, %32 : i32
          %39 = arith.addi %30, %38 : i32
          %40 = arith.index_cast %39 : i32 to index
          %41 = arith.addi %40, %c0 : index
          %42 = memref.load %arg0[%41] : memref<?xf32>
          %43 = arith.addi %35, %c0 : index
          memref.store %42, %arg2[%43] : memref<?xf32>
        }
        %28 = scf.if %true -> (i32) {
          %29 = arith.addi %23, %c1_i32 : i32
          scf.yield %29 : i32
        } else {
          scf.yield %23 : i32
        }
        cf.br ^bb1(%28 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %23 : i32
      }
      scf.yield %21 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %20 : i32
  } else {
    scf.yield %12 : i32
  }
  %19 = scf.if %true -> (i32) {
    %20 = arith.addi %13, %c1_i32 : i32
    scf.yield %20 : i32
  } else {
    scf.yield %13 : i32
  }
  cf.br ^bb1(%18, %19 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %21 = scf.execute_region -> i32 {
    %22 = scf.if %true -> (i32) {
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %12 : i32
    }
    cf.br ^bb1(%22 : i32)
  ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
    %24 = memref.get_global @im : memref<1xi32>
    %25 = memref.load %24[%c0] : memref<1xi32>
    %26 = arith.cmpi slt, %23, %25 : i32
    %27 = arith.andi %26, %true : i1
    cf.cond_br %27, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    scf.if %true {
      %29 = arith.muli %13, %25 : i32
      %30 = arith.addi %23, %29 : i32
      %31 = arith.muli %4, %25 : i32
      %32 = memref.load %14[%c0] : memref<1xi32>
      %33 = arith.muli %31, %32 : i32
      %34 = arith.addi %30, %33 : i32
      %35 = arith.index_cast %34 : i32 to index
      %36 = arith.subi %4, %c1_i32 : i32
      %37 = arith.muli %36, %25 : i32
      %38 = arith.muli %37, %32 : i32
      %39 = arith.addi %30, %38 : i32
      %40 = arith.index_cast %39 : i32 to index
      %41 = arith.addi %40, %c0 : index
      %42 = memref.load %arg0[%41] : memref<?xf32>
      %43 = arith.addi %35, %c0 : index
      memref.store %42, %arg2[%43] : memref<?xf32>
    }
    %28 = scf.if %true -> (i32) {
      %29 = arith.addi %23, %c1_i32 : i32
      scf.yield %29 : i32
    } else {
      scf.yield %23 : i32
    }
    cf.br ^bb1(%28 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %23 : i32
  }
  scf.yield %21 : i32


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = scf.if %true -> (i32) {
    %20 = scf.if %true -> (i32) {
      %21 = scf.execute_region -> i32 {
        %22 = scf.if %true -> (i32) {
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %12 : i32
        }
        cf.br ^bb1(%22 : i32)
      ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
        %24 = memref.get_global @im : memref<1xi32>
        %25 = memref.load %24[%c0] : memref<1xi32>
        %26 = arith.cmpi slt, %23, %25 : i32
        %27 = arith.andi %26, %true : i1
        cf.cond_br %27, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        scf.if %true {
          %29 = arith.muli %13, %25 : i32
          %30 = arith.addi %23, %29 : i32
          %31 = arith.muli %4, %25 : i32
          %32 = memref.load %14[%c0] : memref<1xi32>
          %33 = arith.muli %31, %32 : i32
          %34 = arith.addi %30, %33 : i32
          %35 = arith.index_cast %34 : i32 to index
          %36 = arith.subi %4, %c1_i32 : i32
          %37 = arith.muli %36, %25 : i32
          %38 = arith.muli %37, %32 : i32
          %39 = arith.addi %30, %38 : i32
          %40 = arith.index_cast %39 : i32 to index
          %41 = arith.addi %40, %c0 : index
          %42 = memref.load %arg0[%41] : memref<?xf32>
          %43 = arith.addi %35, %c0 : index
          memref.store %42, %arg2[%43] : memref<?xf32>
        }
        %28 = scf.if %true -> (i32) {
          %29 = arith.addi %23, %c1_i32 : i32
          scf.yield %29 : i32
        } else {
          scf.yield %23 : i32
        }
        cf.br ^bb1(%28 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %23 : i32
      }
      scf.yield %21 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %20 : i32
  } else {
    scf.yield %12 : i32
  }
  %19 = scf.if %true -> (i32) {
    %20 = arith.addi %13, %c1_i32 : i32
    scf.yield %20 : i32
  } else {
    scf.yield %13 : i32
  }
  cf.br ^bb1(%18, %19 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %22 = scf.if %true -> (i32) {
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %12 : i32
  }
  cf.br ^bb1(%22 : i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = scf.if %true -> (i32) {
    %20 = scf.if %true -> (i32) {
      %21 = scf.execute_region -> i32 {
        %22 = scf.if %true -> (i32) {
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %12 : i32
        }
        cf.br ^bb1(%22 : i32)
      ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
        %24 = memref.get_global @im : memref<1xi32>
        %25 = memref.load %24[%c0] : memref<1xi32>
        %26 = arith.cmpi slt, %23, %25 : i32
        %27 = arith.andi %26, %true : i1
        cf.cond_br %27, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        scf.if %true {
          %29 = arith.muli %13, %25 : i32
          %30 = arith.addi %23, %29 : i32
          %31 = arith.muli %4, %25 : i32
          %32 = memref.load %14[%c0] : memref<1xi32>
          %33 = arith.muli %31, %32 : i32
          %34 = arith.addi %30, %33 : i32
          %35 = arith.index_cast %34 : i32 to index
          %36 = arith.subi %4, %c1_i32 : i32
          %37 = arith.muli %36, %25 : i32
          %38 = arith.muli %37, %32 : i32
          %39 = arith.addi %30, %38 : i32
          %40 = arith.index_cast %39 : i32 to index
          %41 = arith.addi %40, %c0 : index
          %42 = memref.load %arg0[%41] : memref<?xf32>
          %43 = arith.addi %35, %c0 : index
          memref.store %42, %arg2[%43] : memref<?xf32>
        }
        %28 = scf.if %true -> (i32) {
          %29 = arith.addi %23, %c1_i32 : i32
          scf.yield %29 : i32
        } else {
          scf.yield %23 : i32
        }
        cf.br ^bb1(%28 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %23 : i32
      }
      scf.yield %21 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %20 : i32
  } else {
    scf.yield %12 : i32
  }
  %19 = scf.if %true -> (i32) {
    %20 = arith.addi %13, %c1_i32 : i32
    scf.yield %20 : i32
  } else {
    scf.yield %13 : i32
  }
  cf.br ^bb1(%18, %19 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %c0_i32 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %c0_i32 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = scf.if %true -> (i32) {
    %20 = scf.if %true -> (i32) {
      %21 = scf.execute_region -> i32 {
        %22 = scf.if %true -> (i32) {
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %12 : i32
        }
        cf.br ^bb1(%22 : i32)
      ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
        %24 = memref.get_global @im : memref<1xi32>
        %25 = memref.load %24[%c0] : memref<1xi32>
        %26 = arith.cmpi slt, %23, %25 : i32
        %27 = arith.andi %26, %true : i1
        cf.cond_br %27, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        scf.if %true {
          %29 = arith.muli %13, %25 : i32
          %30 = arith.addi %23, %29 : i32
          %31 = arith.muli %4, %25 : i32
          %32 = memref.load %14[%c0] : memref<1xi32>
          %33 = arith.muli %31, %32 : i32
          %34 = arith.addi %30, %33 : i32
          %35 = arith.index_cast %34 : i32 to index
          %36 = arith.subi %4, %c1_i32 : i32
          %37 = arith.muli %36, %25 : i32
          %38 = arith.muli %37, %32 : i32
          %39 = arith.addi %30, %38 : i32
          %40 = arith.index_cast %39 : i32 to index
          %41 = arith.addi %40, %c0 : index
          %42 = memref.load %arg0[%41] : memref<?xf32>
          %43 = arith.addi %35, %c0 : index
          memref.store %42, %arg2[%43] : memref<?xf32>
        }
        %28 = scf.if %true -> (i32) {
          %29 = arith.addi %23, %c1_i32 : i32
          scf.yield %29 : i32
        } else {
          scf.yield %23 : i32
        }
        cf.br ^bb1(%28 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %23 : i32
      }
      scf.yield %21 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %20 : i32
  } else {
    scf.yield %12 : i32
  }
  %19 = scf.if %true -> (i32) {
    %20 = arith.addi %13, %c1_i32 : i32
    scf.yield %20 : i32
  } else {
    scf.yield %13 : i32
  }
  cf.br ^bb1(%18, %19 : i32, i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = scf.if %true -> (i32) {
    %20 = scf.if %true -> (i32) {
      %21 = scf.execute_region -> i32 {
        %22 = scf.if %true -> (i32) {
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %12 : i32
        }
        cf.br ^bb1(%22 : i32)
      ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
        %24 = memref.get_global @im : memref<1xi32>
        %25 = memref.load %24[%c0] : memref<1xi32>
        %26 = arith.cmpi slt, %23, %25 : i32
        %27 = arith.andi %26, %true : i1
        cf.cond_br %27, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        scf.if %true {
          %29 = arith.muli %13, %25 : i32
          %30 = arith.addi %23, %29 : i32
          %31 = arith.muli %4, %25 : i32
          %32 = memref.load %14[%c0] : memref<1xi32>
          %33 = arith.muli %31, %32 : i32
          %34 = arith.addi %30, %33 : i32
          %35 = arith.index_cast %34 : i32 to index
          %36 = arith.subi %4, %c1_i32 : i32
          %37 = arith.muli %36, %25 : i32
          %38 = arith.muli %37, %32 : i32
          %39 = arith.addi %30, %38 : i32
          %40 = arith.index_cast %39 : i32 to index
          %41 = arith.addi %40, %c0 : index
          %42 = memref.load %arg0[%41] : memref<?xf32>
          %43 = arith.addi %35, %c0 : index
          memref.store %42, %arg2[%43] : memref<?xf32>
        }
        %28 = scf.if %true -> (i32) {
          %29 = arith.addi %23, %c1_i32 : i32
          scf.yield %29 : i32
        } else {
          scf.yield %23 : i32
        }
        cf.br ^bb1(%28 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %23 : i32
      }
      scf.yield %21 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %20 : i32
  } else {
    scf.yield %12 : i32
  }
  %19 = scf.if %true -> (i32) {
    %20 = arith.addi %13, %c1_i32 : i32
    scf.yield %20 : i32
  } else {
    scf.yield %13 : i32
  }
  cf.br ^bb1(%18, %19 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %12 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %12 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = scf.if %true -> (i32) {
    %20 = scf.if %true -> (i32) {
      %21 = scf.execute_region -> i32 {
        %22 = scf.if %true -> (i32) {
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %12 : i32
        }
        cf.br ^bb1(%22 : i32)
      ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
        %24 = memref.get_global @im : memref<1xi32>
        %25 = memref.load %24[%c0] : memref<1xi32>
        %26 = arith.cmpi slt, %23, %25 : i32
        %27 = arith.andi %26, %true : i1
        cf.cond_br %27, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        scf.if %true {
          %29 = arith.muli %13, %25 : i32
          %30 = arith.addi %23, %29 : i32
          %31 = arith.muli %4, %25 : i32
          %32 = memref.load %14[%c0] : memref<1xi32>
          %33 = arith.muli %31, %32 : i32
          %34 = arith.addi %30, %33 : i32
          %35 = arith.index_cast %34 : i32 to index
          %36 = arith.subi %4, %c1_i32 : i32
          %37 = arith.muli %36, %25 : i32
          %38 = arith.muli %37, %32 : i32
          %39 = arith.addi %30, %38 : i32
          %40 = arith.index_cast %39 : i32 to index
          %41 = arith.addi %40, %c0 : index
          %42 = memref.load %arg0[%41] : memref<?xf32>
          %43 = arith.addi %35, %c0 : index
          memref.store %42, %arg2[%43] : memref<?xf32>
        }
        %28 = scf.if %true -> (i32) {
          %29 = arith.addi %23, %c1_i32 : i32
          scf.yield %29 : i32
        } else {
          scf.yield %23 : i32
        }
        cf.br ^bb1(%28 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %23 : i32
      }
      scf.yield %21 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %20 : i32
  } else {
    scf.yield %12 : i32
  }
  %19 = scf.if %true -> (i32) {
    %20 = arith.addi %13, %c1_i32 : i32
    scf.yield %20 : i32
  } else {
    scf.yield %13 : i32
  }
  cf.br ^bb1(%18, %19 : i32, i32)

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %22 = scf.if %true -> (i32) {
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %12 : i32
  }
  cf.br ^bb1(%22 : i32)
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = scf.if %true -> (i32) {
    %20 = scf.if %true -> (i32) {
      %21 = scf.execute_region -> i32 {
        %22 = scf.if %true -> (i32) {
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %12 : i32
        }
        cf.br ^bb1(%22 : i32)
      ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
        %24 = memref.get_global @im : memref<1xi32>
        %25 = memref.load %24[%c0] : memref<1xi32>
        %26 = arith.cmpi slt, %23, %25 : i32
        %27 = arith.andi %26, %true : i1
        cf.cond_br %27, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        scf.if %true {
          %29 = arith.muli %13, %25 : i32
          %30 = arith.addi %23, %29 : i32
          %31 = arith.muli %4, %25 : i32
          %32 = memref.load %14[%c0] : memref<1xi32>
          %33 = arith.muli %31, %32 : i32
          %34 = arith.addi %30, %33 : i32
          %35 = arith.index_cast %34 : i32 to index
          %36 = arith.subi %4, %c1_i32 : i32
          %37 = arith.muli %36, %25 : i32
          %38 = arith.muli %37, %32 : i32
          %39 = arith.addi %30, %38 : i32
          %40 = arith.index_cast %39 : i32 to index
          %41 = arith.addi %40, %c0 : index
          %42 = memref.load %arg0[%41] : memref<?xf32>
          %43 = arith.addi %35, %c0 : index
          memref.store %42, %arg2[%43] : memref<?xf32>
        }
        %28 = scf.if %true -> (i32) {
          %29 = arith.addi %23, %c1_i32 : i32
          scf.yield %29 : i32
        } else {
          scf.yield %23 : i32
        }
        cf.br ^bb1(%28 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %23 : i32
      }
      scf.yield %21 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %20 : i32
  } else {
    scf.yield %12 : i32
  }
  %19 = scf.if %true -> (i32) {
    %20 = arith.addi %13, %c1_i32 : i32
    scf.yield %20 : i32
  } else {
    scf.yield %13 : i32
  }
  cf.br ^bb1(%18, %19 : i32, i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
  %24 = memref.get_global @im : memref<1xi32>
  %25 = memref.load %24[%c0] : memref<1xi32>
  %26 = arith.cmpi slt, %23, %25 : i32
  %27 = arith.andi %26, %true : i1
  cf.cond_br %27, ^bb2, ^bb3

mlir-asm-printer: Verifying operation: builtin.module
^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
  %24 = memref.get_global @im : memref<1xi32>
  %25 = memref.load %24[%c0] : memref<1xi32>
  %26 = arith.cmpi slt, %23, %25 : i32
  %27 = arith.andi %26, %true : i1
  cf.cond_br %27, ^bb2, ^bb3

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
  %24 = memref.get_global @im : memref<1xi32>
  %25 = memref.load %24[%c0] : memref<1xi32>
  %26 = arith.cmpi slt, %23, %25 : i32
  %27 = arith.andi %26, %true : i1
  cf.cond_br %27, ^bb2, ^bb3
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
  %24 = memref.get_global @im : memref<1xi32>
  %25 = memref.load %24[%c0] : memref<1xi32>
  %26 = arith.cmpi slt, %23, %25 : i32
  %27 = arith.andi %26, %true : i1
  cf.cond_br %27, ^bb2, ^bb3


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  scf.if %true {
    %29 = arith.muli %13, %25 : i32
    %30 = arith.addi %23, %29 : i32
    %31 = arith.muli %4, %25 : i32
    %32 = memref.load %14[%c0] : memref<1xi32>
    %33 = arith.muli %31, %32 : i32
    %34 = arith.addi %30, %33 : i32
    %35 = arith.index_cast %34 : i32 to index
    %36 = arith.subi %4, %c1_i32 : i32
    %37 = arith.muli %36, %25 : i32
    %38 = arith.muli %37, %32 : i32
    %39 = arith.addi %30, %38 : i32
    %40 = arith.index_cast %39 : i32 to index
    %41 = arith.addi %40, %c0 : index
    %42 = memref.load %arg0[%41] : memref<?xf32>
    %43 = arith.addi %35, %c0 : index
    memref.store %42, %arg2[%43] : memref<?xf32>
  }
  %28 = scf.if %true -> (i32) {
    %29 = arith.addi %23, %c1_i32 : i32
    scf.yield %29 : i32
  } else {
    scf.yield %23 : i32
  }
  cf.br ^bb1(%28 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  scf.if %true {
    %29 = arith.muli %13, %25 : i32
    %30 = arith.addi %23, %29 : i32
    %31 = arith.muli %4, %25 : i32
    %32 = memref.load %14[%c0] : memref<1xi32>
    %33 = arith.muli %31, %32 : i32
    %34 = arith.addi %30, %33 : i32
    %35 = arith.index_cast %34 : i32 to index
    %36 = arith.subi %4, %c1_i32 : i32
    %37 = arith.muli %36, %25 : i32
    %38 = arith.muli %37, %32 : i32
    %39 = arith.addi %30, %38 : i32
    %40 = arith.index_cast %39 : i32 to index
    %41 = arith.addi %40, %c0 : index
    %42 = memref.load %arg0[%41] : memref<?xf32>
    %43 = arith.addi %35, %c0 : index
    memref.store %42, %arg2[%43] : memref<?xf32>
  }
  %28 = scf.if %true -> (i32) {
    %29 = arith.addi %23, %c1_i32 : i32
    scf.yield %29 : i32
  } else {
    scf.yield %23 : i32
  }
  cf.br ^bb1(%28 : i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  scf.if %true {
    %29 = arith.muli %13, %25 : i32
    %30 = arith.addi %23, %29 : i32
    %31 = arith.muli %4, %25 : i32
    %32 = memref.load %14[%c0] : memref<1xi32>
    %33 = arith.muli %31, %32 : i32
    %34 = arith.addi %30, %33 : i32
    %35 = arith.index_cast %34 : i32 to index
    %36 = arith.subi %4, %c1_i32 : i32
    %37 = arith.muli %36, %25 : i32
    %38 = arith.muli %37, %32 : i32
    %39 = arith.addi %30, %38 : i32
    %40 = arith.index_cast %39 : i32 to index
    %41 = arith.addi %40, %c0 : index
    %42 = memref.load %arg0[%41] : memref<?xf32>
    %43 = arith.addi %35, %c0 : index
    memref.store %42, %arg2[%43] : memref<?xf32>
  }
  %28 = scf.if %true -> (i32) {
    %29 = arith.addi %23, %c1_i32 : i32
    scf.yield %29 : i32
  } else {
    scf.yield %23 : i32
  }
  cf.br ^bb1(%28 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %29 = arith.muli %13, %25 : i32
  %30 = arith.addi %23, %29 : i32
  %31 = arith.muli %4, %25 : i32
  %32 = memref.load %14[%c0] : memref<1xi32>
  %33 = arith.muli %31, %32 : i32
  %34 = arith.addi %30, %33 : i32
  %35 = arith.index_cast %34 : i32 to index
  %36 = arith.subi %4, %c1_i32 : i32
  %37 = arith.muli %36, %25 : i32
  %38 = arith.muli %37, %32 : i32
  %39 = arith.addi %30, %38 : i32
  %40 = arith.index_cast %39 : i32 to index
  %41 = arith.addi %40, %c0 : index
  %42 = memref.load %arg0[%41] : memref<?xf32>
  %43 = arith.addi %35, %c0 : index
  memref.store %42, %arg2[%43] : memref<?xf32>
  scf.yield

erased store due to: mlir-asm-printer: Verifying operation: func.func
memref.store %42, %arg2[%43] : memref<?xf32>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %29 = arith.muli %13, %25 : i32
  %30 = arith.addi %23, %29 : i32
  %31 = arith.muli %4, %25 : i32
  %32 = memref.load %14[%c0] : memref<1xi32>
  %33 = arith.muli %31, %32 : i32
  %34 = arith.addi %30, %33 : i32
  %35 = arith.index_cast %34 : i32 to index
  %36 = arith.subi %4, %c1_i32 : i32
  %37 = arith.muli %36, %25 : i32
  %38 = arith.muli %37, %32 : i32
  %39 = arith.addi %30, %38 : i32
  %40 = arith.index_cast %39 : i32 to index
  %41 = arith.addi %40, %c0 : index
  %42 = memref.load %arg0[%41] : memref<?xf32>
  %43 = arith.addi %35, %c0 : index
  memref.store %42, %arg2[%43] : memref<?xf32>
  scf.yield
 with val:<overwritten>

starting block: lastVal=ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %true {
  %29 = arith.muli %13, %25 : i32
  %30 = arith.addi %23, %29 : i32
  %31 = arith.muli %4, %25 : i32
  %32 = memref.load %14[%c0] : memref<1xi32>
  %33 = arith.muli %31, %32 : i32
  %34 = arith.addi %30, %33 : i32
  %35 = arith.index_cast %34 : i32 to index
  %36 = arith.subi %4, %c1_i32 : i32
  %37 = arith.muli %36, %25 : i32
  %38 = arith.muli %37, %32 : i32
  %39 = arith.addi %30, %38 : i32
  %40 = arith.index_cast %39 : i32 to index
  %41 = arith.addi %40, %c0 : index
  %42 = memref.load %arg0[%41] : memref<?xf32>
  %43 = arith.addi %35, %c0 : index
  memref.store %42, %arg2[%43] : memref<?xf32>
}
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %29 = arith.addi %23, %c1_i32 : i32
  scf.yield %29 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %29 = arith.addi %23, %c1_i32 : i32
  scf.yield %29 : i32
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %true {
  %29 = arith.muli %13, %25 : i32
  %30 = arith.addi %23, %29 : i32
  %31 = arith.muli %4, %25 : i32
  %32 = memref.load %14[%c0] : memref<1xi32>
  %33 = arith.muli %31, %32 : i32
  %34 = arith.addi %30, %33 : i32
  %35 = arith.index_cast %34 : i32 to index
  %36 = arith.subi %4, %c1_i32 : i32
  %37 = arith.muli %36, %25 : i32
  %38 = arith.muli %37, %32 : i32
  %39 = arith.addi %30, %38 : i32
  %40 = arith.index_cast %39 : i32 to index
  %41 = arith.addi %40, %c0 : index
  %42 = memref.load %arg0[%41] : memref<?xf32>
  %43 = arith.addi %35, %c0 : index
  memref.store %42, %arg2[%43] : memref<?xf32>
}

starting block: lastVal=ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %true {
  %29 = arith.muli %13, %25 : i32
  %30 = arith.addi %23, %29 : i32
  %31 = arith.muli %4, %25 : i32
  %32 = memref.load %14[%c0] : memref<1xi32>
  %33 = arith.muli %31, %32 : i32
  %34 = arith.addi %30, %33 : i32
  %35 = arith.index_cast %34 : i32 to index
  %36 = arith.subi %4, %c1_i32 : i32
  %37 = arith.muli %36, %25 : i32
  %38 = arith.muli %37, %32 : i32
  %39 = arith.addi %30, %38 : i32
  %40 = arith.index_cast %39 : i32 to index
  %41 = arith.addi %40, %c0 : index
  %42 = memref.load %arg0[%41] : memref<?xf32>
  %43 = arith.addi %35, %c0 : index
  memref.store %42, %arg2[%43] : memref<?xf32>
}
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %23 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %23 : i32
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %true {
  %29 = arith.muli %13, %25 : i32
  %30 = arith.addi %23, %29 : i32
  %31 = arith.muli %4, %25 : i32
  %32 = memref.load %14[%c0] : memref<1xi32>
  %33 = arith.muli %31, %32 : i32
  %34 = arith.addi %30, %33 : i32
  %35 = arith.index_cast %34 : i32 to index
  %36 = arith.subi %4, %c1_i32 : i32
  %37 = arith.muli %36, %25 : i32
  %38 = arith.muli %37, %32 : i32
  %39 = arith.addi %30, %38 : i32
  %40 = arith.index_cast %39 : i32 to index
  %41 = arith.addi %40, %c0 : index
  %42 = memref.load %arg0[%41] : memref<?xf32>
  %43 = arith.addi %35, %c0 : index
  memref.store %42, %arg2[%43] : memref<?xf32>
}
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  scf.if %true {
    %29 = arith.muli %13, %25 : i32
    %30 = arith.addi %23, %29 : i32
    %31 = arith.muli %4, %25 : i32
    %32 = memref.load %14[%c0] : memref<1xi32>
    %33 = arith.muli %31, %32 : i32
    %34 = arith.addi %30, %33 : i32
    %35 = arith.index_cast %34 : i32 to index
    %36 = arith.subi %4, %c1_i32 : i32
    %37 = arith.muli %36, %25 : i32
    %38 = arith.muli %37, %32 : i32
    %39 = arith.addi %30, %38 : i32
    %40 = arith.index_cast %39 : i32 to index
    %41 = arith.addi %40, %c0 : index
    %42 = memref.load %arg0[%41] : memref<?xf32>
    %43 = arith.addi %35, %c0 : index
    memref.store %42, %arg2[%43] : memref<?xf32>
  }
  %28 = scf.if %true -> (i32) {
    %29 = arith.addi %23, %c1_i32 : i32
    scf.yield %29 : i32
  } else {
    scf.yield %23 : i32
  }
  cf.br ^bb1(%28 : i32)
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
scf.if %true {
  %29 = arith.muli %13, %25 : i32
  %30 = arith.addi %23, %29 : i32
  %31 = arith.muli %4, %25 : i32
  %32 = memref.load %14[%c0] : memref<1xi32>
  %33 = arith.muli %31, %32 : i32
  %34 = arith.addi %30, %33 : i32
  %35 = arith.index_cast %34 : i32 to index
  %36 = arith.subi %4, %c1_i32 : i32
  %37 = arith.muli %36, %25 : i32
  %38 = arith.muli %37, %32 : i32
  %39 = arith.addi %30, %38 : i32
  %40 = arith.index_cast %39 : i32 to index
  %41 = arith.addi %40, %c0 : index
  %42 = memref.load %arg0[%41] : memref<?xf32>
  %43 = arith.addi %35, %c0 : index
  memref.store %42, %arg2[%43] : memref<?xf32>
}

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %23 : i32

mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %23 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %23 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb3:  // pred: ^bb1
  scf.yield %23 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %21 = scf.execute_region -> i32 {
    %22 = scf.if %true -> (i32) {
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %12 : i32
    }
    cf.br ^bb1(%22 : i32)
  ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
    %24 = memref.get_global @im : memref<1xi32>
    %25 = memref.load %24[%c0] : memref<1xi32>
    %26 = arith.cmpi slt, %23, %25 : i32
    %27 = arith.andi %26, %true : i1
    cf.cond_br %27, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    scf.if %true {
      %29 = arith.muli %13, %25 : i32
      %30 = arith.addi %23, %29 : i32
      %31 = arith.muli %4, %25 : i32
      %32 = memref.load %14[%c0] : memref<1xi32>
      %33 = arith.muli %31, %32 : i32
      %34 = arith.addi %30, %33 : i32
      %35 = arith.index_cast %34 : i32 to index
      %36 = arith.subi %4, %c1_i32 : i32
      %37 = arith.muli %36, %25 : i32
      %38 = arith.muli %37, %32 : i32
      %39 = arith.addi %30, %38 : i32
      %40 = arith.index_cast %39 : i32 to index
      %41 = arith.addi %40, %c0 : index
      %42 = memref.load %arg0[%41] : memref<?xf32>
      %43 = arith.addi %35, %c0 : index
      memref.store %42, %arg2[%43] : memref<?xf32>
    }
    %28 = scf.if %true -> (i32) {
      %29 = arith.addi %23, %c1_i32 : i32
      scf.yield %29 : i32
    } else {
      scf.yield %23 : i32
    }
    cf.br ^bb1(%28 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %23 : i32
  }
  scf.yield %21 : i32
 with val:exOp:mlir-asm-printer: Verifying operation: func.func
%21 = scf.execute_region -> i32 {
  %22 = scf.if %true -> (i32) {
    scf.yield %c0_i32 : i32
  } else {
    scf.yield %12 : i32
  }
  cf.br ^bb1(%22 : i32)
^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
  %24 = memref.get_global @im : memref<1xi32>
  %25 = memref.load %24[%c0] : memref<1xi32>
  %26 = arith.cmpi slt, %23, %25 : i32
  %27 = arith.andi %26, %true : i1
  cf.cond_br %27, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  scf.if %true {
    %29 = arith.muli %13, %25 : i32
    %30 = arith.addi %23, %29 : i32
    %31 = arith.muli %4, %25 : i32
    %32 = memref.load %14[%c0] : memref<1xi32>
    %33 = arith.muli %31, %32 : i32
    %34 = arith.addi %30, %33 : i32
    %35 = arith.index_cast %34 : i32 to index
    %36 = arith.subi %4, %c1_i32 : i32
    %37 = arith.muli %36, %25 : i32
    %38 = arith.muli %37, %32 : i32
    %39 = arith.addi %30, %38 : i32
    %40 = arith.index_cast %39 : i32 to index
    %41 = arith.addi %40, %c0 : index
    %42 = memref.load %arg0[%41] : memref<?xf32>
    %43 = arith.addi %35, %c0 : index
    memref.store %42, %arg2[%43] : memref<?xf32>
  }
  %28 = scf.if %true -> (i32) {
    %29 = arith.addi %23, %c1_i32 : i32
    scf.yield %29 : i32
  } else {
    scf.yield %23 : i32
  }
  cf.br ^bb1(%28 : i32)
^bb3:  // pred: ^bb1
  scf.yield %23 : i32
}

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = scf.if %true -> (i32) {
    %20 = scf.if %true -> (i32) {
      %21 = scf.execute_region -> i32 {
        %22 = scf.if %true -> (i32) {
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %12 : i32
        }
        cf.br ^bb1(%22 : i32)
      ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
        %24 = memref.get_global @im : memref<1xi32>
        %25 = memref.load %24[%c0] : memref<1xi32>
        %26 = arith.cmpi slt, %23, %25 : i32
        %27 = arith.andi %26, %true : i1
        cf.cond_br %27, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        scf.if %true {
          %29 = arith.muli %13, %25 : i32
          %30 = arith.addi %23, %29 : i32
          %31 = arith.muli %4, %25 : i32
          %32 = memref.load %14[%c0] : memref<1xi32>
          %33 = arith.muli %31, %32 : i32
          %34 = arith.addi %30, %33 : i32
          %35 = arith.index_cast %34 : i32 to index
          %36 = arith.subi %4, %c1_i32 : i32
          %37 = arith.muli %36, %25 : i32
          %38 = arith.muli %37, %32 : i32
          %39 = arith.addi %30, %38 : i32
          %40 = arith.index_cast %39 : i32 to index
          %41 = arith.addi %40, %c0 : index
          %42 = memref.load %arg0[%41] : memref<?xf32>
          %43 = arith.addi %35, %c0 : index
          memref.store %42, %arg2[%43] : memref<?xf32>
        }
        %28 = scf.if %true -> (i32) {
          %29 = arith.addi %23, %c1_i32 : i32
          scf.yield %29 : i32
        } else {
          scf.yield %23 : i32
        }
        cf.br ^bb1(%28 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %23 : i32
      }
      scf.yield %21 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %20 : i32
  } else {
    scf.yield %12 : i32
  }
  %19 = scf.if %true -> (i32) {
    %20 = arith.addi %13, %c1_i32 : i32
    scf.yield %20 : i32
  } else {
    scf.yield %13 : i32
  }
  cf.br ^bb1(%18, %19 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %12 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %12 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = scf.if %true -> (i32) {
    %20 = scf.if %true -> (i32) {
      %21 = scf.execute_region -> i32 {
        %22 = scf.if %true -> (i32) {
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %12 : i32
        }
        cf.br ^bb1(%22 : i32)
      ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
        %24 = memref.get_global @im : memref<1xi32>
        %25 = memref.load %24[%c0] : memref<1xi32>
        %26 = arith.cmpi slt, %23, %25 : i32
        %27 = arith.andi %26, %true : i1
        cf.cond_br %27, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        scf.if %true {
          %29 = arith.muli %13, %25 : i32
          %30 = arith.addi %23, %29 : i32
          %31 = arith.muli %4, %25 : i32
          %32 = memref.load %14[%c0] : memref<1xi32>
          %33 = arith.muli %31, %32 : i32
          %34 = arith.addi %30, %33 : i32
          %35 = arith.index_cast %34 : i32 to index
          %36 = arith.subi %4, %c1_i32 : i32
          %37 = arith.muli %36, %25 : i32
          %38 = arith.muli %37, %32 : i32
          %39 = arith.addi %30, %38 : i32
          %40 = arith.index_cast %39 : i32 to index
          %41 = arith.addi %40, %c0 : index
          %42 = memref.load %arg0[%41] : memref<?xf32>
          %43 = arith.addi %35, %c0 : index
          memref.store %42, %arg2[%43] : memref<?xf32>
        }
        %28 = scf.if %true -> (i32) {
          %29 = arith.addi %23, %c1_i32 : i32
          scf.yield %29 : i32
        } else {
          scf.yield %23 : i32
        }
        cf.br ^bb1(%28 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %23 : i32
      }
      scf.yield %21 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %20 : i32
  } else {
    scf.yield %12 : i32
  }
  %19 = scf.if %true -> (i32) {
    %20 = arith.addi %13, %c1_i32 : i32
    scf.yield %20 : i32
  } else {
    scf.yield %13 : i32
  }
  cf.br ^bb1(%18, %19 : i32, i32)

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %20 = scf.if %true -> (i32) {
    %21 = scf.execute_region -> i32 {
      %22 = scf.if %true -> (i32) {
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %12 : i32
      }
      cf.br ^bb1(%22 : i32)
    ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
      %24 = memref.get_global @im : memref<1xi32>
      %25 = memref.load %24[%c0] : memref<1xi32>
      %26 = arith.cmpi slt, %23, %25 : i32
      %27 = arith.andi %26, %true : i1
      cf.cond_br %27, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      scf.if %true {
        %29 = arith.muli %13, %25 : i32
        %30 = arith.addi %23, %29 : i32
        %31 = arith.muli %4, %25 : i32
        %32 = memref.load %14[%c0] : memref<1xi32>
        %33 = arith.muli %31, %32 : i32
        %34 = arith.addi %30, %33 : i32
        %35 = arith.index_cast %34 : i32 to index
        %36 = arith.subi %4, %c1_i32 : i32
        %37 = arith.muli %36, %25 : i32
        %38 = arith.muli %37, %32 : i32
        %39 = arith.addi %30, %38 : i32
        %40 = arith.index_cast %39 : i32 to index
        %41 = arith.addi %40, %c0 : index
        %42 = memref.load %arg0[%41] : memref<?xf32>
        %43 = arith.addi %35, %c0 : index
        memref.store %42, %arg2[%43] : memref<?xf32>
      }
      %28 = scf.if %true -> (i32) {
        %29 = arith.addi %23, %c1_i32 : i32
        scf.yield %29 : i32
      } else {
        scf.yield %23 : i32
      }
      cf.br ^bb1(%28 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %23 : i32
    }
    scf.yield %21 : i32
  } else {
    scf.yield %12 : i32
  }
  scf.yield %20 : i32
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
%20 = scf.if %true -> (i32) {
  %21 = scf.execute_region -> i32 {
    %22 = scf.if %true -> (i32) {
      scf.yield %c0_i32 : i32
    } else {
      scf.yield %12 : i32
    }
    cf.br ^bb1(%22 : i32)
  ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
    %24 = memref.get_global @im : memref<1xi32>
    %25 = memref.load %24[%c0] : memref<1xi32>
    %26 = arith.cmpi slt, %23, %25 : i32
    %27 = arith.andi %26, %true : i1
    cf.cond_br %27, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    scf.if %true {
      %29 = arith.muli %13, %25 : i32
      %30 = arith.addi %23, %29 : i32
      %31 = arith.muli %4, %25 : i32
      %32 = memref.load %14[%c0] : memref<1xi32>
      %33 = arith.muli %31, %32 : i32
      %34 = arith.addi %30, %33 : i32
      %35 = arith.index_cast %34 : i32 to index
      %36 = arith.subi %4, %c1_i32 : i32
      %37 = arith.muli %36, %25 : i32
      %38 = arith.muli %37, %32 : i32
      %39 = arith.addi %30, %38 : i32
      %40 = arith.index_cast %39 : i32 to index
      %41 = arith.addi %40, %c0 : index
      %42 = memref.load %arg0[%41] : memref<?xf32>
      %43 = arith.addi %35, %c0 : index
      memref.store %42, %arg2[%43] : memref<?xf32>
    }
    %28 = scf.if %true -> (i32) {
      %29 = arith.addi %23, %c1_i32 : i32
      scf.yield %29 : i32
    } else {
      scf.yield %23 : i32
    }
    cf.br ^bb1(%28 : i32)
  ^bb3:  // pred: ^bb1
    scf.yield %23 : i32
  }
  scf.yield %21 : i32
} else {
  scf.yield %12 : i32
}

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = scf.if %true -> (i32) {
    %20 = scf.if %true -> (i32) {
      %21 = scf.execute_region -> i32 {
        %22 = scf.if %true -> (i32) {
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %12 : i32
        }
        cf.br ^bb1(%22 : i32)
      ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
        %24 = memref.get_global @im : memref<1xi32>
        %25 = memref.load %24[%c0] : memref<1xi32>
        %26 = arith.cmpi slt, %23, %25 : i32
        %27 = arith.andi %26, %true : i1
        cf.cond_br %27, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        scf.if %true {
          %29 = arith.muli %13, %25 : i32
          %30 = arith.addi %23, %29 : i32
          %31 = arith.muli %4, %25 : i32
          %32 = memref.load %14[%c0] : memref<1xi32>
          %33 = arith.muli %31, %32 : i32
          %34 = arith.addi %30, %33 : i32
          %35 = arith.index_cast %34 : i32 to index
          %36 = arith.subi %4, %c1_i32 : i32
          %37 = arith.muli %36, %25 : i32
          %38 = arith.muli %37, %32 : i32
          %39 = arith.addi %30, %38 : i32
          %40 = arith.index_cast %39 : i32 to index
          %41 = arith.addi %40, %c0 : index
          %42 = memref.load %arg0[%41] : memref<?xf32>
          %43 = arith.addi %35, %c0 : index
          memref.store %42, %arg2[%43] : memref<?xf32>
        }
        %28 = scf.if %true -> (i32) {
          %29 = arith.addi %23, %c1_i32 : i32
          scf.yield %29 : i32
        } else {
          scf.yield %23 : i32
        }
        cf.br ^bb1(%28 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %23 : i32
      }
      scf.yield %21 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %20 : i32
  } else {
    scf.yield %12 : i32
  }
  %19 = scf.if %true -> (i32) {
    %20 = arith.addi %13, %c1_i32 : i32
    scf.yield %20 : i32
  } else {
    scf.yield %13 : i32
  }
  cf.br ^bb1(%18, %19 : i32, i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %12 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %12 : i32
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = scf.if %true -> (i32) {
    %20 = scf.if %true -> (i32) {
      %21 = scf.execute_region -> i32 {
        %22 = scf.if %true -> (i32) {
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %12 : i32
        }
        cf.br ^bb1(%22 : i32)
      ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
        %24 = memref.get_global @im : memref<1xi32>
        %25 = memref.load %24[%c0] : memref<1xi32>
        %26 = arith.cmpi slt, %23, %25 : i32
        %27 = arith.andi %26, %true : i1
        cf.cond_br %27, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        scf.if %true {
          %29 = arith.muli %13, %25 : i32
          %30 = arith.addi %23, %29 : i32
          %31 = arith.muli %4, %25 : i32
          %32 = memref.load %14[%c0] : memref<1xi32>
          %33 = arith.muli %31, %32 : i32
          %34 = arith.addi %30, %33 : i32
          %35 = arith.index_cast %34 : i32 to index
          %36 = arith.subi %4, %c1_i32 : i32
          %37 = arith.muli %36, %25 : i32
          %38 = arith.muli %37, %32 : i32
          %39 = arith.addi %30, %38 : i32
          %40 = arith.index_cast %39 : i32 to index
          %41 = arith.addi %40, %c0 : index
          %42 = memref.load %arg0[%41] : memref<?xf32>
          %43 = arith.addi %35, %c0 : index
          memref.store %42, %arg2[%43] : memref<?xf32>
        }
        %28 = scf.if %true -> (i32) {
          %29 = arith.addi %23, %c1_i32 : i32
          scf.yield %29 : i32
        } else {
          scf.yield %23 : i32
        }
        cf.br ^bb1(%28 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %23 : i32
      }
      scf.yield %21 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %20 : i32
  } else {
    scf.yield %12 : i32
  }
  %19 = scf.if %true -> (i32) {
    %20 = arith.addi %13, %c1_i32 : i32
    scf.yield %20 : i32
  } else {
    scf.yield %13 : i32
  }
  cf.br ^bb1(%18, %19 : i32, i32)


starting block: lastVal=ifOp:mlir-asm-printer: Verifying operation: func.func
%18 = scf.if %true -> (i32) {
  %20 = scf.if %true -> (i32) {
    %21 = scf.execute_region -> i32 {
      %22 = scf.if %true -> (i32) {
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %12 : i32
      }
      cf.br ^bb1(%22 : i32)
    ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
      %24 = memref.get_global @im : memref<1xi32>
      %25 = memref.load %24[%c0] : memref<1xi32>
      %26 = arith.cmpi slt, %23, %25 : i32
      %27 = arith.andi %26, %true : i1
      cf.cond_br %27, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      scf.if %true {
        %29 = arith.muli %13, %25 : i32
        %30 = arith.addi %23, %29 : i32
        %31 = arith.muli %4, %25 : i32
        %32 = memref.load %14[%c0] : memref<1xi32>
        %33 = arith.muli %31, %32 : i32
        %34 = arith.addi %30, %33 : i32
        %35 = arith.index_cast %34 : i32 to index
        %36 = arith.subi %4, %c1_i32 : i32
        %37 = arith.muli %36, %25 : i32
        %38 = arith.muli %37, %32 : i32
        %39 = arith.addi %30, %38 : i32
        %40 = arith.index_cast %39 : i32 to index
        %41 = arith.addi %40, %c0 : index
        %42 = memref.load %arg0[%41] : memref<?xf32>
        %43 = arith.addi %35, %c0 : index
        memref.store %42, %arg2[%43] : memref<?xf32>
      }
      %28 = scf.if %true -> (i32) {
        %29 = arith.addi %23, %c1_i32 : i32
        scf.yield %29 : i32
      } else {
        scf.yield %23 : i32
      }
      cf.br ^bb1(%28 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %23 : i32
    }
    scf.yield %21 : i32
  } else {
    scf.yield %12 : i32
  }
  scf.yield %20 : i32
} else {
  scf.yield %12 : i32
}
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %20 = arith.addi %13, %c1_i32 : i32
  scf.yield %20 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  %20 = arith.addi %13, %c1_i32 : i32
  scf.yield %20 : i32
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
%18 = scf.if %true -> (i32) {
  %20 = scf.if %true -> (i32) {
    %21 = scf.execute_region -> i32 {
      %22 = scf.if %true -> (i32) {
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %12 : i32
      }
      cf.br ^bb1(%22 : i32)
    ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
      %24 = memref.get_global @im : memref<1xi32>
      %25 = memref.load %24[%c0] : memref<1xi32>
      %26 = arith.cmpi slt, %23, %25 : i32
      %27 = arith.andi %26, %true : i1
      cf.cond_br %27, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      scf.if %true {
        %29 = arith.muli %13, %25 : i32
        %30 = arith.addi %23, %29 : i32
        %31 = arith.muli %4, %25 : i32
        %32 = memref.load %14[%c0] : memref<1xi32>
        %33 = arith.muli %31, %32 : i32
        %34 = arith.addi %30, %33 : i32
        %35 = arith.index_cast %34 : i32 to index
        %36 = arith.subi %4, %c1_i32 : i32
        %37 = arith.muli %36, %25 : i32
        %38 = arith.muli %37, %32 : i32
        %39 = arith.addi %30, %38 : i32
        %40 = arith.index_cast %39 : i32 to index
        %41 = arith.addi %40, %c0 : index
        %42 = memref.load %arg0[%41] : memref<?xf32>
        %43 = arith.addi %35, %c0 : index
        memref.store %42, %arg2[%43] : memref<?xf32>
      }
      %28 = scf.if %true -> (i32) {
        %29 = arith.addi %23, %c1_i32 : i32
        scf.yield %29 : i32
      } else {
        scf.yield %23 : i32
      }
      cf.br ^bb1(%28 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %23 : i32
    }
    scf.yield %21 : i32
  } else {
    scf.yield %12 : i32
  }
  scf.yield %20 : i32
} else {
  scf.yield %12 : i32
}

starting block: lastVal=ifOp:mlir-asm-printer: Verifying operation: func.func
%18 = scf.if %true -> (i32) {
  %20 = scf.if %true -> (i32) {
    %21 = scf.execute_region -> i32 {
      %22 = scf.if %true -> (i32) {
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %12 : i32
      }
      cf.br ^bb1(%22 : i32)
    ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
      %24 = memref.get_global @im : memref<1xi32>
      %25 = memref.load %24[%c0] : memref<1xi32>
      %26 = arith.cmpi slt, %23, %25 : i32
      %27 = arith.andi %26, %true : i1
      cf.cond_br %27, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      scf.if %true {
        %29 = arith.muli %13, %25 : i32
        %30 = arith.addi %23, %29 : i32
        %31 = arith.muli %4, %25 : i32
        %32 = memref.load %14[%c0] : memref<1xi32>
        %33 = arith.muli %31, %32 : i32
        %34 = arith.addi %30, %33 : i32
        %35 = arith.index_cast %34 : i32 to index
        %36 = arith.subi %4, %c1_i32 : i32
        %37 = arith.muli %36, %25 : i32
        %38 = arith.muli %37, %32 : i32
        %39 = arith.addi %30, %38 : i32
        %40 = arith.index_cast %39 : i32 to index
        %41 = arith.addi %40, %c0 : index
        %42 = memref.load %arg0[%41] : memref<?xf32>
        %43 = arith.addi %35, %c0 : index
        memref.store %42, %arg2[%43] : memref<?xf32>
      }
      %28 = scf.if %true -> (i32) {
        %29 = arith.addi %23, %c1_i32 : i32
        scf.yield %29 : i32
      } else {
        scf.yield %23 : i32
      }
      cf.br ^bb1(%28 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %23 : i32
    }
    scf.yield %21 : i32
  } else {
    scf.yield %12 : i32
  }
  scf.yield %20 : i32
} else {
  scf.yield %12 : i32
}
mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %13 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0:
  scf.yield %13 : i32
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
%18 = scf.if %true -> (i32) {
  %20 = scf.if %true -> (i32) {
    %21 = scf.execute_region -> i32 {
      %22 = scf.if %true -> (i32) {
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %12 : i32
      }
      cf.br ^bb1(%22 : i32)
    ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
      %24 = memref.get_global @im : memref<1xi32>
      %25 = memref.load %24[%c0] : memref<1xi32>
      %26 = arith.cmpi slt, %23, %25 : i32
      %27 = arith.andi %26, %true : i1
      cf.cond_br %27, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      scf.if %true {
        %29 = arith.muli %13, %25 : i32
        %30 = arith.addi %23, %29 : i32
        %31 = arith.muli %4, %25 : i32
        %32 = memref.load %14[%c0] : memref<1xi32>
        %33 = arith.muli %31, %32 : i32
        %34 = arith.addi %30, %33 : i32
        %35 = arith.index_cast %34 : i32 to index
        %36 = arith.subi %4, %c1_i32 : i32
        %37 = arith.muli %36, %25 : i32
        %38 = arith.muli %37, %32 : i32
        %39 = arith.addi %30, %38 : i32
        %40 = arith.index_cast %39 : i32 to index
        %41 = arith.addi %40, %c0 : index
        %42 = memref.load %arg0[%41] : memref<?xf32>
        %43 = arith.addi %35, %c0 : index
        memref.store %42, %arg2[%43] : memref<?xf32>
      }
      %28 = scf.if %true -> (i32) {
        %29 = arith.addi %23, %c1_i32 : i32
        scf.yield %29 : i32
      } else {
        scf.yield %23 : i32
      }
      cf.br ^bb1(%28 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %23 : i32
    }
    scf.yield %21 : i32
  } else {
    scf.yield %12 : i32
  }
  scf.yield %20 : i32
} else {
  scf.yield %12 : i32
}
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2:  // pred: ^bb1
  %18 = scf.if %true -> (i32) {
    %20 = scf.if %true -> (i32) {
      %21 = scf.execute_region -> i32 {
        %22 = scf.if %true -> (i32) {
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %12 : i32
        }
        cf.br ^bb1(%22 : i32)
      ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
        %24 = memref.get_global @im : memref<1xi32>
        %25 = memref.load %24[%c0] : memref<1xi32>
        %26 = arith.cmpi slt, %23, %25 : i32
        %27 = arith.andi %26, %true : i1
        cf.cond_br %27, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        scf.if %true {
          %29 = arith.muli %13, %25 : i32
          %30 = arith.addi %23, %29 : i32
          %31 = arith.muli %4, %25 : i32
          %32 = memref.load %14[%c0] : memref<1xi32>
          %33 = arith.muli %31, %32 : i32
          %34 = arith.addi %30, %33 : i32
          %35 = arith.index_cast %34 : i32 to index
          %36 = arith.subi %4, %c1_i32 : i32
          %37 = arith.muli %36, %25 : i32
          %38 = arith.muli %37, %32 : i32
          %39 = arith.addi %30, %38 : i32
          %40 = arith.index_cast %39 : i32 to index
          %41 = arith.addi %40, %c0 : index
          %42 = memref.load %arg0[%41] : memref<?xf32>
          %43 = arith.addi %35, %c0 : index
          memref.store %42, %arg2[%43] : memref<?xf32>
        }
        %28 = scf.if %true -> (i32) {
          %29 = arith.addi %23, %c1_i32 : i32
          scf.yield %29 : i32
        } else {
          scf.yield %23 : i32
        }
        cf.br ^bb1(%28 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %23 : i32
      }
      scf.yield %21 : i32
    } else {
      scf.yield %12 : i32
    }
    scf.yield %20 : i32
  } else {
    scf.yield %12 : i32
  }
  %19 = scf.if %true -> (i32) {
    %20 = arith.addi %13, %c1_i32 : i32
    scf.yield %20 : i32
  } else {
    scf.yield %13 : i32
  }
  cf.br ^bb1(%18, %19 : i32, i32)
 with val:ifOp:mlir-asm-printer: Verifying operation: func.func
%18 = scf.if %true -> (i32) {
  %20 = scf.if %true -> (i32) {
    %21 = scf.execute_region -> i32 {
      %22 = scf.if %true -> (i32) {
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %12 : i32
      }
      cf.br ^bb1(%22 : i32)
    ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
      %24 = memref.get_global @im : memref<1xi32>
      %25 = memref.load %24[%c0] : memref<1xi32>
      %26 = arith.cmpi slt, %23, %25 : i32
      %27 = arith.andi %26, %true : i1
      cf.cond_br %27, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      scf.if %true {
        %29 = arith.muli %13, %25 : i32
        %30 = arith.addi %23, %29 : i32
        %31 = arith.muli %4, %25 : i32
        %32 = memref.load %14[%c0] : memref<1xi32>
        %33 = arith.muli %31, %32 : i32
        %34 = arith.addi %30, %33 : i32
        %35 = arith.index_cast %34 : i32 to index
        %36 = arith.subi %4, %c1_i32 : i32
        %37 = arith.muli %36, %25 : i32
        %38 = arith.muli %37, %32 : i32
        %39 = arith.addi %30, %38 : i32
        %40 = arith.index_cast %39 : i32 to index
        %41 = arith.addi %40, %c0 : index
        %42 = memref.load %arg0[%41] : memref<?xf32>
        %43 = arith.addi %35, %c0 : index
        memref.store %42, %arg2[%43] : memref<?xf32>
      }
      %28 = scf.if %true -> (i32) {
        %29 = arith.addi %23, %c1_i32 : i32
        scf.yield %29 : i32
      } else {
        scf.yield %23 : i32
      }
      cf.br ^bb1(%28 : i32)
    ^bb3:  // pred: ^bb1
      scf.yield %23 : i32
    }
    scf.yield %21 : i32
  } else {
    scf.yield %12 : i32
  }
  scf.yield %20 : i32
} else {
  scf.yield %12 : i32
}
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%24 = memref.get_global @im : memref<1xi32>

//===-------------------------------------------===//
Processing operation : 'func.return'(0x7fbd9800c610) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd98166820) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
    ** Insert  : 'arith.andi'(0x7fbd9b104e40)
    ** Insert  : 'scf.yield'(0x7fbd9b104ed0)
    ** Insert  : 'scf.if'(0x7fbd9b104080)
    ** Erase   : 'scf.yield'(0x7fbd9b104ed0)
    ** Insert  : 'scf.yield'(0x7fbd9b104ed0)
    ** Replace : 'scf.yield'(0x7fbd98166a40)
    ** Replace : 'scf.if'(0x7fbd98166820)
"(anonymous namespace)::CombineNestedIfs" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = llvm.mlir.undef : i32
  %1 = arith.andi %true, %true : i1
  scf.if %1 {
    scf.execute_region {
      %2 = scf.if %true -> (i32) {
        %10 = memref.get_global @kbm3 : memref<1xi32>
        %11 = memref.load %10[%c0] : memref<1xi32>
        scf.yield %11 : i32
      } else {
        scf.yield %0 : i32
      }
      cf.br ^bb1(%0, %0, %2 : i32, i32, i32)
    ^bb1(%3: i32, %4: i32, %5: i32):  // 2 preds: ^bb0, ^bb2
      %6 = arith.cmpi sgt, %5, %c0_i32 : i32
      %7 = arith.andi %6, %true : i1
      cf.cond_br %7, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %8:2 = scf.if %true -> (i32, i32) {
        %10:2 = scf.if %true -> (i32, i32) {
          %11:2 = scf.execute_region -> (i32, i32) {
            %12 = scf.if %true -> (i32) {
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %4 : i32
            }
            cf.br ^bb1(%3, %12 : i32, i32)
          ^bb1(%13: i32, %14: i32):  // 2 preds: ^bb0, ^bb2
            %15 = memref.get_global @jm : memref<1xi32>
            %16 = memref.load %15[%c0] : memref<1xi32>
            %17 = arith.cmpi slt, %14, %16 : i32
            %18 = arith.andi %17, %true : i1
            cf.cond_br %18, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %19 = scf.if %true -> (i32) {
              %21 = scf.if %true -> (i32) {
                %22 = scf.execute_region -> i32 {
                  %23 = scf.if %true -> (i32) {
                    scf.yield %c0_i32 : i32
                  } else {
                    scf.yield %13 : i32
                  }
                  cf.br ^bb1(%23 : i32)
                ^bb1(%24: i32):  // 2 preds: ^bb0, ^bb2
                  %25 = memref.get_global @im : memref<1xi32>
                  %26 = memref.load %25[%c0] : memref<1xi32>
                  %27 = arith.cmpi slt, %24, %26 : i32
                  %28 = arith.andi %27, %true : i1
                  cf.cond_br %28, ^bb2, ^bb3
                ^bb2:  // pred: ^bb1
                  scf.if %true {
                    %30 = arith.muli %14, %26 : i32
                    %31 = arith.addi %24, %30 : i32
                    %32 = arith.muli %5, %26 : i32
                    %33 = memref.load %15[%c0] : memref<1xi32>
                    %34 = arith.muli %32, %33 : i32
                    %35 = arith.addi %31, %34 : i32
                    %36 = arith.index_cast %35 : i32 to index
                    %37 = arith.subi %5, %c1_i32 : i32
                    %38 = arith.muli %37, %26 : i32
                    %39 = arith.muli %38, %33 : i32
                    %40 = arith.addi %31, %39 : i32
                    %41 = arith.index_cast %40 : i32 to index
                    %42 = arith.addi %41, %c0 : index
                    %43 = memref.load %arg0[%42] : memref<?xf32>
                    %44 = arith.addi %36, %c0 : index
                    memref.store %43, %arg2[%44] : memref<?xf32>
                  }
                  %29 = scf.if %true -> (i32) {
                    %30 = arith.addi %24, %c1_i32 : i32
                    scf.yield %30 : i32
                  } else {
                    scf.yield %24 : i32
                  }
                  cf.br ^bb1(%29 : i32)
                ^bb3:  // pred: ^bb1
                  scf.yield %24 : i32
                }
                scf.yield %22 : i32
              } else {
                scf.yield %13 : i32
              }
              scf.yield %21 : i32
            } else {
              scf.yield %13 : i32
            }
            %20 = scf.if %true -> (i32) {
              %21 = arith.addi %14, %c1_i32 : i32
              scf.yield %21 : i32
            } else {
              scf.yield %14 : i32
            }
            cf.br ^bb1(%19, %20 : i32, i32)
          ^bb3:  // pred: ^bb1
            scf.yield %13, %14 : i32, i32
          }
          scf.yield %11#0, %11#1 : i32, i32
        } else {
          scf.yield %3, %4 : i32, i32
        }
        scf.yield %10#0, %10#1 : i32, i32
      } else {
        scf.yield %3, %4 : i32, i32
      }
      %9 = scf.if %true -> (i32) {
        %10 = arith.subi %5, %c1_i32 : i32
        scf.yield %10 : i32
      } else {
        scf.yield %5 : i32
      }
      cf.br ^bb1(%8#0, %8#1, %9 : i32, i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b104ed0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b104080) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.andi'(0x7fbd9b104e40) {
  %5 = "arith.andi"(%0, %0) : (i1, i1) -> i1

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b104080) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  scf.if %true {
    %0 = llvm.mlir.undef : i32
    scf.execute_region {
      %1 = scf.if %true -> (i32) {
        %9 = memref.get_global @kbm3 : memref<1xi32>
        %10 = memref.load %9[%c0] : memref<1xi32>
        scf.yield %10 : i32
      } else {
        scf.yield %0 : i32
      }
      cf.br ^bb1(%0, %0, %1 : i32, i32, i32)
    ^bb1(%2: i32, %3: i32, %4: i32):  // 2 preds: ^bb0, ^bb2
      %5 = arith.cmpi sgt, %4, %c0_i32 : i32
      %6 = arith.andi %5, %true : i1
      cf.cond_br %6, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %7:2 = scf.if %true -> (i32, i32) {
        %9:2 = scf.if %true -> (i32, i32) {
          %10:2 = scf.execute_region -> (i32, i32) {
            %11 = scf.if %true -> (i32) {
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %3 : i32
            }
            cf.br ^bb1(%2, %11 : i32, i32)
          ^bb1(%12: i32, %13: i32):  // 2 preds: ^bb0, ^bb2
            %14 = memref.get_global @jm : memref<1xi32>
            %15 = memref.load %14[%c0] : memref<1xi32>
            %16 = arith.cmpi slt, %13, %15 : i32
            %17 = arith.andi %16, %true : i1
            cf.cond_br %17, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %18 = scf.if %true -> (i32) {
              %20 = scf.if %true -> (i32) {
                %21 = scf.execute_region -> i32 {
                  %22 = scf.if %true -> (i32) {
                    scf.yield %c0_i32 : i32
                  } else {
                    scf.yield %12 : i32
                  }
                  cf.br ^bb1(%22 : i32)
                ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
                  %24 = memref.get_global @im : memref<1xi32>
                  %25 = memref.load %24[%c0] : memref<1xi32>
                  %26 = arith.cmpi slt, %23, %25 : i32
                  %27 = arith.andi %26, %true : i1
                  cf.cond_br %27, ^bb2, ^bb3
                ^bb2:  // pred: ^bb1
                  scf.if %true {
                    %29 = arith.muli %13, %25 : i32
                    %30 = arith.addi %23, %29 : i32
                    %31 = arith.muli %4, %25 : i32
                    %32 = memref.load %14[%c0] : memref<1xi32>
                    %33 = arith.muli %31, %32 : i32
                    %34 = arith.addi %30, %33 : i32
                    %35 = arith.index_cast %34 : i32 to index
                    %36 = arith.subi %4, %c1_i32 : i32
                    %37 = arith.muli %36, %25 : i32
                    %38 = arith.muli %37, %32 : i32
                    %39 = arith.addi %30, %38 : i32
                    %40 = arith.index_cast %39 : i32 to index
                    %41 = arith.addi %40, %c0 : index
                    %42 = memref.load %arg0[%41] : memref<?xf32>
                    %43 = arith.addi %35, %c0 : index
                    memref.store %42, %arg2[%43] : memref<?xf32>
                  }
                  %28 = scf.if %true -> (i32) {
                    %29 = arith.addi %23, %c1_i32 : i32
                    scf.yield %29 : i32
                  } else {
                    scf.yield %23 : i32
                  }
                  cf.br ^bb1(%28 : i32)
                ^bb3:  // pred: ^bb1
                  scf.yield %23 : i32
                }
                scf.yield %21 : i32
              } else {
                scf.yield %12 : i32
              }
              scf.yield %20 : i32
            } else {
              scf.yield %12 : i32
            }
            %19 = scf.if %true -> (i32) {
              %20 = arith.addi %13, %c1_i32 : i32
              scf.yield %20 : i32
            } else {
              scf.yield %13 : i32
            }
            cf.br ^bb1(%18, %19 : i32, i32)
          ^bb3:  // pred: ^bb1
            scf.yield %12, %13 : i32, i32
          }
          scf.yield %10#0, %10#1 : i32, i32
        } else {
          scf.yield %2, %3 : i32, i32
        }
        scf.yield %9#0, %9#1 : i32, i32
      } else {
        scf.yield %2, %3 : i32, i32
      }
      %8 = scf.if %true -> (i32) {
        %9 = arith.subi %4, %c1_i32 : i32
        scf.yield %9 : i32
      } else {
        scf.yield %4 : i32
      }
      cf.br ^bb1(%7#0, %7#1, %8 : i32, i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.execute_region'(0x7fbd98166b30) {

  * Pattern SingleBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "SingleBlockExecuteInliner"
"SingleBlockExecuteInliner" result 0
  } -> failure : pattern failed to match

  * Pattern MultiBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "MultiBlockExecuteInliner"
"MultiBlockExecuteInliner" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9800c570) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b105050) {
  "cf.br"(%11#0, %11#1, %12)[^bb1] : (i32, i32, i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9800f910) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
    ** Insert  : 'scf.if'(0x7fbd9b104150)
    ** Insert  : 'scf.yield'(0x7fbd9b104f20)
    ** Erase   : 'scf.yield'(0x7fbd98168820)
    ** Erase   : 'scf.yield'(0x7fbd9800c010)
    ** Insert  : 'scf.yield'(0x7fbd9b1041f0)
    ** Erase   : 'scf.yield'(0x7fbd9b305ff0)
    ** Erase   : 'scf.yield'(0x7fbd9800fa30)
    ** Replace : 'scf.if'(0x7fbd9800bbf0)
    ** Replace : 'scf.if'(0x7fbd9800f910)
"(anonymous namespace)::CombineIfs" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  scf.if %true {
    %0 = llvm.mlir.undef : i32
    scf.execute_region {
      %1 = scf.if %true -> (i32) {
        %8 = memref.get_global @kbm3 : memref<1xi32>
        %9 = memref.load %8[%c0] : memref<1xi32>
        scf.yield %9 : i32
      } else {
        scf.yield %0 : i32
      }
      cf.br ^bb1(%0, %0, %1 : i32, i32, i32)
    ^bb1(%2: i32, %3: i32, %4: i32):  // 2 preds: ^bb0, ^bb2
      %5 = arith.cmpi sgt, %4, %c0_i32 : i32
      %6 = arith.andi %5, %true : i1
      cf.cond_br %6, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %7:3 = scf.if %true -> (i32, i32, i32) {
        %8:2 = scf.if %true -> (i32, i32) {
          %10:2 = scf.execute_region -> (i32, i32) {
            %11 = scf.if %true -> (i32) {
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %3 : i32
            }
            cf.br ^bb1(%2, %11 : i32, i32)
          ^bb1(%12: i32, %13: i32):  // 2 preds: ^bb0, ^bb2
            %14 = memref.get_global @jm : memref<1xi32>
            %15 = memref.load %14[%c0] : memref<1xi32>
            %16 = arith.cmpi slt, %13, %15 : i32
            %17 = arith.andi %16, %true : i1
            cf.cond_br %17, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %18 = scf.if %true -> (i32) {
              %20 = scf.if %true -> (i32) {
                %21 = scf.execute_region -> i32 {
                  %22 = scf.if %true -> (i32) {
                    scf.yield %c0_i32 : i32
                  } else {
                    scf.yield %12 : i32
                  }
                  cf.br ^bb1(%22 : i32)
                ^bb1(%23: i32):  // 2 preds: ^bb0, ^bb2
                  %24 = memref.get_global @im : memref<1xi32>
                  %25 = memref.load %24[%c0] : memref<1xi32>
                  %26 = arith.cmpi slt, %23, %25 : i32
                  %27 = arith.andi %26, %true : i1
                  cf.cond_br %27, ^bb2, ^bb3
                ^bb2:  // pred: ^bb1
                  scf.if %true {
                    %29 = arith.muli %13, %25 : i32
                    %30 = arith.addi %23, %29 : i32
                    %31 = arith.muli %4, %25 : i32
                    %32 = memref.load %14[%c0] : memref<1xi32>
                    %33 = arith.muli %31, %32 : i32
                    %34 = arith.addi %30, %33 : i32
                    %35 = arith.index_cast %34 : i32 to index
                    %36 = arith.subi %4, %c1_i32 : i32
                    %37 = arith.muli %36, %25 : i32
                    %38 = arith.muli %37, %32 : i32
                    %39 = arith.addi %30, %38 : i32
                    %40 = arith.index_cast %39 : i32 to index
                    %41 = arith.addi %40, %c0 : index
                    %42 = memref.load %arg0[%41] : memref<?xf32>
                    %43 = arith.addi %35, %c0 : index
                    memref.store %42, %arg2[%43] : memref<?xf32>
                  }
                  %28 = scf.if %true -> (i32) {
                    %29 = arith.addi %23, %c1_i32 : i32
                    scf.yield %29 : i32
                  } else {
                    scf.yield %23 : i32
                  }
                  cf.br ^bb1(%28 : i32)
                ^bb3:  // pred: ^bb1
                  scf.yield %23 : i32
                }
                scf.yield %21 : i32
              } else {
                scf.yield %12 : i32
              }
              scf.yield %20 : i32
            } else {
              scf.yield %12 : i32
            }
            %19 = scf.if %true -> (i32) {
              %20 = arith.addi %13, %c1_i32 : i32
              scf.yield %20 : i32
            } else {
              scf.yield %13 : i32
            }
            cf.br ^bb1(%18, %19 : i32, i32)
          ^bb3:  // pred: ^bb1
            scf.yield %12, %13 : i32, i32
          }
          scf.yield %10#0, %10#1 : i32, i32
        } else {
          scf.yield %2, %3 : i32, i32
        }
        %9 = arith.subi %4, %c1_i32 : i32
        scf.yield %8#0, %8#1, %9 : i32, i32, i32
      } else {
        scf.yield %2, %3, %4 : i32, i32, i32
      }
      cf.br ^bb1(%7#0, %7#1, %7#2 : i32, i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b105050) {
  "cf.br"(%11#0, %11#1, %11#2)[^bb1] : (i32, i32, i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1041f0) {
  "scf.yield"(%6, %7, %8) : (i32, i32, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b104f20) {
  "scf.yield"(%12#0, %12#1, %13) : (i32, i32, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b104150) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
    ** Replace : 'scf.if'(0x7fbd9b104150)
    ** Erase   : 'scf.yield'(0x7fbd9b104f20)
"(anonymous namespace)::RemoveStaticCondition" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  scf.if %true {
    %0 = llvm.mlir.undef : i32
    scf.execute_region {
      %1 = scf.if %true -> (i32) {
        %9 = memref.get_global @kbm3 : memref<1xi32>
        %10 = memref.load %9[%c0] : memref<1xi32>
        scf.yield %10 : i32
      } else {
        scf.yield %0 : i32
      }
      cf.br ^bb1(%0, %0, %1 : i32, i32, i32)
    ^bb1(%2: i32, %3: i32, %4: i32):  // 2 preds: ^bb0, ^bb2
      %5 = arith.cmpi sgt, %4, %c0_i32 : i32
      %6 = arith.andi %5, %true : i1
      cf.cond_br %6, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %7:2 = scf.if %true -> (i32, i32) {
        %9:2 = scf.execute_region -> (i32, i32) {
          %10 = scf.if %true -> (i32) {
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %3 : i32
          }
          cf.br ^bb1(%2, %10 : i32, i32)
        ^bb1(%11: i32, %12: i32):  // 2 preds: ^bb0, ^bb2
          %13 = memref.get_global @jm : memref<1xi32>
          %14 = memref.load %13[%c0] : memref<1xi32>
          %15 = arith.cmpi slt, %12, %14 : i32
          %16 = arith.andi %15, %true : i1
          cf.cond_br %16, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %17 = scf.if %true -> (i32) {
            %19 = scf.if %true -> (i32) {
              %20 = scf.execute_region -> i32 {
                %21 = scf.if %true -> (i32) {
                  scf.yield %c0_i32 : i32
                } else {
                  scf.yield %11 : i32
                }
                cf.br ^bb1(%21 : i32)
              ^bb1(%22: i32):  // 2 preds: ^bb0, ^bb2
                %23 = memref.get_global @im : memref<1xi32>
                %24 = memref.load %23[%c0] : memref<1xi32>
                %25 = arith.cmpi slt, %22, %24 : i32
                %26 = arith.andi %25, %true : i1
                cf.cond_br %26, ^bb2, ^bb3
              ^bb2:  // pred: ^bb1
                scf.if %true {
                  %28 = arith.muli %12, %24 : i32
                  %29 = arith.addi %22, %28 : i32
                  %30 = arith.muli %4, %24 : i32
                  %31 = memref.load %13[%c0] : memref<1xi32>
                  %32 = arith.muli %30, %31 : i32
                  %33 = arith.addi %29, %32 : i32
                  %34 = arith.index_cast %33 : i32 to index
                  %35 = arith.subi %4, %c1_i32 : i32
                  %36 = arith.muli %35, %24 : i32
                  %37 = arith.muli %36, %31 : i32
                  %38 = arith.addi %29, %37 : i32
                  %39 = arith.index_cast %38 : i32 to index
                  %40 = arith.addi %39, %c0 : index
                  %41 = memref.load %arg0[%40] : memref<?xf32>
                  %42 = arith.addi %34, %c0 : index
                  memref.store %41, %arg2[%42] : memref<?xf32>
                }
                %27 = scf.if %true -> (i32) {
                  %28 = arith.addi %22, %c1_i32 : i32
                  scf.yield %28 : i32
                } else {
                  scf.yield %22 : i32
                }
                cf.br ^bb1(%27 : i32)
              ^bb3:  // pred: ^bb1
                scf.yield %22 : i32
              }
              scf.yield %20 : i32
            } else {
              scf.yield %11 : i32
            }
            scf.yield %19 : i32
          } else {
            scf.yield %11 : i32
          }
          %18 = scf.if %true -> (i32) {
            %19 = arith.addi %12, %c1_i32 : i32
            scf.yield %19 : i32
          } else {
            scf.yield %12 : i32
          }
          cf.br ^bb1(%17, %18 : i32, i32)
        ^bb3:  // pred: ^bb1
          scf.yield %11, %12 : i32, i32
        }
        scf.yield %9#0, %9#1 : i32, i32
      } else {
        scf.yield %2, %3 : i32, i32
      }
      %8 = arith.subi %4, %c1_i32 : i32
      cf.br ^bb1(%7#0, %7#1, %8 : i32, i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b105050) {
  "cf.br"(%11#0, %11#1, %12)[^bb1] : (i32, i32, i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9800c320) {
  %12 = "arith.subi"(%8, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9800c460) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
    ** Replace : 'scf.if'(0x7fbd9800c460)
    ** Erase   : 'scf.yield'(0x7fbd98168ad0)
"(anonymous namespace)::RemoveStaticCondition" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  scf.if %true {
    %0 = llvm.mlir.undef : i32
    scf.execute_region {
      %1 = scf.if %true -> (i32) {
        %9 = memref.get_global @kbm3 : memref<1xi32>
        %10 = memref.load %9[%c0] : memref<1xi32>
        scf.yield %10 : i32
      } else {
        scf.yield %0 : i32
      }
      cf.br ^bb1(%0, %0, %1 : i32, i32, i32)
    ^bb1(%2: i32, %3: i32, %4: i32):  // 2 preds: ^bb0, ^bb2
      %5 = arith.cmpi sgt, %4, %c0_i32 : i32
      %6 = arith.andi %5, %true : i1
      cf.cond_br %6, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %7:2 = scf.execute_region -> (i32, i32) {
        %9 = scf.if %true -> (i32) {
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %3 : i32
        }
        cf.br ^bb1(%2, %9 : i32, i32)
      ^bb1(%10: i32, %11: i32):  // 2 preds: ^bb0, ^bb2
        %12 = memref.get_global @jm : memref<1xi32>
        %13 = memref.load %12[%c0] : memref<1xi32>
        %14 = arith.cmpi slt, %11, %13 : i32
        %15 = arith.andi %14, %true : i1
        cf.cond_br %15, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %16 = scf.if %true -> (i32) {
          %18 = scf.if %true -> (i32) {
            %19 = scf.execute_region -> i32 {
              %20 = scf.if %true -> (i32) {
                scf.yield %c0_i32 : i32
              } else {
                scf.yield %10 : i32
              }
              cf.br ^bb1(%20 : i32)
            ^bb1(%21: i32):  // 2 preds: ^bb0, ^bb2
              %22 = memref.get_global @im : memref<1xi32>
              %23 = memref.load %22[%c0] : memref<1xi32>
              %24 = arith.cmpi slt, %21, %23 : i32
              %25 = arith.andi %24, %true : i1
              cf.cond_br %25, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              scf.if %true {
                %27 = arith.muli %11, %23 : i32
                %28 = arith.addi %21, %27 : i32
                %29 = arith.muli %4, %23 : i32
                %30 = memref.load %12[%c0] : memref<1xi32>
                %31 = arith.muli %29, %30 : i32
                %32 = arith.addi %28, %31 : i32
                %33 = arith.index_cast %32 : i32 to index
                %34 = arith.subi %4, %c1_i32 : i32
                %35 = arith.muli %34, %23 : i32
                %36 = arith.muli %35, %30 : i32
                %37 = arith.addi %28, %36 : i32
                %38 = arith.index_cast %37 : i32 to index
                %39 = arith.addi %38, %c0 : index
                %40 = memref.load %arg0[%39] : memref<?xf32>
                %41 = arith.addi %33, %c0 : index
                memref.store %40, %arg2[%41] : memref<?xf32>
              }
              %26 = scf.if %true -> (i32) {
                %27 = arith.addi %21, %c1_i32 : i32
                scf.yield %27 : i32
              } else {
                scf.yield %21 : i32
              }
              cf.br ^bb1(%26 : i32)
            ^bb3:  // pred: ^bb1
              scf.yield %21 : i32
            }
            scf.yield %19 : i32
          } else {
            scf.yield %10 : i32
          }
          scf.yield %18 : i32
        } else {
          scf.yield %10 : i32
        }
        %17 = scf.if %true -> (i32) {
          %18 = arith.addi %11, %c1_i32 : i32
          scf.yield %18 : i32
        } else {
          scf.yield %11 : i32
        }
        cf.br ^bb1(%16, %17 : i32, i32)
      ^bb3:  // pred: ^bb1
        scf.yield %10, %11 : i32, i32
      }
      %8 = arith.subi %4, %c1_i32 : i32
      cf.br ^bb1(%7#0, %7#1, %8 : i32, i32, i32)
    ^bb3:  // pred: ^bb1
      scf.yield
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b105050) {
  "cf.br"(%11#0, %11#1, %12)[^bb1] : (i32, i32, i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.execute_region'(0x7fbd9b305c10) {

  * Pattern SingleBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "SingleBlockExecuteInliner"
"SingleBlockExecuteInliner" result 0
  } -> failure : pattern failed to match

  * Pattern MultiBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "MultiBlockExecuteInliner"
    ** Insert  : 'cf.br'(0x7fbd9b306df0)
    ** Insert  : 'cf.br'(0x7fbd9b306b60)
    ** Erase   : 'scf.yield'(0x7fbd9800bd90)
    ** Replace : 'scf.execute_region'(0x7fbd9b305c10)
"MultiBlockExecuteInliner" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  scf.if %true {
    %0 = llvm.mlir.undef : i32
    scf.execute_region {
      %1 = scf.if %true -> (i32) {
        %19 = memref.get_global @kbm3 : memref<1xi32>
        %20 = memref.load %19[%c0] : memref<1xi32>
        scf.yield %20 : i32
      } else {
        scf.yield %0 : i32
      }
      cf.br ^bb1(%0, %0, %1 : i32, i32, i32)
    ^bb1(%2: i32, %3: i32, %4: i32):  // 2 preds: ^bb0, ^bb7
      %5 = arith.cmpi sgt, %4, %c0_i32 : i32
      %6 = arith.andi %5, %true : i1
      cf.cond_br %6, ^bb2, ^bb8
    ^bb2:  // pred: ^bb1
      cf.br ^bb3
    ^bb3:  // pred: ^bb2
      %7 = scf.if %true -> (i32) {
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %3 : i32
      }
      cf.br ^bb4(%2, %7 : i32, i32)
    ^bb4(%8: i32, %9: i32):  // 2 preds: ^bb3, ^bb5
      %10 = memref.get_global @jm : memref<1xi32>
      %11 = memref.load %10[%c0] : memref<1xi32>
      %12 = arith.cmpi slt, %9, %11 : i32
      %13 = arith.andi %12, %true : i1
      cf.cond_br %13, ^bb5, ^bb6
    ^bb5:  // pred: ^bb4
      %14 = scf.if %true -> (i32) {
        %19 = scf.if %true -> (i32) {
          %20 = scf.execute_region -> i32 {
            %21 = scf.if %true -> (i32) {
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %8 : i32
            }
            cf.br ^bb1(%21 : i32)
          ^bb1(%22: i32):  // 2 preds: ^bb0, ^bb2
            %23 = memref.get_global @im : memref<1xi32>
            %24 = memref.load %23[%c0] : memref<1xi32>
            %25 = arith.cmpi slt, %22, %24 : i32
            %26 = arith.andi %25, %true : i1
            cf.cond_br %26, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            scf.if %true {
              %28 = arith.muli %9, %24 : i32
              %29 = arith.addi %22, %28 : i32
              %30 = arith.muli %4, %24 : i32
              %31 = memref.load %10[%c0] : memref<1xi32>
              %32 = arith.muli %30, %31 : i32
              %33 = arith.addi %29, %32 : i32
              %34 = arith.index_cast %33 : i32 to index
              %35 = arith.subi %4, %c1_i32 : i32
              %36 = arith.muli %35, %24 : i32
              %37 = arith.muli %36, %31 : i32
              %38 = arith.addi %29, %37 : i32
              %39 = arith.index_cast %38 : i32 to index
              %40 = arith.addi %39, %c0 : index
              %41 = memref.load %arg0[%40] : memref<?xf32>
              %42 = arith.addi %34, %c0 : index
              memref.store %41, %arg2[%42] : memref<?xf32>
            }
            %27 = scf.if %true -> (i32) {
              %28 = arith.addi %22, %c1_i32 : i32
              scf.yield %28 : i32
            } else {
              scf.yield %22 : i32
            }
            cf.br ^bb1(%27 : i32)
          ^bb3:  // pred: ^bb1
            scf.yield %22 : i32
          }
          scf.yield %20 : i32
        } else {
          scf.yield %8 : i32
        }
        scf.yield %19 : i32
      } else {
        scf.yield %8 : i32
      }
      %15 = scf.if %true -> (i32) {
        %19 = arith.addi %9, %c1_i32 : i32
        scf.yield %19 : i32
      } else {
        scf.yield %9 : i32
      }
      cf.br ^bb4(%14, %15 : i32, i32)
    ^bb6:  // pred: ^bb4
      cf.br ^bb7(%8, %9 : i32, i32)
    ^bb7(%16: i32, %17: i32):  // pred: ^bb6
      %18 = arith.subi %4, %c1_i32 : i32
      cf.br ^bb1(%16, %17, %18 : i32, i32, i32)
    ^bb8:  // pred: ^bb1
      scf.yield
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b105050) {
  "cf.br"(%20, %21, %22)[^bb1] : (i32, i32, i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b306b60) {
  "cf.br"(%12, %13)[^bb7] : (i32, i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
    ** Erase   : 'cf.br'(0x7fbd9b306b60)
"" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  scf.if %true {
    %0 = llvm.mlir.undef : i32
    scf.execute_region {
      %1 = scf.if %true -> (i32) {
        %17 = memref.get_global @kbm3 : memref<1xi32>
        %18 = memref.load %17[%c0] : memref<1xi32>
        scf.yield %18 : i32
      } else {
        scf.yield %0 : i32
      }
      cf.br ^bb1(%0, %0, %1 : i32, i32, i32)
    ^bb1(%2: i32, %3: i32, %4: i32):  // 2 preds: ^bb0, ^bb6
      %5 = arith.cmpi sgt, %4, %c0_i32 : i32
      %6 = arith.andi %5, %true : i1
      cf.cond_br %6, ^bb2, ^bb7
    ^bb2:  // pred: ^bb1
      cf.br ^bb3
    ^bb3:  // pred: ^bb2
      %7 = scf.if %true -> (i32) {
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %3 : i32
      }
      cf.br ^bb4(%2, %7 : i32, i32)
    ^bb4(%8: i32, %9: i32):  // 2 preds: ^bb3, ^bb5
      %10 = memref.get_global @jm : memref<1xi32>
      %11 = memref.load %10[%c0] : memref<1xi32>
      %12 = arith.cmpi slt, %9, %11 : i32
      %13 = arith.andi %12, %true : i1
      cf.cond_br %13, ^bb5, ^bb6
    ^bb5:  // pred: ^bb4
      %14 = scf.if %true -> (i32) {
        %17 = scf.if %true -> (i32) {
          %18 = scf.execute_region -> i32 {
            %19 = scf.if %true -> (i32) {
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %8 : i32
            }
            cf.br ^bb1(%19 : i32)
          ^bb1(%20: i32):  // 2 preds: ^bb0, ^bb2
            %21 = memref.get_global @im : memref<1xi32>
            %22 = memref.load %21[%c0] : memref<1xi32>
            %23 = arith.cmpi slt, %20, %22 : i32
            %24 = arith.andi %23, %true : i1
            cf.cond_br %24, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            scf.if %true {
              %26 = arith.muli %9, %22 : i32
              %27 = arith.addi %20, %26 : i32
              %28 = arith.muli %4, %22 : i32
              %29 = memref.load %10[%c0] : memref<1xi32>
              %30 = arith.muli %28, %29 : i32
              %31 = arith.addi %27, %30 : i32
              %32 = arith.index_cast %31 : i32 to index
              %33 = arith.subi %4, %c1_i32 : i32
              %34 = arith.muli %33, %22 : i32
              %35 = arith.muli %34, %29 : i32
              %36 = arith.addi %27, %35 : i32
              %37 = arith.index_cast %36 : i32 to index
              %38 = arith.addi %37, %c0 : index
              %39 = memref.load %arg0[%38] : memref<?xf32>
              %40 = arith.addi %32, %c0 : index
              memref.store %39, %arg2[%40] : memref<?xf32>
            }
            %25 = scf.if %true -> (i32) {
              %26 = arith.addi %20, %c1_i32 : i32
              scf.yield %26 : i32
            } else {
              scf.yield %20 : i32
            }
            cf.br ^bb1(%25 : i32)
          ^bb3:  // pred: ^bb1
            scf.yield %20 : i32
          }
          scf.yield %18 : i32
        } else {
          scf.yield %8 : i32
        }
        scf.yield %17 : i32
      } else {
        scf.yield %8 : i32
      }
      %15 = scf.if %true -> (i32) {
        %17 = arith.addi %9, %c1_i32 : i32
        scf.yield %17 : i32
      } else {
        scf.yield %9 : i32
      }
      cf.br ^bb4(%14, %15 : i32, i32)
    ^bb6:  // pred: ^bb4
      %16 = arith.subi %4, %c1_i32 : i32
      cf.br ^bb1(%8, %9, %16 : i32, i32, i32)
    ^bb7:  // pred: ^bb1
      scf.yield
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b306df0) {
  "cf.br"()[^bb3] : () -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
    ** Erase   : 'cf.br'(0x7fbd9b306df0)
"" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  scf.if %true {
    %0 = llvm.mlir.undef : i32
    scf.execute_region {
      %1 = scf.if %true -> (i32) {
        %17 = memref.get_global @kbm3 : memref<1xi32>
        %18 = memref.load %17[%c0] : memref<1xi32>
        scf.yield %18 : i32
      } else {
        scf.yield %0 : i32
      }
      cf.br ^bb1(%0, %0, %1 : i32, i32, i32)
    ^bb1(%2: i32, %3: i32, %4: i32):  // 2 preds: ^bb0, ^bb5
      %5 = arith.cmpi sgt, %4, %c0_i32 : i32
      %6 = arith.andi %5, %true : i1
      cf.cond_br %6, ^bb2, ^bb6
    ^bb2:  // pred: ^bb1
      %7 = scf.if %true -> (i32) {
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %3 : i32
      }
      cf.br ^bb3(%2, %7 : i32, i32)
    ^bb3(%8: i32, %9: i32):  // 2 preds: ^bb2, ^bb4
      %10 = memref.get_global @jm : memref<1xi32>
      %11 = memref.load %10[%c0] : memref<1xi32>
      %12 = arith.cmpi slt, %9, %11 : i32
      %13 = arith.andi %12, %true : i1
      cf.cond_br %13, ^bb4, ^bb5
    ^bb4:  // pred: ^bb3
      %14 = scf.if %true -> (i32) {
        %17 = scf.if %true -> (i32) {
          %18 = scf.execute_region -> i32 {
            %19 = scf.if %true -> (i32) {
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %8 : i32
            }
            cf.br ^bb1(%19 : i32)
          ^bb1(%20: i32):  // 2 preds: ^bb0, ^bb2
            %21 = memref.get_global @im : memref<1xi32>
            %22 = memref.load %21[%c0] : memref<1xi32>
            %23 = arith.cmpi slt, %20, %22 : i32
            %24 = arith.andi %23, %true : i1
            cf.cond_br %24, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            scf.if %true {
              %26 = arith.muli %9, %22 : i32
              %27 = arith.addi %20, %26 : i32
              %28 = arith.muli %4, %22 : i32
              %29 = memref.load %10[%c0] : memref<1xi32>
              %30 = arith.muli %28, %29 : i32
              %31 = arith.addi %27, %30 : i32
              %32 = arith.index_cast %31 : i32 to index
              %33 = arith.subi %4, %c1_i32 : i32
              %34 = arith.muli %33, %22 : i32
              %35 = arith.muli %34, %29 : i32
              %36 = arith.addi %27, %35 : i32
              %37 = arith.index_cast %36 : i32 to index
              %38 = arith.addi %37, %c0 : index
              %39 = memref.load %arg0[%38] : memref<?xf32>
              %40 = arith.addi %32, %c0 : index
              memref.store %39, %arg2[%40] : memref<?xf32>
            }
            %25 = scf.if %true -> (i32) {
              %26 = arith.addi %20, %c1_i32 : i32
              scf.yield %26 : i32
            } else {
              scf.yield %20 : i32
            }
            cf.br ^bb1(%25 : i32)
          ^bb3:  // pred: ^bb1
            scf.yield %20 : i32
          }
          scf.yield %18 : i32
        } else {
          scf.yield %8 : i32
        }
        scf.yield %17 : i32
      } else {
        scf.yield %8 : i32
      }
      %15 = scf.if %true -> (i32) {
        %17 = arith.addi %9, %c1_i32 : i32
        scf.yield %17 : i32
      } else {
        scf.yield %9 : i32
      }
      cf.br ^bb3(%14, %15 : i32, i32)
    ^bb5:  // pred: ^bb3
      %16 = arith.subi %4, %c1_i32 : i32
      cf.br ^bb1(%8, %9, %16 : i32, i32, i32)
    ^bb6:  // pred: ^bb1
      scf.yield
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b004880) {
  "cf.br"(%18, %19)[^bb3] : (i32, i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9800f440) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
    ** Insert  : 'scf.if'(0x7fbd9816a370)
    ** Insert  : 'scf.yield'(0x7fbd98154ce0)
    ** Erase   : 'scf.yield'(0x7fbd9816a300)
    ** Erase   : 'scf.yield'(0x7fbd9800a090)
    ** Insert  : 'scf.yield'(0x7fbd98154ea0)
    ** Erase   : 'scf.yield'(0x7fbd9b3067d0)
    ** Erase   : 'scf.yield'(0x7fbd9800c500)
    ** Replace : 'scf.if'(0x7fbd9b3066b0)
    ** Replace : 'scf.if'(0x7fbd9800f440)
"(anonymous namespace)::CombineIfs" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  scf.if %true {
    %0 = llvm.mlir.undef : i32
    scf.execute_region {
      %1 = scf.if %true -> (i32) {
        %16 = memref.get_global @kbm3 : memref<1xi32>
        %17 = memref.load %16[%c0] : memref<1xi32>
        scf.yield %17 : i32
      } else {
        scf.yield %0 : i32
      }
      cf.br ^bb1(%0, %0, %1 : i32, i32, i32)
    ^bb1(%2: i32, %3: i32, %4: i32):  // 2 preds: ^bb0, ^bb5
      %5 = arith.cmpi sgt, %4, %c0_i32 : i32
      %6 = arith.andi %5, %true : i1
      cf.cond_br %6, ^bb2, ^bb6
    ^bb2:  // pred: ^bb1
      %7 = scf.if %true -> (i32) {
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %3 : i32
      }
      cf.br ^bb3(%2, %7 : i32, i32)
    ^bb3(%8: i32, %9: i32):  // 2 preds: ^bb2, ^bb4
      %10 = memref.get_global @jm : memref<1xi32>
      %11 = memref.load %10[%c0] : memref<1xi32>
      %12 = arith.cmpi slt, %9, %11 : i32
      %13 = arith.andi %12, %true : i1
      cf.cond_br %13, ^bb4, ^bb5
    ^bb4:  // pred: ^bb3
      %14:2 = scf.if %true -> (i32, i32) {
        %16 = scf.if %true -> (i32) {
          %18 = scf.execute_region -> i32 {
            %19 = scf.if %true -> (i32) {
              scf.yield %c0_i32 : i32
            } else {
              scf.yield %8 : i32
            }
            cf.br ^bb1(%19 : i32)
          ^bb1(%20: i32):  // 2 preds: ^bb0, ^bb2
            %21 = memref.get_global @im : memref<1xi32>
            %22 = memref.load %21[%c0] : memref<1xi32>
            %23 = arith.cmpi slt, %20, %22 : i32
            %24 = arith.andi %23, %true : i1
            cf.cond_br %24, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            scf.if %true {
              %26 = arith.muli %9, %22 : i32
              %27 = arith.addi %20, %26 : i32
              %28 = arith.muli %4, %22 : i32
              %29 = memref.load %10[%c0] : memref<1xi32>
              %30 = arith.muli %28, %29 : i32
              %31 = arith.addi %27, %30 : i32
              %32 = arith.index_cast %31 : i32 to index
              %33 = arith.subi %4, %c1_i32 : i32
              %34 = arith.muli %33, %22 : i32
              %35 = arith.muli %34, %29 : i32
              %36 = arith.addi %27, %35 : i32
              %37 = arith.index_cast %36 : i32 to index
              %38 = arith.addi %37, %c0 : index
              %39 = memref.load %arg0[%38] : memref<?xf32>
              %40 = arith.addi %32, %c0 : index
              memref.store %39, %arg2[%40] : memref<?xf32>
            }
            %25 = scf.if %true -> (i32) {
              %26 = arith.addi %20, %c1_i32 : i32
              scf.yield %26 : i32
            } else {
              scf.yield %20 : i32
            }
            cf.br ^bb1(%25 : i32)
          ^bb3:  // pred: ^bb1
            scf.yield %20 : i32
          }
          scf.yield %18 : i32
        } else {
          scf.yield %8 : i32
        }
        %17 = arith.addi %9, %c1_i32 : i32
        scf.yield %16, %17 : i32, i32
      } else {
        scf.yield %8, %9 : i32, i32
      }
      cf.br ^bb3(%14#0, %14#1 : i32, i32)
    ^bb5:  // pred: ^bb3
      %15 = arith.subi %4, %c1_i32 : i32
      cf.br ^bb1(%8, %9, %15 : i32, i32, i32)
    ^bb6:  // pred: ^bb1
      scf.yield
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b004880) {
  "cf.br"(%18#0, %18#1)[^bb3] : (i32, i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd98154ea0) {
  "scf.yield"(%12, %13) : (i32, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd98154ce0) {
  "scf.yield"(%20, %21) : (i32, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9816a370) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
    ** Replace : 'scf.if'(0x7fbd9816a370)
    ** Erase   : 'scf.yield'(0x7fbd98154ce0)
"(anonymous namespace)::RemoveStaticCondition" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  scf.if %true {
    %0 = llvm.mlir.undef : i32
    scf.execute_region {
      %1 = scf.if %true -> (i32) {
        %17 = memref.get_global @kbm3 : memref<1xi32>
        %18 = memref.load %17[%c0] : memref<1xi32>
        scf.yield %18 : i32
      } else {
        scf.yield %0 : i32
      }
      cf.br ^bb1(%0, %0, %1 : i32, i32, i32)
    ^bb1(%2: i32, %3: i32, %4: i32):  // 2 preds: ^bb0, ^bb5
      %5 = arith.cmpi sgt, %4, %c0_i32 : i32
      %6 = arith.andi %5, %true : i1
      cf.cond_br %6, ^bb2, ^bb6
    ^bb2:  // pred: ^bb1
      %7 = scf.if %true -> (i32) {
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %3 : i32
      }
      cf.br ^bb3(%2, %7 : i32, i32)
    ^bb3(%8: i32, %9: i32):  // 2 preds: ^bb2, ^bb4
      %10 = memref.get_global @jm : memref<1xi32>
      %11 = memref.load %10[%c0] : memref<1xi32>
      %12 = arith.cmpi slt, %9, %11 : i32
      %13 = arith.andi %12, %true : i1
      cf.cond_br %13, ^bb4, ^bb5
    ^bb4:  // pred: ^bb3
      %14 = scf.if %true -> (i32) {
        %17 = scf.execute_region -> i32 {
          %18 = scf.if %true -> (i32) {
            scf.yield %c0_i32 : i32
          } else {
            scf.yield %8 : i32
          }
          cf.br ^bb1(%18 : i32)
        ^bb1(%19: i32):  // 2 preds: ^bb0, ^bb2
          %20 = memref.get_global @im : memref<1xi32>
          %21 = memref.load %20[%c0] : memref<1xi32>
          %22 = arith.cmpi slt, %19, %21 : i32
          %23 = arith.andi %22, %true : i1
          cf.cond_br %23, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          scf.if %true {
            %25 = arith.muli %9, %21 : i32
            %26 = arith.addi %19, %25 : i32
            %27 = arith.muli %4, %21 : i32
            %28 = memref.load %10[%c0] : memref<1xi32>
            %29 = arith.muli %27, %28 : i32
            %30 = arith.addi %26, %29 : i32
            %31 = arith.index_cast %30 : i32 to index
            %32 = arith.subi %4, %c1_i32 : i32
            %33 = arith.muli %32, %21 : i32
            %34 = arith.muli %33, %28 : i32
            %35 = arith.addi %26, %34 : i32
            %36 = arith.index_cast %35 : i32 to index
            %37 = arith.addi %36, %c0 : index
            %38 = memref.load %arg0[%37] : memref<?xf32>
            %39 = arith.addi %31, %c0 : index
            memref.store %38, %arg2[%39] : memref<?xf32>
          }
          %24 = scf.if %true -> (i32) {
            %25 = arith.addi %19, %c1_i32 : i32
            scf.yield %25 : i32
          } else {
            scf.yield %19 : i32
          }
          cf.br ^bb1(%24 : i32)
        ^bb3:  // pred: ^bb1
          scf.yield %19 : i32
        }
        scf.yield %17 : i32
      } else {
        scf.yield %8 : i32
      }
      %15 = arith.addi %9, %c1_i32 : i32
      cf.br ^bb3(%14, %15 : i32, i32)
    ^bb5:  // pred: ^bb3
      %16 = arith.subi %4, %c1_i32 : i32
      cf.br ^bb1(%8, %9, %16 : i32, i32, i32)
    ^bb6:  // pred: ^bb1
      scf.yield
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b004880) {
  "cf.br"(%18, %19)[^bb3] : (i32, i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %19 = "arith.addi"(%13, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b3064c0) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
    ** Replace : 'scf.if'(0x7fbd9b3064c0)
    ** Erase   : 'scf.yield'(0x7fbd9816a590)
"(anonymous namespace)::RemoveStaticCondition" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  scf.if %true {
    %0 = llvm.mlir.undef : i32
    scf.execute_region {
      %1 = scf.if %true -> (i32) {
        %17 = memref.get_global @kbm3 : memref<1xi32>
        %18 = memref.load %17[%c0] : memref<1xi32>
        scf.yield %18 : i32
      } else {
        scf.yield %0 : i32
      }
      cf.br ^bb1(%0, %0, %1 : i32, i32, i32)
    ^bb1(%2: i32, %3: i32, %4: i32):  // 2 preds: ^bb0, ^bb5
      %5 = arith.cmpi sgt, %4, %c0_i32 : i32
      %6 = arith.andi %5, %true : i1
      cf.cond_br %6, ^bb2, ^bb6
    ^bb2:  // pred: ^bb1
      %7 = scf.if %true -> (i32) {
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %3 : i32
      }
      cf.br ^bb3(%2, %7 : i32, i32)
    ^bb3(%8: i32, %9: i32):  // 2 preds: ^bb2, ^bb4
      %10 = memref.get_global @jm : memref<1xi32>
      %11 = memref.load %10[%c0] : memref<1xi32>
      %12 = arith.cmpi slt, %9, %11 : i32
      %13 = arith.andi %12, %true : i1
      cf.cond_br %13, ^bb4, ^bb5
    ^bb4:  // pred: ^bb3
      %14 = scf.execute_region -> i32 {
        %17 = scf.if %true -> (i32) {
          scf.yield %c0_i32 : i32
        } else {
          scf.yield %8 : i32
        }
        cf.br ^bb1(%17 : i32)
      ^bb1(%18: i32):  // 2 preds: ^bb0, ^bb2
        %19 = memref.get_global @im : memref<1xi32>
        %20 = memref.load %19[%c0] : memref<1xi32>
        %21 = arith.cmpi slt, %18, %20 : i32
        %22 = arith.andi %21, %true : i1
        cf.cond_br %22, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        scf.if %true {
          %24 = arith.muli %9, %20 : i32
          %25 = arith.addi %18, %24 : i32
          %26 = arith.muli %4, %20 : i32
          %27 = memref.load %10[%c0] : memref<1xi32>
          %28 = arith.muli %26, %27 : i32
          %29 = arith.addi %25, %28 : i32
          %30 = arith.index_cast %29 : i32 to index
          %31 = arith.subi %4, %c1_i32 : i32
          %32 = arith.muli %31, %20 : i32
          %33 = arith.muli %32, %27 : i32
          %34 = arith.addi %25, %33 : i32
          %35 = arith.index_cast %34 : i32 to index
          %36 = arith.addi %35, %c0 : index
          %37 = memref.load %arg0[%36] : memref<?xf32>
          %38 = arith.addi %30, %c0 : index
          memref.store %37, %arg2[%38] : memref<?xf32>
        }
        %23 = scf.if %true -> (i32) {
          %24 = arith.addi %18, %c1_i32 : i32
          scf.yield %24 : i32
        } else {
          scf.yield %18 : i32
        }
        cf.br ^bb1(%23 : i32)
      ^bb3:  // pred: ^bb1
        scf.yield %18 : i32
      }
      %15 = arith.addi %9, %c1_i32 : i32
      cf.br ^bb3(%14, %15 : i32, i32)
    ^bb5:  // pred: ^bb3
      %16 = arith.subi %4, %c1_i32 : i32
      cf.br ^bb1(%8, %9, %16 : i32, i32, i32)
    ^bb6:  // pred: ^bb1
      scf.yield
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b004880) {
  "cf.br"(%18, %19)[^bb3] : (i32, i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.execute_region'(0x7fbd9b306330) {

  * Pattern SingleBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "SingleBlockExecuteInliner"
"SingleBlockExecuteInliner" result 0
  } -> failure : pattern failed to match

  * Pattern MultiBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "MultiBlockExecuteInliner"
    ** Insert  : 'cf.br'(0x7fbd9800e320)
    ** Insert  : 'cf.br'(0x7fbd9800ba90)
    ** Erase   : 'scf.yield'(0x7fbd9800a830)
    ** Replace : 'scf.execute_region'(0x7fbd9b306330)
"MultiBlockExecuteInliner" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  scf.if %true {
    %0 = llvm.mlir.undef : i32
    scf.execute_region {
      %1 = scf.if %true -> (i32) {
        %24 = memref.get_global @kbm3 : memref<1xi32>
        %25 = memref.load %24[%c0] : memref<1xi32>
        scf.yield %25 : i32
      } else {
        scf.yield %0 : i32
      }
      cf.br ^bb1(%0, %0, %1 : i32, i32, i32)
    ^bb1(%2: i32, %3: i32, %4: i32):  // 2 preds: ^bb0, ^bb10
      %5 = arith.cmpi sgt, %4, %c0_i32 : i32
      %6 = arith.andi %5, %true : i1
      cf.cond_br %6, ^bb2, ^bb11
    ^bb2:  // pred: ^bb1
      %7 = scf.if %true -> (i32) {
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %3 : i32
      }
      cf.br ^bb3(%2, %7 : i32, i32)
    ^bb3(%8: i32, %9: i32):  // 2 preds: ^bb2, ^bb9
      %10 = memref.get_global @jm : memref<1xi32>
      %11 = memref.load %10[%c0] : memref<1xi32>
      %12 = arith.cmpi slt, %9, %11 : i32
      %13 = arith.andi %12, %true : i1
      cf.cond_br %13, ^bb4, ^bb10
    ^bb4:  // pred: ^bb3
      cf.br ^bb5
    ^bb5:  // pred: ^bb4
      %14 = scf.if %true -> (i32) {
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %8 : i32
      }
      cf.br ^bb6(%14 : i32)
    ^bb6(%15: i32):  // 2 preds: ^bb5, ^bb7
      %16 = memref.get_global @im : memref<1xi32>
      %17 = memref.load %16[%c0] : memref<1xi32>
      %18 = arith.cmpi slt, %15, %17 : i32
      %19 = arith.andi %18, %true : i1
      cf.cond_br %19, ^bb7, ^bb8
    ^bb7:  // pred: ^bb6
      scf.if %true {
        %24 = arith.muli %9, %17 : i32
        %25 = arith.addi %15, %24 : i32
        %26 = arith.muli %4, %17 : i32
        %27 = memref.load %10[%c0] : memref<1xi32>
        %28 = arith.muli %26, %27 : i32
        %29 = arith.addi %25, %28 : i32
        %30 = arith.index_cast %29 : i32 to index
        %31 = arith.subi %4, %c1_i32 : i32
        %32 = arith.muli %31, %17 : i32
        %33 = arith.muli %32, %27 : i32
        %34 = arith.addi %25, %33 : i32
        %35 = arith.index_cast %34 : i32 to index
        %36 = arith.addi %35, %c0 : index
        %37 = memref.load %arg0[%36] : memref<?xf32>
        %38 = arith.addi %30, %c0 : index
        memref.store %37, %arg2[%38] : memref<?xf32>
      }
      %20 = scf.if %true -> (i32) {
        %24 = arith.addi %15, %c1_i32 : i32
        scf.yield %24 : i32
      } else {
        scf.yield %15 : i32
      }
      cf.br ^bb6(%20 : i32)
    ^bb8:  // pred: ^bb6
      cf.br ^bb9(%15 : i32)
    ^bb9(%21: i32):  // pred: ^bb8
      %22 = arith.addi %9, %c1_i32 : i32
      cf.br ^bb3(%21, %22 : i32, i32)
    ^bb10:  // pred: ^bb3
      %23 = arith.subi %4, %c1_i32 : i32
      cf.br ^bb1(%8, %9, %23 : i32, i32, i32)
    ^bb11:  // pred: ^bb1
      scf.yield
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b004880) {
  "cf.br"(%25, %26)[^bb3] : (i32, i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9800ba90) {
  "cf.br"(%19)[^bb9] : (i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
    ** Erase   : 'cf.br'(0x7fbd9800ba90)
"" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  scf.if %true {
    %0 = llvm.mlir.undef : i32
    scf.execute_region {
      %1 = scf.if %true -> (i32) {
        %23 = memref.get_global @kbm3 : memref<1xi32>
        %24 = memref.load %23[%c0] : memref<1xi32>
        scf.yield %24 : i32
      } else {
        scf.yield %0 : i32
      }
      cf.br ^bb1(%0, %0, %1 : i32, i32, i32)
    ^bb1(%2: i32, %3: i32, %4: i32):  // 2 preds: ^bb0, ^bb9
      %5 = arith.cmpi sgt, %4, %c0_i32 : i32
      %6 = arith.andi %5, %true : i1
      cf.cond_br %6, ^bb2, ^bb10
    ^bb2:  // pred: ^bb1
      %7 = scf.if %true -> (i32) {
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %3 : i32
      }
      cf.br ^bb3(%2, %7 : i32, i32)
    ^bb3(%8: i32, %9: i32):  // 2 preds: ^bb2, ^bb8
      %10 = memref.get_global @jm : memref<1xi32>
      %11 = memref.load %10[%c0] : memref<1xi32>
      %12 = arith.cmpi slt, %9, %11 : i32
      %13 = arith.andi %12, %true : i1
      cf.cond_br %13, ^bb4, ^bb9
    ^bb4:  // pred: ^bb3
      cf.br ^bb5
    ^bb5:  // pred: ^bb4
      %14 = scf.if %true -> (i32) {
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %8 : i32
      }
      cf.br ^bb6(%14 : i32)
    ^bb6(%15: i32):  // 2 preds: ^bb5, ^bb7
      %16 = memref.get_global @im : memref<1xi32>
      %17 = memref.load %16[%c0] : memref<1xi32>
      %18 = arith.cmpi slt, %15, %17 : i32
      %19 = arith.andi %18, %true : i1
      cf.cond_br %19, ^bb7, ^bb8
    ^bb7:  // pred: ^bb6
      scf.if %true {
        %23 = arith.muli %9, %17 : i32
        %24 = arith.addi %15, %23 : i32
        %25 = arith.muli %4, %17 : i32
        %26 = memref.load %10[%c0] : memref<1xi32>
        %27 = arith.muli %25, %26 : i32
        %28 = arith.addi %24, %27 : i32
        %29 = arith.index_cast %28 : i32 to index
        %30 = arith.subi %4, %c1_i32 : i32
        %31 = arith.muli %30, %17 : i32
        %32 = arith.muli %31, %26 : i32
        %33 = arith.addi %24, %32 : i32
        %34 = arith.index_cast %33 : i32 to index
        %35 = arith.addi %34, %c0 : index
        %36 = memref.load %arg0[%35] : memref<?xf32>
        %37 = arith.addi %29, %c0 : index
        memref.store %36, %arg2[%37] : memref<?xf32>
      }
      %20 = scf.if %true -> (i32) {
        %23 = arith.addi %15, %c1_i32 : i32
        scf.yield %23 : i32
      } else {
        scf.yield %15 : i32
      }
      cf.br ^bb6(%20 : i32)
    ^bb8:  // pred: ^bb6
      %21 = arith.addi %9, %c1_i32 : i32
      cf.br ^bb3(%15, %21 : i32, i32)
    ^bb9:  // pred: ^bb3
      %22 = arith.subi %4, %c1_i32 : i32
      cf.br ^bb1(%8, %9, %22 : i32, i32, i32)
    ^bb10:  // pred: ^bb1
      scf.yield
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9800e320) {
  "cf.br"()[^bb5] : () -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
    ** Erase   : 'cf.br'(0x7fbd9800e320)
"" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  scf.if %true {
    %0 = llvm.mlir.undef : i32
    scf.execute_region {
      %1 = scf.if %true -> (i32) {
        %23 = memref.get_global @kbm3 : memref<1xi32>
        %24 = memref.load %23[%c0] : memref<1xi32>
        scf.yield %24 : i32
      } else {
        scf.yield %0 : i32
      }
      cf.br ^bb1(%0, %0, %1 : i32, i32, i32)
    ^bb1(%2: i32, %3: i32, %4: i32):  // 2 preds: ^bb0, ^bb8
      %5 = arith.cmpi sgt, %4, %c0_i32 : i32
      %6 = arith.andi %5, %true : i1
      cf.cond_br %6, ^bb2, ^bb9
    ^bb2:  // pred: ^bb1
      %7 = scf.if %true -> (i32) {
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %3 : i32
      }
      cf.br ^bb3(%2, %7 : i32, i32)
    ^bb3(%8: i32, %9: i32):  // 2 preds: ^bb2, ^bb7
      %10 = memref.get_global @jm : memref<1xi32>
      %11 = memref.load %10[%c0] : memref<1xi32>
      %12 = arith.cmpi slt, %9, %11 : i32
      %13 = arith.andi %12, %true : i1
      cf.cond_br %13, ^bb4, ^bb8
    ^bb4:  // pred: ^bb3
      %14 = scf.if %true -> (i32) {
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %8 : i32
      }
      cf.br ^bb5(%14 : i32)
    ^bb5(%15: i32):  // 2 preds: ^bb4, ^bb6
      %16 = memref.get_global @im : memref<1xi32>
      %17 = memref.load %16[%c0] : memref<1xi32>
      %18 = arith.cmpi slt, %15, %17 : i32
      %19 = arith.andi %18, %true : i1
      cf.cond_br %19, ^bb6, ^bb7
    ^bb6:  // pred: ^bb5
      scf.if %true {
        %23 = arith.muli %9, %17 : i32
        %24 = arith.addi %15, %23 : i32
        %25 = arith.muli %4, %17 : i32
        %26 = memref.load %10[%c0] : memref<1xi32>
        %27 = arith.muli %25, %26 : i32
        %28 = arith.addi %24, %27 : i32
        %29 = arith.index_cast %28 : i32 to index
        %30 = arith.subi %4, %c1_i32 : i32
        %31 = arith.muli %30, %17 : i32
        %32 = arith.muli %31, %26 : i32
        %33 = arith.addi %24, %32 : i32
        %34 = arith.index_cast %33 : i32 to index
        %35 = arith.addi %34, %c0 : index
        %36 = memref.load %arg0[%35] : memref<?xf32>
        %37 = arith.addi %29, %c0 : index
        memref.store %36, %arg2[%37] : memref<?xf32>
      }
      %20 = scf.if %true -> (i32) {
        %23 = arith.addi %15, %c1_i32 : i32
        scf.yield %23 : i32
      } else {
        scf.yield %15 : i32
      }
      cf.br ^bb5(%20 : i32)
    ^bb7:  // pred: ^bb5
      %21 = arith.addi %9, %c1_i32 : i32
      cf.br ^bb3(%15, %21 : i32, i32)
    ^bb8:  // pred: ^bb3
      %22 = arith.subi %4, %c1_i32 : i32
      cf.br ^bb1(%8, %9, %22 : i32, i32, i32)
    ^bb9:  // pred: ^bb1
      scf.yield
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9800a0e0) {
  "cf.br"(%24)[^bb5] : (i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b306c60) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
    ** Insert  : 'scf.if'(0x7fbd981680b0)
    ** Insert  : 'scf.yield'(0x7fbd98167bf0)
    ** Erase   : 'scf.yield'(0x7fbd9816bd70)
    ** Erase   : 'scf.yield'(0x7fbd983051c0)
    ** Replace : 'scf.if'(0x7fbd9816bdc0)
    ** Replace : 'scf.if'(0x7fbd9b306c60)
"(anonymous namespace)::CombineIfs" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  scf.if %true {
    %0 = llvm.mlir.undef : i32
    scf.execute_region {
      %1 = scf.if %true -> (i32) {
        %23 = memref.get_global @kbm3 : memref<1xi32>
        %24 = memref.load %23[%c0] : memref<1xi32>
        scf.yield %24 : i32
      } else {
        scf.yield %0 : i32
      }
      cf.br ^bb1(%0, %0, %1 : i32, i32, i32)
    ^bb1(%2: i32, %3: i32, %4: i32):  // 2 preds: ^bb0, ^bb8
      %5 = arith.cmpi sgt, %4, %c0_i32 : i32
      %6 = arith.andi %5, %true : i1
      cf.cond_br %6, ^bb2, ^bb9
    ^bb2:  // pred: ^bb1
      %7 = scf.if %true -> (i32) {
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %3 : i32
      }
      cf.br ^bb3(%2, %7 : i32, i32)
    ^bb3(%8: i32, %9: i32):  // 2 preds: ^bb2, ^bb7
      %10 = memref.get_global @jm : memref<1xi32>
      %11 = memref.load %10[%c0] : memref<1xi32>
      %12 = arith.cmpi slt, %9, %11 : i32
      %13 = arith.andi %12, %true : i1
      cf.cond_br %13, ^bb4, ^bb8
    ^bb4:  // pred: ^bb3
      %14 = scf.if %true -> (i32) {
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %8 : i32
      }
      cf.br ^bb5(%14 : i32)
    ^bb5(%15: i32):  // 2 preds: ^bb4, ^bb6
      %16 = memref.get_global @im : memref<1xi32>
      %17 = memref.load %16[%c0] : memref<1xi32>
      %18 = arith.cmpi slt, %15, %17 : i32
      %19 = arith.andi %18, %true : i1
      cf.cond_br %19, ^bb6, ^bb7
    ^bb6:  // pred: ^bb5
      %20 = scf.if %true -> (i32) {
        %23 = arith.muli %9, %17 : i32
        %24 = arith.addi %15, %23 : i32
        %25 = arith.muli %4, %17 : i32
        %26 = memref.load %10[%c0] : memref<1xi32>
        %27 = arith.muli %25, %26 : i32
        %28 = arith.addi %24, %27 : i32
        %29 = arith.index_cast %28 : i32 to index
        %30 = arith.subi %4, %c1_i32 : i32
        %31 = arith.muli %30, %17 : i32
        %32 = arith.muli %31, %26 : i32
        %33 = arith.addi %24, %32 : i32
        %34 = arith.index_cast %33 : i32 to index
        %35 = arith.addi %34, %c0 : index
        %36 = memref.load %arg0[%35] : memref<?xf32>
        %37 = arith.addi %29, %c0 : index
        memref.store %36, %arg2[%37] : memref<?xf32>
        %38 = arith.addi %15, %c1_i32 : i32
        scf.yield %38 : i32
      } else {
        scf.yield %15 : i32
      }
      cf.br ^bb5(%20 : i32)
    ^bb7:  // pred: ^bb5
      %21 = arith.addi %9, %c1_i32 : i32
      cf.br ^bb3(%15, %21 : i32, i32)
    ^bb8:  // pred: ^bb3
      %22 = arith.subi %4, %c1_i32 : i32
      cf.br ^bb1(%8, %9, %22 : i32, i32, i32)
    ^bb9:  // pred: ^bb1
      scf.yield
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9800a0e0) {
  "cf.br"(%24)[^bb5] : (i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd98167bf0) {
  "scf.yield"(%42) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd981680b0) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
    ** Replace : 'scf.if'(0x7fbd981680b0)
    ** Erase   : 'scf.yield'(0x7fbd98167bf0)
"(anonymous namespace)::RemoveStaticCondition" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  scf.if %true {
    %0 = llvm.mlir.undef : i32
    scf.execute_region {
      %1 = scf.if %true -> (i32) {
        %38 = memref.get_global @kbm3 : memref<1xi32>
        %39 = memref.load %38[%c0] : memref<1xi32>
        scf.yield %39 : i32
      } else {
        scf.yield %0 : i32
      }
      cf.br ^bb1(%0, %0, %1 : i32, i32, i32)
    ^bb1(%2: i32, %3: i32, %4: i32):  // 2 preds: ^bb0, ^bb8
      %5 = arith.cmpi sgt, %4, %c0_i32 : i32
      %6 = arith.andi %5, %true : i1
      cf.cond_br %6, ^bb2, ^bb9
    ^bb2:  // pred: ^bb1
      %7 = scf.if %true -> (i32) {
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %3 : i32
      }
      cf.br ^bb3(%2, %7 : i32, i32)
    ^bb3(%8: i32, %9: i32):  // 2 preds: ^bb2, ^bb7
      %10 = memref.get_global @jm : memref<1xi32>
      %11 = memref.load %10[%c0] : memref<1xi32>
      %12 = arith.cmpi slt, %9, %11 : i32
      %13 = arith.andi %12, %true : i1
      cf.cond_br %13, ^bb4, ^bb8
    ^bb4:  // pred: ^bb3
      %14 = scf.if %true -> (i32) {
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %8 : i32
      }
      cf.br ^bb5(%14 : i32)
    ^bb5(%15: i32):  // 2 preds: ^bb4, ^bb6
      %16 = memref.get_global @im : memref<1xi32>
      %17 = memref.load %16[%c0] : memref<1xi32>
      %18 = arith.cmpi slt, %15, %17 : i32
      %19 = arith.andi %18, %true : i1
      cf.cond_br %19, ^bb6, ^bb7
    ^bb6:  // pred: ^bb5
      %20 = arith.muli %9, %17 : i32
      %21 = arith.addi %15, %20 : i32
      %22 = arith.muli %4, %17 : i32
      %23 = memref.load %10[%c0] : memref<1xi32>
      %24 = arith.muli %22, %23 : i32
      %25 = arith.addi %21, %24 : i32
      %26 = arith.index_cast %25 : i32 to index
      %27 = arith.subi %4, %c1_i32 : i32
      %28 = arith.muli %27, %17 : i32
      %29 = arith.muli %28, %23 : i32
      %30 = arith.addi %21, %29 : i32
      %31 = arith.index_cast %30 : i32 to index
      %32 = arith.addi %31, %c0 : index
      %33 = memref.load %arg0[%32] : memref<?xf32>
      %34 = arith.addi %26, %c0 : index
      memref.store %33, %arg2[%34] : memref<?xf32>
      %35 = arith.addi %15, %c1_i32 : i32
      cf.br ^bb5(%35 : i32)
    ^bb7:  // pred: ^bb5
      %36 = arith.addi %9, %c1_i32 : i32
      cf.br ^bb3(%15, %36 : i32, i32)
    ^bb8:  // pred: ^bb3
      %37 = arith.subi %4, %c1_i32 : i32
      cf.br ^bb1(%8, %9, %37 : i32, i32, i32)
    ^bb9:  // pred: ^bb1
      scf.yield
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9800a0e0) {
  "cf.br"(%39)[^bb5] : (i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %39 = "arith.addi"(%19, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%37, %arg2, %38) : (f32, memref<?xf32>, index) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98165e60) {
  %38 = "arith.addi"(%30, %3) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %37 = "memref.load"(%arg0, %36) : (memref<?xf32>, index) -> f32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b0040e0) {
  %36 = "arith.addi"(%35, %3) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd98304bd0) {
  %35 = "arith.index_cast"(%34) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98304b30) {
  %34 = "arith.addi"(%25, %33) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304a90) {
  %33 = "arith.muli"(%32, %27) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %32 = "arith.muli"(%31, %21) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd983045d0) {
  %31 = "arith.subi"(%8, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9816cb40) {
  %30 = "arith.index_cast"(%29) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816caa0) {
  %29 = "arith.addi"(%25, %28) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816ca00) {
  %28 = "arith.muli"(%26, %27) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816c960) {
  %27 = "memref.load"(%14, %3) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %26 = "arith.muli"(%8, %21) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %25 = "arith.addi"(%19, %24) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %24 = "arith.muli"(%13, %21) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd98168590) {
  "cf.cond_br"(%23)[^bb6, ^bb7] {operand_segment_sizes = array<i32: 1, 0, 0>} : (i1) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors"
"(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition"
"(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CondBranchTruthPropagation : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::CondBranchTruthPropagation"
"(anonymous namespace)::CondBranchTruthPropagation" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.andi'(0x7fbd9816ba50) {
  %23 = "arith.andi"(%22, %0) : (i1, i1) -> i1

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd98168590) {
  "cf.cond_br"(%22)[^bb6, ^bb7] {operand_segment_sizes = array<i32: 1, 0, 0>} : (i1) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors"
"(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition"
"(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CondBranchTruthPropagation : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::CondBranchTruthPropagation"
"(anonymous namespace)::CondBranchTruthPropagation" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %22 = "arith.cmpi"(%19, %21) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816b720) {
  %21 = "memref.load"(%20, %3) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9816b600) {
  %20 = "memref.get_global"() {name = @im} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9800f220) {
  "cf.br"(%18)[^bb5] : (i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b306e90) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
    ** Insert  : 'scf.yield'(0x7fbd9b0049d0)
    ** Insert  : 'scf.if'(0x7fbd9b004930)
    ** Erase   : 'scf.yield'(0x7fbd9b0049d0)
    ** Insert  : 'arith.select'(0x7fbd9b104130)
    ** Insert  : 'scf.yield'(0x7fbd9b104f20)
    ** Replace : 'scf.yield'(0x7fbd9816a830)
    ** Insert  : 'scf.yield'(0x7fbd9b104f70)
    ** Replace : 'scf.yield'(0x7fbd9b306fb0)
    ** Replace : 'scf.if'(0x7fbd9b306e90)
"(anonymous namespace)::ConvertTrivialIfToSelect" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  scf.if %true {
    %0 = llvm.mlir.undef : i32
    scf.execute_region {
      %1 = scf.if %true -> (i32) {
        %37 = memref.get_global @kbm3 : memref<1xi32>
        %38 = memref.load %37[%c0] : memref<1xi32>
        scf.yield %38 : i32
      } else {
        scf.yield %0 : i32
      }
      cf.br ^bb1(%0, %0, %1 : i32, i32, i32)
    ^bb1(%2: i32, %3: i32, %4: i32):  // 2 preds: ^bb0, ^bb8
      %5 = arith.cmpi sgt, %4, %c0_i32 : i32
      %6 = arith.andi %5, %true : i1
      cf.cond_br %6, ^bb2, ^bb9
    ^bb2:  // pred: ^bb1
      %7 = scf.if %true -> (i32) {
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %3 : i32
      }
      cf.br ^bb3(%2, %7 : i32, i32)
    ^bb3(%8: i32, %9: i32):  // 2 preds: ^bb2, ^bb7
      %10 = memref.get_global @jm : memref<1xi32>
      %11 = memref.load %10[%c0] : memref<1xi32>
      %12 = arith.cmpi slt, %9, %11 : i32
      %13 = arith.andi %12, %true : i1
      cf.cond_br %13, ^bb4, ^bb8
    ^bb4:  // pred: ^bb3
      %14 = arith.select %true, %c0_i32, %8 : i32
      scf.if %true {
      } else {
      }
      cf.br ^bb5(%14 : i32)
    ^bb5(%15: i32):  // 2 preds: ^bb4, ^bb6
      %16 = memref.get_global @im : memref<1xi32>
      %17 = memref.load %16[%c0] : memref<1xi32>
      %18 = arith.cmpi slt, %15, %17 : i32
      cf.cond_br %18, ^bb6, ^bb7
    ^bb6:  // pred: ^bb5
      %19 = arith.muli %9, %17 : i32
      %20 = arith.addi %15, %19 : i32
      %21 = arith.muli %4, %17 : i32
      %22 = memref.load %10[%c0] : memref<1xi32>
      %23 = arith.muli %21, %22 : i32
      %24 = arith.addi %20, %23 : i32
      %25 = arith.index_cast %24 : i32 to index
      %26 = arith.subi %4, %c1_i32 : i32
      %27 = arith.muli %26, %17 : i32
      %28 = arith.muli %27, %22 : i32
      %29 = arith.addi %20, %28 : i32
      %30 = arith.index_cast %29 : i32 to index
      %31 = arith.addi %30, %c0 : index
      %32 = memref.load %arg0[%31] : memref<?xf32>
      %33 = arith.addi %25, %c0 : index
      memref.store %32, %arg2[%33] : memref<?xf32>
      %34 = arith.addi %15, %c1_i32 : i32
      cf.br ^bb5(%34 : i32)
    ^bb7:  // pred: ^bb5
      %35 = arith.addi %9, %c1_i32 : i32
      cf.br ^bb3(%15, %35 : i32, i32)
    ^bb8:  // pred: ^bb3
      %36 = arith.subi %4, %c1_i32 : i32
      cf.br ^bb1(%8, %9, %36 : i32, i32, i32)
    ^bb9:  // pred: ^bb1
      scf.yield
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9800f220) {
  "cf.br"(%18)[^bb5] : (i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b104f70) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b104f20) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.select'(0x7fbd9b104130) {
  %18 = "arith.select"(%0, %2, %12) : (i1, i32, i32) -> i32

ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NOperands<3>::Impl<Empty>)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9800f220) {
  "cf.br"(%2)[^bb5] : (i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b004930) {
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd9b004c20) {
  "cf.cond_br"(%17)[^bb4, ^bb8] {operand_segment_sizes = array<i32: 1, 0, 0>} : (i1) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
    ** Insert  : 'cf.cond_br'(0x7fbd96f18d20)
    ** Replace : 'cf.cond_br'(0x7fbd9b004c20)
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  scf.if %true {
    %0 = llvm.mlir.undef : i32
    scf.execute_region {
      %1 = scf.if %true -> (i32) {
        %36 = memref.get_global @kbm3 : memref<1xi32>
        %37 = memref.load %36[%c0] : memref<1xi32>
        scf.yield %37 : i32
      } else {
        scf.yield %0 : i32
      }
      cf.br ^bb1(%0, %0, %1 : i32, i32, i32)
    ^bb1(%2: i32, %3: i32, %4: i32):  // 2 preds: ^bb0, ^bb8
      %5 = arith.cmpi sgt, %4, %c0_i32 : i32
      %6 = arith.andi %5, %true : i1
      cf.cond_br %6, ^bb2, ^bb9
    ^bb2:  // pred: ^bb1
      %7 = scf.if %true -> (i32) {
        scf.yield %c0_i32 : i32
      } else {
        scf.yield %3 : i32
      }
      cf.br ^bb3(%2, %7 : i32, i32)
    ^bb3(%8: i32, %9: i32):  // 2 preds: ^bb2, ^bb7
      %10 = memref.get_global @jm : memref<1xi32>
      %11 = memref.load %10[%c0] : memref<1xi32>
      %12 = arith.cmpi slt, %9, %11 : i32
      %13 = arith.andi %12, %true : i1
      cf.cond_br %13, ^bb5(%c0_i32 : i32), ^bb8
    ^bb4:  // no predecessors
      cf.br ^bb5(%c0_i32 : i32)
    ^bb5(%14: i32):  // 3 preds: ^bb3, ^bb4, ^bb6
      %15 = memref.get_global @im : memref<1xi32>
      %16 = memref.load %15[%c0] : memref<1xi32>
      %17 = arith.cmpi slt, %14, %16 : i32
      cf.cond_br %17, ^bb6, ^bb7
    ^bb6:  // pred: ^bb5
      %18 = arith.muli %9, %16 : i32
      %19 = arith.addi %14, %18 : i32
      %20 = arith.muli %4, %16 : i32
      %21 = memref.load %10[%c0] : memref<1xi32>
      %22 = arith.muli %20, %21 : i32
      %23 = arith.addi %19, %22 : i32
      %24 = arith.index_cast %23 : i32 to index
      %25 = arith.subi %4, %c1_i32 : i32
      %26 = arith.muli %25, %16 : i32
      %27 = arith.muli %26, %21 : i32
      %28 = arith.addi %19, %27 : i32
      %29 = arith.index_cast %28 : i32 to index
      %30 = arith.addi %29, %c0 : index
      %31 = memref.load %arg0[%30] : memref<?xf32>
      %32 = arith.addi %24, %c0 : index
      memref.store %31, %arg2[%32] : memref<?xf32>
      %33 = arith.addi %14, %c1_i32 : i32
      cf.br ^bb5(%33 : i32)
    ^bb7:  // pred: ^bb5
      %34 = arith.addi %9, %c1_i32 : i32
      cf.br ^bb3(%14, %34 : i32, i32)
    ^bb8:  // pred: ^bb3
      %35 = arith.subi %4, %c1_i32 : i32
      cf.br ^bb1(%8, %9, %35 : i32, i32, i32)
    ^bb9:  // pred: ^bb1
      scf.yield
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd96f18d20) {
  "cf.cond_br"(%17, %2)[^bb5, ^bb8] {operand_segment_sizes = array<i32: 1, 1, 0>} : (i1, i32) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors"
"(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition"
"(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CondBranchTruthPropagation : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::CondBranchTruthPropagation"
"(anonymous namespace)::CondBranchTruthPropagation" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.andi'(0x7fbd98169fa0) {
  %17 = "arith.andi"(%16, %0) : (i1, i1) -> i1

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd96f18d20) {
  "cf.cond_br"(%16, %2)[^bb5, ^bb8] {operand_segment_sizes = array<i32: 1, 1, 0>} : (i1, i32) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors"
"(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition"
"(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CondBranchTruthPropagation : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::CondBranchTruthPropagation"
"(anonymous namespace)::CondBranchTruthPropagation" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %16 = "arith.cmpi"(%13, %15) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98169b40) {
  %15 = "memref.load"(%14, %3) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd98169a20) {
  %14 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b004b50) {
  "cf.br"(%6, %11)[^bb3] : (i32, i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9800c200) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
    ** Insert  : 'scf.yield'(0x7fbd9800e320)
    ** Insert  : 'scf.if'(0x7fbd9800a030)
    ** Erase   : 'scf.yield'(0x7fbd9800e320)
    ** Insert  : 'arith.select'(0x7fbd9800bbe0)
    ** Insert  : 'scf.yield'(0x7fbd9800bd80)
    ** Replace : 'scf.yield'(0x7fbd98168e70)
    ** Insert  : 'scf.yield'(0x7fbd9800e320)
    ** Replace : 'scf.yield'(0x7fbd9800c2a0)
    ** Replace : 'scf.if'(0x7fbd9800c200)
"(anonymous namespace)::ConvertTrivialIfToSelect" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  scf.if %true {
    %0 = llvm.mlir.undef : i32
    scf.execute_region {
      %1 = scf.if %true -> (i32) {
        %35 = memref.get_global @kbm3 : memref<1xi32>
        %36 = memref.load %35[%c0] : memref<1xi32>
        scf.yield %36 : i32
      } else {
        scf.yield %0 : i32
      }
      cf.br ^bb1(%0, %0, %1 : i32, i32, i32)
    ^bb1(%2: i32, %3: i32, %4: i32):  // 2 preds: ^bb0, ^bb8
      %5 = arith.cmpi sgt, %4, %c0_i32 : i32
      %6 = arith.andi %5, %true : i1
      cf.cond_br %6, ^bb2, ^bb9
    ^bb2:  // pred: ^bb1
      %7 = arith.select %true, %c0_i32, %3 : i32
      scf.if %true {
      } else {
      }
      cf.br ^bb3(%2, %7 : i32, i32)
    ^bb3(%8: i32, %9: i32):  // 2 preds: ^bb2, ^bb7
      %10 = memref.get_global @jm : memref<1xi32>
      %11 = memref.load %10[%c0] : memref<1xi32>
      %12 = arith.cmpi slt, %9, %11 : i32
      cf.cond_br %12, ^bb5(%c0_i32 : i32), ^bb8
    ^bb4:  // no predecessors
      cf.br ^bb5(%c0_i32 : i32)
    ^bb5(%13: i32):  // 3 preds: ^bb3, ^bb4, ^bb6
      %14 = memref.get_global @im : memref<1xi32>
      %15 = memref.load %14[%c0] : memref<1xi32>
      %16 = arith.cmpi slt, %13, %15 : i32
      cf.cond_br %16, ^bb6, ^bb7
    ^bb6:  // pred: ^bb5
      %17 = arith.muli %9, %15 : i32
      %18 = arith.addi %13, %17 : i32
      %19 = arith.muli %4, %15 : i32
      %20 = memref.load %10[%c0] : memref<1xi32>
      %21 = arith.muli %19, %20 : i32
      %22 = arith.addi %18, %21 : i32
      %23 = arith.index_cast %22 : i32 to index
      %24 = arith.subi %4, %c1_i32 : i32
      %25 = arith.muli %24, %15 : i32
      %26 = arith.muli %25, %20 : i32
      %27 = arith.addi %18, %26 : i32
      %28 = arith.index_cast %27 : i32 to index
      %29 = arith.addi %28, %c0 : index
      %30 = memref.load %arg0[%29] : memref<?xf32>
      %31 = arith.addi %23, %c0 : index
      memref.store %30, %arg2[%31] : memref<?xf32>
      %32 = arith.addi %13, %c1_i32 : i32
      cf.br ^bb5(%32 : i32)
    ^bb7:  // pred: ^bb5
      %33 = arith.addi %9, %c1_i32 : i32
      cf.br ^bb3(%13, %33 : i32, i32)
    ^bb8:  // pred: ^bb3
      %34 = arith.subi %4, %c1_i32 : i32
      cf.br ^bb1(%8, %9, %34 : i32, i32, i32)
    ^bb9:  // pred: ^bb1
      scf.yield
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b004b50) {
  "cf.br"(%6, %11)[^bb3] : (i32, i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9800e320) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9800bd80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.select'(0x7fbd9800bbe0) {
  %11 = "arith.select"(%0, %2, %7) : (i1, i32, i32) -> i32

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b004b50) {
  "cf.br"(%6, %2)[^bb3] : (i32, i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9800a030) {
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd9b105120) {
  "cf.cond_br"(%10)[^bb2, ^bb9] {operand_segment_sizes = array<i32: 1, 0, 0>} : (i1) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
    ** Insert  : 'cf.cond_br'(0x7fbd9b004930)
    ** Replace : 'cf.cond_br'(0x7fbd9b105120)
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  scf.if %true {
    %0 = llvm.mlir.undef : i32
    scf.execute_region {
      %1 = scf.if %true -> (i32) {
        %34 = memref.get_global @kbm3 : memref<1xi32>
        %35 = memref.load %34[%c0] : memref<1xi32>
        scf.yield %35 : i32
      } else {
        scf.yield %0 : i32
      }
      cf.br ^bb1(%0, %0, %1 : i32, i32, i32)
    ^bb1(%2: i32, %3: i32, %4: i32):  // 2 preds: ^bb0, ^bb8
      %5 = arith.cmpi sgt, %4, %c0_i32 : i32
      %6 = arith.andi %5, %true : i1
      cf.cond_br %6, ^bb3(%2, %c0_i32 : i32, i32), ^bb9
    ^bb2:  // no predecessors
      cf.br ^bb3(%2, %c0_i32 : i32, i32)
    ^bb3(%7: i32, %8: i32):  // 3 preds: ^bb1, ^bb2, ^bb7
      %9 = memref.get_global @jm : memref<1xi32>
      %10 = memref.load %9[%c0] : memref<1xi32>
      %11 = arith.cmpi slt, %8, %10 : i32
      cf.cond_br %11, ^bb5(%c0_i32 : i32), ^bb8
    ^bb4:  // no predecessors
      cf.br ^bb5(%c0_i32 : i32)
    ^bb5(%12: i32):  // 3 preds: ^bb3, ^bb4, ^bb6
      %13 = memref.get_global @im : memref<1xi32>
      %14 = memref.load %13[%c0] : memref<1xi32>
      %15 = arith.cmpi slt, %12, %14 : i32
      cf.cond_br %15, ^bb6, ^bb7
    ^bb6:  // pred: ^bb5
      %16 = arith.muli %8, %14 : i32
      %17 = arith.addi %12, %16 : i32
      %18 = arith.muli %4, %14 : i32
      %19 = memref.load %9[%c0] : memref<1xi32>
      %20 = arith.muli %18, %19 : i32
      %21 = arith.addi %17, %20 : i32
      %22 = arith.index_cast %21 : i32 to index
      %23 = arith.subi %4, %c1_i32 : i32
      %24 = arith.muli %23, %14 : i32
      %25 = arith.muli %24, %19 : i32
      %26 = arith.addi %17, %25 : i32
      %27 = arith.index_cast %26 : i32 to index
      %28 = arith.addi %27, %c0 : index
      %29 = memref.load %arg0[%28] : memref<?xf32>
      %30 = arith.addi %22, %c0 : index
      memref.store %29, %arg2[%30] : memref<?xf32>
      %31 = arith.addi %12, %c1_i32 : i32
      cf.br ^bb5(%31 : i32)
    ^bb7:  // pred: ^bb5
      %32 = arith.addi %8, %c1_i32 : i32
      cf.br ^bb3(%12, %32 : i32, i32)
    ^bb8:  // pred: ^bb3
      %33 = arith.subi %4, %c1_i32 : i32
      cf.br ^bb1(%7, %8, %33 : i32, i32, i32)
    ^bb9:  // pred: ^bb1
      scf.yield
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd9b004930) {
  "cf.cond_br"(%10, %6, %2)[^bb3, ^bb9] {operand_segment_sizes = array<i32: 1, 2, 0>} : (i1, i32, i32) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors"
"(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition"
"(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CondBranchTruthPropagation : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::CondBranchTruthPropagation"
"(anonymous namespace)::CondBranchTruthPropagation" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.andi'(0x7fbd981683d0) {
  %10 = "arith.andi"(%9, %0) : (i1, i1) -> i1

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd9b004930) {
  "cf.cond_br"(%9, %6, %2)[^bb3, ^bb9] {operand_segment_sizes = array<i32: 1, 2, 0>} : (i1, i32, i32) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors"
"(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition"
"(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CondBranchTruthPropagation : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::CondBranchTruthPropagation"
"(anonymous namespace)::CondBranchTruthPropagation" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98168010) {
  %9 = "arith.cmpi"(%8, %2) {predicate = 4 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b104d60) {
  "cf.br"(%4, %4, %5)[^bb1] : (i32, i32, i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9800bca0) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
    ** Replace : 'scf.if'(0x7fbd9800bca0)
    ** Erase   : 'scf.yield'(0x7fbd98166cb0)
"(anonymous namespace)::RemoveStaticCondition" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  scf.if %true {
    %0 = llvm.mlir.undef : i32
    scf.execute_region {
      %1 = memref.get_global @kbm3 : memref<1xi32>
      %2 = memref.load %1[%c0] : memref<1xi32>
      cf.br ^bb1(%0, %0, %2 : i32, i32, i32)
    ^bb1(%3: i32, %4: i32, %5: i32):  // 2 preds: ^bb0, ^bb8
      %6 = arith.cmpi sgt, %5, %c0_i32 : i32
      cf.cond_br %6, ^bb3(%3, %c0_i32 : i32, i32), ^bb9
    ^bb2:  // no predecessors
      cf.br ^bb3(%3, %c0_i32 : i32, i32)
    ^bb3(%7: i32, %8: i32):  // 3 preds: ^bb1, ^bb2, ^bb7
      %9 = memref.get_global @jm : memref<1xi32>
      %10 = memref.load %9[%c0] : memref<1xi32>
      %11 = arith.cmpi slt, %8, %10 : i32
      cf.cond_br %11, ^bb5(%c0_i32 : i32), ^bb8
    ^bb4:  // no predecessors
      cf.br ^bb5(%c0_i32 : i32)
    ^bb5(%12: i32):  // 3 preds: ^bb3, ^bb4, ^bb6
      %13 = memref.get_global @im : memref<1xi32>
      %14 = memref.load %13[%c0] : memref<1xi32>
      %15 = arith.cmpi slt, %12, %14 : i32
      cf.cond_br %15, ^bb6, ^bb7
    ^bb6:  // pred: ^bb5
      %16 = arith.muli %8, %14 : i32
      %17 = arith.addi %12, %16 : i32
      %18 = arith.muli %5, %14 : i32
      %19 = memref.load %9[%c0] : memref<1xi32>
      %20 = arith.muli %18, %19 : i32
      %21 = arith.addi %17, %20 : i32
      %22 = arith.index_cast %21 : i32 to index
      %23 = arith.subi %5, %c1_i32 : i32
      %24 = arith.muli %23, %14 : i32
      %25 = arith.muli %24, %19 : i32
      %26 = arith.addi %17, %25 : i32
      %27 = arith.index_cast %26 : i32 to index
      %28 = arith.addi %27, %c0 : index
      %29 = memref.load %arg0[%28] : memref<?xf32>
      %30 = arith.addi %22, %c0 : index
      memref.store %29, %arg2[%30] : memref<?xf32>
      %31 = arith.addi %12, %c1_i32 : i32
      cf.br ^bb5(%31 : i32)
    ^bb7:  // pred: ^bb5
      %32 = arith.addi %8, %c1_i32 : i32
      cf.br ^bb3(%12, %32 : i32, i32)
    ^bb8:  // pred: ^bb3
      %33 = arith.subi %5, %c1_i32 : i32
      cf.br ^bb1(%7, %8, %33 : i32, i32, i32)
    ^bb9:  // pred: ^bb1
      scf.yield
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b104d60) {
  "cf.br"(%4, %4, %6)[^bb1] : (i32, i32, i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98167510) {
  %6 = "memref.load"(%5, %3) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd981673f0) {
  %5 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llvm.mlir.undef'(0x7fbd9816adc0) {
  %4 = "llvm.mlir.undef"() : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9816cc60) {
  %3 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98167e90) {
  %2 = "arith.constant"() {value = 0 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98304580) {
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98166480) {
  %0 = "arith.constant"() {value = true} : () -> i1

} -> failure : pattern failed to match
//===-------------------------------------------===//
** Erase   : 'cf.br'(0x7fbd9b004b50)
** Erase   : 'cf.br'(0x7fbd9800f220)
** Erase   : 'llvm.mlir.undef'(0x7fbd9816adc0)

//===-------------------------------------------===//
Processing operation : 'func.return'(0x7fbd9800c610) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b104080) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
    ** Replace : 'scf.if'(0x7fbd9b104080)
    ** Erase   : 'scf.yield'(0x7fbd9b104ed0)
"(anonymous namespace)::RemoveStaticCondition" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  scf.execute_region {
    %0 = memref.get_global @kbm3 : memref<1xi32>
    %1 = memref.load %0[%c0] : memref<1xi32>
    cf.br ^bb1(%1 : i32)
  ^bb1(%2: i32):  // 2 preds: ^bb0, ^bb6
    %3 = arith.cmpi sgt, %2, %c0_i32 : i32
    cf.cond_br %3, ^bb2(%c0_i32 : i32), ^bb7
  ^bb2(%4: i32):  // 2 preds: ^bb1, ^bb5
    %5 = memref.get_global @jm : memref<1xi32>
    %6 = memref.load %5[%c0] : memref<1xi32>
    %7 = arith.cmpi slt, %4, %6 : i32
    cf.cond_br %7, ^bb3(%c0_i32 : i32), ^bb6
  ^bb3(%8: i32):  // 2 preds: ^bb2, ^bb4
    %9 = memref.get_global @im : memref<1xi32>
    %10 = memref.load %9[%c0] : memref<1xi32>
    %11 = arith.cmpi slt, %8, %10 : i32
    cf.cond_br %11, ^bb4, ^bb5
  ^bb4:  // pred: ^bb3
    %12 = arith.muli %4, %10 : i32
    %13 = arith.addi %8, %12 : i32
    %14 = arith.muli %2, %10 : i32
    %15 = memref.load %5[%c0] : memref<1xi32>
    %16 = arith.muli %14, %15 : i32
    %17 = arith.addi %13, %16 : i32
    %18 = arith.index_cast %17 : i32 to index
    %19 = arith.subi %2, %c1_i32 : i32
    %20 = arith.muli %19, %10 : i32
    %21 = arith.muli %20, %15 : i32
    %22 = arith.addi %13, %21 : i32
    %23 = arith.index_cast %22 : i32 to index
    %24 = arith.addi %23, %c0 : index
    %25 = memref.load %arg0[%24] : memref<?xf32>
    %26 = arith.addi %18, %c0 : index
    memref.store %25, %arg2[%26] : memref<?xf32>
    %27 = arith.addi %8, %c1_i32 : i32
    cf.br ^bb3(%27 : i32)
  ^bb5:  // pred: ^bb3
    %28 = arith.addi %4, %c1_i32 : i32
    cf.br ^bb2(%28 : i32)
  ^bb6:  // pred: ^bb2
    %29 = arith.subi %2, %c1_i32 : i32
    cf.br ^bb1(%29 : i32)
  ^bb7:  // pred: ^bb1
    scf.yield
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.execute_region'(0x7fbd98166b30) {

  * Pattern SingleBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "SingleBlockExecuteInliner"
"SingleBlockExecuteInliner" result 0
  } -> failure : pattern failed to match

  * Pattern MultiBlockExecuteInliner : 'scf.execute_region -> ()' {
Trying to match "MultiBlockExecuteInliner"
    ** Insert  : 'cf.br'(0x7fbd9b104ed0)
    ** Insert  : 'cf.br'(0x7fbd9b104f40)
    ** Erase   : 'scf.yield'(0x7fbd9800c570)
    ** Replace : 'scf.execute_region'(0x7fbd98166b30)
"MultiBlockExecuteInliner" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  cf.br ^bb1
^bb1:  // pred: ^bb0
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = memref.load %0[%c0] : memref<1xi32>
  cf.br ^bb2(%1 : i32)
^bb2(%2: i32):  // 2 preds: ^bb1, ^bb7
  %3 = arith.cmpi sgt, %2, %c0_i32 : i32
  cf.cond_br %3, ^bb3(%c0_i32 : i32), ^bb8
^bb3(%4: i32):  // 2 preds: ^bb2, ^bb6
  %5 = memref.get_global @jm : memref<1xi32>
  %6 = memref.load %5[%c0] : memref<1xi32>
  %7 = arith.cmpi slt, %4, %6 : i32
  cf.cond_br %7, ^bb4(%c0_i32 : i32), ^bb7
^bb4(%8: i32):  // 2 preds: ^bb3, ^bb5
  %9 = memref.get_global @im : memref<1xi32>
  %10 = memref.load %9[%c0] : memref<1xi32>
  %11 = arith.cmpi slt, %8, %10 : i32
  cf.cond_br %11, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %12 = arith.muli %4, %10 : i32
  %13 = arith.addi %8, %12 : i32
  %14 = arith.muli %2, %10 : i32
  %15 = memref.load %5[%c0] : memref<1xi32>
  %16 = arith.muli %14, %15 : i32
  %17 = arith.addi %13, %16 : i32
  %18 = arith.index_cast %17 : i32 to index
  %19 = arith.subi %2, %c1_i32 : i32
  %20 = arith.muli %19, %10 : i32
  %21 = arith.muli %20, %15 : i32
  %22 = arith.addi %13, %21 : i32
  %23 = arith.index_cast %22 : i32 to index
  %24 = arith.addi %23, %c0 : index
  %25 = memref.load %arg0[%24] : memref<?xf32>
  %26 = arith.addi %18, %c0 : index
  memref.store %25, %arg2[%26] : memref<?xf32>
  %27 = arith.addi %8, %c1_i32 : i32
  cf.br ^bb4(%27 : i32)
^bb6:  // pred: ^bb4
  %28 = arith.addi %4, %c1_i32 : i32
  cf.br ^bb3(%28 : i32)
^bb7:  // pred: ^bb3
  %29 = arith.subi %2, %c1_i32 : i32
  cf.br ^bb2(%29 : i32)
^bb8:  // pred: ^bb2
  cf.br ^bb9
^bb9:  // pred: ^bb8
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b104f40) {
  "cf.br"()[^bb9] : () -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
    ** Erase   : 'cf.br'(0x7fbd9b104f40)
"" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  cf.br ^bb1
^bb1:  // pred: ^bb0
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = memref.load %0[%c0] : memref<1xi32>
  cf.br ^bb2(%1 : i32)
^bb2(%2: i32):  // 2 preds: ^bb1, ^bb7
  %3 = arith.cmpi sgt, %2, %c0_i32 : i32
  cf.cond_br %3, ^bb3(%c0_i32 : i32), ^bb8
^bb3(%4: i32):  // 2 preds: ^bb2, ^bb6
  %5 = memref.get_global @jm : memref<1xi32>
  %6 = memref.load %5[%c0] : memref<1xi32>
  %7 = arith.cmpi slt, %4, %6 : i32
  cf.cond_br %7, ^bb4(%c0_i32 : i32), ^bb7
^bb4(%8: i32):  // 2 preds: ^bb3, ^bb5
  %9 = memref.get_global @im : memref<1xi32>
  %10 = memref.load %9[%c0] : memref<1xi32>
  %11 = arith.cmpi slt, %8, %10 : i32
  cf.cond_br %11, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %12 = arith.muli %4, %10 : i32
  %13 = arith.addi %8, %12 : i32
  %14 = arith.muli %2, %10 : i32
  %15 = memref.load %5[%c0] : memref<1xi32>
  %16 = arith.muli %14, %15 : i32
  %17 = arith.addi %13, %16 : i32
  %18 = arith.index_cast %17 : i32 to index
  %19 = arith.subi %2, %c1_i32 : i32
  %20 = arith.muli %19, %10 : i32
  %21 = arith.muli %20, %15 : i32
  %22 = arith.addi %13, %21 : i32
  %23 = arith.index_cast %22 : i32 to index
  %24 = arith.addi %23, %c0 : index
  %25 = memref.load %arg0[%24] : memref<?xf32>
  %26 = arith.addi %18, %c0 : index
  memref.store %25, %arg2[%26] : memref<?xf32>
  %27 = arith.addi %8, %c1_i32 : i32
  cf.br ^bb4(%27 : i32)
^bb6:  // pred: ^bb4
  %28 = arith.addi %4, %c1_i32 : i32
  cf.br ^bb3(%28 : i32)
^bb7:  // pred: ^bb3
  %29 = arith.subi %2, %c1_i32 : i32
  cf.br ^bb2(%29 : i32)
^bb8:  // pred: ^bb2
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b104ed0) {
  "cf.br"()[^bb1] : () -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
    ** Erase   : 'cf.br'(0x7fbd9b104ed0)
"" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = memref.load %0[%c0] : memref<1xi32>
  cf.br ^bb1(%1 : i32)
^bb1(%2: i32):  // 2 preds: ^bb0, ^bb6
  %3 = arith.cmpi sgt, %2, %c0_i32 : i32
  cf.cond_br %3, ^bb2(%c0_i32 : i32), ^bb7
^bb2(%4: i32):  // 2 preds: ^bb1, ^bb5
  %5 = memref.get_global @jm : memref<1xi32>
  %6 = memref.load %5[%c0] : memref<1xi32>
  %7 = arith.cmpi slt, %4, %6 : i32
  cf.cond_br %7, ^bb3(%c0_i32 : i32), ^bb6
^bb3(%8: i32):  // 2 preds: ^bb2, ^bb4
  %9 = memref.get_global @im : memref<1xi32>
  %10 = memref.load %9[%c0] : memref<1xi32>
  %11 = arith.cmpi slt, %8, %10 : i32
  cf.cond_br %11, ^bb4, ^bb5
^bb4:  // pred: ^bb3
  %12 = arith.muli %4, %10 : i32
  %13 = arith.addi %8, %12 : i32
  %14 = arith.muli %2, %10 : i32
  %15 = memref.load %5[%c0] : memref<1xi32>
  %16 = arith.muli %14, %15 : i32
  %17 = arith.addi %13, %16 : i32
  %18 = arith.index_cast %17 : i32 to index
  %19 = arith.subi %2, %c1_i32 : i32
  %20 = arith.muli %19, %10 : i32
  %21 = arith.muli %20, %15 : i32
  %22 = arith.addi %13, %21 : i32
  %23 = arith.index_cast %22 : i32 to index
  %24 = arith.addi %23, %c0 : index
  %25 = memref.load %arg0[%24] : memref<?xf32>
  %26 = arith.addi %18, %c0 : index
  memref.store %25, %arg2[%26] : memref<?xf32>
  %27 = arith.addi %8, %c1_i32 : i32
  cf.br ^bb3(%27 : i32)
^bb5:  // pred: ^bb3
  %28 = arith.addi %4, %c1_i32 : i32
  cf.br ^bb2(%28 : i32)
^bb6:  // pred: ^bb2
  %29 = arith.subi %2, %c1_i32 : i32
  cf.br ^bb1(%29 : i32)
^bb7:  // pred: ^bb1
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b105050) {
  "cf.br"(%33)[^bb1] : (i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9800c320) {
  %33 = "arith.subi"(%6, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b004880) {
  "cf.br"(%32)[^bb2] : (i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %32 = "arith.addi"(%8, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9800a0e0) {
  "cf.br"(%31)[^bb3] : (i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %31 = "arith.addi"(%12, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%29, %arg2, %30) : (f32, memref<?xf32>, index) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98165e60) {
  %30 = "arith.addi"(%22, %3) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %29 = "memref.load"(%arg0, %28) : (memref<?xf32>, index) -> f32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b0040e0) {
  %28 = "arith.addi"(%27, %3) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd98304bd0) {
  %27 = "arith.index_cast"(%26) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98304b30) {
  %26 = "arith.addi"(%17, %25) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304a90) {
  %25 = "arith.muli"(%24, %19) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %24 = "arith.muli"(%23, %14) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd983045d0) {
  %23 = "arith.subi"(%6, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9816cb40) {
  %22 = "arith.index_cast"(%21) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816caa0) {
  %21 = "arith.addi"(%17, %20) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816ca00) {
  %20 = "arith.muli"(%18, %19) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816c960) {
  %19 = "memref.load"(%9, %3) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %18 = "arith.muli"(%6, %14) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %17 = "arith.addi"(%12, %16) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %16 = "arith.muli"(%8, %14) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd98168590) {
  "cf.cond_br"(%15)[^bb4, ^bb5] {operand_segment_sizes = array<i32: 1, 0, 0>} : (i1) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors"
"(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition"
"(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CondBranchTruthPropagation : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::CondBranchTruthPropagation"
"(anonymous namespace)::CondBranchTruthPropagation" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %15 = "arith.cmpi"(%12, %14) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816b720) {
  %14 = "memref.load"(%13, %3) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9816b600) {
  %13 = "memref.get_global"() {name = @im} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd96f18d20) {
  "cf.cond_br"(%11, %2)[^bb3, ^bb6] {operand_segment_sizes = array<i32: 1, 1, 0>} : (i1, i32) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors"
"(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition"
"(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CondBranchTruthPropagation : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::CondBranchTruthPropagation"
"(anonymous namespace)::CondBranchTruthPropagation" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %11 = "arith.cmpi"(%8, %10) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98169b40) {
  %10 = "memref.load"(%9, %3) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd98169a20) {
  %9 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd9b004930) {
  "cf.cond_br"(%7, %2)[^bb2, ^bb7] {operand_segment_sizes = array<i32: 1, 1, 0>} : (i1, i32) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors"
"(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition"
"(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CondBranchTruthPropagation : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::CondBranchTruthPropagation"
"(anonymous namespace)::CondBranchTruthPropagation" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98168010) {
  %7 = "arith.cmpi"(%6, %2) {predicate = 4 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b104d60) {
  "cf.br"(%5)[^bb1] : (i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98167510) {
  %5 = "memref.load"(%4, %3) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd981673f0) {
  %4 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9816cc60) {
  %3 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98167e90) {
  %2 = "arith.constant"() {value = 0 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98304580) {
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98166480) {
  %0 = "arith.constant"() {value = true} : () -> i1

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x7fbd9800c610) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b105050) {
  "cf.br"(%32)[^bb1] : (i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9800c320) {
  %32 = "arith.subi"(%5, %0) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b004880) {
  "cf.br"(%31)[^bb2] : (i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %31 = "arith.addi"(%7, %0) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9800a0e0) {
  "cf.br"(%30)[^bb3] : (i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %30 = "arith.addi"(%11, %0) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%28, %arg2, %29) : (f32, memref<?xf32>, index) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98165e60) {
  %29 = "arith.addi"(%21, %2) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %28 = "memref.load"(%arg0, %27) : (memref<?xf32>, index) -> f32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b0040e0) {
  %27 = "arith.addi"(%26, %2) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd98304bd0) {
  %26 = "arith.index_cast"(%25) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98304b30) {
  %25 = "arith.addi"(%16, %24) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304a90) {
  %24 = "arith.muli"(%23, %18) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %23 = "arith.muli"(%22, %13) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd983045d0) {
  %22 = "arith.subi"(%5, %0) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9816cb40) {
  %21 = "arith.index_cast"(%20) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816caa0) {
  %20 = "arith.addi"(%16, %19) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816ca00) {
  %19 = "arith.muli"(%17, %18) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816c960) {
  %18 = "memref.load"(%8, %2) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %17 = "arith.muli"(%5, %13) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %16 = "arith.addi"(%11, %15) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %15 = "arith.muli"(%7, %13) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd98168590) {
  "cf.cond_br"(%14)[^bb4, ^bb5] {operand_segment_sizes = array<i32: 1, 0, 0>} : (i1) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors"
"(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition"
"(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CondBranchTruthPropagation : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::CondBranchTruthPropagation"
"(anonymous namespace)::CondBranchTruthPropagation" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %14 = "arith.cmpi"(%11, %13) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816b720) {
  %13 = "memref.load"(%12, %2) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9816b600) {
  %12 = "memref.get_global"() {name = @im} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd96f18d20) {
  "cf.cond_br"(%10, %1)[^bb3, ^bb6] {operand_segment_sizes = array<i32: 1, 1, 0>} : (i1, i32) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors"
"(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition"
"(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CondBranchTruthPropagation : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::CondBranchTruthPropagation"
"(anonymous namespace)::CondBranchTruthPropagation" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %10 = "arith.cmpi"(%7, %9) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98169b40) {
  %9 = "memref.load"(%8, %2) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd98169a20) {
  %8 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd9b004930) {
  "cf.cond_br"(%6, %1)[^bb2, ^bb7] {operand_segment_sizes = array<i32: 1, 1, 0>} : (i1, i32) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors"
"(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition"
"(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CondBranchTruthPropagation : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::CondBranchTruthPropagation"
"(anonymous namespace)::CondBranchTruthPropagation" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98168010) {
  %6 = "arith.cmpi"(%5, %1) {predicate = 4 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b104d60) {
  "cf.br"(%4)[^bb1] : (i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98167510) {
  %4 = "memref.load"(%3, %2) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd981673f0) {
  %3 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9816cc60) {
  %2 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98167e90) {
  %1 = "arith.constant"() {value = 0 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98304580) {
  %0 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%0 = memref.get_global @kbm3 : memref<1xi32>
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%5 = memref.get_global @jm : memref<1xi32>
 + forwarding vec to promote {0,} of mlir-asm-printer: Verifying operation: builtin.module
%5 = memref.get_global @jm : memref<1xi32>
Begin forwarding store of mlir-asm-printer: Verifying operation: builtin.module
%5 = memref.get_global @jm : memref<1xi32> to load
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = memref.load %0[%c0] : memref<1xi32>
  cf.br ^bb1(%1 : i32)
^bb1(%2: i32):  // 2 preds: ^bb0, ^bb6
  %3 = arith.cmpi sgt, %2, %c0_i32 : i32
  cf.cond_br %3, ^bb2(%c0_i32 : i32), ^bb7
^bb2(%4: i32):  // 2 preds: ^bb1, ^bb5
  %5 = memref.get_global @jm : memref<1xi32>
  %6 = memref.load %5[%c0] : memref<1xi32>
  %7 = arith.cmpi slt, %4, %6 : i32
  cf.cond_br %7, ^bb3(%c0_i32 : i32), ^bb6
^bb3(%8: i32):  // 2 preds: ^bb2, ^bb4
  %9 = memref.get_global @im : memref<1xi32>
  %10 = memref.load %9[%c0] : memref<1xi32>
  %11 = arith.cmpi slt, %8, %10 : i32
  cf.cond_br %11, ^bb4, ^bb5
^bb4:  // pred: ^bb3
  %12 = arith.muli %4, %10 : i32
  %13 = arith.addi %8, %12 : i32
  %14 = arith.muli %2, %10 : i32
  %15 = memref.load %5[%c0] : memref<1xi32>
  %16 = arith.muli %14, %15 : i32
  %17 = arith.addi %13, %16 : i32
  %18 = arith.index_cast %17 : i32 to index
  %19 = arith.subi %2, %c1_i32 : i32
  %20 = arith.muli %19, %10 : i32
  %21 = arith.muli %20, %15 : i32
  %22 = arith.addi %13, %21 : i32
  %23 = arith.index_cast %22 : i32 to index
  %24 = arith.addi %23, %c0 : index
  %25 = memref.load %arg0[%24] : memref<?xf32>
  %26 = arith.addi %18, %c0 : index
  memref.store %25, %arg2[%26] : memref<?xf32>
  %27 = arith.addi %8, %c1_i32 : i32
  cf.br ^bb3(%27 : i32)
^bb5:  // pred: ^bb3
  %28 = arith.addi %4, %c1_i32 : i32
  cf.br ^bb2(%28 : i32)
^bb6:  // pred: ^bb2
  %29 = arith.subi %2, %c1_i32 : i32
  cf.br ^bb1(%29 : i32)
^bb7:  // pred: ^bb1
  return
}
Matching Load: mlir-asm-printer: Verifying operation: func.func
%6 = memref.load %5[%c0] : memref<1xi32>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%15 = memref.load %5[%c0] : memref<1xi32>
Potential Op ith Effect: mlir-asm-printer: Verifying operation: func.func
memref.store %25, %arg2[%26] : memref<?xf32>
Potential Op ith Effect: mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = memref.load %0[%c0] : memref<1xi32>
  cf.br ^bb1(%1 : i32)
^bb1(%2: i32):  // 2 preds: ^bb0, ^bb6
  %3 = arith.cmpi sgt, %2, %c0_i32 : i32
  cf.cond_br %3, ^bb2(%c0_i32 : i32), ^bb7
^bb2(%4: i32):  // 2 preds: ^bb1, ^bb5
  %5 = memref.get_global @jm : memref<1xi32>
  %6 = memref.load %5[%c0] : memref<1xi32>
  %7 = arith.cmpi slt, %4, %6 : i32
  cf.cond_br %7, ^bb3(%c0_i32 : i32), ^bb6
^bb3(%8: i32):  // 2 preds: ^bb2, ^bb4
  %9 = memref.get_global @im : memref<1xi32>
  %10 = memref.load %9[%c0] : memref<1xi32>
  %11 = arith.cmpi slt, %8, %10 : i32
  cf.cond_br %11, ^bb4, ^bb5
^bb4:  // pred: ^bb3
  %12 = arith.muli %4, %10 : i32
  %13 = arith.addi %8, %12 : i32
  %14 = arith.muli %2, %10 : i32
  %15 = memref.load %5[%c0] : memref<1xi32>
  %16 = arith.muli %14, %15 : i32
  %17 = arith.addi %13, %16 : i32
  %18 = arith.index_cast %17 : i32 to index
  %19 = arith.subi %2, %c1_i32 : i32
  %20 = arith.muli %19, %10 : i32
  %21 = arith.muli %20, %15 : i32
  %22 = arith.addi %13, %21 : i32
  %23 = arith.index_cast %22 : i32 to index
  %24 = arith.addi %23, %c0 : index
  %25 = memref.load %arg0[%24] : memref<?xf32>
  %26 = arith.addi %18, %c0 : index
  memref.store %25, %arg2[%26] : memref<?xf32>
  %27 = arith.addi %8, %c1_i32 : i32
  cf.br ^bb3(%27 : i32)
^bb5:  // pred: ^bb3
  %28 = arith.addi %4, %c1_i32 : i32
  cf.br ^bb2(%28 : i32)
^bb6:  // pred: ^bb2
  %29 = arith.subi %2, %c1_i32 : i32
  cf.br ^bb1(%29 : i32)
^bb7:  // pred: ^bb1
  return
}
 aliasing storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %25, %arg2[%26] : memref<?xf32>
 aliasing storing operation: mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = memref.load %0[%c0] : memref<1xi32>
  cf.br ^bb1(%1 : i32)
^bb1(%2: i32):  // 2 preds: ^bb0, ^bb6
  %3 = arith.cmpi sgt, %2, %c0_i32 : i32
  cf.cond_br %3, ^bb2(%c0_i32 : i32), ^bb7
^bb2(%4: i32):  // 2 preds: ^bb1, ^bb5
  %5 = memref.get_global @jm : memref<1xi32>
  %6 = memref.load %5[%c0] : memref<1xi32>
  %7 = arith.cmpi slt, %4, %6 : i32
  cf.cond_br %7, ^bb3(%c0_i32 : i32), ^bb6
^bb3(%8: i32):  // 2 preds: ^bb2, ^bb4
  %9 = memref.get_global @im : memref<1xi32>
  %10 = memref.load %9[%c0] : memref<1xi32>
  %11 = arith.cmpi slt, %8, %10 : i32
  cf.cond_br %11, ^bb4, ^bb5
^bb4:  // pred: ^bb3
  %12 = arith.muli %4, %10 : i32
  %13 = arith.addi %8, %12 : i32
  %14 = arith.muli %2, %10 : i32
  %15 = memref.load %5[%c0] : memref<1xi32>
  %16 = arith.muli %14, %15 : i32
  %17 = arith.addi %13, %16 : i32
  %18 = arith.index_cast %17 : i32 to index
  %19 = arith.subi %2, %c1_i32 : i32
  %20 = arith.muli %19, %10 : i32
  %21 = arith.muli %20, %15 : i32
  %22 = arith.addi %13, %21 : i32
  %23 = arith.index_cast %22 : i32 to index
  %24 = arith.addi %23, %c0 : index
  %25 = memref.load %arg0[%24] : memref<?xf32>
  %26 = arith.addi %18, %c0 : index
  memref.store %25, %arg2[%26] : memref<?xf32>
  %27 = arith.addi %8, %c1_i32 : i32
  cf.br ^bb3(%27 : i32)
^bb5:  // pred: ^bb3
  %28 = arith.addi %4, %c1_i32 : i32
  cf.br ^bb2(%28 : i32)
^bb6:  // pred: ^bb2
  %29 = arith.subi %2, %c1_i32 : i32
  cf.br ^bb1(%29 : i32)
^bb7:  // pred: ^bb1
  return
}
 initial storing block: 0x7fbd9816b230
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb2(%4: i32):  // 2 preds: ^bb1, ^bb5
  %5 = memref.get_global @jm : memref<1xi32>
  %6 = memref.load %5[%c0] : memref<1xi32>
  %7 = arith.cmpi slt, %4, %6 : i32
  cf.cond_br %7, ^bb3(%c0_i32 : i32), ^bb6

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2(%4: i32):  // 2 preds: ^bb1, ^bb5
  %5 = memref.get_global @jm : memref<1xi32>
  %6 = memref.load %5[%c0] : memref<1xi32>
  %7 = arith.cmpi slt, %4, %6 : i32
  cf.cond_br %7, ^bb3(%c0_i32 : i32), ^bb6
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%6 = memref.load %5[%c0] : memref<1xi32>

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb6:  // pred: ^bb2
  %29 = arith.subi %2, %c1_i32 : i32
  cf.br ^bb1(%29 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb6:  // pred: ^bb2
  %29 = arith.subi %2, %c1_i32 : i32
  cf.br ^bb1(%29 : i32)

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb6:  // pred: ^bb2
  %29 = arith.subi %2, %c1_i32 : i32
  cf.br ^bb1(%29 : i32)
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb6:  // pred: ^bb2
  %29 = arith.subi %2, %c1_i32 : i32
  cf.br ^bb1(%29 : i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb1(%2: i32):  // 2 preds: ^bb0, ^bb6
  %3 = arith.cmpi sgt, %2, %c0_i32 : i32
  cf.cond_br %3, ^bb2(%c0_i32 : i32), ^bb7

mlir-asm-printer: Verifying operation: builtin.module
^bb1(%2: i32):  // 2 preds: ^bb0, ^bb6
  %3 = arith.cmpi sgt, %2, %c0_i32 : i32
  cf.cond_br %3, ^bb2(%c0_i32 : i32), ^bb7

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%2: i32):  // 2 preds: ^bb0, ^bb6
  %3 = arith.cmpi sgt, %2, %c0_i32 : i32
  cf.cond_br %3, ^bb2(%c0_i32 : i32), ^bb7
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb1(%2: i32):  // 2 preds: ^bb0, ^bb6
  %3 = arith.cmpi sgt, %2, %c0_i32 : i32
  cf.cond_br %3, ^bb2(%c0_i32 : i32), ^bb7


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb7:  // pred: ^bb1
  func.return

mlir-asm-printer: Verifying operation: builtin.module
^bb7:  // pred: ^bb1
  func.return

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb7:  // pred: ^bb1
  func.return
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb7:  // pred: ^bb1
  func.return


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb3(%8: i32):  // 2 preds: ^bb2, ^bb4
  %9 = memref.get_global @im : memref<1xi32>
  %10 = memref.load %9[%c0] : memref<1xi32>
  %11 = arith.cmpi slt, %8, %10 : i32
  cf.cond_br %11, ^bb4, ^bb5

mlir-asm-printer: Verifying operation: builtin.module
^bb3(%8: i32):  // 2 preds: ^bb2, ^bb4
  %9 = memref.get_global @im : memref<1xi32>
  %10 = memref.load %9[%c0] : memref<1xi32>
  %11 = arith.cmpi slt, %8, %10 : i32
  cf.cond_br %11, ^bb4, ^bb5

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3(%8: i32):  // 2 preds: ^bb2, ^bb4
  %9 = memref.get_global @im : memref<1xi32>
  %10 = memref.load %9[%c0] : memref<1xi32>
  %11 = arith.cmpi slt, %8, %10 : i32
  cf.cond_br %11, ^bb4, ^bb5
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb3(%8: i32):  // 2 preds: ^bb2, ^bb4
  %9 = memref.get_global @im : memref<1xi32>
  %10 = memref.load %9[%c0] : memref<1xi32>
  %11 = arith.cmpi slt, %8, %10 : i32
  cf.cond_br %11, ^bb4, ^bb5


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb5:  // pred: ^bb3
  %28 = arith.addi %4, %c1_i32 : i32
  cf.br ^bb2(%28 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb5:  // pred: ^bb3
  %28 = arith.addi %4, %c1_i32 : i32
  cf.br ^bb2(%28 : i32)

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb5:  // pred: ^bb3
  %28 = arith.addi %4, %c1_i32 : i32
  cf.br ^bb2(%28 : i32)
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb5:  // pred: ^bb3
  %28 = arith.addi %4, %c1_i32 : i32
  cf.br ^bb2(%28 : i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb4:  // pred: ^bb3
  %12 = arith.muli %4, %10 : i32
  %13 = arith.addi %8, %12 : i32
  %14 = arith.muli %2, %10 : i32
  %15 = memref.load %5[%c0] : memref<1xi32>
  %16 = arith.muli %14, %15 : i32
  %17 = arith.addi %13, %16 : i32
  %18 = arith.index_cast %17 : i32 to index
  %19 = arith.subi %2, %c1_i32 : i32
  %20 = arith.muli %19, %10 : i32
  %21 = arith.muli %20, %15 : i32
  %22 = arith.addi %13, %21 : i32
  %23 = arith.index_cast %22 : i32 to index
  %24 = arith.addi %23, %c0 : index
  %25 = memref.load %arg0[%24] : memref<?xf32>
  %26 = arith.addi %18, %c0 : index
  memref.store %25, %arg2[%26] : memref<?xf32>
  %27 = arith.addi %8, %c1_i32 : i32
  cf.br ^bb3(%27 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb4:  // pred: ^bb3
  %12 = arith.muli %4, %10 : i32
  %13 = arith.addi %8, %12 : i32
  %14 = arith.muli %2, %10 : i32
  %15 = memref.load %5[%c0] : memref<1xi32>
  %16 = arith.muli %14, %15 : i32
  %17 = arith.addi %13, %16 : i32
  %18 = arith.index_cast %17 : i32 to index
  %19 = arith.subi %2, %c1_i32 : i32
  %20 = arith.muli %19, %10 : i32
  %21 = arith.muli %20, %15 : i32
  %22 = arith.addi %13, %21 : i32
  %23 = arith.index_cast %22 : i32 to index
  %24 = arith.addi %23, %c0 : index
  %25 = memref.load %arg0[%24] : memref<?xf32>
  %26 = arith.addi %18, %c0 : index
  memref.store %25, %arg2[%26] : memref<?xf32>
  %27 = arith.addi %8, %c1_i32 : i32
  cf.br ^bb3(%27 : i32)

erased store due to: mlir-asm-printer: Verifying operation: func.func
memref.store %25, %arg2[%26] : memref<?xf32>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb4:  // pred: ^bb3
  %12 = arith.muli %4, %10 : i32
  %13 = arith.addi %8, %12 : i32
  %14 = arith.muli %2, %10 : i32
  %15 = memref.load %5[%c0] : memref<1xi32>
  %16 = arith.muli %14, %15 : i32
  %17 = arith.addi %13, %16 : i32
  %18 = arith.index_cast %17 : i32 to index
  %19 = arith.subi %2, %c1_i32 : i32
  %20 = arith.muli %19, %10 : i32
  %21 = arith.muli %20, %15 : i32
  %22 = arith.addi %13, %21 : i32
  %23 = arith.index_cast %22 : i32 to index
  %24 = arith.addi %23, %c0 : index
  %25 = memref.load %arg0[%24] : memref<?xf32>
  %26 = arith.addi %18, %c0 : index
  memref.store %25, %arg2[%26] : memref<?xf32>
  %27 = arith.addi %8, %c1_i32 : i32
  cf.br ^bb3(%27 : i32)
 with val:<overwritten>
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%9 = memref.get_global @im : memref<1xi32>

//===-------------------------------------------===//
Processing operation : 'func.return'(0x7fbd9800c610) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b105050) {
  "cf.br"(%32)[^bb1] : (i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9800c320) {
  %32 = "arith.subi"(%5, %0) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b004880) {
  "cf.br"(%31)[^bb2] : (i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %31 = "arith.addi"(%7, %0) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9800a0e0) {
  "cf.br"(%30)[^bb3] : (i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %30 = "arith.addi"(%11, %0) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%28, %arg2, %29) : (f32, memref<?xf32>, index) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98165e60) {
  %29 = "arith.addi"(%21, %2) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %28 = "memref.load"(%arg0, %27) : (memref<?xf32>, index) -> f32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b0040e0) {
  %27 = "arith.addi"(%26, %2) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd98304bd0) {
  %26 = "arith.index_cast"(%25) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98304b30) {
  %25 = "arith.addi"(%16, %24) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304a90) {
  %24 = "arith.muli"(%23, %18) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %23 = "arith.muli"(%22, %13) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd983045d0) {
  %22 = "arith.subi"(%5, %0) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9816cb40) {
  %21 = "arith.index_cast"(%20) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816caa0) {
  %20 = "arith.addi"(%16, %19) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816ca00) {
  %19 = "arith.muli"(%17, %18) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816c960) {
  %18 = "memref.load"(%8, %2) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %17 = "arith.muli"(%5, %13) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %16 = "arith.addi"(%11, %15) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %15 = "arith.muli"(%7, %13) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd98168590) {
  "cf.cond_br"(%14)[^bb4, ^bb5] {operand_segment_sizes = array<i32: 1, 0, 0>} : (i1) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors"
"(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition"
"(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CondBranchTruthPropagation : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::CondBranchTruthPropagation"
"(anonymous namespace)::CondBranchTruthPropagation" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %14 = "arith.cmpi"(%11, %13) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816b720) {
  %13 = "memref.load"(%12, %2) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9816b600) {
  %12 = "memref.get_global"() {name = @im} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd96f18d20) {
  "cf.cond_br"(%10, %1)[^bb3, ^bb6] {operand_segment_sizes = array<i32: 1, 1, 0>} : (i1, i32) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors"
"(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition"
"(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CondBranchTruthPropagation : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::CondBranchTruthPropagation"
"(anonymous namespace)::CondBranchTruthPropagation" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %10 = "arith.cmpi"(%7, %9) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98169b40) {
  %9 = "memref.load"(%8, %2) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd98169a20) {
  %8 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd9b004930) {
  "cf.cond_br"(%6, %1)[^bb2, ^bb7] {operand_segment_sizes = array<i32: 1, 1, 0>} : (i1, i32) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors"
"(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition"
"(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CondBranchTruthPropagation : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::CondBranchTruthPropagation"
"(anonymous namespace)::CondBranchTruthPropagation" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98168010) {
  %6 = "arith.cmpi"(%5, %1) {predicate = 4 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b104d60) {
  "cf.br"(%4)[^bb1] : (i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98167510) {
  %4 = "memref.load"(%3, %2) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd981673f0) {
  %3 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9816cc60) {
  %2 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98167e90) {
  %1 = "arith.constant"() {value = 0 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98304580) {
  %0 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%0 = memref.get_global @kbm3 : memref<1xi32>
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%5 = memref.get_global @jm : memref<1xi32>
 + forwarding vec to promote {0,} of mlir-asm-printer: Verifying operation: builtin.module
%5 = memref.get_global @jm : memref<1xi32>
Begin forwarding store of mlir-asm-printer: Verifying operation: builtin.module
%5 = memref.get_global @jm : memref<1xi32> to load
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = memref.load %0[%c0] : memref<1xi32>
  cf.br ^bb1(%1 : i32)
^bb1(%2: i32):  // 2 preds: ^bb0, ^bb6
  %3 = arith.cmpi sgt, %2, %c0_i32 : i32
  cf.cond_br %3, ^bb2(%c0_i32 : i32), ^bb7
^bb2(%4: i32):  // 2 preds: ^bb1, ^bb5
  %5 = memref.get_global @jm : memref<1xi32>
  %6 = memref.load %5[%c0] : memref<1xi32>
  %7 = arith.cmpi slt, %4, %6 : i32
  cf.cond_br %7, ^bb3(%c0_i32 : i32), ^bb6
^bb3(%8: i32):  // 2 preds: ^bb2, ^bb4
  %9 = memref.get_global @im : memref<1xi32>
  %10 = memref.load %9[%c0] : memref<1xi32>
  %11 = arith.cmpi slt, %8, %10 : i32
  cf.cond_br %11, ^bb4, ^bb5
^bb4:  // pred: ^bb3
  %12 = arith.muli %4, %10 : i32
  %13 = arith.addi %8, %12 : i32
  %14 = arith.muli %2, %10 : i32
  %15 = memref.load %5[%c0] : memref<1xi32>
  %16 = arith.muli %14, %15 : i32
  %17 = arith.addi %13, %16 : i32
  %18 = arith.index_cast %17 : i32 to index
  %19 = arith.subi %2, %c1_i32 : i32
  %20 = arith.muli %19, %10 : i32
  %21 = arith.muli %20, %15 : i32
  %22 = arith.addi %13, %21 : i32
  %23 = arith.index_cast %22 : i32 to index
  %24 = arith.addi %23, %c0 : index
  %25 = memref.load %arg0[%24] : memref<?xf32>
  %26 = arith.addi %18, %c0 : index
  memref.store %25, %arg2[%26] : memref<?xf32>
  %27 = arith.addi %8, %c1_i32 : i32
  cf.br ^bb3(%27 : i32)
^bb5:  // pred: ^bb3
  %28 = arith.addi %4, %c1_i32 : i32
  cf.br ^bb2(%28 : i32)
^bb6:  // pred: ^bb2
  %29 = arith.subi %2, %c1_i32 : i32
  cf.br ^bb1(%29 : i32)
^bb7:  // pred: ^bb1
  return
}
Matching Load: mlir-asm-printer: Verifying operation: func.func
%6 = memref.load %5[%c0] : memref<1xi32>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%15 = memref.load %5[%c0] : memref<1xi32>
Potential Op ith Effect: mlir-asm-printer: Verifying operation: func.func
memref.store %25, %arg2[%26] : memref<?xf32>
Potential Op ith Effect: mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = memref.load %0[%c0] : memref<1xi32>
  cf.br ^bb1(%1 : i32)
^bb1(%2: i32):  // 2 preds: ^bb0, ^bb6
  %3 = arith.cmpi sgt, %2, %c0_i32 : i32
  cf.cond_br %3, ^bb2(%c0_i32 : i32), ^bb7
^bb2(%4: i32):  // 2 preds: ^bb1, ^bb5
  %5 = memref.get_global @jm : memref<1xi32>
  %6 = memref.load %5[%c0] : memref<1xi32>
  %7 = arith.cmpi slt, %4, %6 : i32
  cf.cond_br %7, ^bb3(%c0_i32 : i32), ^bb6
^bb3(%8: i32):  // 2 preds: ^bb2, ^bb4
  %9 = memref.get_global @im : memref<1xi32>
  %10 = memref.load %9[%c0] : memref<1xi32>
  %11 = arith.cmpi slt, %8, %10 : i32
  cf.cond_br %11, ^bb4, ^bb5
^bb4:  // pred: ^bb3
  %12 = arith.muli %4, %10 : i32
  %13 = arith.addi %8, %12 : i32
  %14 = arith.muli %2, %10 : i32
  %15 = memref.load %5[%c0] : memref<1xi32>
  %16 = arith.muli %14, %15 : i32
  %17 = arith.addi %13, %16 : i32
  %18 = arith.index_cast %17 : i32 to index
  %19 = arith.subi %2, %c1_i32 : i32
  %20 = arith.muli %19, %10 : i32
  %21 = arith.muli %20, %15 : i32
  %22 = arith.addi %13, %21 : i32
  %23 = arith.index_cast %22 : i32 to index
  %24 = arith.addi %23, %c0 : index
  %25 = memref.load %arg0[%24] : memref<?xf32>
  %26 = arith.addi %18, %c0 : index
  memref.store %25, %arg2[%26] : memref<?xf32>
  %27 = arith.addi %8, %c1_i32 : i32
  cf.br ^bb3(%27 : i32)
^bb5:  // pred: ^bb3
  %28 = arith.addi %4, %c1_i32 : i32
  cf.br ^bb2(%28 : i32)
^bb6:  // pred: ^bb2
  %29 = arith.subi %2, %c1_i32 : i32
  cf.br ^bb1(%29 : i32)
^bb7:  // pred: ^bb1
  return
}
 aliasing storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %25, %arg2[%26] : memref<?xf32>
 aliasing storing operation: mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = memref.load %0[%c0] : memref<1xi32>
  cf.br ^bb1(%1 : i32)
^bb1(%2: i32):  // 2 preds: ^bb0, ^bb6
  %3 = arith.cmpi sgt, %2, %c0_i32 : i32
  cf.cond_br %3, ^bb2(%c0_i32 : i32), ^bb7
^bb2(%4: i32):  // 2 preds: ^bb1, ^bb5
  %5 = memref.get_global @jm : memref<1xi32>
  %6 = memref.load %5[%c0] : memref<1xi32>
  %7 = arith.cmpi slt, %4, %6 : i32
  cf.cond_br %7, ^bb3(%c0_i32 : i32), ^bb6
^bb3(%8: i32):  // 2 preds: ^bb2, ^bb4
  %9 = memref.get_global @im : memref<1xi32>
  %10 = memref.load %9[%c0] : memref<1xi32>
  %11 = arith.cmpi slt, %8, %10 : i32
  cf.cond_br %11, ^bb4, ^bb5
^bb4:  // pred: ^bb3
  %12 = arith.muli %4, %10 : i32
  %13 = arith.addi %8, %12 : i32
  %14 = arith.muli %2, %10 : i32
  %15 = memref.load %5[%c0] : memref<1xi32>
  %16 = arith.muli %14, %15 : i32
  %17 = arith.addi %13, %16 : i32
  %18 = arith.index_cast %17 : i32 to index
  %19 = arith.subi %2, %c1_i32 : i32
  %20 = arith.muli %19, %10 : i32
  %21 = arith.muli %20, %15 : i32
  %22 = arith.addi %13, %21 : i32
  %23 = arith.index_cast %22 : i32 to index
  %24 = arith.addi %23, %c0 : index
  %25 = memref.load %arg0[%24] : memref<?xf32>
  %26 = arith.addi %18, %c0 : index
  memref.store %25, %arg2[%26] : memref<?xf32>
  %27 = arith.addi %8, %c1_i32 : i32
  cf.br ^bb3(%27 : i32)
^bb5:  // pred: ^bb3
  %28 = arith.addi %4, %c1_i32 : i32
  cf.br ^bb2(%28 : i32)
^bb6:  // pred: ^bb2
  %29 = arith.subi %2, %c1_i32 : i32
  cf.br ^bb1(%29 : i32)
^bb7:  // pred: ^bb1
  return
}
 initial storing block: 0x7fbd9816b230
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb2(%4: i32):  // 2 preds: ^bb1, ^bb5
  %5 = memref.get_global @jm : memref<1xi32>
  %6 = memref.load %5[%c0] : memref<1xi32>
  %7 = arith.cmpi slt, %4, %6 : i32
  cf.cond_br %7, ^bb3(%c0_i32 : i32), ^bb6

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb2(%4: i32):  // 2 preds: ^bb1, ^bb5
  %5 = memref.get_global @jm : memref<1xi32>
  %6 = memref.load %5[%c0] : memref<1xi32>
  %7 = arith.cmpi slt, %4, %6 : i32
  cf.cond_br %7, ^bb3(%c0_i32 : i32), ^bb6
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%6 = memref.load %5[%c0] : memref<1xi32>

starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb6:  // pred: ^bb2
  %29 = arith.subi %2, %c1_i32 : i32
  cf.br ^bb1(%29 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb6:  // pred: ^bb2
  %29 = arith.subi %2, %c1_i32 : i32
  cf.br ^bb1(%29 : i32)

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb6:  // pred: ^bb2
  %29 = arith.subi %2, %c1_i32 : i32
  cf.br ^bb1(%29 : i32)
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb6:  // pred: ^bb2
  %29 = arith.subi %2, %c1_i32 : i32
  cf.br ^bb1(%29 : i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb1(%2: i32):  // 2 preds: ^bb0, ^bb6
  %3 = arith.cmpi sgt, %2, %c0_i32 : i32
  cf.cond_br %3, ^bb2(%c0_i32 : i32), ^bb7

mlir-asm-printer: Verifying operation: builtin.module
^bb1(%2: i32):  // 2 preds: ^bb0, ^bb6
  %3 = arith.cmpi sgt, %2, %c0_i32 : i32
  cf.cond_br %3, ^bb2(%c0_i32 : i32), ^bb7

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb1(%2: i32):  // 2 preds: ^bb0, ^bb6
  %3 = arith.cmpi sgt, %2, %c0_i32 : i32
  cf.cond_br %3, ^bb2(%c0_i32 : i32), ^bb7
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb1(%2: i32):  // 2 preds: ^bb0, ^bb6
  %3 = arith.cmpi sgt, %2, %c0_i32 : i32
  cf.cond_br %3, ^bb2(%c0_i32 : i32), ^bb7


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb7:  // pred: ^bb1
  func.return

mlir-asm-printer: Verifying operation: builtin.module
^bb7:  // pred: ^bb1
  func.return

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb7:  // pred: ^bb1
  func.return
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb7:  // pred: ^bb1
  func.return


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb3(%8: i32):  // 2 preds: ^bb2, ^bb4
  %9 = memref.get_global @im : memref<1xi32>
  %10 = memref.load %9[%c0] : memref<1xi32>
  %11 = arith.cmpi slt, %8, %10 : i32
  cf.cond_br %11, ^bb4, ^bb5

mlir-asm-printer: Verifying operation: builtin.module
^bb3(%8: i32):  // 2 preds: ^bb2, ^bb4
  %9 = memref.get_global @im : memref<1xi32>
  %10 = memref.load %9[%c0] : memref<1xi32>
  %11 = arith.cmpi slt, %8, %10 : i32
  cf.cond_br %11, ^bb4, ^bb5

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb3(%8: i32):  // 2 preds: ^bb2, ^bb4
  %9 = memref.get_global @im : memref<1xi32>
  %10 = memref.load %9[%c0] : memref<1xi32>
  %11 = arith.cmpi slt, %8, %10 : i32
  cf.cond_br %11, ^bb4, ^bb5
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb3(%8: i32):  // 2 preds: ^bb2, ^bb4
  %9 = memref.get_global @im : memref<1xi32>
  %10 = memref.load %9[%c0] : memref<1xi32>
  %11 = arith.cmpi slt, %8, %10 : i32
  cf.cond_br %11, ^bb4, ^bb5


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb5:  // pred: ^bb3
  %28 = arith.addi %4, %c1_i32 : i32
  cf.br ^bb2(%28 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb5:  // pred: ^bb3
  %28 = arith.addi %4, %c1_i32 : i32
  cf.br ^bb2(%28 : i32)

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb5:  // pred: ^bb3
  %28 = arith.addi %4, %c1_i32 : i32
  cf.br ^bb2(%28 : i32)
 with val:mlir-asm-printer: Verifying operation: builtin.module
^bb5:  // pred: ^bb3
  %28 = arith.addi %4, %c1_i32 : i32
  cf.br ^bb2(%28 : i32)


starting block: lastVal=mlir-asm-printer: Verifying operation: builtin.module
^bb4:  // pred: ^bb3
  %12 = arith.muli %4, %10 : i32
  %13 = arith.addi %8, %12 : i32
  %14 = arith.muli %2, %10 : i32
  %15 = memref.load %5[%c0] : memref<1xi32>
  %16 = arith.muli %14, %15 : i32
  %17 = arith.addi %13, %16 : i32
  %18 = arith.index_cast %17 : i32 to index
  %19 = arith.subi %2, %c1_i32 : i32
  %20 = arith.muli %19, %10 : i32
  %21 = arith.muli %20, %15 : i32
  %22 = arith.addi %13, %21 : i32
  %23 = arith.index_cast %22 : i32 to index
  %24 = arith.addi %23, %c0 : index
  %25 = memref.load %arg0[%24] : memref<?xf32>
  %26 = arith.addi %18, %c0 : index
  memref.store %25, %arg2[%26] : memref<?xf32>
  %27 = arith.addi %8, %c1_i32 : i32
  cf.br ^bb3(%27 : i32)

mlir-asm-printer: Verifying operation: builtin.module
^bb4:  // pred: ^bb3
  %12 = arith.muli %4, %10 : i32
  %13 = arith.addi %8, %12 : i32
  %14 = arith.muli %2, %10 : i32
  %15 = memref.load %5[%c0] : memref<1xi32>
  %16 = arith.muli %14, %15 : i32
  %17 = arith.addi %13, %16 : i32
  %18 = arith.index_cast %17 : i32 to index
  %19 = arith.subi %2, %c1_i32 : i32
  %20 = arith.muli %19, %10 : i32
  %21 = arith.muli %20, %15 : i32
  %22 = arith.addi %13, %21 : i32
  %23 = arith.index_cast %22 : i32 to index
  %24 = arith.addi %23, %c0 : index
  %25 = memref.load %arg0[%24] : memref<?xf32>
  %26 = arith.addi %18, %c0 : index
  memref.store %25, %arg2[%26] : memref<?xf32>
  %27 = arith.addi %8, %c1_i32 : i32
  cf.br ^bb3(%27 : i32)

erased store due to: mlir-asm-printer: Verifying operation: func.func
memref.store %25, %arg2[%26] : memref<?xf32>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb4:  // pred: ^bb3
  %12 = arith.muli %4, %10 : i32
  %13 = arith.addi %8, %12 : i32
  %14 = arith.muli %2, %10 : i32
  %15 = memref.load %5[%c0] : memref<1xi32>
  %16 = arith.muli %14, %15 : i32
  %17 = arith.addi %13, %16 : i32
  %18 = arith.index_cast %17 : i32 to index
  %19 = arith.subi %2, %c1_i32 : i32
  %20 = arith.muli %19, %10 : i32
  %21 = arith.muli %20, %15 : i32
  %22 = arith.addi %13, %21 : i32
  %23 = arith.index_cast %22 : i32 to index
  %24 = arith.addi %23, %c0 : index
  %25 = memref.load %arg0[%24] : memref<?xf32>
  %26 = arith.addi %18, %c0 : index
  memref.store %25, %arg2[%26] : memref<?xf32>
  %27 = arith.addi %8, %c1_i32 : i32
  cf.br ^bb3(%27 : i32)
 with val:<overwritten>
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%9 = memref.get_global @im : memref<1xi32>

//===-------------------------------------------===//
Processing operation : 'func.return'(0x7fbd9800c610) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b105050) {
  "cf.br"(%32)[^bb1] : (i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9800c320) {
  %32 = "arith.subi"(%5, %0) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b004880) {
  "cf.br"(%31)[^bb2] : (i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %31 = "arith.addi"(%7, %0) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9800a0e0) {
  "cf.br"(%30)[^bb3] : (i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %30 = "arith.addi"(%11, %0) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%28, %arg2, %29) : (f32, memref<?xf32>, index) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98165e60) {
  %29 = "arith.addi"(%21, %2) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %28 = "memref.load"(%arg0, %27) : (memref<?xf32>, index) -> f32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b0040e0) {
  %27 = "arith.addi"(%26, %2) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd98304bd0) {
  %26 = "arith.index_cast"(%25) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98304b30) {
  %25 = "arith.addi"(%16, %24) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304a90) {
  %24 = "arith.muli"(%23, %18) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %23 = "arith.muli"(%22, %13) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd983045d0) {
  %22 = "arith.subi"(%5, %0) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9816cb40) {
  %21 = "arith.index_cast"(%20) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816caa0) {
  %20 = "arith.addi"(%16, %19) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816ca00) {
  %19 = "arith.muli"(%17, %18) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816c960) {
  %18 = "memref.load"(%8, %2) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %17 = "arith.muli"(%5, %13) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %16 = "arith.addi"(%11, %15) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %15 = "arith.muli"(%7, %13) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd98168590) {
  "cf.cond_br"(%14)[^bb4, ^bb5] {operand_segment_sizes = array<i32: 1, 0, 0>} : (i1) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors"
"(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition"
"(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CondBranchTruthPropagation : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::CondBranchTruthPropagation"
"(anonymous namespace)::CondBranchTruthPropagation" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %14 = "arith.cmpi"(%11, %13) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816b720) {
  %13 = "memref.load"(%12, %2) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9816b600) {
  %12 = "memref.get_global"() {name = @im} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd96f18d20) {
  "cf.cond_br"(%10, %1)[^bb3, ^bb6] {operand_segment_sizes = array<i32: 1, 1, 0>} : (i1, i32) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors"
"(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition"
"(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CondBranchTruthPropagation : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::CondBranchTruthPropagation"
"(anonymous namespace)::CondBranchTruthPropagation" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %10 = "arith.cmpi"(%7, %9) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98169b40) {
  %9 = "memref.load"(%8, %2) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd98169a20) {
  %8 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.cond_br'(0x7fbd9b004930) {
  "cf.cond_br"(%6, %1)[^bb2, ^bb7] {operand_segment_sizes = array<i32: 1, 1, 0>} : (i1, i32) -> ()


  * Pattern (anonymous namespace)::SimplifyConstCondBranchPred : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyConstCondBranchPred"
"(anonymous namespace)::SimplifyConstCondBranchPred" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyPassThroughCondBranch : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyPassThroughCondBranch"
"(anonymous namespace)::SimplifyPassThroughCondBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors"
"(anonymous namespace)::SimplifyCondBranchIdenticalSuccessors" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition"
"(anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CondBranchTruthPropagation : 'cf.cond_br -> ()' {
Trying to match "(anonymous namespace)::CondBranchTruthPropagation"
"(anonymous namespace)::CondBranchTruthPropagation" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98168010) {
  %6 = "arith.cmpi"(%5, %1) {predicate = 4 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'cf.br'(0x7fbd9b104d60) {
  "cf.br"(%4)[^bb1] : (i32) -> ()


  * Pattern  : 'cf.br -> ()' {
Trying to match ""
"" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98167510) {
  %4 = "memref.load"(%3, %2) : (memref<1xi32>, index) -> i32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd981673f0) {
  %3 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9816cc60) {
  %2 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98167e90) {
  %1 = "arith.constant"() {value = 0 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98304580) {
  %0 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x7fbd9800c610) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b1042d0) {
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchTerminatorOpInterface::Trait<Empty>)
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b104910) {
  "scf.yield"(%arg5) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b1044b0) {
  "scf.condition"(%9#0, %9#1) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b1052f0) {

  * Pattern MoveIfToAffine : 'scf.if -> ()' {
Trying to match "MoveIfToAffine"
"MoveIfToAffine" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1066e0) {
  "scf.yield"(%1, %arg5) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b105460) {
  "scf.yield"(%0, %11) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9800c320) {
  %11 = "arith.subi"(%arg5, %2) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b105060) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1056d0) {
  "scf.yield"(%arg6) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b105240) {
  "scf.condition"(%15#0, %15#1) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b105f70) {

  * Pattern MoveIfToAffine : 'scf.if -> ()' {
Trying to match "MoveIfToAffine"
"MoveIfToAffine" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b106090) {
  "scf.yield"(%1, %arg6) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b105cb0) {
  "scf.yield"(%0, %17) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %17 = "arith.addi"(%arg6, %2) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b105a40) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1061f0) {
  "scf.yield"(%arg7) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b105c20) {
  "scf.condition"(%21#0, %21#1) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b1064d0) {

  * Pattern MoveIfToAffine : 'scf.if -> ()' {
Trying to match "MoveIfToAffine"
"MoveIfToAffine" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1065c0) {
  "scf.yield"(%1, %arg7) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b106650) {
  "scf.yield"(%0, %37) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b106050) {
  %0 = "arith.constant"() {value = true} : () -> i1

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %37 = "arith.addi"(%arg7, %2) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%35, %arg2, %36) : (f32, memref<?xf32>, index) -> ()


  * Pattern MoveStoreToAffine : 'memref.store -> ()' {
Trying to match "MoveStoreToAffine"
illegal isValidIndex: <block argument> of type 'i32' at index: 0
"MoveStoreToAffine" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98165e60) {
  %36 = "arith.addi"(%28, %4) : (index, index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %35 = "memref.load"(%arg0, %34) : (memref<?xf32>, index) -> f32


  * Pattern MoveLoadToAffine : 'memref.load -> ()' {
Trying to match "MoveLoadToAffine"
illegal isValidIndex: <block argument> of type 'i32' at index: 0
"MoveLoadToAffine" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b0040e0) {
  %34 = "arith.addi"(%33, %4) : (index, index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd98304bd0) {
  %33 = "arith.index_cast"(%32) : (i32) -> index


  * Pattern CanonicalizeIndexCast : 'arith.index_cast -> ()' {
Trying to match "CanonicalizeIndexCast"
"CanonicalizeIndexCast" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98304b30) {
  %32 = "arith.addi"(%23, %31) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304a90) {
  %31 = "arith.muli"(%30, %25) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %30 = "arith.muli"(%29, %19) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd983045d0) {
  %29 = "arith.subi"(%arg5, %2) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9816cb40) {
  %28 = "arith.index_cast"(%27) : (i32) -> index


  * Pattern CanonicalizeIndexCast : 'arith.index_cast -> ()' {
Trying to match "CanonicalizeIndexCast"
"CanonicalizeIndexCast" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816caa0) {
  %27 = "arith.addi"(%23, %26) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816ca00) {
  %26 = "arith.muli"(%24, %25) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816c960) {
  %25 = "memref.load"(%12, %4) : (memref<1xi32>, index) -> i32


  * Pattern MoveLoadToAffine : 'memref.load -> ()' {
Trying to match "MoveLoadToAffine"
    ** Insert  : 'affine.load'(0x7fbd9b104ce0)
    ** Erase   : 'memref.load'(0x7fbd9816c960)
"MoveLoadToAffine" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %false = arith.constant false
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = memref.load %0[%c0] : memref<1xi32>
  %2 = scf.while (%arg5 = %1) : (i32) -> i32 {
    %3 = arith.cmpi sgt, %arg5, %c0_i32 : i32
    %4:2 = scf.if %3 -> (i1, i32) {
      %5 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
        %7 = memref.get_global @jm : memref<1xi32>
        %8 = memref.load %7[%c0] : memref<1xi32>
        %9 = arith.cmpi slt, %arg6, %8 : i32
        %10:2 = scf.if %9 -> (i1, i32) {
          %11 = scf.while (%arg7 = %c0_i32) : (i32) -> i32 {
            %13 = memref.get_global @im : memref<1xi32>
            %14 = memref.load %13[%c0] : memref<1xi32>
            %15 = arith.cmpi slt, %arg7, %14 : i32
            %16:2 = scf.if %15 -> (i1, i32) {
              %17 = arith.muli %arg6, %14 : i32
              %18 = arith.addi %arg7, %17 : i32
              %19 = arith.muli %arg5, %14 : i32
              %20 = affine.load %7[0] : memref<1xi32>
              %21 = arith.muli %19, %20 : i32
              %22 = arith.addi %18, %21 : i32
              %23 = arith.index_cast %22 : i32 to index
              %24 = arith.subi %arg5, %c1_i32 : i32
              %25 = arith.muli %24, %14 : i32
              %26 = arith.muli %25, %20 : i32
              %27 = arith.addi %18, %26 : i32
              %28 = arith.index_cast %27 : i32 to index
              %29 = arith.addi %28, %c0 : index
              %30 = memref.load %arg0[%29] : memref<?xf32>
              %31 = arith.addi %23, %c0 : index
              memref.store %30, %arg2[%31] : memref<?xf32>
              %32 = arith.addi %arg7, %c1_i32 : i32
              scf.yield %true, %32 : i1, i32
            } else {
              scf.yield %false, %arg7 : i1, i32
            }
            scf.condition(%16#0) %16#1 : i32
          } do {
          ^bb0(%arg7: i32):
            scf.yield %arg7 : i32
          }
          %12 = arith.addi %arg6, %c1_i32 : i32
          scf.yield %true, %12 : i1, i32
        } else {
          scf.yield %false, %arg6 : i1, i32
        }
        scf.condition(%10#0) %10#1 : i32
      } do {
      ^bb0(%arg6: i32):
        scf.yield %arg6 : i32
      }
      %6 = arith.subi %arg5, %c1_i32 : i32
      scf.yield %true, %6 : i1, i32
    } else {
      scf.yield %false, %arg5 : i1, i32
    }
    scf.condition(%4#0) %4#1 : i32
  } do {
  ^bb0(%arg5: i32):
    scf.yield %arg5 : i32
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104ce0) {
  %25 = "affine.load"(%12) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern AffineFixup<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "AffineFixup<mlir::AffineLoadOp>"
"AffineFixup<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %24 = "arith.muli"(%arg5, %19) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %23 = "arith.addi"(%arg7, %22) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %22 = "arith.muli"(%arg6, %19) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %20 = "arith.cmpi"(%arg7, %19) {predicate = 2 : i64} : (i32, i32) -> i1

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9816b720) {
  %19 = "memref.load"(%18, %4) : (memref<1xi32>, index) -> i32


  * Pattern MoveLoadToAffine : 'memref.load -> ()' {
Trying to match "MoveLoadToAffine"
    ** Insert  : 'affine.load'(0x7fbd9b104b90)
    ** Erase   : 'memref.load'(0x7fbd9816b720)
"MoveLoadToAffine" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %false = arith.constant false
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = memref.load %0[%c0] : memref<1xi32>
  %2 = scf.while (%arg5 = %1) : (i32) -> i32 {
    %3 = arith.cmpi sgt, %arg5, %c0_i32 : i32
    %4:2 = scf.if %3 -> (i1, i32) {
      %5 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
        %7 = memref.get_global @jm : memref<1xi32>
        %8 = memref.load %7[%c0] : memref<1xi32>
        %9 = arith.cmpi slt, %arg6, %8 : i32
        %10:2 = scf.if %9 -> (i1, i32) {
          %11 = scf.while (%arg7 = %c0_i32) : (i32) -> i32 {
            %13 = memref.get_global @im : memref<1xi32>
            %14 = affine.load %13[0] : memref<1xi32>
            %15 = arith.cmpi slt, %arg7, %14 : i32
            %16:2 = scf.if %15 -> (i1, i32) {
              %17 = arith.muli %arg6, %14 : i32
              %18 = arith.addi %arg7, %17 : i32
              %19 = arith.muli %arg5, %14 : i32
              %20 = affine.load %7[0] : memref<1xi32>
              %21 = arith.muli %19, %20 : i32
              %22 = arith.addi %18, %21 : i32
              %23 = arith.index_cast %22 : i32 to index
              %24 = arith.subi %arg5, %c1_i32 : i32
              %25 = arith.muli %24, %14 : i32
              %26 = arith.muli %25, %20 : i32
              %27 = arith.addi %18, %26 : i32
              %28 = arith.index_cast %27 : i32 to index
              %29 = arith.addi %28, %c0 : index
              %30 = memref.load %arg0[%29] : memref<?xf32>
              %31 = arith.addi %23, %c0 : index
              memref.store %30, %arg2[%31] : memref<?xf32>
              %32 = arith.addi %arg7, %c1_i32 : i32
              scf.yield %true, %32 : i1, i32
            } else {
              scf.yield %false, %arg7 : i1, i32
            }
            scf.condition(%16#0) %16#1 : i32
          } do {
          ^bb0(%arg7: i32):
            scf.yield %arg7 : i32
          }
          %12 = arith.addi %arg6, %c1_i32 : i32
          scf.yield %true, %12 : i1, i32
        } else {
          scf.yield %false, %arg6 : i1, i32
        }
        scf.condition(%10#0) %10#1 : i32
      } do {
      ^bb0(%arg6: i32):
        scf.yield %arg6 : i32
      }
      %6 = arith.subi %arg5, %c1_i32 : i32
      scf.yield %true, %6 : i1, i32
    } else {
      scf.yield %false, %arg5 : i1, i32
    }
    scf.condition(%4#0) %4#1 : i32
  } do {
  ^bb0(%arg5: i32):
    scf.yield %arg5 : i32
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104b90) {
  %19 = "affine.load"(%18) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern AffineFixup<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "AffineFixup<mlir::AffineLoadOp>"
"AffineFixup<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9816b600) {
  %18 = "memref.get_global"() {name = @im} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %14 = "arith.cmpi"(%arg6, %13) {predicate = 2 : i64} : (i32, i32) -> i1

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98169b40) {
  %13 = "memref.load"(%12, %4) : (memref<1xi32>, index) -> i32


  * Pattern MoveLoadToAffine : 'memref.load -> ()' {
Trying to match "MoveLoadToAffine"
    ** Insert  : 'affine.load'(0x7fbd9b104c10)
    ** Erase   : 'memref.load'(0x7fbd98169b40)
"MoveLoadToAffine" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %false = arith.constant false
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = memref.load %0[%c0] : memref<1xi32>
  %2 = scf.while (%arg5 = %1) : (i32) -> i32 {
    %3 = arith.cmpi sgt, %arg5, %c0_i32 : i32
    %4:2 = scf.if %3 -> (i1, i32) {
      %5 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
        %7 = memref.get_global @jm : memref<1xi32>
        %8 = affine.load %7[0] : memref<1xi32>
        %9 = arith.cmpi slt, %arg6, %8 : i32
        %10:2 = scf.if %9 -> (i1, i32) {
          %11 = scf.while (%arg7 = %c0_i32) : (i32) -> i32 {
            %13 = memref.get_global @im : memref<1xi32>
            %14 = affine.load %13[0] : memref<1xi32>
            %15 = arith.cmpi slt, %arg7, %14 : i32
            %16:2 = scf.if %15 -> (i1, i32) {
              %17 = arith.muli %arg6, %14 : i32
              %18 = arith.addi %arg7, %17 : i32
              %19 = arith.muli %arg5, %14 : i32
              %20 = affine.load %7[0] : memref<1xi32>
              %21 = arith.muli %19, %20 : i32
              %22 = arith.addi %18, %21 : i32
              %23 = arith.index_cast %22 : i32 to index
              %24 = arith.subi %arg5, %c1_i32 : i32
              %25 = arith.muli %24, %14 : i32
              %26 = arith.muli %25, %20 : i32
              %27 = arith.addi %18, %26 : i32
              %28 = arith.index_cast %27 : i32 to index
              %29 = arith.addi %28, %c0 : index
              %30 = memref.load %arg0[%29] : memref<?xf32>
              %31 = arith.addi %23, %c0 : index
              memref.store %30, %arg2[%31] : memref<?xf32>
              %32 = arith.addi %arg7, %c1_i32 : i32
              scf.yield %true, %32 : i1, i32
            } else {
              scf.yield %false, %arg7 : i1, i32
            }
            scf.condition(%16#0) %16#1 : i32
          } do {
          ^bb0(%arg7: i32):
            scf.yield %arg7 : i32
          }
          %12 = arith.addi %arg6, %c1_i32 : i32
          scf.yield %true, %12 : i1, i32
        } else {
          scf.yield %false, %arg6 : i1, i32
        }
        scf.condition(%10#0) %10#1 : i32
      } do {
      ^bb0(%arg6: i32):
        scf.yield %arg6 : i32
      }
      %6 = arith.subi %arg5, %c1_i32 : i32
      scf.yield %true, %6 : i1, i32
    } else {
      scf.yield %false, %arg5 : i1, i32
    }
    scf.condition(%4#0) %4#1 : i32
  } do {
  ^bb0(%arg5: i32):
    scf.yield %arg5 : i32
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104c10) {
  %13 = "affine.load"(%12) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern AffineFixup<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "AffineFixup<mlir::AffineLoadOp>"
"AffineFixup<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd98169a20) {
  %12 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b104660) {
  %1 = "arith.constant"() {value = false} : () -> i1

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98168010) {
  %8 = "arith.cmpi"(%arg5, %3) {predicate = 4 : i64} : (i32, i32) -> i1

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd98167510) {
  %6 = "memref.load"(%5, %4) : (memref<1xi32>, index) -> i32


  * Pattern MoveLoadToAffine : 'memref.load -> ()' {
Trying to match "MoveLoadToAffine"
    ** Insert  : 'affine.load'(0x7fbd9b104d70)
    ** Erase   : 'memref.load'(0x7fbd98167510)
"MoveLoadToAffine" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %false = arith.constant false
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = affine.load %0[0] : memref<1xi32>
  %2 = scf.while (%arg5 = %1) : (i32) -> i32 {
    %3 = arith.cmpi sgt, %arg5, %c0_i32 : i32
    %4:2 = scf.if %3 -> (i1, i32) {
      %5 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
        %7 = memref.get_global @jm : memref<1xi32>
        %8 = affine.load %7[0] : memref<1xi32>
        %9 = arith.cmpi slt, %arg6, %8 : i32
        %10:2 = scf.if %9 -> (i1, i32) {
          %11 = scf.while (%arg7 = %c0_i32) : (i32) -> i32 {
            %13 = memref.get_global @im : memref<1xi32>
            %14 = affine.load %13[0] : memref<1xi32>
            %15 = arith.cmpi slt, %arg7, %14 : i32
            %16:2 = scf.if %15 -> (i1, i32) {
              %17 = arith.muli %arg6, %14 : i32
              %18 = arith.addi %arg7, %17 : i32
              %19 = arith.muli %arg5, %14 : i32
              %20 = affine.load %7[0] : memref<1xi32>
              %21 = arith.muli %19, %20 : i32
              %22 = arith.addi %18, %21 : i32
              %23 = arith.index_cast %22 : i32 to index
              %24 = arith.subi %arg5, %c1_i32 : i32
              %25 = arith.muli %24, %14 : i32
              %26 = arith.muli %25, %20 : i32
              %27 = arith.addi %18, %26 : i32
              %28 = arith.index_cast %27 : i32 to index
              %29 = arith.addi %28, %c0 : index
              %30 = memref.load %arg0[%29] : memref<?xf32>
              %31 = arith.addi %23, %c0 : index
              memref.store %30, %arg2[%31] : memref<?xf32>
              %32 = arith.addi %arg7, %c1_i32 : i32
              scf.yield %true, %32 : i1, i32
            } else {
              scf.yield %false, %arg7 : i1, i32
            }
            scf.condition(%16#0) %16#1 : i32
          } do {
          ^bb0(%arg7: i32):
            scf.yield %arg7 : i32
          }
          %12 = arith.addi %arg6, %c1_i32 : i32
          scf.yield %true, %12 : i1, i32
        } else {
          scf.yield %false, %arg6 : i1, i32
        }
        scf.condition(%10#0) %10#1 : i32
      } do {
      ^bb0(%arg6: i32):
        scf.yield %arg6 : i32
      }
      %6 = arith.subi %arg5, %c1_i32 : i32
      scf.yield %true, %6 : i1, i32
    } else {
      scf.yield %false, %arg5 : i1, i32
    }
    scf.condition(%4#0) %4#1 : i32
  } do {
  ^bb0(%arg5: i32):
    scf.yield %arg5 : i32
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104d70) {
  %6 = "affine.load"(%5) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern AffineFixup<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "AffineFixup<mlir::AffineLoadOp>"
"AffineFixup<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd981673f0) {
  %5 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9816cc60) {
  %4 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98167e90) {
  %3 = "arith.constant"() {value = 0 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98304580) {
  %2 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//
ImplicitTypeIDRegistry::lookupOrInsert(mlir::AffineReadOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::AffineMapAccessInterface::Trait<Empty>)

//===-------------------------------------------===//
Processing operation : 'func.return'(0x7fbd9800c610) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b1042d0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b104910) {
  "scf.yield"(%arg5) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b1044b0) {
  "scf.condition"(%9#0, %9#1) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b1052f0) {

  * Pattern MoveIfToAffine : 'scf.if -> ()' {
Trying to match "MoveIfToAffine"
"MoveIfToAffine" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1066e0) {
  "scf.yield"(%1, %arg5) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b105460) {
  "scf.yield"(%0, %11) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9800c320) {
  %11 = "arith.subi"(%arg5, %2) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b105060) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1056d0) {
  "scf.yield"(%arg6) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b105240) {
  "scf.condition"(%15#0, %15#1) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b105f70) {

  * Pattern MoveIfToAffine : 'scf.if -> ()' {
Trying to match "MoveIfToAffine"
"MoveIfToAffine" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b106090) {
  "scf.yield"(%1, %arg6) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b105cb0) {
  "scf.yield"(%0, %17) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %17 = "arith.addi"(%arg6, %2) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b105a40) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1061f0) {
  "scf.yield"(%arg7) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b105c20) {
  "scf.condition"(%21#0, %21#1) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b1064d0) {

  * Pattern MoveIfToAffine : 'scf.if -> ()' {
Trying to match "MoveIfToAffine"
"MoveIfToAffine" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1065c0) {
  "scf.yield"(%1, %arg7) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b106650) {
  "scf.yield"(%0, %37) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %37 = "arith.addi"(%arg7, %2) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%35, %arg2, %36) : (f32, memref<?xf32>, index) -> ()


  * Pattern MoveStoreToAffine : 'memref.store -> ()' {
Trying to match "MoveStoreToAffine"
illegal isValidIndex: <block argument> of type 'i32' at index: 0
"MoveStoreToAffine" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98165e60) {
  %36 = "arith.addi"(%28, %4) : (index, index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %35 = "memref.load"(%arg0, %34) : (memref<?xf32>, index) -> f32


  * Pattern MoveLoadToAffine : 'memref.load -> ()' {
Trying to match "MoveLoadToAffine"
illegal isValidIndex: <block argument> of type 'i32' at index: 0
"MoveLoadToAffine" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b0040e0) {
  %34 = "arith.addi"(%33, %4) : (index, index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd98304bd0) {
  %33 = "arith.index_cast"(%32) : (i32) -> index


  * Pattern CanonicalizeIndexCast : 'arith.index_cast -> ()' {
Trying to match "CanonicalizeIndexCast"
"CanonicalizeIndexCast" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98304b30) {
  %32 = "arith.addi"(%23, %31) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304a90) {
  %31 = "arith.muli"(%30, %25) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %30 = "arith.muli"(%29, %19) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd983045d0) {
  %29 = "arith.subi"(%arg5, %2) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9816cb40) {
  %28 = "arith.index_cast"(%27) : (i32) -> index


  * Pattern CanonicalizeIndexCast : 'arith.index_cast -> ()' {
Trying to match "CanonicalizeIndexCast"
"CanonicalizeIndexCast" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816caa0) {
  %27 = "arith.addi"(%23, %26) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816ca00) {
  %26 = "arith.muli"(%24, %25) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104ce0) {
  %25 = "affine.load"(%12) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern AffineFixup<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "AffineFixup<mlir::AffineLoadOp>"
"AffineFixup<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %24 = "arith.muli"(%arg5, %19) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %23 = "arith.addi"(%arg7, %22) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %22 = "arith.muli"(%arg6, %19) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %20 = "arith.cmpi"(%arg7, %19) {predicate = 2 : i64} : (i32, i32) -> i1

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104b90) {
  %19 = "affine.load"(%18) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern AffineFixup<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "AffineFixup<mlir::AffineLoadOp>"
"AffineFixup<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9816b600) {
  %18 = "memref.get_global"() {name = @im} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %14 = "arith.cmpi"(%arg6, %13) {predicate = 2 : i64} : (i32, i32) -> i1

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104c10) {
  %13 = "affine.load"(%12) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern AffineFixup<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "AffineFixup<mlir::AffineLoadOp>"
"AffineFixup<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd98169a20) {
  %12 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98168010) {
  %8 = "arith.cmpi"(%arg5, %3) {predicate = 4 : i64} : (i32, i32) -> i1

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104d70) {
  %6 = "affine.load"(%5) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern AffineFixup<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "AffineFixup<mlir::AffineLoadOp>"
"AffineFixup<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd981673f0) {
  %5 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9816cc60) {
  %4 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98167e90) {
  %3 = "arith.constant"() {value = 0 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98304580) {
  %2 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b104660) {
  %1 = "arith.constant"() {value = false} : () -> i1

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b106050) {
  %0 = "arith.constant"() {value = true} : () -> i1

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x7fbd9800c610) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b1042d0) {

  * Pattern (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock"
"(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveLoopInvariantValueYielded : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantValueYielded"
"(anonymous namespace)::RemoveLoopInvariantValueYielded" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileConditionTruth : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileConditionTruth"
"(anonymous namespace)::WhileConditionTruth" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileCmpCond : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileCmpCond"
"(anonymous namespace)::WhileCmpCond" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileUnusedResult : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileUnusedResult"
"(anonymous namespace)::WhileUnusedResult" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b104910) {
  "scf.yield"(%arg5) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b1044b0) {
  "scf.condition"(%9#0, %9#1) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b1052f0) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
    ** Insert  : 'scf.yield'(0x7fbd9b1049f0)
    ** Insert  : 'scf.if'(0x7fbd9b1053a0)
    ** Erase   : 'scf.yield'(0x7fbd9b1049f0)
    ** Insert  : 'arith.select'(0x7fbd9b105d50)
    ** Insert  : 'scf.yield'(0x7fbd9b104370)
    ** Replace : 'scf.yield'(0x7fbd9b105460)
    ** Insert  : 'scf.yield'(0x7fbd9b105ae0)
    ** Replace : 'scf.yield'(0x7fbd9b1066e0)
    ** Replace : 'scf.if'(0x7fbd9b1052f0)
"(anonymous namespace)::ConvertTrivialIfToSelect" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %false = arith.constant false
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = affine.load %0[0] : memref<1xi32>
  %2 = scf.while (%arg5 = %1) : (i32) -> i32 {
    %3 = arith.cmpi sgt, %arg5, %c0_i32 : i32
    %4 = arith.select %3, %true, %false : i1
    %5 = scf.if %3 -> (i32) {
      %6 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
        %8 = memref.get_global @jm : memref<1xi32>
        %9 = affine.load %8[0] : memref<1xi32>
        %10 = arith.cmpi slt, %arg6, %9 : i32
        %11:2 = scf.if %10 -> (i1, i32) {
          %12 = scf.while (%arg7 = %c0_i32) : (i32) -> i32 {
            %14 = memref.get_global @im : memref<1xi32>
            %15 = affine.load %14[0] : memref<1xi32>
            %16 = arith.cmpi slt, %arg7, %15 : i32
            %17:2 = scf.if %16 -> (i1, i32) {
              %18 = arith.muli %arg6, %15 : i32
              %19 = arith.addi %arg7, %18 : i32
              %20 = arith.muli %arg5, %15 : i32
              %21 = affine.load %8[0] : memref<1xi32>
              %22 = arith.muli %20, %21 : i32
              %23 = arith.addi %19, %22 : i32
              %24 = arith.index_cast %23 : i32 to index
              %25 = arith.subi %arg5, %c1_i32 : i32
              %26 = arith.muli %25, %15 : i32
              %27 = arith.muli %26, %21 : i32
              %28 = arith.addi %19, %27 : i32
              %29 = arith.index_cast %28 : i32 to index
              %30 = arith.addi %29, %c0 : index
              %31 = memref.load %arg0[%30] : memref<?xf32>
              %32 = arith.addi %24, %c0 : index
              memref.store %31, %arg2[%32] : memref<?xf32>
              %33 = arith.addi %arg7, %c1_i32 : i32
              scf.yield %true, %33 : i1, i32
            } else {
              scf.yield %false, %arg7 : i1, i32
            }
            scf.condition(%17#0) %17#1 : i32
          } do {
          ^bb0(%arg7: i32):
            scf.yield %arg7 : i32
          }
          %13 = arith.addi %arg6, %c1_i32 : i32
          scf.yield %true, %13 : i1, i32
        } else {
          scf.yield %false, %arg6 : i1, i32
        }
        scf.condition(%11#0) %11#1 : i32
      } do {
      ^bb0(%arg6: i32):
        scf.yield %arg6 : i32
      }
      %7 = arith.subi %arg5, %c1_i32 : i32
      scf.yield %7 : i32
    } else {
      scf.yield %arg5 : i32
    }
    scf.condition(%4) %5 : i32
  } do {
  ^bb0(%arg5: i32):
    scf.yield %arg5 : i32
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b1044b0) {
  "scf.condition"(%9, %10) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b105ae0) {
  "scf.yield"(%arg5) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b104370) {
  "scf.yield"(%12) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.select'(0x7fbd9b105d50) {
  %9 = "arith.select"(%8, %0, %1) : (i1, i1, i1) -> i1

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b1044b0) {
  "scf.condition"(%8, %9) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b1053a0) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9800c320) {
  %11 = "arith.subi"(%arg5, %2) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b105060) {

  * Pattern (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock"
"(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveLoopInvariantValueYielded : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantValueYielded"
"(anonymous namespace)::RemoveLoopInvariantValueYielded" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileConditionTruth : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileConditionTruth"
"(anonymous namespace)::WhileConditionTruth" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileCmpCond : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileCmpCond"
"(anonymous namespace)::WhileCmpCond" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileUnusedResult : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileUnusedResult"
"(anonymous namespace)::WhileUnusedResult" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1056d0) {
  "scf.yield"(%arg6) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b105240) {
  "scf.condition"(%15#0, %15#1) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b105f70) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
    ** Insert  : 'scf.yield'(0x7fbd96f10370)
    ** Insert  : 'scf.if'(0x7fbd96f18d30)
    ** Erase   : 'scf.yield'(0x7fbd96f10370)
    ** Insert  : 'arith.select'(0x7fbd96f14710)
    ** Insert  : 'scf.yield'(0x7fbd96f10370)
    ** Replace : 'scf.yield'(0x7fbd9b105cb0)
    ** Insert  : 'scf.yield'(0x7fbd96f18dd0)
    ** Replace : 'scf.yield'(0x7fbd9b106090)
    ** Replace : 'scf.if'(0x7fbd9b105f70)
"(anonymous namespace)::ConvertTrivialIfToSelect" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %false = arith.constant false
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = affine.load %0[0] : memref<1xi32>
  %2 = scf.while (%arg5 = %1) : (i32) -> i32 {
    %3 = arith.cmpi sgt, %arg5, %c0_i32 : i32
    %4 = scf.if %3 -> (i32) {
      %5 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
        %7 = memref.get_global @jm : memref<1xi32>
        %8 = affine.load %7[0] : memref<1xi32>
        %9 = arith.cmpi slt, %arg6, %8 : i32
        %10 = arith.select %9, %true, %false : i1
        %11 = scf.if %9 -> (i32) {
          %12 = scf.while (%arg7 = %c0_i32) : (i32) -> i32 {
            %14 = memref.get_global @im : memref<1xi32>
            %15 = affine.load %14[0] : memref<1xi32>
            %16 = arith.cmpi slt, %arg7, %15 : i32
            %17:2 = scf.if %16 -> (i1, i32) {
              %18 = arith.muli %arg6, %15 : i32
              %19 = arith.addi %arg7, %18 : i32
              %20 = arith.muli %arg5, %15 : i32
              %21 = affine.load %7[0] : memref<1xi32>
              %22 = arith.muli %20, %21 : i32
              %23 = arith.addi %19, %22 : i32
              %24 = arith.index_cast %23 : i32 to index
              %25 = arith.subi %arg5, %c1_i32 : i32
              %26 = arith.muli %25, %15 : i32
              %27 = arith.muli %26, %21 : i32
              %28 = arith.addi %19, %27 : i32
              %29 = arith.index_cast %28 : i32 to index
              %30 = arith.addi %29, %c0 : index
              %31 = memref.load %arg0[%30] : memref<?xf32>
              %32 = arith.addi %24, %c0 : index
              memref.store %31, %arg2[%32] : memref<?xf32>
              %33 = arith.addi %arg7, %c1_i32 : i32
              scf.yield %true, %33 : i1, i32
            } else {
              scf.yield %false, %arg7 : i1, i32
            }
            scf.condition(%17#0) %17#1 : i32
          } do {
          ^bb0(%arg7: i32):
            scf.yield %arg7 : i32
          }
          %13 = arith.addi %arg6, %c1_i32 : i32
          scf.yield %13 : i32
        } else {
          scf.yield %arg6 : i32
        }
        scf.condition(%10) %11 : i32
      } do {
      ^bb0(%arg6: i32):
        scf.yield %arg6 : i32
      }
      %6 = arith.subi %arg5, %c1_i32 : i32
      scf.yield %6 : i32
    } else {
      scf.yield %arg5 : i32
    }
    scf.condition(%3) %4 : i32
  } do {
  ^bb0(%arg5: i32):
    scf.yield %arg5 : i32
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b105240) {
  "scf.condition"(%15, %16) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd96f18dd0) {
  "scf.yield"(%arg6) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd96f10370) {
  "scf.yield"(%18) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.select'(0x7fbd96f14710) {
  %15 = "arith.select"(%14, %0, %1) : (i1, i1, i1) -> i1

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b105240) {
  "scf.condition"(%14, %15) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd96f18d30) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %17 = "arith.addi"(%arg6, %2) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b105a40) {

  * Pattern (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock"
"(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveLoopInvariantValueYielded : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantValueYielded"
"(anonymous namespace)::RemoveLoopInvariantValueYielded" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileConditionTruth : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileConditionTruth"
"(anonymous namespace)::WhileConditionTruth" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileCmpCond : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileCmpCond"
"(anonymous namespace)::WhileCmpCond" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileUnusedResult : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileUnusedResult"
"(anonymous namespace)::WhileUnusedResult" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1061f0) {
  "scf.yield"(%arg7) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b105c20) {
  "scf.condition"(%21#0, %21#1) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b1064d0) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
    ** Insert  : 'scf.yield'(0x7fbd96f14750)
    ** Insert  : 'scf.if'(0x7fbd96f147b0)
    ** Erase   : 'scf.yield'(0x7fbd96f14750)
    ** Insert  : 'arith.select'(0x7fbd96f059f0)
    ** Insert  : 'scf.yield'(0x7fbd96f14850)
    ** Replace : 'scf.yield'(0x7fbd9b106650)
    ** Insert  : 'scf.yield'(0x7fbd96f05aa0)
    ** Replace : 'scf.yield'(0x7fbd9b1065c0)
    ** Replace : 'scf.if'(0x7fbd9b1064d0)
"(anonymous namespace)::ConvertTrivialIfToSelect" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %true = arith.constant true
  %false = arith.constant false
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = affine.load %0[0] : memref<1xi32>
  %2 = scf.while (%arg5 = %1) : (i32) -> i32 {
    %3 = arith.cmpi sgt, %arg5, %c0_i32 : i32
    %4 = scf.if %3 -> (i32) {
      %5 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
        %7 = memref.get_global @jm : memref<1xi32>
        %8 = affine.load %7[0] : memref<1xi32>
        %9 = arith.cmpi slt, %arg6, %8 : i32
        %10 = scf.if %9 -> (i32) {
          %11 = scf.while (%arg7 = %c0_i32) : (i32) -> i32 {
            %13 = memref.get_global @im : memref<1xi32>
            %14 = affine.load %13[0] : memref<1xi32>
            %15 = arith.cmpi slt, %arg7, %14 : i32
            %16 = arith.select %15, %true, %false : i1
            %17 = scf.if %15 -> (i32) {
              %18 = arith.muli %arg6, %14 : i32
              %19 = arith.addi %arg7, %18 : i32
              %20 = arith.muli %arg5, %14 : i32
              %21 = affine.load %7[0] : memref<1xi32>
              %22 = arith.muli %20, %21 : i32
              %23 = arith.addi %19, %22 : i32
              %24 = arith.index_cast %23 : i32 to index
              %25 = arith.subi %arg5, %c1_i32 : i32
              %26 = arith.muli %25, %14 : i32
              %27 = arith.muli %26, %21 : i32
              %28 = arith.addi %19, %27 : i32
              %29 = arith.index_cast %28 : i32 to index
              %30 = arith.addi %29, %c0 : index
              %31 = memref.load %arg0[%30] : memref<?xf32>
              %32 = arith.addi %24, %c0 : index
              memref.store %31, %arg2[%32] : memref<?xf32>
              %33 = arith.addi %arg7, %c1_i32 : i32
              scf.yield %33 : i32
            } else {
              scf.yield %arg7 : i32
            }
            scf.condition(%16) %17 : i32
          } do {
          ^bb0(%arg7: i32):
            scf.yield %arg7 : i32
          }
          %12 = arith.addi %arg6, %c1_i32 : i32
          scf.yield %12 : i32
        } else {
          scf.yield %arg6 : i32
        }
        scf.condition(%9) %10 : i32
      } do {
      ^bb0(%arg6: i32):
        scf.yield %arg6 : i32
      }
      %6 = arith.subi %arg5, %c1_i32 : i32
      scf.yield %6 : i32
    } else {
      scf.yield %arg5 : i32
    }
    scf.condition(%3) %4 : i32
  } do {
  ^bb0(%arg5: i32):
    scf.yield %arg5 : i32
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b105c20) {
  "scf.condition"(%21, %22) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd96f05aa0) {
  "scf.yield"(%arg7) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd96f14850) {
  "scf.yield"(%38) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.select'(0x7fbd96f059f0) {
  %21 = "arith.select"(%20, %0, %1) : (i1, i1, i1) -> i1

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b105c20) {
  "scf.condition"(%20, %21) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd96f147b0) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %37 = "arith.addi"(%arg7, %2) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%35, %arg2, %36) : (f32, memref<?xf32>, index) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98165e60) {
  %36 = "arith.addi"(%28, %4) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %35 = "memref.load"(%arg0, %34) : (memref<?xf32>, index) -> f32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b0040e0) {
  %34 = "arith.addi"(%33, %4) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd98304bd0) {
  %33 = "arith.index_cast"(%32) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98304b30) {
  %32 = "arith.addi"(%23, %31) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304a90) {
  %31 = "arith.muli"(%30, %25) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %30 = "arith.muli"(%29, %19) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd983045d0) {
  %29 = "arith.subi"(%arg5, %2) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9816cb40) {
  %28 = "arith.index_cast"(%27) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816caa0) {
  %27 = "arith.addi"(%23, %26) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816ca00) {
  %26 = "arith.muli"(%24, %25) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104ce0) {
  %25 = "affine.load"(%12) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %24 = "arith.muli"(%arg5, %19) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %23 = "arith.addi"(%arg7, %22) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %22 = "arith.muli"(%arg6, %19) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %20 = "arith.cmpi"(%arg7, %19) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104b90) {
  %19 = "affine.load"(%18) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9816b600) {
  %18 = "memref.get_global"() {name = @im} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %14 = "arith.cmpi"(%arg6, %13) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104c10) {
  %13 = "affine.load"(%12) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd98169a20) {
  %12 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98168010) {
  %8 = "arith.cmpi"(%arg5, %3) {predicate = 4 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104d70) {
  %6 = "affine.load"(%5) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd981673f0) {
  %5 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9816cc60) {
  %4 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98167e90) {
  %3 = "arith.constant"() {value = 0 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98304580) {
  %2 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b104660) {
  %1 = "arith.constant"() {value = false} : () -> i1

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b106050) {
  %0 = "arith.constant"() {value = true} : () -> i1

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x7fbd9800c610) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b1042d0) {

  * Pattern (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock"
"(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveLoopInvariantValueYielded : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantValueYielded"
"(anonymous namespace)::RemoveLoopInvariantValueYielded" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileConditionTruth : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileConditionTruth"
"(anonymous namespace)::WhileConditionTruth" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileCmpCond : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileCmpCond"
"(anonymous namespace)::WhileCmpCond" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileUnusedResult : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileUnusedResult"
"(anonymous namespace)::WhileUnusedResult" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b104910) {
  "scf.yield"(%arg5) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b1044b0) {
  "scf.condition"(%6, %7) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b1053a0) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b105ae0) {
  "scf.yield"(%arg5) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b104370) {
  "scf.yield"(%9) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9800c320) {
  %9 = "arith.subi"(%arg5, %0) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b105060) {

  * Pattern (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock"
"(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveLoopInvariantValueYielded : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantValueYielded"
"(anonymous namespace)::RemoveLoopInvariantValueYielded" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileConditionTruth : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileConditionTruth"
"(anonymous namespace)::WhileConditionTruth" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileCmpCond : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileCmpCond"
"(anonymous namespace)::WhileCmpCond" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileUnusedResult : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileUnusedResult"
"(anonymous namespace)::WhileUnusedResult" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1056d0) {
  "scf.yield"(%arg6) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b105240) {
  "scf.condition"(%12, %13) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd96f18d30) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd96f18dd0) {
  "scf.yield"(%arg6) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd96f10370) {
  "scf.yield"(%15) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %15 = "arith.addi"(%arg6, %0) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b105a40) {

  * Pattern (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock"
"(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveLoopInvariantValueYielded : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantValueYielded"
"(anonymous namespace)::RemoveLoopInvariantValueYielded" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileConditionTruth : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileConditionTruth"
"(anonymous namespace)::WhileConditionTruth" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileCmpCond : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileCmpCond"
"(anonymous namespace)::WhileCmpCond" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileUnusedResult : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileUnusedResult"
"(anonymous namespace)::WhileUnusedResult" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1061f0) {
  "scf.yield"(%arg7) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b105c20) {
  "scf.condition"(%18, %19) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd96f147b0) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd96f05aa0) {
  "scf.yield"(%arg7) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd96f14850) {
  "scf.yield"(%35) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %35 = "arith.addi"(%arg7, %0) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%33, %arg2, %34) : (f32, memref<?xf32>, index) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98165e60) {
  %34 = "arith.addi"(%26, %2) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %33 = "memref.load"(%arg0, %32) : (memref<?xf32>, index) -> f32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b0040e0) {
  %32 = "arith.addi"(%31, %2) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd98304bd0) {
  %31 = "arith.index_cast"(%30) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98304b30) {
  %30 = "arith.addi"(%21, %29) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304a90) {
  %29 = "arith.muli"(%28, %23) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %28 = "arith.muli"(%27, %17) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd983045d0) {
  %27 = "arith.subi"(%arg5, %0) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9816cb40) {
  %26 = "arith.index_cast"(%25) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816caa0) {
  %25 = "arith.addi"(%21, %24) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816ca00) {
  %24 = "arith.muli"(%22, %23) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104ce0) {
  %23 = "affine.load"(%10) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %22 = "arith.muli"(%arg5, %17) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %21 = "arith.addi"(%arg7, %20) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %20 = "arith.muli"(%arg6, %17) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %18 = "arith.cmpi"(%arg7, %17) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104b90) {
  %17 = "affine.load"(%16) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9816b600) {
  %16 = "memref.get_global"() {name = @im} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %12 = "arith.cmpi"(%arg6, %11) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104c10) {
  %11 = "affine.load"(%10) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd98169a20) {
  %10 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98168010) {
  %6 = "arith.cmpi"(%arg5, %1) {predicate = 4 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104d70) {
  %4 = "affine.load"(%3) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd981673f0) {
  %3 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9816cc60) {
  %2 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98167e90) {
  %1 = "arith.constant"() {value = 0 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98304580) {
  %0 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x7fbd9800c610) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b1042d0) {

  * Pattern (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock"
"(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveLoopInvariantValueYielded : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantValueYielded"
"(anonymous namespace)::RemoveLoopInvariantValueYielded" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileConditionTruth : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileConditionTruth"
"(anonymous namespace)::WhileConditionTruth" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileCmpCond : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileCmpCond"
"(anonymous namespace)::WhileCmpCond" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileUnusedResult : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileUnusedResult"
"(anonymous namespace)::WhileUnusedResult" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b104910) {
  "scf.yield"(%arg5) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b1044b0) {
  "scf.condition"(%6, %7) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd9b1053a0) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b105ae0) {
  "scf.yield"(%arg5) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b104370) {
  "scf.yield"(%9) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9800c320) {
  %9 = "arith.subi"(%arg5, %0) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b105060) {

  * Pattern (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock"
"(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveLoopInvariantValueYielded : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantValueYielded"
"(anonymous namespace)::RemoveLoopInvariantValueYielded" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileConditionTruth : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileConditionTruth"
"(anonymous namespace)::WhileConditionTruth" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileCmpCond : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileCmpCond"
"(anonymous namespace)::WhileCmpCond" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileUnusedResult : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileUnusedResult"
"(anonymous namespace)::WhileUnusedResult" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1056d0) {
  "scf.yield"(%arg6) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b105240) {
  "scf.condition"(%12, %13) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd96f18d30) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd96f18dd0) {
  "scf.yield"(%arg6) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd96f10370) {
  "scf.yield"(%15) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %15 = "arith.addi"(%arg6, %0) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b105a40) {

  * Pattern (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock"
"(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveLoopInvariantValueYielded : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantValueYielded"
"(anonymous namespace)::RemoveLoopInvariantValueYielded" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileConditionTruth : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileConditionTruth"
"(anonymous namespace)::WhileConditionTruth" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileCmpCond : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileCmpCond"
"(anonymous namespace)::WhileCmpCond" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileUnusedResult : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileUnusedResult"
"(anonymous namespace)::WhileUnusedResult" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1061f0) {
  "scf.yield"(%arg7) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b105c20) {
  "scf.condition"(%18, %19) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.if'(0x7fbd96f147b0) {

  * Pattern MoveIntoIfs : 'scf.if -> ()' {
Trying to match "MoveIntoIfs"
"MoveIntoIfs" result 0
  } -> failure : pattern failed to match

  * Pattern MoveOutOfIfs : 'scf.if -> ()' {
Trying to match "MoveOutOfIfs"
"MoveOutOfIfs" result 0
  } -> failure : pattern failed to match

  * Pattern IfAndLazy : 'scf.if -> ()' {
Trying to match "IfAndLazy"
"IfAndLazy" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineIfs"
"(anonymous namespace)::CombineIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineNestedIfs : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::CombineNestedIfs"
"(anonymous namespace)::CombineNestedIfs" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConditionPropagation : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConditionPropagation"
"(anonymous namespace)::ConditionPropagation" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ConvertTrivialIfToSelect : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ConvertTrivialIfToSelect"
"(anonymous namespace)::ConvertTrivialIfToSelect" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveEmptyElseBranch : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveEmptyElseBranch"
"(anonymous namespace)::RemoveEmptyElseBranch" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveStaticCondition : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveStaticCondition"
"(anonymous namespace)::RemoveStaticCondition" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedResults : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::RemoveUnusedResults"
"(anonymous namespace)::RemoveUnusedResults" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ReplaceIfYieldWithConditionOrValue : 'scf.if -> ()' {
Trying to match "(anonymous namespace)::ReplaceIfYieldWithConditionOrValue"
"(anonymous namespace)::ReplaceIfYieldWithConditionOrValue" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd96f05aa0) {
  "scf.yield"(%arg7) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd96f14850) {
  "scf.yield"(%35) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %35 = "arith.addi"(%arg7, %0) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%33, %arg2, %34) : (f32, memref<?xf32>, index) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98165e60) {
  %34 = "arith.addi"(%26, %2) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %33 = "memref.load"(%arg0, %32) : (memref<?xf32>, index) -> f32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b0040e0) {
  %32 = "arith.addi"(%31, %2) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd98304bd0) {
  %31 = "arith.index_cast"(%30) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98304b30) {
  %30 = "arith.addi"(%21, %29) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304a90) {
  %29 = "arith.muli"(%28, %23) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %28 = "arith.muli"(%27, %17) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd983045d0) {
  %27 = "arith.subi"(%arg5, %0) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9816cb40) {
  %26 = "arith.index_cast"(%25) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816caa0) {
  %25 = "arith.addi"(%21, %24) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816ca00) {
  %24 = "arith.muli"(%22, %23) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104ce0) {
  %23 = "affine.load"(%10) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %22 = "arith.muli"(%arg5, %17) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %21 = "arith.addi"(%arg7, %20) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %20 = "arith.muli"(%arg6, %17) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %18 = "arith.cmpi"(%arg7, %17) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104b90) {
  %17 = "affine.load"(%16) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9816b600) {
  %16 = "memref.get_global"() {name = @im} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %12 = "arith.cmpi"(%arg6, %11) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104c10) {
  %11 = "affine.load"(%10) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd98169a20) {
  %10 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98168010) {
  %6 = "arith.cmpi"(%arg5, %1) {predicate = 4 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104d70) {
  %4 = "affine.load"(%3) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd981673f0) {
  %3 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9816cc60) {
  %2 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98167e90) {
  %1 = "arith.constant"() {value = 0 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98304580) {
  %0 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x7fbd9800c610) {
  "func.return"() : () -> ()


  * Pattern ReturnSq : 'func.return -> ()' {
Trying to match "ReturnSq"
"ReturnSq" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b1042d0) {

  * Pattern MoveWhileToFor : 'scf.while -> ()' {
Trying to match "MoveWhileToFor"
"MoveWhileToFor" result 0
  } -> failure : pattern failed to match

  * Pattern RemoveWhileSelect : 'scf.while -> ()' {
Trying to match "RemoveWhileSelect"
"RemoveWhileSelect" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown : 'scf.while -> ()' {
Trying to match "MoveWhileDown"
"MoveWhileDown" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown2 : 'scf.while -> ()' {
Trying to match "MoveWhileDown2"
    ** Insert  : 'scf.condition'(0x7fbd9b104fa0)
    ** Replace : 'scf.condition'(0x7fbd9b1044b0)
    ** Erase   : 'scf.yield'(0x7fbd9b104370)
    ** Erase   : 'scf.if'(0x7fbd9b1053a0)
    ** Insert  : 'scf.while'(0x7fbd9b1053a0)
    ** Erase   : 'scf.while'(0x7fbd9b1042d0)
"MoveWhileDown2" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = affine.load %0[0] : memref<1xi32>
  %2 = scf.while (%arg5 = %1) : (i32) -> i32 {
    %3 = arith.cmpi sgt, %arg5, %c0_i32 : i32
    scf.condition(%3) %arg5 : i32
  } do {
  ^bb0(%arg5: i32):
    %3 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
      %5 = memref.get_global @jm : memref<1xi32>
      %6 = affine.load %5[0] : memref<1xi32>
      %7 = arith.cmpi slt, %arg6, %6 : i32
      %8 = scf.if %7 -> (i32) {
        %9 = scf.while (%arg7 = %c0_i32) : (i32) -> i32 {
          %11 = memref.get_global @im : memref<1xi32>
          %12 = affine.load %11[0] : memref<1xi32>
          %13 = arith.cmpi slt, %arg7, %12 : i32
          %14 = scf.if %13 -> (i32) {
            %15 = arith.muli %arg6, %12 : i32
            %16 = arith.addi %arg7, %15 : i32
            %17 = arith.muli %arg5, %12 : i32
            %18 = affine.load %5[0] : memref<1xi32>
            %19 = arith.muli %17, %18 : i32
            %20 = arith.addi %16, %19 : i32
            %21 = arith.index_cast %20 : i32 to index
            %22 = arith.subi %arg5, %c1_i32 : i32
            %23 = arith.muli %22, %12 : i32
            %24 = arith.muli %23, %18 : i32
            %25 = arith.addi %16, %24 : i32
            %26 = arith.index_cast %25 : i32 to index
            %27 = arith.addi %26, %c0 : index
            %28 = memref.load %arg0[%27] : memref<?xf32>
            %29 = arith.addi %21, %c0 : index
            memref.store %28, %arg2[%29] : memref<?xf32>
            %30 = arith.addi %arg7, %c1_i32 : i32
            scf.yield %30 : i32
          } else {
            scf.yield %arg7 : i32
          }
          scf.condition(%13) %14 : i32
        } do {
        ^bb0(%arg7: i32):
          scf.yield %arg7 : i32
        }
        %10 = arith.addi %arg6, %c1_i32 : i32
        scf.yield %10 : i32
      } else {
        scf.yield %arg6 : i32
      }
      scf.condition(%7) %8 : i32
    } do {
    ^bb0(%arg6: i32):
      scf.yield %arg6 : i32
    }
    %4 = arith.subi %arg5, %c1_i32 : i32
    scf.yield %4 : i32
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b1053a0) {

  * Pattern MoveWhileToFor : 'scf.while -> ()' {
Trying to match "MoveWhileToFor"
"MoveWhileToFor" result 0
  } -> failure : pattern failed to match

  * Pattern RemoveWhileSelect : 'scf.while -> ()' {
Trying to match "RemoveWhileSelect"
"RemoveWhileSelect" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown : 'scf.while -> ()' {
Trying to match "MoveWhileDown"
"MoveWhileDown" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown2 : 'scf.while -> ()' {
Trying to match "MoveWhileDown2"
"MoveWhileDown2" result 0
  } -> failure : pattern failed to match

  * Pattern WhileShiftToInduction : 'scf.while -> ()' {
Trying to match "WhileShiftToInduction"
"WhileShiftToInduction" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileAndDown : 'scf.while -> ()' {
Trying to match "MoveWhileAndDown"
"MoveWhileAndDown" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown3 : 'scf.while -> ()' {
Trying to match "MoveWhileDown3"
"MoveWhileDown3" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileInvariantIfResult : 'scf.while -> ()' {
Trying to match "MoveWhileInvariantIfResult"
"MoveWhileInvariantIfResult" result 0
  } -> failure : pattern failed to match

  * Pattern WhileLogicalNegation : 'scf.while -> ()' {
Trying to match "WhileLogicalNegation"
"WhileLogicalNegation" result 0
  } -> failure : pattern failed to match

  * Pattern WhileCmpOffset : 'scf.while -> ()' {
Trying to match "WhileCmpOffset"
"WhileCmpOffset" result 0
  } -> failure : pattern failed to match

  * Pattern WhileLICM : 'scf.while -> ()' {
Trying to match "WhileLICM"
"WhileLICM" result 0
  } -> failure : pattern failed to match

  * Pattern RemoveUnusedCondVar : 'scf.while -> ()' {
Trying to match "RemoveUnusedCondVar"
"RemoveUnusedCondVar" result 0
  } -> failure : pattern failed to match

  * Pattern MoveSideEffectFreeWhile : 'scf.while -> ()' {
Trying to match "MoveSideEffectFreeWhile"
"MoveSideEffectFreeWhile" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b104fa0) {
  "scf.condition"(%6, %arg5) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b104910) {
  "scf.yield"(%7) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9800c320) {
  %7 = "arith.subi"(%arg5, %0) : (i32, i32) -> i32


  * Pattern SubToAdd : 'arith.subi -> ()' {
Trying to match "SubToAdd"
    ** Insert  : 'arith.constant'(0x7fbd9b104c90)
    ** Insert  : 'arith.addi'(0x7fbd9b1067d0)
    ** Replace : 'arith.subi'(0x7fbd9800c320)
"SubToAdd" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = affine.load %0[0] : memref<1xi32>
  %2 = scf.while (%arg5 = %1) : (i32) -> i32 {
    %3 = arith.cmpi sgt, %arg5, %c0_i32 : i32
    scf.condition(%3) %arg5 : i32
  } do {
  ^bb0(%arg5: i32):
    %3 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
      %5 = memref.get_global @jm : memref<1xi32>
      %6 = affine.load %5[0] : memref<1xi32>
      %7 = arith.cmpi slt, %arg6, %6 : i32
      %8 = scf.if %7 -> (i32) {
        %9 = scf.while (%arg7 = %c0_i32) : (i32) -> i32 {
          %11 = memref.get_global @im : memref<1xi32>
          %12 = affine.load %11[0] : memref<1xi32>
          %13 = arith.cmpi slt, %arg7, %12 : i32
          %14 = scf.if %13 -> (i32) {
            %15 = arith.muli %arg6, %12 : i32
            %16 = arith.addi %arg7, %15 : i32
            %17 = arith.muli %arg5, %12 : i32
            %18 = affine.load %5[0] : memref<1xi32>
            %19 = arith.muli %17, %18 : i32
            %20 = arith.addi %16, %19 : i32
            %21 = arith.index_cast %20 : i32 to index
            %22 = arith.subi %arg5, %c1_i32 : i32
            %23 = arith.muli %22, %12 : i32
            %24 = arith.muli %23, %18 : i32
            %25 = arith.addi %16, %24 : i32
            %26 = arith.index_cast %25 : i32 to index
            %27 = arith.addi %26, %c0 : index
            %28 = memref.load %arg0[%27] : memref<?xf32>
            %29 = arith.addi %21, %c0 : index
            memref.store %28, %arg2[%29] : memref<?xf32>
            %30 = arith.addi %arg7, %c1_i32 : i32
            scf.yield %30 : i32
          } else {
            scf.yield %arg7 : i32
          }
          scf.condition(%13) %14 : i32
        } do {
        ^bb0(%arg7: i32):
          scf.yield %arg7 : i32
        }
        %10 = arith.addi %arg6, %c1_i32 : i32
        scf.yield %10 : i32
      } else {
        scf.yield %arg6 : i32
      }
      scf.condition(%7) %8 : i32
    } do {
    ^bb0(%arg6: i32):
      scf.yield %arg6 : i32
    }
    %c-1_i32 = arith.constant -1 : i32
    %4 = arith.addi %arg5, %c-1_i32 : i32
    scf.yield %4 : i32
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b104910) {
  "scf.yield"(%8) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b1067d0) {
  %8 = "arith.addi"(%arg5, %7) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b104c90) {
  %7 = "arith.constant"() {value = -1 : i32} : () -> i32

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b1067d0) {
  %8 = "arith.addi"(%arg5, %0) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b1054b0) {
  %0 = "arith.constant"() {value = -1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b105060) {

  * Pattern MoveWhileToFor : 'scf.while -> ()' {
Trying to match "MoveWhileToFor"
"MoveWhileToFor" result 0
  } -> failure : pattern failed to match

  * Pattern RemoveWhileSelect : 'scf.while -> ()' {
Trying to match "RemoveWhileSelect"
"RemoveWhileSelect" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown : 'scf.while -> ()' {
Trying to match "MoveWhileDown"
"MoveWhileDown" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown2 : 'scf.while -> ()' {
Trying to match "MoveWhileDown2"
    ** Insert  : 'scf.condition'(0x7fbd9b106860)
    ** Replace : 'scf.condition'(0x7fbd9b105240)
    ** Erase   : 'scf.yield'(0x7fbd96f10370)
    ** Erase   : 'scf.if'(0x7fbd96f18d30)
    ** Insert  : 'scf.while'(0x7fbd9b105760)
    ** Erase   : 'scf.while'(0x7fbd9b105060)
"MoveWhileDown2" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c-1_i32 = arith.constant -1 : i32
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = affine.load %0[0] : memref<1xi32>
  %2 = scf.while (%arg5 = %1) : (i32) -> i32 {
    %3 = arith.cmpi sgt, %arg5, %c0_i32 : i32
    scf.condition(%3) %arg5 : i32
  } do {
  ^bb0(%arg5: i32):
    %3:2 = scf.while (%arg6 = %c0_i32) : (i32) -> (memref<1xi32>, i32) {
      %5 = memref.get_global @jm : memref<1xi32>
      %6 = affine.load %5[0] : memref<1xi32>
      %7 = arith.cmpi slt, %arg6, %6 : i32
      scf.condition(%7) %5, %arg6 : memref<1xi32>, i32
    } do {
    ^bb0(%arg6: memref<1xi32>, %arg7: i32):
      %5 = scf.while (%arg8 = %c0_i32) : (i32) -> i32 {
        %7 = memref.get_global @im : memref<1xi32>
        %8 = affine.load %7[0] : memref<1xi32>
        %9 = arith.cmpi slt, %arg8, %8 : i32
        %10 = scf.if %9 -> (i32) {
          %11 = arith.muli %arg7, %8 : i32
          %12 = arith.addi %arg8, %11 : i32
          %13 = arith.muli %arg5, %8 : i32
          %14 = affine.load %arg6[0] : memref<1xi32>
          %15 = arith.muli %13, %14 : i32
          %16 = arith.addi %12, %15 : i32
          %17 = arith.index_cast %16 : i32 to index
          %18 = arith.subi %arg5, %c1_i32 : i32
          %19 = arith.muli %18, %8 : i32
          %20 = arith.muli %19, %14 : i32
          %21 = arith.addi %12, %20 : i32
          %22 = arith.index_cast %21 : i32 to index
          %23 = arith.addi %22, %c0 : index
          %24 = memref.load %arg0[%23] : memref<?xf32>
          %25 = arith.addi %17, %c0 : index
          memref.store %24, %arg2[%25] : memref<?xf32>
          %26 = arith.addi %arg8, %c1_i32 : i32
          scf.yield %26 : i32
        } else {
          scf.yield %arg8 : i32
        }
        scf.condition(%9) %10 : i32
      } do {
      ^bb0(%arg8: i32):
        scf.yield %arg8 : i32
      }
      %6 = arith.addi %arg7, %c1_i32 : i32
      scf.yield %6 : i32
    }
    %4 = arith.addi %arg5, %c-1_i32 : i32
    scf.yield %4 : i32
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b105760) {

  * Pattern MoveWhileToFor : 'scf.while -> ()' {
Trying to match "MoveWhileToFor"
"MoveWhileToFor" result 0
  } -> failure : pattern failed to match

  * Pattern RemoveWhileSelect : 'scf.while -> ()' {
Trying to match "RemoveWhileSelect"
"RemoveWhileSelect" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown : 'scf.while -> ()' {
Trying to match "MoveWhileDown"
"MoveWhileDown" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown2 : 'scf.while -> ()' {
Trying to match "MoveWhileDown2"
"MoveWhileDown2" result 0
  } -> failure : pattern failed to match

  * Pattern WhileShiftToInduction : 'scf.while -> ()' {
Trying to match "WhileShiftToInduction"
"WhileShiftToInduction" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileAndDown : 'scf.while -> ()' {
Trying to match "MoveWhileAndDown"
"MoveWhileAndDown" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown3 : 'scf.while -> ()' {
Trying to match "MoveWhileDown3"
    ** Insert  : 'scf.condition'(0x7fbd9b1044b0)
    ** Replace : 'scf.condition'(0x7fbd9b106860)
    ** Insert  : 'scf.while'(0x7fbd9b106870)
    ** Erase   : 'scf.while'(0x7fbd9b105760)
"MoveWhileDown3" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c-1_i32 = arith.constant -1 : i32
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = affine.load %0[0] : memref<1xi32>
  %2 = scf.while (%arg5 = %1) : (i32) -> i32 {
    %3 = arith.cmpi sgt, %arg5, %c0_i32 : i32
    scf.condition(%3) %arg5 : i32
  } do {
  ^bb0(%arg5: i32):
    %3 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
      %5 = memref.get_global @jm : memref<1xi32>
      %6 = affine.load %5[0] : memref<1xi32>
      %7 = arith.cmpi slt, %arg6, %6 : i32
      scf.condition(%7) %arg6 : i32
    } do {
    ^bb0(%arg6: i32):
      %5 = memref.get_global @jm : memref<1xi32>
      %6 = scf.while (%arg7 = %c0_i32) : (i32) -> i32 {
        %8 = memref.get_global @im : memref<1xi32>
        %9 = affine.load %8[0] : memref<1xi32>
        %10 = arith.cmpi slt, %arg7, %9 : i32
        %11 = scf.if %10 -> (i32) {
          %12 = arith.muli %arg6, %9 : i32
          %13 = arith.addi %arg7, %12 : i32
          %14 = arith.muli %arg5, %9 : i32
          %15 = affine.load %5[0] : memref<1xi32>
          %16 = arith.muli %14, %15 : i32
          %17 = arith.addi %13, %16 : i32
          %18 = arith.index_cast %17 : i32 to index
          %19 = arith.subi %arg5, %c1_i32 : i32
          %20 = arith.muli %19, %9 : i32
          %21 = arith.muli %20, %15 : i32
          %22 = arith.addi %13, %21 : i32
          %23 = arith.index_cast %22 : i32 to index
          %24 = arith.addi %23, %c0 : index
          %25 = memref.load %arg0[%24] : memref<?xf32>
          %26 = arith.addi %18, %c0 : index
          memref.store %25, %arg2[%26] : memref<?xf32>
          %27 = arith.addi %arg7, %c1_i32 : i32
          scf.yield %27 : i32
        } else {
          scf.yield %arg7 : i32
        }
        scf.condition(%10) %11 : i32
      } do {
      ^bb0(%arg7: i32):
        scf.yield %arg7 : i32
      }
      %7 = arith.addi %arg6, %c1_i32 : i32
      scf.yield %7 : i32
    }
    %4 = arith.addi %arg5, %c-1_i32 : i32
    scf.yield %4 : i32
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b106870) {

  * Pattern MoveWhileToFor : 'scf.while -> ()' {
Trying to match "MoveWhileToFor"
"MoveWhileToFor" result 0
  } -> failure : pattern failed to match

  * Pattern RemoveWhileSelect : 'scf.while -> ()' {
Trying to match "RemoveWhileSelect"
"RemoveWhileSelect" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown : 'scf.while -> ()' {
Trying to match "MoveWhileDown"
"MoveWhileDown" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown2 : 'scf.while -> ()' {
Trying to match "MoveWhileDown2"
"MoveWhileDown2" result 0
  } -> failure : pattern failed to match

  * Pattern WhileShiftToInduction : 'scf.while -> ()' {
Trying to match "WhileShiftToInduction"
"WhileShiftToInduction" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileAndDown : 'scf.while -> ()' {
Trying to match "MoveWhileAndDown"
"MoveWhileAndDown" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown3 : 'scf.while -> ()' {
Trying to match "MoveWhileDown3"
"MoveWhileDown3" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileInvariantIfResult : 'scf.while -> ()' {
Trying to match "MoveWhileInvariantIfResult"
"MoveWhileInvariantIfResult" result 0
  } -> failure : pattern failed to match

  * Pattern WhileLogicalNegation : 'scf.while -> ()' {
Trying to match "WhileLogicalNegation"
"WhileLogicalNegation" result 0
  } -> failure : pattern failed to match

  * Pattern WhileCmpOffset : 'scf.while -> ()' {
Trying to match "WhileCmpOffset"
"WhileCmpOffset" result 0
  } -> failure : pattern failed to match

  * Pattern WhileLICM : 'scf.while -> ()' {
Trying to match "WhileLICM"
"WhileLICM" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c-1_i32 = arith.constant -1 : i32
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = affine.load %0[0] : memref<1xi32>
  %2 = scf.while (%arg5 = %1) : (i32) -> i32 {
    %3 = arith.cmpi sgt, %arg5, %c0_i32 : i32
    scf.condition(%3) %arg5 : i32
  } do {
  ^bb0(%arg5: i32):
    %3 = memref.get_global @jm : memref<1xi32>
    %4 = memref.get_global @jm : memref<1xi32>
    %5 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
      %7 = affine.load %3[0] : memref<1xi32>
      %8 = arith.cmpi slt, %arg6, %7 : i32
      scf.condition(%8) %arg6 : i32
    } do {
    ^bb0(%arg6: i32):
      %7 = scf.while (%arg7 = %c0_i32) : (i32) -> i32 {
        %9 = memref.get_global @im : memref<1xi32>
        %10 = affine.load %9[0] : memref<1xi32>
        %11 = arith.cmpi slt, %arg7, %10 : i32
        %12 = scf.if %11 -> (i32) {
          %13 = arith.muli %arg6, %10 : i32
          %14 = arith.addi %arg7, %13 : i32
          %15 = arith.muli %arg5, %10 : i32
          %16 = affine.load %4[0] : memref<1xi32>
          %17 = arith.muli %15, %16 : i32
          %18 = arith.addi %14, %17 : i32
          %19 = arith.index_cast %18 : i32 to index
          %20 = arith.subi %arg5, %c1_i32 : i32
          %21 = arith.muli %20, %10 : i32
          %22 = arith.muli %21, %16 : i32
          %23 = arith.addi %14, %22 : i32
          %24 = arith.index_cast %23 : i32 to index
          %25 = arith.addi %24, %c0 : index
          %26 = memref.load %arg0[%25] : memref<?xf32>
          %27 = arith.addi %19, %c0 : index
          memref.store %26, %arg2[%27] : memref<?xf32>
          %28 = arith.addi %arg7, %c1_i32 : i32
          scf.yield %28 : i32
        } else {
          scf.yield %arg7 : i32
        }
        scf.condition(%11) %12 : i32
      } do {
      ^bb0(%arg7: i32):
        scf.yield %arg7 : i32
      }
      %8 = arith.addi %arg6, %c1_i32 : i32
      scf.yield %8 : i32
    }
    %6 = arith.addi %arg5, %c-1_i32 : i32
    scf.yield %6 : i32
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b1044b0) {
  "scf.condition"(%12, %arg6) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1056d0) {
  "scf.yield"(%12) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %12 = "arith.addi"(%arg6, %1) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b105a40) {

  * Pattern MoveWhileToFor : 'scf.while -> ()' {
Trying to match "MoveWhileToFor"
"MoveWhileToFor" result 0
  } -> failure : pattern failed to match

  * Pattern RemoveWhileSelect : 'scf.while -> ()' {
Trying to match "RemoveWhileSelect"
"RemoveWhileSelect" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown : 'scf.while -> ()' {
Trying to match "MoveWhileDown"
"MoveWhileDown" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown2 : 'scf.while -> ()' {
Trying to match "MoveWhileDown2"
    ** Insert  : 'scf.condition'(0x7fbd9b306b60)
    ** Replace : 'scf.condition'(0x7fbd9b105c20)
    ** Erase   : 'scf.yield'(0x7fbd96f14850)
    ** Erase   : 'scf.if'(0x7fbd96f147b0)
    ** Insert  : 'scf.while'(0x7fbd9b306c90)
    ** Erase   : 'scf.while'(0x7fbd9b105a40)
"MoveWhileDown2" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c-1_i32 = arith.constant -1 : i32
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = affine.load %0[0] : memref<1xi32>
  %2 = scf.while (%arg5 = %1) : (i32) -> i32 {
    %3 = arith.cmpi sgt, %arg5, %c0_i32 : i32
    scf.condition(%3) %arg5 : i32
  } do {
  ^bb0(%arg5: i32):
    %3 = memref.get_global @jm : memref<1xi32>
    %4 = memref.get_global @jm : memref<1xi32>
    %5 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
      %7 = affine.load %3[0] : memref<1xi32>
      %8 = arith.cmpi slt, %arg6, %7 : i32
      scf.condition(%8) %arg6 : i32
    } do {
    ^bb0(%arg6: i32):
      %7:2 = scf.while (%arg7 = %c0_i32) : (i32) -> (i32, i32) {
        %9 = memref.get_global @im : memref<1xi32>
        %10 = affine.load %9[0] : memref<1xi32>
        %11 = arith.cmpi slt, %arg7, %10 : i32
        scf.condition(%11) %10, %arg7 : i32, i32
      } do {
      ^bb0(%arg7: i32, %arg8: i32):
        %9 = arith.muli %arg6, %arg7 : i32
        %10 = arith.addi %arg8, %9 : i32
        %11 = arith.muli %arg5, %arg7 : i32
        %12 = affine.load %4[0] : memref<1xi32>
        %13 = arith.muli %11, %12 : i32
        %14 = arith.addi %10, %13 : i32
        %15 = arith.index_cast %14 : i32 to index
        %16 = arith.subi %arg5, %c1_i32 : i32
        %17 = arith.muli %16, %arg7 : i32
        %18 = arith.muli %17, %12 : i32
        %19 = arith.addi %10, %18 : i32
        %20 = arith.index_cast %19 : i32 to index
        %21 = arith.addi %20, %c0 : index
        %22 = memref.load %arg0[%21] : memref<?xf32>
        %23 = arith.addi %15, %c0 : index
        memref.store %22, %arg2[%23] : memref<?xf32>
        %24 = arith.addi %arg8, %c1_i32 : i32
        scf.yield %24 : i32
      }
      %8 = arith.addi %arg6, %c1_i32 : i32
      scf.yield %8 : i32
    }
    %6 = arith.addi %arg5, %c-1_i32 : i32
    scf.yield %6 : i32
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b306c90) {

  * Pattern MoveWhileToFor : 'scf.while -> ()' {
Trying to match "MoveWhileToFor"
"MoveWhileToFor" result 0
  } -> failure : pattern failed to match

  * Pattern RemoveWhileSelect : 'scf.while -> ()' {
Trying to match "RemoveWhileSelect"
"RemoveWhileSelect" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown : 'scf.while -> ()' {
Trying to match "MoveWhileDown"
"MoveWhileDown" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown2 : 'scf.while -> ()' {
Trying to match "MoveWhileDown2"
"MoveWhileDown2" result 0
  } -> failure : pattern failed to match

  * Pattern WhileShiftToInduction : 'scf.while -> ()' {
Trying to match "WhileShiftToInduction"
"WhileShiftToInduction" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileAndDown : 'scf.while -> ()' {
Trying to match "MoveWhileAndDown"
"MoveWhileAndDown" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown3 : 'scf.while -> ()' {
Trying to match "MoveWhileDown3"
"MoveWhileDown3" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileInvariantIfResult : 'scf.while -> ()' {
Trying to match "MoveWhileInvariantIfResult"
"MoveWhileInvariantIfResult" result 0
  } -> failure : pattern failed to match

  * Pattern WhileLogicalNegation : 'scf.while -> ()' {
Trying to match "WhileLogicalNegation"
"WhileLogicalNegation" result 0
  } -> failure : pattern failed to match

  * Pattern WhileCmpOffset : 'scf.while -> ()' {
Trying to match "WhileCmpOffset"
"WhileCmpOffset" result 0
  } -> failure : pattern failed to match

  * Pattern WhileLICM : 'scf.while -> ()' {
Trying to match "WhileLICM"
"WhileLICM" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c-1_i32 = arith.constant -1 : i32
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = affine.load %0[0] : memref<1xi32>
  %2 = scf.while (%arg5 = %1) : (i32) -> i32 {
    %3 = arith.cmpi sgt, %arg5, %c0_i32 : i32
    scf.condition(%3) %arg5 : i32
  } do {
  ^bb0(%arg5: i32):
    %3 = memref.get_global @jm : memref<1xi32>
    %4 = memref.get_global @jm : memref<1xi32>
    %5 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
      %7 = affine.load %3[0] : memref<1xi32>
      %8 = arith.cmpi slt, %arg6, %7 : i32
      scf.condition(%8) %arg6 : i32
    } do {
    ^bb0(%arg6: i32):
      %7 = memref.get_global @im : memref<1xi32>
      %8 = arith.subi %arg5, %c1_i32 : i32
      %9:2 = scf.while (%arg7 = %c0_i32) : (i32) -> (i32, i32) {
        %11 = affine.load %7[0] : memref<1xi32>
        %12 = arith.cmpi slt, %arg7, %11 : i32
        scf.condition(%12) %11, %arg7 : i32, i32
      } do {
      ^bb0(%arg7: i32, %arg8: i32):
        %11 = arith.muli %arg6, %arg7 : i32
        %12 = arith.addi %arg8, %11 : i32
        %13 = arith.muli %arg5, %arg7 : i32
        %14 = affine.load %4[0] : memref<1xi32>
        %15 = arith.muli %13, %14 : i32
        %16 = arith.addi %12, %15 : i32
        %17 = arith.index_cast %16 : i32 to index
        %18 = arith.muli %8, %arg7 : i32
        %19 = arith.muli %18, %14 : i32
        %20 = arith.addi %12, %19 : i32
        %21 = arith.index_cast %20 : i32 to index
        %22 = arith.addi %21, %c0 : index
        %23 = memref.load %arg0[%22] : memref<?xf32>
        %24 = arith.addi %17, %c0 : index
        memref.store %23, %arg2[%24] : memref<?xf32>
        %25 = arith.addi %arg8, %c1_i32 : i32
        scf.yield %25 : i32
      }
      %10 = arith.addi %arg6, %c1_i32 : i32
      scf.yield %10 : i32
    }
    %6 = arith.addi %arg5, %c-1_i32 : i32
    scf.yield %6 : i32
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b306b60) {
  "scf.condition"(%16, %15, %arg7) : (i1, i32, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1061f0) {
  "scf.yield"(%29) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %29 = "arith.addi"(%arg8, %1) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%27, %arg2, %28) : (f32, memref<?xf32>, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98165e60) {
  %28 = "arith.addi"(%21, %3) : (index, index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %27 = "memref.load"(%arg0, %26) : (memref<?xf32>, index) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b0040e0) {
  %26 = "arith.addi"(%25, %3) : (index, index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd98304bd0) {
  %25 = "arith.index_cast"(%24) : (i32) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98304b30) {
  %24 = "arith.addi"(%16, %23) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304a90) {
  %23 = "arith.muli"(%22, %18) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %22 = "arith.muli"(%12, %arg7) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd983045d0) {
  %12 = "arith.subi"(%arg5, %1) : (i32, i32) -> i32


  * Pattern SubToAdd : 'arith.subi -> ()' {
Trying to match "SubToAdd"
    ** Insert  : 'arith.constant'(0x7fbd9b004220)
    ** Insert  : 'arith.addi'(0x7fbd9b004270)
    ** Replace : 'arith.subi'(0x7fbd983045d0)
"SubToAdd" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c-1_i32 = arith.constant -1 : i32
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = affine.load %0[0] : memref<1xi32>
  %2 = scf.while (%arg5 = %1) : (i32) -> i32 {
    %3 = arith.cmpi sgt, %arg5, %c0_i32 : i32
    scf.condition(%3) %arg5 : i32
  } do {
  ^bb0(%arg5: i32):
    %3 = memref.get_global @jm : memref<1xi32>
    %4 = memref.get_global @jm : memref<1xi32>
    %5 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
      %7 = affine.load %3[0] : memref<1xi32>
      %8 = arith.cmpi slt, %arg6, %7 : i32
      scf.condition(%8) %arg6 : i32
    } do {
    ^bb0(%arg6: i32):
      %7 = memref.get_global @im : memref<1xi32>
      %c-1_i32_0 = arith.constant -1 : i32
      %8 = arith.addi %arg5, %c-1_i32_0 : i32
      %9:2 = scf.while (%arg7 = %c0_i32) : (i32) -> (i32, i32) {
        %11 = affine.load %7[0] : memref<1xi32>
        %12 = arith.cmpi slt, %arg7, %11 : i32
        scf.condition(%12) %11, %arg7 : i32, i32
      } do {
      ^bb0(%arg7: i32, %arg8: i32):
        %11 = arith.muli %arg6, %arg7 : i32
        %12 = arith.addi %arg8, %11 : i32
        %13 = arith.muli %arg5, %arg7 : i32
        %14 = affine.load %4[0] : memref<1xi32>
        %15 = arith.muli %13, %14 : i32
        %16 = arith.addi %12, %15 : i32
        %17 = arith.index_cast %16 : i32 to index
        %18 = arith.muli %8, %arg7 : i32
        %19 = arith.muli %18, %14 : i32
        %20 = arith.addi %12, %19 : i32
        %21 = arith.index_cast %20 : i32 to index
        %22 = arith.addi %21, %c0 : index
        %23 = memref.load %arg0[%22] : memref<?xf32>
        %24 = arith.addi %17, %c0 : index
        memref.store %23, %arg2[%24] : memref<?xf32>
        %25 = arith.addi %arg8, %c1_i32 : i32
        scf.yield %25 : i32
      }
      %10 = arith.addi %arg6, %c1_i32 : i32
      scf.yield %10 : i32
    }
    %6 = arith.addi %arg5, %c-1_i32 : i32
    scf.yield %6 : i32
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %23 = "arith.muli"(%13, %arg7) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b004270) {
  %13 = "arith.addi"(%arg5, %12) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b004220) {
  %12 = "arith.constant"() {value = -1 : i32} : () -> i32

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b004270) {
  %12 = "arith.addi"(%arg5, %0) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9816cb40) {
  %21 = "arith.index_cast"(%20) : (i32) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816caa0) {
  %20 = "arith.addi"(%16, %19) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816ca00) {
  %19 = "arith.muli"(%17, %18) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104ce0) {
  %18 = "affine.load"(%8) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %17 = "arith.muli"(%arg5, %arg7) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %16 = "arith.addi"(%arg8, %15) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %15 = "arith.muli"(%arg6, %arg7) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %16 = "arith.cmpi"(%arg7, %15) {predicate = 2 : i64} : (i32, i32) -> i1

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104b90) {
  %15 = "affine.load"(%11) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9816b600) {
  %11 = "memref.get_global"() {name = @im} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %12 = "arith.cmpi"(%arg6, %11) {predicate = 2 : i64} : (i32, i32) -> i1

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104c10) {
  %11 = "affine.load"(%7) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd98169a20) {
  %7 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98168010) {
  %7 = "arith.cmpi"(%arg5, %2) {predicate = 4 : i64} : (i32, i32) -> i1

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104d70) {
  %5 = "affine.load"(%4) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd981673f0) {
  %4 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9816cc60) {
  %3 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98167e90) {
  %2 = "arith.constant"() {value = 0 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98304580) {
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x7fbd9800c610) {
  "func.return"() : () -> ()


  * Pattern ReturnSq : 'func.return -> ()' {
Trying to match "ReturnSq"
"ReturnSq" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b1053a0) {

  * Pattern MoveWhileToFor : 'scf.while -> ()' {
Trying to match "MoveWhileToFor"
    ** Insert  : 'arith.constant'(0x7fbd9800e820)
    ** Insert  : 'arith.addi'(0x7fbd9800a760)
    ** Insert  : 'arith.constant'(0x7fbd9800ec40)
    ** Insert  : 'arith.addi'(0x7fbd9800a840)
    ** Insert  : 'arith.constant'(0x7fbd9800a8e0)
    ** Insert  : 'arith.index_cast'(0x7fbd9800baa0)
    ** Insert  : 'arith.index_cast'(0x7fbd9800be40)
    ** Insert  : 'arith.index_cast'(0x7fbd9800bec0)
    ** Insert  : 'scf.for'(0x7fbd9800bf50)
    ** Insert  : 'scf.yield'(0x7fbd9800bbd0)
    ** Replace : 'scf.yield'(0x7fbd9b104910)
    ** Replace : 'scf.while'(0x7fbd9b1053a0)
"MoveWhileToFor" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
'arith.index_cast' op operand type 'index' and result type 'index' are cast incompatible
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.func"() ({
^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32):
  %0 = "arith.constant"() {value = -1 : i32} : () -> i32
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32
  %2 = "arith.constant"() {value = 0 : i32} : () -> i32
  %3 = "arith.constant"() {value = 0 : index} : () -> index
  %4 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>
  %5 = "affine.load"(%4) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32
  %6 = "arith.constant"() {value = 1 : i32} : () -> i32
  %7 = "arith.addi"(%2, %6) : (i32, i32) -> i32
  %8 = "arith.constant"() {value = 1 : i32} : () -> i32
  %9 = "arith.addi"(%5, %8) : (i32, i32) -> i32
  %10 = "arith.constant"() {value = 1 : index} : () -> index
  %11 = "arith.index_cast"(%9) : (i32) -> index
  %12 = "arith.index_cast"(%7) : (i32) -> index
  %13 = "arith.index_cast"(%10) : (index) -> index
  %14:2 = "scf.for"(%12, %11, %13, %5, %5) ({
  ^bb0(%arg5: index, %arg6: i32, %arg7: i32):
    %15 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>
    %16 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>
    %17 = "scf.while"(%2) ({
    ^bb0(%arg8: i32):
      %19 = "affine.load"(%15) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32
      %20 = "arith.cmpi"(%arg8, %19) {predicate = 2 : i64} : (i32, i32) -> i1
      "scf.condition"(%20, %arg8) : (i1, i32) -> ()
    }, {
    ^bb0(%arg8: i32):
      %19 = "memref.get_global"() {name = @im} : () -> memref<1xi32>
      %20 = "arith.addi"(%arg6, %0) : (i32, i32) -> i32
      %21:2 = "scf.while"(%2) ({
      ^bb0(%arg9: i32):
        %23 = "affine.load"(%19) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32
        %24 = "arith.cmpi"(%arg9, %23) {predicate = 2 : i64} : (i32, i32) -> i1
        "scf.condition"(%24, %23, %arg9) : (i1, i32, i32) -> ()
      }, {
      ^bb0(%arg9: i32, %arg10: i32):
        %23 = "arith.muli"(%arg8, %arg9) : (i32, i32) -> i32
        %24 = "arith.addi"(%arg10, %23) : (i32, i32) -> i32
        %25 = "arith.muli"(%arg6, %arg9) : (i32, i32) -> i32
        %26 = "affine.load"(%16) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32
        %27 = "arith.muli"(%25, %26) : (i32, i32) -> i32
        %28 = "arith.addi"(%24, %27) : (i32, i32) -> i32
        %29 = "arith.index_cast"(%28) : (i32) -> index
        %30 = "arith.muli"(%20, %arg9) : (i32, i32) -> i32
        %31 = "arith.muli"(%30, %26) : (i32, i32) -> i32
        %32 = "arith.addi"(%24, %31) : (i32, i32) -> i32
        %33 = "arith.index_cast"(%32) : (i32) -> index
        %34 = "arith.addi"(%33, %3) : (index, index) -> index
        %35 = "memref.load"(%arg0, %34) : (memref<?xf32>, index) -> f32
        %36 = "arith.addi"(%29, %3) : (index, index) -> index
        "memref.store"(%35, %arg2, %36) : (f32, memref<?xf32>, index) -> ()
        %37 = "arith.addi"(%arg10, %1) : (i32, i32) -> i32
        "scf.yield"(%37) : (i32) -> ()
      }) : (i32) -> (i32, i32)
      %22 = "arith.addi"(%arg8, %1) : (i32, i32) -> i32
      "scf.yield"(%22) : (i32) -> ()
    }) : (i32) -> i32
    %18 = "arith.addi"(%arg6, %0) : (i32, i32) -> i32
    "scf.yield"(%18, %18) : (i32, i32) -> ()
  }) : (index, index, index, i32, i32) -> (i32, i32)
  "func.return"() : () -> ()
}) {function_type = (memref<?xf32>, memref<?xf32>, memref<?xf32>, memref<?xf32>, i32) -> (), llvm.linkage = #llvm.linkage<external>, sym_name = "example"} : () -> ()


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9800bbd0) {
  "scf.yield"(%18, %18) : (i32, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x7fbd9800bf50) {
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AtLeastNOperands<3>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LoopLikeOpInterface::Trait<Empty>)

  * Pattern PropagateInLoopBody : 'scf.for -> ()' {
Trying to match "PropagateInLoopBody"
"PropagateInLoopBody" result 0
  } -> failure : pattern failed to match

  * Pattern ForOpInductionReplacement : 'scf.for -> ()' {
Trying to match "ForOpInductionReplacement"
"ForOpInductionReplacement" result 0
  } -> failure : pattern failed to match

  * Pattern RemoveUnusedArgs : 'scf.for -> ()' {
Trying to match "RemoveUnusedArgs"
    ** Insert  : 'scf.for'(0x7fbd9800bc70)
    ** Insert  : 'scf.yield'(0x7fbd9800e320)
    ** Replace : 'scf.yield'(0x7fbd9800bbd0)
    ** Replace : 'scf.for'(0x7fbd9800bf50)
"RemoveUnusedArgs" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
'arith.index_cast' op operand type 'index' and result type 'index' are cast incompatible
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.func"() ({
^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32):
  %0 = "arith.constant"() {value = -1 : i32} : () -> i32
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32
  %2 = "arith.constant"() {value = 0 : i32} : () -> i32
  %3 = "arith.constant"() {value = 0 : index} : () -> index
  %4 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>
  %5 = "affine.load"(%4) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32
  %6 = "arith.constant"() {value = 1 : i32} : () -> i32
  %7 = "arith.addi"(%2, %6) : (i32, i32) -> i32
  %8 = "arith.constant"() {value = 1 : i32} : () -> i32
  %9 = "arith.addi"(%5, %8) : (i32, i32) -> i32
  %10 = "arith.constant"() {value = 1 : index} : () -> index
  %11 = "arith.index_cast"(%9) : (i32) -> index
  %12 = "arith.index_cast"(%7) : (i32) -> index
  %13 = "arith.index_cast"(%10) : (index) -> index
  %14 = "scf.for"(%12, %11, %13, %5) ({
  ^bb0(%arg5: index, %arg6: i32):
    %15 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>
    %16 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>
    %17 = "scf.while"(%2) ({
    ^bb0(%arg7: i32):
      %19 = "affine.load"(%15) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32
      %20 = "arith.cmpi"(%arg7, %19) {predicate = 2 : i64} : (i32, i32) -> i1
      "scf.condition"(%20, %arg7) : (i1, i32) -> ()
    }, {
    ^bb0(%arg7: i32):
      %19 = "memref.get_global"() {name = @im} : () -> memref<1xi32>
      %20 = "arith.addi"(%arg6, %0) : (i32, i32) -> i32
      %21:2 = "scf.while"(%2) ({
      ^bb0(%arg8: i32):
        %23 = "affine.load"(%19) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32
        %24 = "arith.cmpi"(%arg8, %23) {predicate = 2 : i64} : (i32, i32) -> i1
        "scf.condition"(%24, %23, %arg8) : (i1, i32, i32) -> ()
      }, {
      ^bb0(%arg8: i32, %arg9: i32):
        %23 = "arith.muli"(%arg7, %arg8) : (i32, i32) -> i32
        %24 = "arith.addi"(%arg9, %23) : (i32, i32) -> i32
        %25 = "arith.muli"(%arg6, %arg8) : (i32, i32) -> i32
        %26 = "affine.load"(%16) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32
        %27 = "arith.muli"(%25, %26) : (i32, i32) -> i32
        %28 = "arith.addi"(%24, %27) : (i32, i32) -> i32
        %29 = "arith.index_cast"(%28) : (i32) -> index
        %30 = "arith.muli"(%20, %arg8) : (i32, i32) -> i32
        %31 = "arith.muli"(%30, %26) : (i32, i32) -> i32
        %32 = "arith.addi"(%24, %31) : (i32, i32) -> i32
        %33 = "arith.index_cast"(%32) : (i32) -> index
        %34 = "arith.addi"(%33, %3) : (index, index) -> index
        %35 = "memref.load"(%arg0, %34) : (memref<?xf32>, index) -> f32
        %36 = "arith.addi"(%29, %3) : (index, index) -> index
        "memref.store"(%35, %arg2, %36) : (f32, memref<?xf32>, index) -> ()
        %37 = "arith.addi"(%arg9, %1) : (i32, i32) -> i32
        "scf.yield"(%37) : (i32) -> ()
      }) : (i32) -> (i32, i32)
      %22 = "arith.addi"(%arg7, %1) : (i32, i32) -> i32
      "scf.yield"(%22) : (i32) -> ()
    }) : (i32) -> i32
    %18 = "arith.addi"(%arg6, %0) : (i32, i32) -> i32
    "scf.yield"(%18) : (i32) -> ()
  }) : (index, index, index, i32) -> i32
  "func.return"() : () -> ()
}) {function_type = (memref<?xf32>, memref<?xf32>, memref<?xf32>, memref<?xf32>, i32) -> (), llvm.linkage = #llvm.linkage<external>, sym_name = "example"} : () -> ()


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9800e320) {
  "scf.yield"(%18) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x7fbd9800bc70) {

  * Pattern PropagateInLoopBody : 'scf.for -> ()' {
Trying to match "PropagateInLoopBody"
"PropagateInLoopBody" result 0
  } -> failure : pattern failed to match

  * Pattern ForOpInductionReplacement : 'scf.for -> ()' {
Trying to match "ForOpInductionReplacement"
"ForOpInductionReplacement" result 0
  } -> failure : pattern failed to match

  * Pattern RemoveUnusedArgs : 'scf.for -> ()' {
Trying to match "RemoveUnusedArgs"
"RemoveUnusedArgs" result 0
  } -> failure : pattern failed to match

  * Pattern ReplaceRedundantArgs : 'scf.for -> ()' {
Trying to match "ReplaceRedundantArgs"
"ReplaceRedundantArgs" result 0
  } -> failure : pattern failed to match

  * Pattern ForBreakAddUpgrade : 'scf.for -> ()' {
Trying to match "ForBreakAddUpgrade"
"ForBreakAddUpgrade" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9800bec0) {
  %13 = "arith.index_cast"(%10) : (index) -> index

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x7fbd9800bc70) {

  * Pattern PropagateInLoopBody : 'scf.for -> ()' {
Trying to match "PropagateInLoopBody"
"PropagateInLoopBody" result 0
  } -> failure : pattern failed to match

  * Pattern ForOpInductionReplacement : 'scf.for -> ()' {
Trying to match "ForOpInductionReplacement"
    ** Insert  : 'arith.subi'(0x7fbd9b306e10)
    ** Insert  : 'arith.divui'(0x7fbd9b105230)
    ** Insert  : 'arith.index_cast'(0x7fbd9b106430)
    ** Insert  : 'arith.muli'(0x7fbd9b1048d0)
    ** Insert  : 'arith.index_cast'(0x7fbd9b104380)
    ** Insert  : 'arith.addi'(0x7fbd9b105750)
    ** Insert  : 'arith.index_cast'(0x7fbd9b105c30)
"ForOpInductionReplacement" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1 = arith.constant 1 : index
  %c-1_i32 = arith.constant -1 : i32
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = affine.load %0[0] : memref<1xi32>
  %c1_i32_0 = arith.constant 1 : i32
  %2 = arith.addi %c0_i32, %c1_i32_0 : i32
  %c1_i32_1 = arith.constant 1 : i32
  %3 = arith.addi %1, %c1_i32_1 : i32
  %c1_2 = arith.constant 1 : index
  %4 = arith.index_cast %3 : i32 to index
  %5 = arith.index_cast %2 : i32 to index
  %6 = scf.for %arg5 = %5 to %4 step %c1 iter_args(%arg6 = %1) -> (i32) {
    %7 = arith.subi %arg5, %5 : index
    %8 = arith.divui %7, %c1 : index
    %9 = arith.index_cast %c-1_i32 : i32 to index
    %10 = arith.muli %8, %9 : index
    %11 = arith.index_cast %1 : i32 to index
    %12 = arith.addi %11, %10 : index
    %13 = arith.index_cast %12 : index to i32
    %14 = memref.get_global @jm : memref<1xi32>
    %15 = memref.get_global @jm : memref<1xi32>
    %16 = scf.while (%arg7 = %c0_i32) : (i32) -> i32 {
      %18 = affine.load %14[0] : memref<1xi32>
      %19 = arith.cmpi slt, %arg7, %18 : i32
      scf.condition(%19) %arg7 : i32
    } do {
    ^bb0(%arg7: i32):
      %18 = memref.get_global @im : memref<1xi32>
      %19 = arith.addi %13, %c-1_i32 : i32
      %20:2 = scf.while (%arg8 = %c0_i32) : (i32) -> (i32, i32) {
        %22 = affine.load %18[0] : memref<1xi32>
        %23 = arith.cmpi slt, %arg8, %22 : i32
        scf.condition(%23) %22, %arg8 : i32, i32
      } do {
      ^bb0(%arg8: i32, %arg9: i32):
        %22 = arith.muli %arg7, %arg8 : i32
        %23 = arith.addi %arg9, %22 : i32
        %24 = arith.muli %13, %arg8 : i32
        %25 = affine.load %15[0] : memref<1xi32>
        %26 = arith.muli %24, %25 : i32
        %27 = arith.addi %23, %26 : i32
        %28 = arith.index_cast %27 : i32 to index
        %29 = arith.muli %19, %arg8 : i32
        %30 = arith.muli %29, %25 : i32
        %31 = arith.addi %23, %30 : i32
        %32 = arith.index_cast %31 : i32 to index
        %33 = arith.addi %32, %c0 : index
        %34 = memref.load %arg0[%33] : memref<?xf32>
        %35 = arith.addi %28, %c0 : index
        memref.store %34, %arg2[%35] : memref<?xf32>
        %36 = arith.addi %arg9, %c1_i32 : i32
        scf.yield %36 : i32
      }
      %21 = arith.addi %arg7, %c1_i32 : i32
      scf.yield %21 : i32
    }
    %17 = arith.addi %13, %c-1_i32 : i32
    scf.yield %17 : i32
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9b105c30) {
  %21 = "arith.index_cast"(%20) : (index) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b105750) {
  %20 = "arith.addi"(%19, %18) : (index, index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9b104380) {
  %19 = "arith.index_cast"(%6) : (i32) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9b1048d0) {
  %18 = "arith.muli"(%16, %17) : (index, index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9b106430) {
  %17 = "arith.index_cast"(%1) : (i32) -> index

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9b1048d0) {
  %18 = "arith.muli"(%17, %0) : (index, index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98009280) {
  %0 = "arith.constant"() {value = -1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.divui'(0x7fbd9b105230) {
  %17 = "arith.divui"(%16, %1) : (index, index) -> index

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9b1048d0) {
  %17 = "arith.muli"(%16, %0) : (index, index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9b306e10) {
  %16 = "arith.subi"(%arg5, %14) : (index, index) -> index


  * Pattern SubToAdd : 'arith.subi -> ()' {
Trying to match "SubToAdd"
"SubToAdd" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b306d40) {
  %1 = "arith.constant"() {value = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9800be40) {
  %14 = "arith.index_cast"(%9) : (i32) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9800baa0) {
  %13 = "arith.index_cast"(%11) : (i32) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9800a8e0) {
  %12 = "arith.constant"() {value = 1 : index} : () -> index

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800a840) {
  %11 = "arith.addi"(%7, %10) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9800ec40) {
  %10 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800a840) {
  %10 = "arith.addi"(%7, %0) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800a760) {
  %9 = "arith.addi"(%4, %8) : (i32, i32) -> i32

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9800be40) {
  %11 = "arith.index_cast"(%0) : (i32) -> index

} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x7fbd9800bc70) {

  * Pattern PropagateInLoopBody : 'scf.for -> ()' {
Trying to match "PropagateInLoopBody"
"PropagateInLoopBody" result 0
  } -> failure : pattern failed to match

  * Pattern ForOpInductionReplacement : 'scf.for -> ()' {
Trying to match "ForOpInductionReplacement"
"ForOpInductionReplacement" result 0
  } -> failure : pattern failed to match

  * Pattern RemoveUnusedArgs : 'scf.for -> ()' {
Trying to match "RemoveUnusedArgs"
    ** Insert  : 'scf.yield'(0x7fbd9b106420)
    ** Insert  : 'scf.for'(0x7fbd9b105a30)
    ** Erase   : 'scf.yield'(0x7fbd9b106420)
    ** Insert  : 'scf.yield'(0x7fbd9b106420)
    ** Replace : 'scf.yield'(0x7fbd9800e320)
    ** Replace : 'scf.for'(0x7fbd9800bc70)
"RemoveUnusedArgs" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1 = arith.constant 1 : index
  %c1_i32 = arith.constant 1 : i32
  %c-1 = arith.constant -1 : index
  %c-1_i32 = arith.constant -1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = affine.load %0[0] : memref<1xi32>
  %c1_i32_0 = arith.constant 1 : i32
  %2 = arith.addi %1, %c1_i32 : i32
  %3 = arith.index_cast %2 : i32 to index
  scf.for %arg5 = %c1 to %3 step %c1 {
    %4 = arith.subi %arg5, %c1 : index
    %5 = arith.muli %4, %c-1 : index
    %6 = arith.index_cast %1 : i32 to index
    %7 = arith.addi %6, %5 : index
    %8 = arith.index_cast %7 : index to i32
    %9 = memref.get_global @jm : memref<1xi32>
    %10 = memref.get_global @jm : memref<1xi32>
    %11 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
      %13 = affine.load %9[0] : memref<1xi32>
      %14 = arith.cmpi slt, %arg6, %13 : i32
      scf.condition(%14) %arg6 : i32
    } do {
    ^bb0(%arg6: i32):
      %13 = memref.get_global @im : memref<1xi32>
      %14 = arith.addi %8, %c-1_i32 : i32
      %15:2 = scf.while (%arg7 = %c0_i32) : (i32) -> (i32, i32) {
        %17 = affine.load %13[0] : memref<1xi32>
        %18 = arith.cmpi slt, %arg7, %17 : i32
        scf.condition(%18) %17, %arg7 : i32, i32
      } do {
      ^bb0(%arg7: i32, %arg8: i32):
        %17 = arith.muli %arg6, %arg7 : i32
        %18 = arith.addi %arg8, %17 : i32
        %19 = arith.muli %8, %arg7 : i32
        %20 = affine.load %10[0] : memref<1xi32>
        %21 = arith.muli %19, %20 : i32
        %22 = arith.addi %18, %21 : i32
        %23 = arith.index_cast %22 : i32 to index
        %24 = arith.muli %14, %arg7 : i32
        %25 = arith.muli %24, %20 : i32
        %26 = arith.addi %18, %25 : i32
        %27 = arith.index_cast %26 : i32 to index
        %28 = arith.addi %27, %c0 : index
        %29 = memref.load %arg0[%28] : memref<?xf32>
        %30 = arith.addi %23, %c0 : index
        memref.store %29, %arg2[%30] : memref<?xf32>
        %31 = arith.addi %arg8, %c1_i32 : i32
        scf.yield %31 : i32
      }
      %16 = arith.addi %arg6, %c1_i32 : i32
      scf.yield %16 : i32
    }
    %12 = arith.addi %8, %c-1_i32 : i32
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b106420) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x7fbd9b105a30) {

  * Pattern PropagateInLoopBody : 'scf.for -> ()' {
Trying to match "PropagateInLoopBody"
"PropagateInLoopBody" result 0
  } -> failure : pattern failed to match

  * Pattern ForOpInductionReplacement : 'scf.for -> ()' {
Trying to match "ForOpInductionReplacement"
"ForOpInductionReplacement" result 0
  } -> failure : pattern failed to match

  * Pattern RemoveUnusedArgs : 'scf.for -> ()' {
Trying to match "RemoveUnusedArgs"
"RemoveUnusedArgs" result 0
  } -> failure : pattern failed to match

  * Pattern ReplaceRedundantArgs : 'scf.for -> ()' {
Trying to match "ReplaceRedundantArgs"
"ReplaceRedundantArgs" result 0
  } -> failure : pattern failed to match

  * Pattern ForBreakAddUpgrade : 'scf.for -> ()' {
Trying to match "ForBreakAddUpgrade"
"ForBreakAddUpgrade" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9b306e10) {
  %11 = "arith.subi"(%arg5, %0) : (index, index) -> index


  * Pattern SubToAdd : 'arith.subi -> ()' {
Trying to match "SubToAdd"
"SubToAdd" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b306d40) {
  %0 = "arith.constant"() {value = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9800e820) {
  %8 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b1067d0) {
  %18 = "arith.addi"(%14, %3) : (i32, i32) -> i32

} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b106870) {

  * Pattern MoveWhileToFor : 'scf.while -> ()' {
Trying to match "MoveWhileToFor"
"MoveWhileToFor" result 0
  } -> failure : pattern failed to match

  * Pattern RemoveWhileSelect : 'scf.while -> ()' {
Trying to match "RemoveWhileSelect"
"RemoveWhileSelect" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown : 'scf.while -> ()' {
Trying to match "MoveWhileDown"
"MoveWhileDown" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown2 : 'scf.while -> ()' {
Trying to match "MoveWhileDown2"
"MoveWhileDown2" result 0
  } -> failure : pattern failed to match

  * Pattern WhileShiftToInduction : 'scf.while -> ()' {
Trying to match "WhileShiftToInduction"
"WhileShiftToInduction" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileAndDown : 'scf.while -> ()' {
Trying to match "MoveWhileAndDown"
"MoveWhileAndDown" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown3 : 'scf.while -> ()' {
Trying to match "MoveWhileDown3"
"MoveWhileDown3" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileInvariantIfResult : 'scf.while -> ()' {
Trying to match "MoveWhileInvariantIfResult"
"MoveWhileInvariantIfResult" result 0
  } -> failure : pattern failed to match

  * Pattern WhileLogicalNegation : 'scf.while -> ()' {
Trying to match "WhileLogicalNegation"
"WhileLogicalNegation" result 0
  } -> failure : pattern failed to match

  * Pattern WhileCmpOffset : 'scf.while -> ()' {
Trying to match "WhileCmpOffset"
"WhileCmpOffset" result 0
  } -> failure : pattern failed to match

  * Pattern WhileLICM : 'scf.while -> ()' {
Trying to match "WhileLICM"
"WhileLICM" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1 = arith.constant 1 : index
  %c1_i32 = arith.constant 1 : i32
  %c-1 = arith.constant -1 : index
  %c-1_i32 = arith.constant -1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = affine.load %0[0] : memref<1xi32>
  %2 = arith.addi %1, %c1_i32 : i32
  %3 = arith.index_cast %2 : i32 to index
  scf.for %arg5 = %c1 to %3 step %c1 {
    %4 = arith.subi %arg5, %c1 : index
    %5 = arith.muli %4, %c-1 : index
    %6 = arith.index_cast %1 : i32 to index
    %7 = arith.addi %6, %5 : index
    %8 = arith.index_cast %7 : index to i32
    %9 = memref.get_global @jm : memref<1xi32>
    %10 = memref.get_global @jm : memref<1xi32>
    %11 = memref.get_global @im : memref<1xi32>
    %12 = arith.addi %8, %c-1_i32 : i32
    %13 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
      %14 = affine.load %9[0] : memref<1xi32>
      %15 = arith.cmpi slt, %arg6, %14 : i32
      scf.condition(%15) %arg6 : i32
    } do {
    ^bb0(%arg6: i32):
      %14:2 = scf.while (%arg7 = %c0_i32) : (i32) -> (i32, i32) {
        %16 = affine.load %11[0] : memref<1xi32>
        %17 = arith.cmpi slt, %arg7, %16 : i32
        scf.condition(%17) %16, %arg7 : i32, i32
      } do {
      ^bb0(%arg7: i32, %arg8: i32):
        %16 = arith.muli %arg6, %arg7 : i32
        %17 = arith.addi %arg8, %16 : i32
        %18 = arith.muli %8, %arg7 : i32
        %19 = affine.load %10[0] : memref<1xi32>
        %20 = arith.muli %18, %19 : i32
        %21 = arith.addi %17, %20 : i32
        %22 = arith.index_cast %21 : i32 to index
        %23 = arith.muli %12, %arg7 : i32
        %24 = arith.muli %23, %19 : i32
        %25 = arith.addi %17, %24 : i32
        %26 = arith.index_cast %25 : i32 to index
        %27 = arith.addi %26, %c0 : index
        %28 = memref.load %arg0[%27] : memref<?xf32>
        %29 = arith.addi %22, %c0 : index
        memref.store %28, %arg2[%29] : memref<?xf32>
        %30 = arith.addi %arg8, %c1_i32 : i32
        scf.yield %30 : i32
      }
      %15 = arith.addi %arg6, %c1_i32 : i32
      scf.yield %15 : i32
    }
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1056d0) {
  "scf.yield"(%21) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %21 = "arith.addi"(%arg6, %1) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b306c90) {

  * Pattern MoveWhileToFor : 'scf.while -> ()' {
Trying to match "MoveWhileToFor"
"MoveWhileToFor" result 0
  } -> failure : pattern failed to match

  * Pattern RemoveWhileSelect : 'scf.while -> ()' {
Trying to match "RemoveWhileSelect"
"RemoveWhileSelect" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown : 'scf.while -> ()' {
Trying to match "MoveWhileDown"
"MoveWhileDown" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown2 : 'scf.while -> ()' {
Trying to match "MoveWhileDown2"
"MoveWhileDown2" result 0
  } -> failure : pattern failed to match

  * Pattern WhileShiftToInduction : 'scf.while -> ()' {
Trying to match "WhileShiftToInduction"
"WhileShiftToInduction" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileAndDown : 'scf.while -> ()' {
Trying to match "MoveWhileAndDown"
"MoveWhileAndDown" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown3 : 'scf.while -> ()' {
Trying to match "MoveWhileDown3"
"MoveWhileDown3" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileInvariantIfResult : 'scf.while -> ()' {
Trying to match "MoveWhileInvariantIfResult"
"MoveWhileInvariantIfResult" result 0
  } -> failure : pattern failed to match

  * Pattern WhileLogicalNegation : 'scf.while -> ()' {
Trying to match "WhileLogicalNegation"
"WhileLogicalNegation" result 0
  } -> failure : pattern failed to match

  * Pattern WhileCmpOffset : 'scf.while -> ()' {
Trying to match "WhileCmpOffset"
"WhileCmpOffset" result 0
  } -> failure : pattern failed to match

  * Pattern WhileLICM : 'scf.while -> ()' {
Trying to match "WhileLICM"
"WhileLICM" result 0
  } -> failure : pattern failed to match

  * Pattern RemoveUnusedCondVar : 'scf.while -> ()' {
Trying to match "RemoveUnusedCondVar"
"RemoveUnusedCondVar" result 0
  } -> failure : pattern failed to match

  * Pattern MoveSideEffectFreeWhile : 'scf.while -> ()' {
Trying to match "MoveSideEffectFreeWhile"
"MoveSideEffectFreeWhile" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1061f0) {
  "scf.yield"(%36) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %36 = "arith.addi"(%arg8, %1) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%34, %arg2, %35) : (f32, memref<?xf32>, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98165e60) {
  %35 = "arith.addi"(%28, %5) : (index, index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %34 = "memref.load"(%arg0, %33) : (memref<?xf32>, index) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b0040e0) {
  %33 = "arith.addi"(%32, %5) : (index, index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd98304bd0) {
  %32 = "arith.index_cast"(%31) : (i32) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98304b30) {
  %31 = "arith.addi"(%23, %30) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304a90) {
  %30 = "arith.muli"(%29, %25) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %29 = "arith.muli"(%18, %arg7) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9816cb40) {
  %28 = "arith.index_cast"(%27) : (i32) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816caa0) {
  %27 = "arith.addi"(%23, %26) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816ca00) {
  %26 = "arith.muli"(%24, %25) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104ce0) {
  %25 = "affine.load"(%16) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %24 = "arith.muli"(%14, %arg7) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %23 = "arith.addi"(%arg8, %22) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %22 = "arith.muli"(%arg6, %arg7) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b306b60) {
  "scf.condition"(%23, %22, %arg7) : (i1, i32, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %23 = "arith.cmpi"(%arg7, %22) {predicate = 2 : i64} : (i32, i32) -> i1

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104b90) {
  %22 = "affine.load"(%17) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b004270) {
  %18 = "arith.addi"(%14, %3) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9816b600) {
  %17 = "memref.get_global"() {name = @im} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b1044b0) {
  "scf.condition"(%21, %arg6) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %21 = "arith.cmpi"(%arg6, %20) {predicate = 2 : i64} : (i32, i32) -> i1

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104c10) {
  %20 = "affine.load"(%15) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9b105bb0) {
  %16 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd98169a20) {
  %15 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104d70) {
  %7 = "affine.load"(%6) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd981673f0) {
  %6 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9816cc60) {
  %5 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98167e90) {
  %4 = "arith.constant"() {value = 0 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98304580) {
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b1054b0) {
  %3 = "arith.constant"() {value = -1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x7fbd9800c610) {
  "func.return"() : () -> ()


  * Pattern ReturnSq : 'func.return -> ()' {
Trying to match "ReturnSq"
"ReturnSq" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x7fbd9b105a30) {

  * Pattern PropagateInLoopBody : 'scf.for -> ()' {
Trying to match "PropagateInLoopBody"
"PropagateInLoopBody" result 0
  } -> failure : pattern failed to match

  * Pattern ForOpInductionReplacement : 'scf.for -> ()' {
Trying to match "ForOpInductionReplacement"
"ForOpInductionReplacement" result 0
  } -> failure : pattern failed to match

  * Pattern RemoveUnusedArgs : 'scf.for -> ()' {
Trying to match "RemoveUnusedArgs"
"RemoveUnusedArgs" result 0
  } -> failure : pattern failed to match

  * Pattern ReplaceRedundantArgs : 'scf.for -> ()' {
Trying to match "ReplaceRedundantArgs"
"ReplaceRedundantArgs" result 0
  } -> failure : pattern failed to match

  * Pattern ForBreakAddUpgrade : 'scf.for -> ()' {
Trying to match "ForBreakAddUpgrade"
"ForBreakAddUpgrade" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b106420) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b106870) {

  * Pattern MoveWhileToFor : 'scf.while -> ()' {
Trying to match "MoveWhileToFor"
"MoveWhileToFor" result 0
  } -> failure : pattern failed to match

  * Pattern RemoveWhileSelect : 'scf.while -> ()' {
Trying to match "RemoveWhileSelect"
"RemoveWhileSelect" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown : 'scf.while -> ()' {
Trying to match "MoveWhileDown"
"MoveWhileDown" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown2 : 'scf.while -> ()' {
Trying to match "MoveWhileDown2"
"MoveWhileDown2" result 0
  } -> failure : pattern failed to match

  * Pattern WhileShiftToInduction : 'scf.while -> ()' {
Trying to match "WhileShiftToInduction"
"WhileShiftToInduction" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileAndDown : 'scf.while -> ()' {
Trying to match "MoveWhileAndDown"
"MoveWhileAndDown" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown3 : 'scf.while -> ()' {
Trying to match "MoveWhileDown3"
"MoveWhileDown3" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileInvariantIfResult : 'scf.while -> ()' {
Trying to match "MoveWhileInvariantIfResult"
"MoveWhileInvariantIfResult" result 0
  } -> failure : pattern failed to match

  * Pattern WhileLogicalNegation : 'scf.while -> ()' {
Trying to match "WhileLogicalNegation"
"WhileLogicalNegation" result 0
  } -> failure : pattern failed to match

  * Pattern WhileCmpOffset : 'scf.while -> ()' {
Trying to match "WhileCmpOffset"
"WhileCmpOffset" result 0
  } -> failure : pattern failed to match

  * Pattern WhileLICM : 'scf.while -> ()' {
Trying to match "WhileLICM"
"WhileLICM" result 0
  } -> failure : pattern failed to match

  * Pattern RemoveUnusedCondVar : 'scf.while -> ()' {
Trying to match "RemoveUnusedCondVar"
"RemoveUnusedCondVar" result 0
  } -> failure : pattern failed to match

  * Pattern MoveSideEffectFreeWhile : 'scf.while -> ()' {
Trying to match "MoveSideEffectFreeWhile"
"MoveSideEffectFreeWhile" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1056d0) {
  "scf.yield"(%21) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %21 = "arith.addi"(%arg6, %1) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b306c90) {

  * Pattern MoveWhileToFor : 'scf.while -> ()' {
Trying to match "MoveWhileToFor"
"MoveWhileToFor" result 0
  } -> failure : pattern failed to match

  * Pattern RemoveWhileSelect : 'scf.while -> ()' {
Trying to match "RemoveWhileSelect"
"RemoveWhileSelect" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown : 'scf.while -> ()' {
Trying to match "MoveWhileDown"
"MoveWhileDown" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown2 : 'scf.while -> ()' {
Trying to match "MoveWhileDown2"
"MoveWhileDown2" result 0
  } -> failure : pattern failed to match

  * Pattern WhileShiftToInduction : 'scf.while -> ()' {
Trying to match "WhileShiftToInduction"
"WhileShiftToInduction" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileAndDown : 'scf.while -> ()' {
Trying to match "MoveWhileAndDown"
"MoveWhileAndDown" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown3 : 'scf.while -> ()' {
Trying to match "MoveWhileDown3"
"MoveWhileDown3" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileInvariantIfResult : 'scf.while -> ()' {
Trying to match "MoveWhileInvariantIfResult"
"MoveWhileInvariantIfResult" result 0
  } -> failure : pattern failed to match

  * Pattern WhileLogicalNegation : 'scf.while -> ()' {
Trying to match "WhileLogicalNegation"
"WhileLogicalNegation" result 0
  } -> failure : pattern failed to match

  * Pattern WhileCmpOffset : 'scf.while -> ()' {
Trying to match "WhileCmpOffset"
"WhileCmpOffset" result 0
  } -> failure : pattern failed to match

  * Pattern WhileLICM : 'scf.while -> ()' {
Trying to match "WhileLICM"
"WhileLICM" result 0
  } -> failure : pattern failed to match

  * Pattern RemoveUnusedCondVar : 'scf.while -> ()' {
Trying to match "RemoveUnusedCondVar"
"RemoveUnusedCondVar" result 0
  } -> failure : pattern failed to match

  * Pattern MoveSideEffectFreeWhile : 'scf.while -> ()' {
Trying to match "MoveSideEffectFreeWhile"
"MoveSideEffectFreeWhile" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1061f0) {
  "scf.yield"(%36) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %36 = "arith.addi"(%arg8, %1) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%34, %arg2, %35) : (f32, memref<?xf32>, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98165e60) {
  %35 = "arith.addi"(%28, %5) : (index, index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %34 = "memref.load"(%arg0, %33) : (memref<?xf32>, index) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b0040e0) {
  %33 = "arith.addi"(%32, %5) : (index, index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd98304bd0) {
  %32 = "arith.index_cast"(%31) : (i32) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98304b30) {
  %31 = "arith.addi"(%23, %30) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304a90) {
  %30 = "arith.muli"(%29, %25) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %29 = "arith.muli"(%18, %arg7) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9816cb40) {
  %28 = "arith.index_cast"(%27) : (i32) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816caa0) {
  %27 = "arith.addi"(%23, %26) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816ca00) {
  %26 = "arith.muli"(%24, %25) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104ce0) {
  %25 = "affine.load"(%16) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %24 = "arith.muli"(%14, %arg7) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %23 = "arith.addi"(%arg8, %22) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %22 = "arith.muli"(%arg6, %arg7) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b306b60) {
  "scf.condition"(%23, %22, %arg7) : (i1, i32, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %23 = "arith.cmpi"(%arg7, %22) {predicate = 2 : i64} : (i32, i32) -> i1

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104b90) {
  %22 = "affine.load"(%17) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b1044b0) {
  "scf.condition"(%21, %arg6) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %21 = "arith.cmpi"(%arg6, %20) {predicate = 2 : i64} : (i32, i32) -> i1

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104c10) {
  %20 = "affine.load"(%15) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b004270) {
  %18 = "arith.addi"(%14, %3) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9816b600) {
  %17 = "memref.get_global"() {name = @im} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9b105bb0) {
  %16 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd98169a20) {
  %15 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9b105c30) {
  %14 = "arith.index_cast"(%13) : (index) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b105750) {
  %13 = "arith.addi"(%12, %11) : (index, index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9b104380) {
  %12 = "arith.index_cast"(%7) : (i32) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9b1048d0) {
  %11 = "arith.muli"(%10, %2) : (index, index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9b306e10) {
  %10 = "arith.subi"(%arg5, %0) : (index, index) -> index


  * Pattern SubToAdd : 'arith.subi -> ()' {
Trying to match "SubToAdd"
"SubToAdd" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9800baa0) {
  %9 = "arith.index_cast"(%8) : (i32) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800a840) {
  %8 = "arith.addi"(%7, %1) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104d70) {
  %7 = "affine.load"(%6) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd981673f0) {
  %6 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9816cc60) {
  %5 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98167e90) {
  %4 = "arith.constant"() {value = 0 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b1054b0) {
  %3 = "arith.constant"() {value = -1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98009280) {
  %2 = "arith.constant"() {value = -1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98304580) {
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b306d40) {
  %0 = "arith.constant"() {value = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x7fbd9800c610) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x7fbd9b105a30) {

  * Pattern AlwaysAllocaScopeHoister<mlir::scf::ForOp> : 'scf.for -> ()' {
Trying to match "AlwaysAllocaScopeHoister<mlir::scf::ForOp>"
"AlwaysAllocaScopeHoister<mlir::scf::ForOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InductiveVarRemoval : 'scf.for -> ()' {
Trying to match "InductiveVarRemoval"
"InductiveVarRemoval" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::ForOpIterArgsFolder"
"(anonymous namespace)::ForOpIterArgsFolder" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::SimplifyTrivialLoops"
"(anonymous namespace)::SimplifyTrivialLoops" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::LastTensorLoadCanonicalization"
"(anonymous namespace)::LastTensorLoadCanonicalization" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::ForOpTensorCastFolder"
"(anonymous namespace)::ForOpTensorCastFolder" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b106420) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b106870) {

  * Pattern (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock"
"(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveLoopInvariantValueYielded : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantValueYielded"
"(anonymous namespace)::RemoveLoopInvariantValueYielded" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileConditionTruth : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileConditionTruth"
"(anonymous namespace)::WhileConditionTruth" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileCmpCond : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileCmpCond"
"(anonymous namespace)::WhileCmpCond" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileUnusedResult : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileUnusedResult"
"(anonymous namespace)::WhileUnusedResult" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1056d0) {
  "scf.yield"(%21) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %21 = "arith.addi"(%arg6, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b306c90) {

  * Pattern (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock"
"(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveLoopInvariantValueYielded : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantValueYielded"
"(anonymous namespace)::RemoveLoopInvariantValueYielded" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileConditionTruth : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileConditionTruth"
"(anonymous namespace)::WhileConditionTruth" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileCmpCond : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileCmpCond"
"(anonymous namespace)::WhileCmpCond" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileUnusedResult : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileUnusedResult"
"(anonymous namespace)::WhileUnusedResult" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1061f0) {
  "scf.yield"(%36) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %36 = "arith.addi"(%arg8, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%34, %arg2, %35) : (f32, memref<?xf32>, index) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98165e60) {
  %35 = "arith.addi"(%28, %5) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %34 = "memref.load"(%arg0, %33) : (memref<?xf32>, index) -> f32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b0040e0) {
  %33 = "arith.addi"(%32, %5) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd98304bd0) {
  %32 = "arith.index_cast"(%31) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98304b30) {
  %31 = "arith.addi"(%23, %30) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304a90) {
  %30 = "arith.muli"(%29, %25) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %29 = "arith.muli"(%18, %arg7) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9816cb40) {
  %28 = "arith.index_cast"(%27) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816caa0) {
  %27 = "arith.addi"(%23, %26) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816ca00) {
  %26 = "arith.muli"(%24, %25) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104ce0) {
  %25 = "affine.load"(%16) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %24 = "arith.muli"(%14, %arg7) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %23 = "arith.addi"(%arg8, %22) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %22 = "arith.muli"(%arg6, %arg7) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b306b60) {
  "scf.condition"(%23, %22, %arg7) : (i1, i32, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %23 = "arith.cmpi"(%arg7, %22) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104b90) {
  %22 = "affine.load"(%17) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b1044b0) {
  "scf.condition"(%21, %arg6) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %21 = "arith.cmpi"(%arg6, %20) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104c10) {
  %20 = "affine.load"(%15) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b004270) {
  %18 = "arith.addi"(%14, %3) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9816b600) {
  %17 = "memref.get_global"() {name = @im} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9b105bb0) {
  %16 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd98169a20) {
  %15 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9b105c30) {
  %14 = "arith.index_cast"(%13) : (index) -> i32


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b105750) {
  %13 = "arith.addi"(%12, %11) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9b104380) {
  %12 = "arith.index_cast"(%7) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9b1048d0) {
  %11 = "arith.muli"(%10, %2) : (index, index) -> index


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9b306e10) {
  %10 = "arith.subi"(%arg5, %0) : (index, index) -> index


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9800baa0) {
  %9 = "arith.index_cast"(%8) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800a840) {
  %8 = "arith.addi"(%7, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104d70) {
  %7 = "affine.load"(%6) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd981673f0) {
  %6 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9816cc60) {
  %5 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98167e90) {
  %4 = "arith.constant"() {value = 0 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b1054b0) {
  %3 = "arith.constant"() {value = -1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98009280) {
  %2 = "arith.constant"() {value = -1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98304580) {
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b306d40) {
  %0 = "arith.constant"() {value = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x7fbd9800c610) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x7fbd9b105a30) {

  * Pattern AlwaysAllocaScopeHoister<mlir::scf::ForOp> : 'scf.for -> ()' {
Trying to match "AlwaysAllocaScopeHoister<mlir::scf::ForOp>"
"AlwaysAllocaScopeHoister<mlir::scf::ForOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InductiveVarRemoval : 'scf.for -> ()' {
Trying to match "InductiveVarRemoval"
"InductiveVarRemoval" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::ForOpIterArgsFolder"
"(anonymous namespace)::ForOpIterArgsFolder" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::SimplifyTrivialLoops"
"(anonymous namespace)::SimplifyTrivialLoops" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::LastTensorLoadCanonicalization"
"(anonymous namespace)::LastTensorLoadCanonicalization" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::ForOpTensorCastFolder"
"(anonymous namespace)::ForOpTensorCastFolder" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b106420) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b106870) {

  * Pattern (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock"
"(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveLoopInvariantValueYielded : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantValueYielded"
"(anonymous namespace)::RemoveLoopInvariantValueYielded" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileConditionTruth : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileConditionTruth"
"(anonymous namespace)::WhileConditionTruth" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileCmpCond : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileCmpCond"
"(anonymous namespace)::WhileCmpCond" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileUnusedResult : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileUnusedResult"
"(anonymous namespace)::WhileUnusedResult" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1056d0) {
  "scf.yield"(%21) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %21 = "arith.addi"(%arg6, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b306c90) {

  * Pattern (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock"
"(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveLoopInvariantValueYielded : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantValueYielded"
"(anonymous namespace)::RemoveLoopInvariantValueYielded" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileConditionTruth : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileConditionTruth"
"(anonymous namespace)::WhileConditionTruth" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileCmpCond : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileCmpCond"
"(anonymous namespace)::WhileCmpCond" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileUnusedResult : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileUnusedResult"
"(anonymous namespace)::WhileUnusedResult" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1061f0) {
  "scf.yield"(%36) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %36 = "arith.addi"(%arg8, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%34, %arg2, %35) : (f32, memref<?xf32>, index) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98165e60) {
  %35 = "arith.addi"(%28, %5) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %34 = "memref.load"(%arg0, %33) : (memref<?xf32>, index) -> f32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b0040e0) {
  %33 = "arith.addi"(%32, %5) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd98304bd0) {
  %32 = "arith.index_cast"(%31) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98304b30) {
  %31 = "arith.addi"(%23, %30) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304a90) {
  %30 = "arith.muli"(%29, %25) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %29 = "arith.muli"(%18, %arg7) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9816cb40) {
  %28 = "arith.index_cast"(%27) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816caa0) {
  %27 = "arith.addi"(%23, %26) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816ca00) {
  %26 = "arith.muli"(%24, %25) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104ce0) {
  %25 = "affine.load"(%16) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %24 = "arith.muli"(%14, %arg7) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %23 = "arith.addi"(%arg8, %22) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %22 = "arith.muli"(%arg6, %arg7) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b306b60) {
  "scf.condition"(%23, %22, %arg7) : (i1, i32, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %23 = "arith.cmpi"(%arg7, %22) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104b90) {
  %22 = "affine.load"(%17) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b1044b0) {
  "scf.condition"(%21, %arg6) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %21 = "arith.cmpi"(%arg6, %20) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104c10) {
  %20 = "affine.load"(%15) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b004270) {
  %18 = "arith.addi"(%14, %3) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9816b600) {
  %17 = "memref.get_global"() {name = @im} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9b105bb0) {
  %16 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd98169a20) {
  %15 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9b105c30) {
  %14 = "arith.index_cast"(%13) : (index) -> i32


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b105750) {
  %13 = "arith.addi"(%12, %11) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9b104380) {
  %12 = "arith.index_cast"(%7) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9b1048d0) {
  %11 = "arith.muli"(%10, %2) : (index, index) -> index


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9b306e10) {
  %10 = "arith.subi"(%arg5, %0) : (index, index) -> index


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9800baa0) {
  %9 = "arith.index_cast"(%8) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800a840) {
  %8 = "arith.addi"(%7, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104d70) {
  %7 = "affine.load"(%6) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd981673f0) {
  %6 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9816cc60) {
  %5 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98167e90) {
  %4 = "arith.constant"() {value = 0 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b1054b0) {
  %3 = "arith.constant"() {value = -1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98009280) {
  %2 = "arith.constant"() {value = -1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98304580) {
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b306d40) {
  %0 = "arith.constant"() {value = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x7fbd9800c610) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x7fbd9b105a30) {

  * Pattern AlwaysAllocaScopeHoister<mlir::scf::ForOp> : 'scf.for -> ()' {
Trying to match "AlwaysAllocaScopeHoister<mlir::scf::ForOp>"
"AlwaysAllocaScopeHoister<mlir::scf::ForOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InductiveVarRemoval : 'scf.for -> ()' {
Trying to match "InductiveVarRemoval"
"InductiveVarRemoval" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::ForOpIterArgsFolder"
"(anonymous namespace)::ForOpIterArgsFolder" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::SimplifyTrivialLoops"
"(anonymous namespace)::SimplifyTrivialLoops" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::LastTensorLoadCanonicalization"
"(anonymous namespace)::LastTensorLoadCanonicalization" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::ForOpTensorCastFolder"
"(anonymous namespace)::ForOpTensorCastFolder" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b106420) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b106870) {

  * Pattern (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock"
"(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveLoopInvariantValueYielded : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantValueYielded"
"(anonymous namespace)::RemoveLoopInvariantValueYielded" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileConditionTruth : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileConditionTruth"
"(anonymous namespace)::WhileConditionTruth" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileCmpCond : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileCmpCond"
"(anonymous namespace)::WhileCmpCond" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileUnusedResult : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileUnusedResult"
"(anonymous namespace)::WhileUnusedResult" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1056d0) {
  "scf.yield"(%20) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %20 = "arith.addi"(%arg6, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b306c90) {

  * Pattern (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock"
"(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveLoopInvariantValueYielded : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantValueYielded"
"(anonymous namespace)::RemoveLoopInvariantValueYielded" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileConditionTruth : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileConditionTruth"
"(anonymous namespace)::WhileConditionTruth" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileCmpCond : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileCmpCond"
"(anonymous namespace)::WhileCmpCond" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileUnusedResult : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileUnusedResult"
"(anonymous namespace)::WhileUnusedResult" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1061f0) {
  "scf.yield"(%35) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %35 = "arith.addi"(%arg8, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%33, %arg2, %34) : (f32, memref<?xf32>, index) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98165e60) {
  %34 = "arith.addi"(%27, %5) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %33 = "memref.load"(%arg0, %32) : (memref<?xf32>, index) -> f32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b0040e0) {
  %32 = "arith.addi"(%31, %5) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd98304bd0) {
  %31 = "arith.index_cast"(%30) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98304b30) {
  %30 = "arith.addi"(%22, %29) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304a90) {
  %29 = "arith.muli"(%28, %24) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %28 = "arith.muli"(%17, %arg7) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9816cb40) {
  %27 = "arith.index_cast"(%26) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816caa0) {
  %26 = "arith.addi"(%22, %25) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816ca00) {
  %25 = "arith.muli"(%23, %24) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104ce0) {
  %24 = "affine.load"(%15) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %23 = "arith.muli"(%14, %arg7) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %22 = "arith.addi"(%arg8, %21) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %21 = "arith.muli"(%arg6, %arg7) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b306b60) {
  "scf.condition"(%22, %21, %arg7) : (i1, i32, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %22 = "arith.cmpi"(%arg7, %21) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104b90) {
  %21 = "affine.load"(%16) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b1044b0) {
  "scf.condition"(%20, %arg6) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %20 = "arith.cmpi"(%arg6, %19) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104c10) {
  %19 = "affine.load"(%15) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b004270) {
  %17 = "arith.addi"(%14, %3) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9816b600) {
  %16 = "memref.get_global"() {name = @im} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd98169a20) {
  %15 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9b105c30) {
  %14 = "arith.index_cast"(%13) : (index) -> i32


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b105750) {
  %13 = "arith.addi"(%12, %11) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9b104380) {
  %12 = "arith.index_cast"(%7) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9b1048d0) {
  %11 = "arith.muli"(%10, %2) : (index, index) -> index


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9b306e10) {
  %10 = "arith.subi"(%arg5, %0) : (index, index) -> index


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9800baa0) {
  %9 = "arith.index_cast"(%8) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800a840) {
  %8 = "arith.addi"(%7, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104d70) {
  %7 = "affine.load"(%6) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd981673f0) {
  %6 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9816cc60) {
  %5 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98167e90) {
  %4 = "arith.constant"() {value = 0 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b1054b0) {
  %3 = "arith.constant"() {value = -1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98009280) {
  %2 = "arith.constant"() {value = -1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98304580) {
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b306d40) {
  %0 = "arith.constant"() {value = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallGraph)

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b306d40) {
  %0 = "arith.constant"() {value = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98304580) {
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98009280) {
  %2 = "arith.constant"() {value = -1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b1054b0) {
  %3 = "arith.constant"() {value = -1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98167e90) {
  %4 = "arith.constant"() {value = 0 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9816cc60) {
  %5 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd981673f0) {
  %6 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104d70) {
  %7 = "affine.load"(%6) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800a840) {
  %8 = "arith.addi"(%7, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9800baa0) {
  %9 = "arith.index_cast"(%8) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x7fbd9b105a30) {

  * Pattern AlwaysAllocaScopeHoister<mlir::scf::ForOp> : 'scf.for -> ()' {
Trying to match "AlwaysAllocaScopeHoister<mlir::scf::ForOp>"
"AlwaysAllocaScopeHoister<mlir::scf::ForOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InductiveVarRemoval : 'scf.for -> ()' {
Trying to match "InductiveVarRemoval"
"InductiveVarRemoval" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::ForOpIterArgsFolder"
"(anonymous namespace)::ForOpIterArgsFolder" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::SimplifyTrivialLoops"
"(anonymous namespace)::SimplifyTrivialLoops" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::LastTensorLoadCanonicalization"
"(anonymous namespace)::LastTensorLoadCanonicalization" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::ForOpTensorCastFolder"
"(anonymous namespace)::ForOpTensorCastFolder" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9b306e10) {
  %10 = "arith.subi"(%arg5, %0) : (index, index) -> index


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9b1048d0) {
  %11 = "arith.muli"(%10, %2) : (index, index) -> index


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9b104380) {
  %12 = "arith.index_cast"(%7) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b105750) {
  %13 = "arith.addi"(%12, %11) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9b105c30) {
  %14 = "arith.index_cast"(%13) : (index) -> i32


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd98169a20) {
  %15 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9816b600) {
  %16 = "memref.get_global"() {name = @im} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b004270) {
  %17 = "arith.addi"(%14, %3) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b106870) {

  * Pattern (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock"
"(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveLoopInvariantValueYielded : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantValueYielded"
"(anonymous namespace)::RemoveLoopInvariantValueYielded" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileConditionTruth : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileConditionTruth"
"(anonymous namespace)::WhileConditionTruth" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileCmpCond : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileCmpCond"
"(anonymous namespace)::WhileCmpCond" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileUnusedResult : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileUnusedResult"
"(anonymous namespace)::WhileUnusedResult" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104c10) {
  %19 = "affine.load"(%15) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %20 = "arith.cmpi"(%arg6, %19) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b1044b0) {
  "scf.condition"(%20, %arg6) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b306c90) {

  * Pattern (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock"
"(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveLoopInvariantValueYielded : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantValueYielded"
"(anonymous namespace)::RemoveLoopInvariantValueYielded" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileConditionTruth : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileConditionTruth"
"(anonymous namespace)::WhileConditionTruth" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileCmpCond : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileCmpCond"
"(anonymous namespace)::WhileCmpCond" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileUnusedResult : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileUnusedResult"
"(anonymous namespace)::WhileUnusedResult" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104b90) {
  %21 = "affine.load"(%16) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %22 = "arith.cmpi"(%arg7, %21) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b306b60) {
  "scf.condition"(%22, %21, %arg7) : (i1, i32, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %21 = "arith.muli"(%arg6, %arg7) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %22 = "arith.addi"(%arg8, %21) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %23 = "arith.muli"(%14, %arg7) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104ce0) {
  %24 = "affine.load"(%15) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816ca00) {
  %25 = "arith.muli"(%23, %24) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816caa0) {
  %26 = "arith.addi"(%22, %25) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9816cb40) {
  %27 = "arith.index_cast"(%26) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %28 = "arith.muli"(%17, %arg7) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304a90) {
  %29 = "arith.muli"(%28, %24) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98304b30) {
  %30 = "arith.addi"(%22, %29) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd98304bd0) {
  %31 = "arith.index_cast"(%30) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b0040e0) {
  %32 = "arith.addi"(%31, %5) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %33 = "memref.load"(%arg0, %32) : (memref<?xf32>, index) -> f32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98165e60) {
  %34 = "arith.addi"(%27, %5) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%33, %arg2, %34) : (f32, memref<?xf32>, index) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %35 = "arith.addi"(%arg8, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1061f0) {
  "scf.yield"(%35) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %20 = "arith.addi"(%arg6, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1056d0) {
  "scf.yield"(%20) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b106420) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x7fbd9800c610) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
* Inliner: Initial calls in SCC are: {
}
* Inliner: Initial calls in SCC are: {
}

//===-------------------------------------------===//
Processing operation : 'func.return'(0x7fbd9800c610) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x7fbd9b105a30) {

  * Pattern AlwaysAllocaScopeHoister<mlir::scf::ForOp> : 'scf.for -> ()' {
Trying to match "AlwaysAllocaScopeHoister<mlir::scf::ForOp>"
"AlwaysAllocaScopeHoister<mlir::scf::ForOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InductiveVarRemoval : 'scf.for -> ()' {
Trying to match "InductiveVarRemoval"
"InductiveVarRemoval" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::ForOpIterArgsFolder"
"(anonymous namespace)::ForOpIterArgsFolder" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::SimplifyTrivialLoops"
"(anonymous namespace)::SimplifyTrivialLoops" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::LastTensorLoadCanonicalization"
"(anonymous namespace)::LastTensorLoadCanonicalization" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::ForOpTensorCastFolder"
"(anonymous namespace)::ForOpTensorCastFolder" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b106420) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b106870) {

  * Pattern (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock"
"(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveLoopInvariantValueYielded : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantValueYielded"
"(anonymous namespace)::RemoveLoopInvariantValueYielded" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileConditionTruth : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileConditionTruth"
"(anonymous namespace)::WhileConditionTruth" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileCmpCond : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileCmpCond"
"(anonymous namespace)::WhileCmpCond" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileUnusedResult : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileUnusedResult"
"(anonymous namespace)::WhileUnusedResult" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1056d0) {
  "scf.yield"(%20) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %20 = "arith.addi"(%arg6, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b306c90) {

  * Pattern (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock"
"(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveLoopInvariantValueYielded : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantValueYielded"
"(anonymous namespace)::RemoveLoopInvariantValueYielded" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileConditionTruth : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileConditionTruth"
"(anonymous namespace)::WhileConditionTruth" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileCmpCond : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileCmpCond"
"(anonymous namespace)::WhileCmpCond" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileUnusedResult : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileUnusedResult"
"(anonymous namespace)::WhileUnusedResult" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1061f0) {
  "scf.yield"(%35) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %35 = "arith.addi"(%arg8, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%33, %arg2, %34) : (f32, memref<?xf32>, index) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98165e60) {
  %34 = "arith.addi"(%27, %5) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %33 = "memref.load"(%arg0, %32) : (memref<?xf32>, index) -> f32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b0040e0) {
  %32 = "arith.addi"(%31, %5) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd98304bd0) {
  %31 = "arith.index_cast"(%30) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98304b30) {
  %30 = "arith.addi"(%22, %29) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304a90) {
  %29 = "arith.muli"(%28, %24) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %28 = "arith.muli"(%17, %arg7) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9816cb40) {
  %27 = "arith.index_cast"(%26) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816caa0) {
  %26 = "arith.addi"(%22, %25) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816ca00) {
  %25 = "arith.muli"(%23, %24) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104ce0) {
  %24 = "affine.load"(%15) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %23 = "arith.muli"(%14, %arg7) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %22 = "arith.addi"(%arg8, %21) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %21 = "arith.muli"(%arg6, %arg7) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b306b60) {
  "scf.condition"(%22, %21, %arg7) : (i1, i32, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %22 = "arith.cmpi"(%arg7, %21) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104b90) {
  %21 = "affine.load"(%16) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b1044b0) {
  "scf.condition"(%20, %arg6) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %20 = "arith.cmpi"(%arg6, %19) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104c10) {
  %19 = "affine.load"(%15) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b004270) {
  %17 = "arith.addi"(%14, %3) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9816b600) {
  %16 = "memref.get_global"() {name = @im} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd98169a20) {
  %15 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9b105c30) {
  %14 = "arith.index_cast"(%13) : (index) -> i32


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b105750) {
  %13 = "arith.addi"(%12, %11) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9b104380) {
  %12 = "arith.index_cast"(%7) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9b1048d0) {
  %11 = "arith.muli"(%10, %2) : (index, index) -> index


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9b306e10) {
  %10 = "arith.subi"(%arg5, %0) : (index, index) -> index


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9800baa0) {
  %9 = "arith.index_cast"(%8) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800a840) {
  %8 = "arith.addi"(%7, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104d70) {
  %7 = "affine.load"(%6) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd981673f0) {
  %6 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9816cc60) {
  %5 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98167e90) {
  %4 = "arith.constant"() {value = 0 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b1054b0) {
  %3 = "arith.constant"() {value = -1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98009280) {
  %2 = "arith.constant"() {value = -1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98304580) {
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b306d40) {
  %0 = "arith.constant"() {value = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%0 = memref.get_global @kbm3 : memref<1xi32>
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%9 = memref.get_global @jm : memref<1xi32>
 + forwarding vec to promote {0,} of mlir-asm-printer: Verifying operation: builtin.module
%9 = memref.get_global @jm : memref<1xi32>
Begin forwarding store of mlir-asm-printer: Verifying operation: builtin.module
%9 = memref.get_global @jm : memref<1xi32> to load
mlir-asm-printer: Verifying operation: func.func
func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
  %c1 = arith.constant 1 : index
  %c1_i32 = arith.constant 1 : i32
  %c-1 = arith.constant -1 : index
  %c-1_i32 = arith.constant -1 : i32
  %c0_i32 = arith.constant 0 : i32
  %c0 = arith.constant 0 : index
  %0 = memref.get_global @kbm3 : memref<1xi32>
  %1 = affine.load %0[0] : memref<1xi32>
  %2 = arith.addi %1, %c1_i32 : i32
  %3 = arith.index_cast %2 : i32 to index
  scf.for %arg5 = %c1 to %3 step %c1 {
    %4 = arith.subi %arg5, %c1 : index
    %5 = arith.muli %4, %c-1 : index
    %6 = arith.index_cast %1 : i32 to index
    %7 = arith.addi %6, %5 : index
    %8 = arith.index_cast %7 : index to i32
    %9 = memref.get_global @jm : memref<1xi32>
    %10 = memref.get_global @im : memref<1xi32>
    %11 = arith.addi %8, %c-1_i32 : i32
    %12 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
      %13 = affine.load %9[0] : memref<1xi32>
      %14 = arith.cmpi slt, %arg6, %13 : i32
      scf.condition(%14) %arg6 : i32
    } do {
    ^bb0(%arg6: i32):
      %13:2 = scf.while (%arg7 = %c0_i32) : (i32) -> (i32, i32) {
        %15 = affine.load %10[0] : memref<1xi32>
        %16 = arith.cmpi slt, %arg7, %15 : i32
        scf.condition(%16) %15, %arg7 : i32, i32
      } do {
      ^bb0(%arg7: i32, %arg8: i32):
        %15 = arith.muli %arg6, %arg7 : i32
        %16 = arith.addi %arg8, %15 : i32
        %17 = arith.muli %8, %arg7 : i32
        %18 = affine.load %9[0] : memref<1xi32>
        %19 = arith.muli %17, %18 : i32
        %20 = arith.addi %16, %19 : i32
        %21 = arith.index_cast %20 : i32 to index
        %22 = arith.muli %11, %arg7 : i32
        %23 = arith.muli %22, %18 : i32
        %24 = arith.addi %16, %23 : i32
        %25 = arith.index_cast %24 : i32 to index
        %26 = arith.addi %25, %c0 : index
        %27 = memref.load %arg0[%26] : memref<?xf32>
        %28 = arith.addi %21, %c0 : index
        memref.store %27, %arg2[%28] : memref<?xf32>
        %29 = arith.addi %arg8, %c1_i32 : i32
        scf.yield %29 : i32
      }
      %14 = arith.addi %arg6, %c1_i32 : i32
      scf.yield %14 : i32
    }
  }
  return
}
Matching Load: mlir-asm-printer: Verifying operation: func.func
%18 = affine.load %9[0] : memref<1xi32>
Matching Load: mlir-asm-printer: Verifying operation: func.func
%13 = affine.load %9[0] : memref<1xi32>
Potential Op ith Effect: mlir-asm-printer: Verifying operation: func.func
memref.store %27, %arg2[%28] : memref<?xf32>
 aliasing storing operation: mlir-asm-printer: Verifying operation: func.func
memref.store %27, %arg2[%28] : memref<?xf32>
 initial storing block: 0x7fbd9b106140
 derived storing block: 0x7fbd9b105620
 initial storing block: 0x7fbd9b105620
 derived storing block: 0x7fbd9b1049e0
 initial storing block: 0x7fbd9b1049e0
 derived storing block: 0x7fbd98164100
 initial storing block: 0x7fbd98164100
 derived storing block: 0x7fbd9814dea0
 initial storing block: 0x7fbd9814dea0

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0(%arg5: index):
  %4 = arith.subi %arg5, %c1 : index
  %5 = arith.muli %4, %c-1 : index
  %6 = arith.index_cast %1 : i32 to index
  %7 = arith.addi %6, %5 : index
  %8 = arith.index_cast %7 : index to i32
  %9 = memref.get_global @jm : memref<1xi32>
  %10 = memref.get_global @im : memref<1xi32>
  %11 = arith.addi %8, %c-1_i32 : i32
  %12 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
    %13 = affine.load %9[0] : memref<1xi32>
    %14 = arith.cmpi slt, %arg6, %13 : i32
    scf.condition(%14) %arg6 : i32
  } do {
  ^bb0(%arg6: i32):
    %13:2 = scf.while (%arg7 = %c0_i32) : (i32) -> (i32, i32) {
      %15 = affine.load %10[0] : memref<1xi32>
      %16 = arith.cmpi slt, %arg7, %15 : i32
      scf.condition(%16) %15, %arg7 : i32, i32
    } do {
    ^bb0(%arg7: i32, %arg8: i32):
      %15 = arith.muli %arg6, %arg7 : i32
      %16 = arith.addi %arg8, %15 : i32
      %17 = arith.muli %8, %arg7 : i32
      %18 = affine.load %9[0] : memref<1xi32>
      %19 = arith.muli %17, %18 : i32
      %20 = arith.addi %16, %19 : i32
      %21 = arith.index_cast %20 : i32 to index
      %22 = arith.muli %11, %arg7 : i32
      %23 = arith.muli %22, %18 : i32
      %24 = arith.addi %16, %23 : i32
      %25 = arith.index_cast %24 : i32 to index
      %26 = arith.addi %25, %c0 : index
      %27 = memref.load %arg0[%26] : memref<?xf32>
      %28 = arith.addi %21, %c0 : index
      memref.store %27, %arg2[%28] : memref<?xf32>
      %29 = arith.addi %arg8, %c1_i32 : i32
      scf.yield %29 : i32
    }
    %14 = arith.addi %arg6, %c1_i32 : i32
    scf.yield %14 : i32
  }
  scf.yield

erased store due to: mlir-asm-printer: Verifying operation: func.func
%12 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
  %13 = affine.load %9[0] : memref<1xi32>
  %14 = arith.cmpi slt, %arg6, %13 : i32
  scf.condition(%14) %arg6 : i32
} do {
^bb0(%arg6: i32):
  %13:2 = scf.while (%arg7 = %c0_i32) : (i32) -> (i32, i32) {
    %15 = affine.load %10[0] : memref<1xi32>
    %16 = arith.cmpi slt, %arg7, %15 : i32
    scf.condition(%16) %15, %arg7 : i32, i32
  } do {
  ^bb0(%arg7: i32, %arg8: i32):
    %15 = arith.muli %arg6, %arg7 : i32
    %16 = arith.addi %arg8, %15 : i32
    %17 = arith.muli %8, %arg7 : i32
    %18 = affine.load %9[0] : memref<1xi32>
    %19 = arith.muli %17, %18 : i32
    %20 = arith.addi %16, %19 : i32
    %21 = arith.index_cast %20 : i32 to index
    %22 = arith.muli %11, %arg7 : i32
    %23 = arith.muli %22, %18 : i32
    %24 = arith.addi %16, %23 : i32
    %25 = arith.index_cast %24 : i32 to index
    %26 = arith.addi %25, %c0 : index
    %27 = memref.load %arg0[%26] : memref<?xf32>
    %28 = arith.addi %21, %c0 : index
    memref.store %27, %arg2[%28] : memref<?xf32>
    %29 = arith.addi %arg8, %c1_i32 : i32
    scf.yield %29 : i32
  }
  %14 = arith.addi %arg6, %c1_i32 : i32
  scf.yield %14 : i32
}

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0(%arg6: i32):
  %13 = affine.load %9[0] : memref<1xi32>
  %14 = arith.cmpi slt, %arg6, %13 : i32
  scf.condition(%14) %arg6 : i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0(%arg6: i32):
  %13 = affine.load %9[0] : memref<1xi32>
  %14 = arith.cmpi slt, %arg6, %13 : i32
  scf.condition(%14) %arg6 : i32
 with val:val:mlir-asm-printer: Verifying operation: builtin.module
%13 = affine.load %9[0] : memref<1xi32>

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0(%arg6: i32):
  %13:2 = scf.while (%arg7 = %c0_i32) : (i32) -> (i32, i32) {
    %15 = affine.load %10[0] : memref<1xi32>
    %16 = arith.cmpi slt, %arg7, %15 : i32
    scf.condition(%16) %15, %arg7 : i32, i32
  } do {
  ^bb0(%arg7: i32, %arg8: i32):
    %15 = arith.muli %arg6, %arg7 : i32
    %16 = arith.addi %arg8, %15 : i32
    %17 = arith.muli %8, %arg7 : i32
    %18 = affine.load %9[0] : memref<1xi32>
    %19 = arith.muli %17, %18 : i32
    %20 = arith.addi %16, %19 : i32
    %21 = arith.index_cast %20 : i32 to index
    %22 = arith.muli %11, %arg7 : i32
    %23 = arith.muli %22, %18 : i32
    %24 = arith.addi %16, %23 : i32
    %25 = arith.index_cast %24 : i32 to index
    %26 = arith.addi %25, %c0 : index
    %27 = memref.load %arg0[%26] : memref<?xf32>
    %28 = arith.addi %21, %c0 : index
    memref.store %27, %arg2[%28] : memref<?xf32>
    %29 = arith.addi %arg8, %c1_i32 : i32
    scf.yield %29 : i32
  }
  %14 = arith.addi %arg6, %c1_i32 : i32
  scf.yield %14 : i32

erased store due to: mlir-asm-printer: Verifying operation: func.func
%13:2 = scf.while (%arg7 = %c0_i32) : (i32) -> (i32, i32) {
  %15 = affine.load %10[0] : memref<1xi32>
  %16 = arith.cmpi slt, %arg7, %15 : i32
  scf.condition(%16) %15, %arg7 : i32, i32
} do {
^bb0(%arg7: i32, %arg8: i32):
  %15 = arith.muli %arg6, %arg7 : i32
  %16 = arith.addi %arg8, %15 : i32
  %17 = arith.muli %8, %arg7 : i32
  %18 = affine.load %9[0] : memref<1xi32>
  %19 = arith.muli %17, %18 : i32
  %20 = arith.addi %16, %19 : i32
  %21 = arith.index_cast %20 : i32 to index
  %22 = arith.muli %11, %arg7 : i32
  %23 = arith.muli %22, %18 : i32
  %24 = arith.addi %16, %23 : i32
  %25 = arith.index_cast %24 : i32 to index
  %26 = arith.addi %25, %c0 : index
  %27 = memref.load %arg0[%26] : memref<?xf32>
  %28 = arith.addi %21, %c0 : index
  memref.store %27, %arg2[%28] : memref<?xf32>
  %29 = arith.addi %arg8, %c1_i32 : i32
  scf.yield %29 : i32
}

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0(%arg7: i32):
  %15 = affine.load %10[0] : memref<1xi32>
  %16 = arith.cmpi slt, %arg7, %15 : i32
  scf.condition(%16) %15, %arg7 : i32, i32

 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0(%arg7: i32):
  %15 = affine.load %10[0] : memref<1xi32>
  %16 = arith.cmpi slt, %arg7, %15 : i32
  scf.condition(%16) %15, %arg7 : i32, i32
 with val:<overwritten>

starting block: lastVal=<overwritten>
mlir-asm-printer: Verifying operation: builtin.module
^bb0(%arg7: i32, %arg8: i32):
  %15 = arith.muli %arg6, %arg7 : i32
  %16 = arith.addi %arg8, %15 : i32
  %17 = arith.muli %8, %arg7 : i32
  %18 = affine.load %9[0] : memref<1xi32>
  %19 = arith.muli %17, %18 : i32
  %20 = arith.addi %16, %19 : i32
  %21 = arith.index_cast %20 : i32 to index
  %22 = arith.muli %11, %arg7 : i32
  %23 = arith.muli %22, %18 : i32
  %24 = arith.addi %16, %23 : i32
  %25 = arith.index_cast %24 : i32 to index
  %26 = arith.addi %25, %c0 : index
  %27 = memref.load %arg0[%26] : memref<?xf32>
  %28 = arith.addi %21, %c0 : index
  memref.store %27, %arg2[%28] : memref<?xf32>
  %29 = arith.addi %arg8, %c1_i32 : i32
  scf.yield %29 : i32

erased store due to: mlir-asm-printer: Verifying operation: func.func
memref.store %27, %arg2[%28] : memref<?xf32>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0(%arg7: i32, %arg8: i32):
  %15 = arith.muli %arg6, %arg7 : i32
  %16 = arith.addi %arg8, %15 : i32
  %17 = arith.muli %8, %arg7 : i32
  %18 = affine.load %9[0] : memref<1xi32>
  %19 = arith.muli %17, %18 : i32
  %20 = arith.addi %16, %19 : i32
  %21 = arith.index_cast %20 : i32 to index
  %22 = arith.muli %11, %arg7 : i32
  %23 = arith.muli %22, %18 : i32
  %24 = arith.addi %16, %23 : i32
  %25 = arith.index_cast %24 : i32 to index
  %26 = arith.addi %25, %c0 : index
  %27 = memref.load %arg0[%26] : memref<?xf32>
  %28 = arith.addi %21, %c0 : index
  memref.store %27, %arg2[%28] : memref<?xf32>
  %29 = arith.addi %arg8, %c1_i32 : i32
  scf.yield %29 : i32
 with val:<overwritten>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0(%arg6: i32):
  %13:2 = scf.while (%arg7 = %c0_i32) : (i32) -> (i32, i32) {
    %15 = affine.load %10[0] : memref<1xi32>
    %16 = arith.cmpi slt, %arg7, %15 : i32
    scf.condition(%16) %15, %arg7 : i32, i32
  } do {
  ^bb0(%arg7: i32, %arg8: i32):
    %15 = arith.muli %arg6, %arg7 : i32
    %16 = arith.addi %arg8, %15 : i32
    %17 = arith.muli %8, %arg7 : i32
    %18 = affine.load %9[0] : memref<1xi32>
    %19 = arith.muli %17, %18 : i32
    %20 = arith.addi %16, %19 : i32
    %21 = arith.index_cast %20 : i32 to index
    %22 = arith.muli %11, %arg7 : i32
    %23 = arith.muli %22, %18 : i32
    %24 = arith.addi %16, %23 : i32
    %25 = arith.index_cast %24 : i32 to index
    %26 = arith.addi %25, %c0 : index
    %27 = memref.load %arg0[%26] : memref<?xf32>
    %28 = arith.addi %21, %c0 : index
    memref.store %27, %arg2[%28] : memref<?xf32>
    %29 = arith.addi %arg8, %c1_i32 : i32
    scf.yield %29 : i32
  }
  %14 = arith.addi %arg6, %c1_i32 : i32
  scf.yield %14 : i32
 with val:<overwritten>
 ending block: mlir-asm-printer: Verifying operation: builtin.module
^bb0(%arg5: index):
  %4 = arith.subi %arg5, %c1 : index
  %5 = arith.muli %4, %c-1 : index
  %6 = arith.index_cast %1 : i32 to index
  %7 = arith.addi %6, %5 : index
  %8 = arith.index_cast %7 : index to i32
  %9 = memref.get_global @jm : memref<1xi32>
  %10 = memref.get_global @im : memref<1xi32>
  %11 = arith.addi %8, %c-1_i32 : i32
  %12 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
    %13 = affine.load %9[0] : memref<1xi32>
    %14 = arith.cmpi slt, %arg6, %13 : i32
    scf.condition(%14) %arg6 : i32
  } do {
  ^bb0(%arg6: i32):
    %13:2 = scf.while (%arg7 = %c0_i32) : (i32) -> (i32, i32) {
      %15 = affine.load %10[0] : memref<1xi32>
      %16 = arith.cmpi slt, %arg7, %15 : i32
      scf.condition(%16) %15, %arg7 : i32, i32
    } do {
    ^bb0(%arg7: i32, %arg8: i32):
      %15 = arith.muli %arg6, %arg7 : i32
      %16 = arith.addi %arg8, %15 : i32
      %17 = arith.muli %8, %arg7 : i32
      %18 = affine.load %9[0] : memref<1xi32>
      %19 = arith.muli %17, %18 : i32
      %20 = arith.addi %16, %19 : i32
      %21 = arith.index_cast %20 : i32 to index
      %22 = arith.muli %11, %arg7 : i32
      %23 = arith.muli %22, %18 : i32
      %24 = arith.addi %16, %23 : i32
      %25 = arith.index_cast %24 : i32 to index
      %26 = arith.addi %25, %c0 : index
      %27 = memref.load %arg0[%26] : memref<?xf32>
      %28 = arith.addi %21, %c0 : index
      memref.store %27, %arg2[%28] : memref<?xf32>
      %29 = arith.addi %arg8, %c1_i32 : i32
      scf.yield %29 : i32
    }
    %14 = arith.addi %arg6, %c1_i32 : i32
    scf.yield %14 : i32
  }
  scf.yield
 with val:<overwritten>
 attempting to promote mlir-asm-printer: Verifying operation: builtin.module
%10 = memref.get_global @im : memref<1xi32>

//===-------------------------------------------===//
Processing operation : 'func.return'(0x7fbd9800c610) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x7fbd9b105a30) {

  * Pattern AlwaysAllocaScopeHoister<mlir::scf::ForOp> : 'scf.for -> ()' {
Trying to match "AlwaysAllocaScopeHoister<mlir::scf::ForOp>"
"AlwaysAllocaScopeHoister<mlir::scf::ForOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InductiveVarRemoval : 'scf.for -> ()' {
Trying to match "InductiveVarRemoval"
"InductiveVarRemoval" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::ForOpIterArgsFolder"
"(anonymous namespace)::ForOpIterArgsFolder" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::SimplifyTrivialLoops"
"(anonymous namespace)::SimplifyTrivialLoops" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::LastTensorLoadCanonicalization"
"(anonymous namespace)::LastTensorLoadCanonicalization" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::ForOpTensorCastFolder"
"(anonymous namespace)::ForOpTensorCastFolder" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b106420) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b106870) {

  * Pattern (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock"
"(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveLoopInvariantValueYielded : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantValueYielded"
"(anonymous namespace)::RemoveLoopInvariantValueYielded" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileConditionTruth : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileConditionTruth"
"(anonymous namespace)::WhileConditionTruth" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileCmpCond : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileCmpCond"
"(anonymous namespace)::WhileCmpCond" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileUnusedResult : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileUnusedResult"
"(anonymous namespace)::WhileUnusedResult" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1056d0) {
  "scf.yield"(%20) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %20 = "arith.addi"(%arg6, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b306c90) {

  * Pattern (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock"
"(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveLoopInvariantValueYielded : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantValueYielded"
"(anonymous namespace)::RemoveLoopInvariantValueYielded" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileConditionTruth : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileConditionTruth"
"(anonymous namespace)::WhileConditionTruth" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileCmpCond : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileCmpCond"
"(anonymous namespace)::WhileCmpCond" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileUnusedResult : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileUnusedResult"
"(anonymous namespace)::WhileUnusedResult" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1061f0) {
  "scf.yield"(%35) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %35 = "arith.addi"(%arg8, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%33, %arg2, %34) : (f32, memref<?xf32>, index) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98165e60) {
  %34 = "arith.addi"(%27, %5) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %33 = "memref.load"(%arg0, %32) : (memref<?xf32>, index) -> f32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b0040e0) {
  %32 = "arith.addi"(%31, %5) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd98304bd0) {
  %31 = "arith.index_cast"(%30) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98304b30) {
  %30 = "arith.addi"(%22, %29) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304a90) {
  %29 = "arith.muli"(%28, %24) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %28 = "arith.muli"(%17, %arg7) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9816cb40) {
  %27 = "arith.index_cast"(%26) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816caa0) {
  %26 = "arith.addi"(%22, %25) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816ca00) {
  %25 = "arith.muli"(%23, %24) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104ce0) {
  %24 = "affine.load"(%15) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %23 = "arith.muli"(%14, %arg7) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %22 = "arith.addi"(%arg8, %21) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %21 = "arith.muli"(%arg6, %arg7) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b306b60) {
  "scf.condition"(%22, %21, %arg7) : (i1, i32, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %22 = "arith.cmpi"(%arg7, %21) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104b90) {
  %21 = "affine.load"(%16) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b1044b0) {
  "scf.condition"(%20, %arg6) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %20 = "arith.cmpi"(%arg6, %19) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104c10) {
  %19 = "affine.load"(%15) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b004270) {
  %17 = "arith.addi"(%14, %3) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9816b600) {
  %16 = "memref.get_global"() {name = @im} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd98169a20) {
  %15 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9b105c30) {
  %14 = "arith.index_cast"(%13) : (index) -> i32


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b105750) {
  %13 = "arith.addi"(%12, %11) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9b104380) {
  %12 = "arith.index_cast"(%7) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9b1048d0) {
  %11 = "arith.muli"(%10, %2) : (index, index) -> index


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9b306e10) {
  %10 = "arith.subi"(%arg5, %0) : (index, index) -> index


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9800baa0) {
  %9 = "arith.index_cast"(%8) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800a840) {
  %8 = "arith.addi"(%7, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104d70) {
  %7 = "affine.load"(%6) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd981673f0) {
  %6 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9816cc60) {
  %5 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98167e90) {
  %4 = "arith.constant"() {value = 0 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b1054b0) {
  %3 = "arith.constant"() {value = -1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98009280) {
  %2 = "arith.constant"() {value = -1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98304580) {
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b306d40) {
  %0 = "arith.constant"() {value = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x7fbd9800c610) {
  "func.return"() : () -> ()


  * Pattern ReturnSq : 'func.return -> ()' {
Trying to match "ReturnSq"
"ReturnSq" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x7fbd9b105a30) {

  * Pattern PropagateInLoopBody : 'scf.for -> ()' {
Trying to match "PropagateInLoopBody"
"PropagateInLoopBody" result 0
  } -> failure : pattern failed to match

  * Pattern ForOpInductionReplacement : 'scf.for -> ()' {
Trying to match "ForOpInductionReplacement"
"ForOpInductionReplacement" result 0
  } -> failure : pattern failed to match

  * Pattern RemoveUnusedArgs : 'scf.for -> ()' {
Trying to match "RemoveUnusedArgs"
"RemoveUnusedArgs" result 0
  } -> failure : pattern failed to match

  * Pattern ReplaceRedundantArgs : 'scf.for -> ()' {
Trying to match "ReplaceRedundantArgs"
"ReplaceRedundantArgs" result 0
  } -> failure : pattern failed to match

  * Pattern ForBreakAddUpgrade : 'scf.for -> ()' {
Trying to match "ForBreakAddUpgrade"
"ForBreakAddUpgrade" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b106420) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b106870) {

  * Pattern MoveWhileToFor : 'scf.while -> ()' {
Trying to match "MoveWhileToFor"
"MoveWhileToFor" result 0
  } -> failure : pattern failed to match

  * Pattern RemoveWhileSelect : 'scf.while -> ()' {
Trying to match "RemoveWhileSelect"
"RemoveWhileSelect" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown : 'scf.while -> ()' {
Trying to match "MoveWhileDown"
"MoveWhileDown" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown2 : 'scf.while -> ()' {
Trying to match "MoveWhileDown2"
"MoveWhileDown2" result 0
  } -> failure : pattern failed to match

  * Pattern WhileShiftToInduction : 'scf.while -> ()' {
Trying to match "WhileShiftToInduction"
"WhileShiftToInduction" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileAndDown : 'scf.while -> ()' {
Trying to match "MoveWhileAndDown"
"MoveWhileAndDown" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown3 : 'scf.while -> ()' {
Trying to match "MoveWhileDown3"
"MoveWhileDown3" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileInvariantIfResult : 'scf.while -> ()' {
Trying to match "MoveWhileInvariantIfResult"
"MoveWhileInvariantIfResult" result 0
  } -> failure : pattern failed to match

  * Pattern WhileLogicalNegation : 'scf.while -> ()' {
Trying to match "WhileLogicalNegation"
"WhileLogicalNegation" result 0
  } -> failure : pattern failed to match

  * Pattern WhileCmpOffset : 'scf.while -> ()' {
Trying to match "WhileCmpOffset"
"WhileCmpOffset" result 0
  } -> failure : pattern failed to match

  * Pattern WhileLICM : 'scf.while -> ()' {
Trying to match "WhileLICM"
"WhileLICM" result 0
  } -> failure : pattern failed to match

  * Pattern RemoveUnusedCondVar : 'scf.while -> ()' {
Trying to match "RemoveUnusedCondVar"
"RemoveUnusedCondVar" result 0
  } -> failure : pattern failed to match

  * Pattern MoveSideEffectFreeWhile : 'scf.while -> ()' {
Trying to match "MoveSideEffectFreeWhile"
"MoveSideEffectFreeWhile" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1056d0) {
  "scf.yield"(%20) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %20 = "arith.addi"(%arg6, %1) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b306c90) {

  * Pattern MoveWhileToFor : 'scf.while -> ()' {
Trying to match "MoveWhileToFor"
"MoveWhileToFor" result 0
  } -> failure : pattern failed to match

  * Pattern RemoveWhileSelect : 'scf.while -> ()' {
Trying to match "RemoveWhileSelect"
"RemoveWhileSelect" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown : 'scf.while -> ()' {
Trying to match "MoveWhileDown"
"MoveWhileDown" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown2 : 'scf.while -> ()' {
Trying to match "MoveWhileDown2"
"MoveWhileDown2" result 0
  } -> failure : pattern failed to match

  * Pattern WhileShiftToInduction : 'scf.while -> ()' {
Trying to match "WhileShiftToInduction"
"WhileShiftToInduction" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileAndDown : 'scf.while -> ()' {
Trying to match "MoveWhileAndDown"
"MoveWhileAndDown" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileDown3 : 'scf.while -> ()' {
Trying to match "MoveWhileDown3"
"MoveWhileDown3" result 0
  } -> failure : pattern failed to match

  * Pattern MoveWhileInvariantIfResult : 'scf.while -> ()' {
Trying to match "MoveWhileInvariantIfResult"
"MoveWhileInvariantIfResult" result 0
  } -> failure : pattern failed to match

  * Pattern WhileLogicalNegation : 'scf.while -> ()' {
Trying to match "WhileLogicalNegation"
"WhileLogicalNegation" result 0
  } -> failure : pattern failed to match

  * Pattern WhileCmpOffset : 'scf.while -> ()' {
Trying to match "WhileCmpOffset"
"WhileCmpOffset" result 0
  } -> failure : pattern failed to match

  * Pattern WhileLICM : 'scf.while -> ()' {
Trying to match "WhileLICM"
"WhileLICM" result 0
  } -> failure : pattern failed to match

  * Pattern RemoveUnusedCondVar : 'scf.while -> ()' {
Trying to match "RemoveUnusedCondVar"
"RemoveUnusedCondVar" result 0
  } -> failure : pattern failed to match

  * Pattern MoveSideEffectFreeWhile : 'scf.while -> ()' {
Trying to match "MoveSideEffectFreeWhile"
"MoveSideEffectFreeWhile" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1061f0) {
  "scf.yield"(%35) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %35 = "arith.addi"(%arg8, %1) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%33, %arg2, %34) : (f32, memref<?xf32>, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98165e60) {
  %34 = "arith.addi"(%27, %5) : (index, index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %33 = "memref.load"(%arg0, %32) : (memref<?xf32>, index) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b0040e0) {
  %32 = "arith.addi"(%31, %5) : (index, index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd98304bd0) {
  %31 = "arith.index_cast"(%30) : (i32) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98304b30) {
  %30 = "arith.addi"(%22, %29) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304a90) {
  %29 = "arith.muli"(%28, %24) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %28 = "arith.muli"(%17, %arg7) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9816cb40) {
  %27 = "arith.index_cast"(%26) : (i32) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816caa0) {
  %26 = "arith.addi"(%22, %25) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816ca00) {
  %25 = "arith.muli"(%23, %24) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104ce0) {
  %24 = "affine.load"(%15) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %23 = "arith.muli"(%14, %arg7) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %22 = "arith.addi"(%arg8, %21) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %21 = "arith.muli"(%arg6, %arg7) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b306b60) {
  "scf.condition"(%22, %21, %arg7) : (i1, i32, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %22 = "arith.cmpi"(%arg7, %21) {predicate = 2 : i64} : (i32, i32) -> i1

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104b90) {
  %21 = "affine.load"(%16) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b1044b0) {
  "scf.condition"(%20, %arg6) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %20 = "arith.cmpi"(%arg6, %19) {predicate = 2 : i64} : (i32, i32) -> i1

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104c10) {
  %19 = "affine.load"(%15) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b004270) {
  %17 = "arith.addi"(%14, %3) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9816b600) {
  %16 = "memref.get_global"() {name = @im} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd98169a20) {
  %15 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9b105c30) {
  %14 = "arith.index_cast"(%13) : (index) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b105750) {
  %13 = "arith.addi"(%12, %11) : (index, index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9b104380) {
  %12 = "arith.index_cast"(%7) : (i32) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9b1048d0) {
  %11 = "arith.muli"(%10, %2) : (index, index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9b306e10) {
  %10 = "arith.subi"(%arg5, %0) : (index, index) -> index


  * Pattern SubToAdd : 'arith.subi -> ()' {
Trying to match "SubToAdd"
"SubToAdd" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9800baa0) {
  %9 = "arith.index_cast"(%8) : (i32) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800a840) {
  %8 = "arith.addi"(%7, %1) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104d70) {
  %7 = "affine.load"(%6) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd981673f0) {
  %6 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9816cc60) {
  %5 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98167e90) {
  %4 = "arith.constant"() {value = 0 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b1054b0) {
  %3 = "arith.constant"() {value = -1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98009280) {
  %2 = "arith.constant"() {value = -1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98304580) {
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b306d40) {
  %0 = "arith.constant"() {value = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x7fbd9800c610) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x7fbd9b105a30) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b106420) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b106870) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1056d0) {
  "scf.yield"(%20) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %20 = "arith.addi"(%arg6, %1) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b306c90) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1061f0) {
  "scf.yield"(%35) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %35 = "arith.addi"(%arg8, %1) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%33, %arg2, %34) : (f32, memref<?xf32>, index) -> ()


  * Pattern MoveStoreToAffine : 'memref.store -> ()' {
Trying to match "MoveStoreToAffine"
illegal isValidIndex: <block argument> of type 'i32' at index: 1
"MoveStoreToAffine" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98165e60) {
  %34 = "arith.addi"(%27, %5) : (index, index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %33 = "memref.load"(%arg0, %32) : (memref<?xf32>, index) -> f32


  * Pattern MoveLoadToAffine : 'memref.load -> ()' {
Trying to match "MoveLoadToAffine"
illegal isValidIndex: <block argument> of type 'i32' at index: 1
"MoveLoadToAffine" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b0040e0) {
  %32 = "arith.addi"(%31, %5) : (index, index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd98304bd0) {
  %31 = "arith.index_cast"(%30) : (i32) -> index


  * Pattern CanonicalizeIndexCast : 'arith.index_cast -> ()' {
Trying to match "CanonicalizeIndexCast"
"CanonicalizeIndexCast" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98304b30) {
  %30 = "arith.addi"(%22, %29) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304a90) {
  %29 = "arith.muli"(%28, %24) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %28 = "arith.muli"(%17, %arg7) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9816cb40) {
  %27 = "arith.index_cast"(%26) : (i32) -> index


  * Pattern CanonicalizeIndexCast : 'arith.index_cast -> ()' {
Trying to match "CanonicalizeIndexCast"
"CanonicalizeIndexCast" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816caa0) {
  %26 = "arith.addi"(%22, %25) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816ca00) {
  %25 = "arith.muli"(%23, %24) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104ce0) {
  %24 = "affine.load"(%15) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern AffineFixup<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "AffineFixup<mlir::AffineLoadOp>"
"AffineFixup<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %23 = "arith.muli"(%14, %arg7) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %22 = "arith.addi"(%arg8, %21) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %21 = "arith.muli"(%arg6, %arg7) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b306b60) {
  "scf.condition"(%22, %21, %arg7) : (i1, i32, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %22 = "arith.cmpi"(%arg7, %21) {predicate = 2 : i64} : (i32, i32) -> i1

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104b90) {
  %21 = "affine.load"(%16) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern AffineFixup<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "AffineFixup<mlir::AffineLoadOp>"
"AffineFixup<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b1044b0) {
  "scf.condition"(%20, %arg6) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %20 = "arith.cmpi"(%arg6, %19) {predicate = 2 : i64} : (i32, i32) -> i1

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104c10) {
  %19 = "affine.load"(%15) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern AffineFixup<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "AffineFixup<mlir::AffineLoadOp>"
"AffineFixup<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b004270) {
  %17 = "arith.addi"(%14, %3) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9816b600) {
  %16 = "memref.get_global"() {name = @im} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd98169a20) {
  %15 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9b105c30) {
  %14 = "arith.index_cast"(%13) : (index) -> i32


  * Pattern CanonicalizeIndexCast : 'arith.index_cast -> ()' {
Trying to match "CanonicalizeIndexCast"
"CanonicalizeIndexCast" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b105750) {
  %13 = "arith.addi"(%12, %11) : (index, index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9b104380) {
  %12 = "arith.index_cast"(%7) : (i32) -> index


  * Pattern CanonicalizeIndexCast : 'arith.index_cast -> ()' {
Trying to match "CanonicalizeIndexCast"
"CanonicalizeIndexCast" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9b1048d0) {
  %11 = "arith.muli"(%10, %2) : (index, index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9b306e10) {
  %10 = "arith.subi"(%arg5, %0) : (index, index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9800baa0) {
  %9 = "arith.index_cast"(%8) : (i32) -> index


  * Pattern CanonicalizeIndexCast : 'arith.index_cast -> ()' {
Trying to match "CanonicalizeIndexCast"
"CanonicalizeIndexCast" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800a840) {
  %8 = "arith.addi"(%7, %1) : (i32, i32) -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104d70) {
  %7 = "affine.load"(%6) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern AffineFixup<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "AffineFixup<mlir::AffineLoadOp>"
"AffineFixup<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd981673f0) {
  %6 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9816cc60) {
  %5 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98167e90) {
  %4 = "arith.constant"() {value = 0 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b1054b0) {
  %3 = "arith.constant"() {value = -1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98009280) {
  %2 = "arith.constant"() {value = -1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98304580) {
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b306d40) {
  %0 = "arith.constant"() {value = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x7fbd9800c610) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x7fbd9b105a30) {

  * Pattern AlwaysAllocaScopeHoister<mlir::scf::ForOp> : 'scf.for -> ()' {
Trying to match "AlwaysAllocaScopeHoister<mlir::scf::ForOp>"
"AlwaysAllocaScopeHoister<mlir::scf::ForOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InductiveVarRemoval : 'scf.for -> ()' {
Trying to match "InductiveVarRemoval"
"InductiveVarRemoval" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::ForOpIterArgsFolder"
"(anonymous namespace)::ForOpIterArgsFolder" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::SimplifyTrivialLoops"
"(anonymous namespace)::SimplifyTrivialLoops" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::LastTensorLoadCanonicalization"
"(anonymous namespace)::LastTensorLoadCanonicalization" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::ForOpTensorCastFolder"
"(anonymous namespace)::ForOpTensorCastFolder" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b106420) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b106870) {

  * Pattern (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock"
"(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveLoopInvariantValueYielded : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantValueYielded"
"(anonymous namespace)::RemoveLoopInvariantValueYielded" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileConditionTruth : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileConditionTruth"
"(anonymous namespace)::WhileConditionTruth" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileCmpCond : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileCmpCond"
"(anonymous namespace)::WhileCmpCond" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileUnusedResult : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileUnusedResult"
"(anonymous namespace)::WhileUnusedResult" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1056d0) {
  "scf.yield"(%20) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %20 = "arith.addi"(%arg6, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b306c90) {

  * Pattern (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock"
"(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveLoopInvariantValueYielded : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantValueYielded"
"(anonymous namespace)::RemoveLoopInvariantValueYielded" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileConditionTruth : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileConditionTruth"
"(anonymous namespace)::WhileConditionTruth" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileCmpCond : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileCmpCond"
"(anonymous namespace)::WhileCmpCond" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileUnusedResult : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileUnusedResult"
"(anonymous namespace)::WhileUnusedResult" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1061f0) {
  "scf.yield"(%35) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %35 = "arith.addi"(%arg8, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%33, %arg2, %34) : (f32, memref<?xf32>, index) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98165e60) {
  %34 = "arith.addi"(%27, %5) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %33 = "memref.load"(%arg0, %32) : (memref<?xf32>, index) -> f32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b0040e0) {
  %32 = "arith.addi"(%31, %5) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd98304bd0) {
  %31 = "arith.index_cast"(%30) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98304b30) {
  %30 = "arith.addi"(%22, %29) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304a90) {
  %29 = "arith.muli"(%28, %24) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %28 = "arith.muli"(%17, %arg7) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9816cb40) {
  %27 = "arith.index_cast"(%26) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816caa0) {
  %26 = "arith.addi"(%22, %25) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816ca00) {
  %25 = "arith.muli"(%23, %24) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104ce0) {
  %24 = "affine.load"(%15) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %23 = "arith.muli"(%14, %arg7) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %22 = "arith.addi"(%arg8, %21) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %21 = "arith.muli"(%arg6, %arg7) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b306b60) {
  "scf.condition"(%22, %21, %arg7) : (i1, i32, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %22 = "arith.cmpi"(%arg7, %21) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104b90) {
  %21 = "affine.load"(%16) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b1044b0) {
  "scf.condition"(%20, %arg6) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %20 = "arith.cmpi"(%arg6, %19) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104c10) {
  %19 = "affine.load"(%15) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b004270) {
  %17 = "arith.addi"(%14, %3) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9816b600) {
  %16 = "memref.get_global"() {name = @im} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd98169a20) {
  %15 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9b105c30) {
  %14 = "arith.index_cast"(%13) : (index) -> i32


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b105750) {
  %13 = "arith.addi"(%12, %11) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9b104380) {
  %12 = "arith.index_cast"(%7) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9b1048d0) {
  %11 = "arith.muli"(%10, %2) : (index, index) -> index


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9b306e10) {
  %10 = "arith.subi"(%arg5, %0) : (index, index) -> index


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9800baa0) {
  %9 = "arith.index_cast"(%8) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800a840) {
  %8 = "arith.addi"(%7, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104d70) {
  %7 = "affine.load"(%6) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd981673f0) {
  %6 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9816cc60) {
  %5 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98167e90) {
  %4 = "arith.constant"() {value = 0 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b1054b0) {
  %3 = "arith.constant"() {value = -1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98009280) {
  %2 = "arith.constant"() {value = -1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98304580) {
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b306d40) {
  %0 = "arith.constant"() {value = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

Original loop:
mlir-asm-printer: Verifying operation: builtin.module
scf.for %arg5 = %c1 to %3 step %c1 {
  %4 = arith.subi %arg5, %c1 : index
  %5 = arith.muli %4, %c-1 : index
  %6 = arith.index_cast %1 : i32 to index
  %7 = arith.addi %6, %5 : index
  %8 = arith.index_cast %7 : index to i32
  %9 = memref.get_global @jm : memref<1xi32>
  %10 = memref.get_global @im : memref<1xi32>
  %11 = arith.addi %8, %c-1_i32 : i32
  %12 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
    %13 = affine.load %9[0] : memref<1xi32>
    %14 = arith.cmpi slt, %arg6, %13 : i32
    scf.condition(%14) %arg6 : i32
  } do {
  ^bb0(%arg6: i32):
    %13:2 = scf.while (%arg7 = %c0_i32) : (i32) -> (i32, i32) {
      %15 = affine.load %10[0] : memref<1xi32>
      %16 = arith.cmpi slt, %arg7, %15 : i32
      scf.condition(%16) %15, %arg7 : i32, i32
    } do {
    ^bb0(%arg7: i32, %arg8: i32):
      %15 = arith.muli %arg6, %arg7 : i32
      %16 = arith.addi %arg8, %15 : i32
      %17 = arith.muli %8, %arg7 : i32
      %18 = affine.load %9[0] : memref<1xi32>
      %19 = arith.muli %17, %18 : i32
      %20 = arith.addi %16, %19 : i32
      %21 = arith.index_cast %20 : i32 to index
      %22 = arith.muli %11, %arg7 : i32
      %23 = arith.muli %22, %18 : i32
      %24 = arith.addi %16, %23 : i32
      %25 = arith.index_cast %24 : i32 to index
      %26 = arith.addi %25, %c0 : index
      %27 = memref.load %arg0[%26] : memref<?xf32>
      %28 = arith.addi %21, %c0 : index
      memref.store %27, %arg2[%28] : memref<?xf32>
      %29 = arith.addi %arg8, %c1_i32 : i32
      scf.yield %29 : i32
    }
    %14 = arith.addi %arg6, %c1_i32 : i32
    scf.yield %14 : i32
  }
}Original loop:
mlir-asm-printer: Verifying operation: func.func
scf.for %arg5 = %c1 to %3 step %c1 {
  %4 = arith.subi %arg5, %c1 : index
  %5 = arith.muli %4, %c-1 : index
  %6 = arith.index_cast %1 : i32 to index
  %7 = arith.addi %6, %5 : index
  %8 = arith.index_cast %7 : index to i32
  %9 = memref.get_global @jm : memref<1xi32>
  %10 = memref.get_global @im : memref<1xi32>
  %11 = arith.addi %8, %c-1_i32 : i32
  %12 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
    %13 = affine.load %9[0] : memref<1xi32>
    %14 = arith.cmpi slt, %arg6, %13 : i32
    scf.condition(%14) %arg6 : i32
  } do {
  ^bb0(%arg6: i32):
    %13:2 = scf.while (%arg7 = %c0_i32) : (i32) -> (i32, i32) {
      %15 = affine.load %10[0] : memref<1xi32>
      %16 = arith.cmpi slt, %arg7, %15 : i32
      scf.condition(%16) %15, %arg7 : i32, i32
    } do {
    ^bb0(%arg7: i32, %arg8: i32):
      %15 = arith.muli %arg6, %arg7 : i32
      %16 = arith.addi %arg8, %15 : i32
      %17 = arith.muli %8, %arg7 : i32
      %18 = affine.load %9[0] : memref<1xi32>
      %19 = arith.muli %17, %18 : i32
      %20 = arith.addi %16, %19 : i32
      %21 = arith.index_cast %20 : i32 to index
      %22 = arith.muli %11, %arg7 : i32
      %23 = arith.muli %22, %18 : i32
      %24 = arith.addi %16, %23 : i32
      %25 = arith.index_cast %24 : i32 to index
      %26 = arith.addi %25, %c0 : index
      %27 = memref.load %arg0[%26] : memref<?xf32>
      %28 = arith.addi %21, %c0 : index
      memref.store %27, %arg2[%28] : memref<?xf32>
      %29 = arith.addi %arg8, %c1_i32 : i32
      scf.yield %29 : i32
    }
    %14 = arith.addi %arg6, %c1_i32 : i32
    scf.yield %14 : i32
  }
}
Checking op: mlir-asm-printer: Verifying operation: func.func
%4 = arith.subi %arg5, %c1 : index
Checking op: mlir-asm-printer: Verifying operation: func.func
%5 = arith.muli %4, %c-1 : index
Checking op: mlir-asm-printer: Verifying operation: func.func
%6 = arith.index_cast %1 : i32 to index
Moving loop-invariant op: mlir-asm-printer: Verifying operation: func.func
%6 = arith.index_cast %1 : i32 to index
Checking op: mlir-asm-printer: Verifying operation: func.func
%7 = arith.addi %4, %6 : index
Checking op: mlir-asm-printer: Verifying operation: func.func
%8 = arith.index_cast %7 : index to i32
Checking op: mlir-asm-printer: Verifying operation: func.func
%9 = memref.get_global @jm : memref<1xi32>
Moving loop-invariant op: mlir-asm-printer: Verifying operation: func.func
%9 = memref.get_global @jm : memref<1xi32>
Checking op: mlir-asm-printer: Verifying operation: func.func
%10 = memref.get_global @im : memref<1xi32>
Moving loop-invariant op: mlir-asm-printer: Verifying operation: func.func
%10 = memref.get_global @im : memref<1xi32>
Checking op: mlir-asm-printer: Verifying operation: func.func
%11 = arith.addi %10, %c-1_i32 : i32
Checking op: mlir-asm-printer: Verifying operation: func.func
%12 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
  %13 = affine.load %5[0] : memref<1xi32>
  %14 = arith.cmpi slt, %arg6, %13 : i32
  scf.condition(%14) %arg6 : i32
} do {
^bb0(%arg6: i32):
  %13:2 = scf.while (%arg7 = %c0_i32) : (i32) -> (i32, i32) {
    %15 = affine.load %6[0] : memref<1xi32>
    %16 = arith.cmpi slt, %arg7, %15 : i32
    scf.condition(%16) %15, %arg7 : i32, i32
  } do {
  ^bb0(%arg7: i32, %arg8: i32):
    %15 = arith.muli %arg6, %arg7 : i32
    %16 = arith.addi %arg8, %15 : i32
    %17 = arith.muli %10, %arg7 : i32
    %18 = affine.load %5[0] : memref<1xi32>
    %19 = arith.muli %17, %18 : i32
    %20 = arith.addi %16, %19 : i32
    %21 = arith.index_cast %20 : i32 to index
    %22 = arith.muli %11, %arg7 : i32
    %23 = arith.muli %22, %18 : i32
    %24 = arith.addi %16, %23 : i32
    %25 = arith.index_cast %24 : i32 to index
    %26 = arith.addi %25, %c0 : index
    %27 = memref.load %arg0[%26] : memref<?xf32>
    %28 = arith.addi %21, %c0 : index
    memref.store %27, %arg2[%28] : memref<?xf32>
    %29 = arith.addi %arg8, %c1_i32 : i32
    scf.yield %29 : i32
  }
  %14 = arith.addi %arg6, %c1_i32 : i32
  scf.yield %14 : i32
}
Checking op: mlir-asm-printer: Verifying operation: func.func
scf.yield
Checking op: mlir-asm-printer: Verifying operation: func.func
%9 = arith.addi %4, %8 : index
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%7 = arith.subi %arg5, %c1 : index
 - cannot hoist due to operand: <block argument> of type 'index' at index: 0
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%8 = arith.muli %7, %c-1 : index
 - cannot hoist due to operand: mlir-asm-printer: Verifying operation: builtin.module
%7 = arith.subi %arg5, %c1 : index
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%9 = arith.addi %4, %8 : index
 - cannot hoist due to operand: mlir-asm-printer: Verifying operation: builtin.module
%8 = arith.muli %7, %c-1 : index
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%10 = arith.index_cast %9 : index to i32
 - cannot hoist due to operand: mlir-asm-printer: Verifying operation: builtin.module
%9 = arith.addi %4, %8 : index
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%11 = arith.addi %10, %c-1_i32 : i32
 - cannot hoist due to operand: mlir-asm-printer: Verifying operation: builtin.module
%10 = arith.index_cast %9 : index to i32
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%12 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
  %13 = affine.load %5[0] : memref<1xi32>
  %14 = arith.cmpi slt, %arg6, %13 : i32
  scf.condition(%14) %arg6 : i32
} do {
^bb0(%arg6: i32):
  %13:2 = scf.while (%arg7 = %c0_i32) : (i32) -> (i32, i32) {
    %15 = affine.load %6[0] : memref<1xi32>
    %16 = arith.cmpi slt, %arg7, %15 : i32
    scf.condition(%16) %15, %arg7 : i32, i32
  } do {
  ^bb0(%arg7: i32, %arg8: i32):
    %15 = arith.muli %arg6, %arg7 : i32
    %16 = arith.addi %arg8, %15 : i32
    %17 = arith.muli %10, %arg7 : i32
    %18 = affine.load %5[0] : memref<1xi32>
    %19 = arith.muli %17, %18 : i32
    %20 = arith.addi %16, %19 : i32
    %21 = arith.index_cast %20 : i32 to index
    %22 = arith.muli %11, %arg7 : i32
    %23 = arith.muli %22, %18 : i32
    %24 = arith.addi %16, %23 : i32
    %25 = arith.index_cast %24 : i32 to index
    %26 = arith.addi %25, %c0 : index
    %27 = memref.load %arg0[%26] : memref<?xf32>
    %28 = arith.addi %21, %c0 : index
    memref.store %27, %arg2[%28] : memref<?xf32>
    %29 = arith.addi %arg8, %c1_i32 : i32
    scf.yield %29 : i32
  }
  %14 = arith.addi %arg6, %c1_i32 : i32
  scf.yield %14 : i32
}
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%13 = affine.load %5[0] : memref<1xi32>
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffects::Free)
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%14 = arith.cmpi slt, %arg6, %13 : i32
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
scf.condition(%14) %arg6 : i32
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%13:2 = scf.while (%arg7 = %c0_i32) : (i32) -> (i32, i32) {
  %15 = affine.load %6[0] : memref<1xi32>
  %16 = arith.cmpi slt, %arg7, %15 : i32
  scf.condition(%16) %15, %arg7 : i32, i32
} do {
^bb0(%arg7: i32, %arg8: i32):
  %15 = arith.muli %arg6, %arg7 : i32
  %16 = arith.addi %arg8, %15 : i32
  %17 = arith.muli %10, %arg7 : i32
  %18 = affine.load %5[0] : memref<1xi32>
  %19 = arith.muli %17, %18 : i32
  %20 = arith.addi %16, %19 : i32
  %21 = arith.index_cast %20 : i32 to index
  %22 = arith.muli %11, %arg7 : i32
  %23 = arith.muli %22, %18 : i32
  %24 = arith.addi %16, %23 : i32
  %25 = arith.index_cast %24 : i32 to index
  %26 = arith.addi %25, %c0 : index
  %27 = memref.load %arg0[%26] : memref<?xf32>
  %28 = arith.addi %21, %c0 : index
  memref.store %27, %arg2[%28] : memref<?xf32>
  %29 = arith.addi %arg8, %c1_i32 : i32
  scf.yield %29 : i32
}
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%15 = affine.load %6[0] : memref<1xi32>
 - cannot hoist due to read->write conflict: mlir-asm-printer: Verifying operation: func.func
memref.store %27, %arg2[%28] : memref<?xf32>
 - cannot hoist due to inner: mlir-asm-printer: Verifying operation: func.func
%15 = affine.load %6[0] : memref<1xi32>
 - cannot hoist due to inner: mlir-asm-printer: Verifying operation: func.func
%13:2 = scf.while (%arg7 = %c0_i32) : (i32) -> (i32, i32) {
  %15 = affine.load %6[0] : memref<1xi32>
  %16 = arith.cmpi slt, %arg7, %15 : i32
  scf.condition(%16) %15, %arg7 : i32, i32
} do {
^bb0(%arg7: i32, %arg8: i32):
  %15 = arith.muli %arg6, %arg7 : i32
  %16 = arith.addi %arg8, %15 : i32
  %17 = arith.muli %10, %arg7 : i32
  %18 = affine.load %5[0] : memref<1xi32>
  %19 = arith.muli %17, %18 : i32
  %20 = arith.addi %16, %19 : i32
  %21 = arith.index_cast %20 : i32 to index
  %22 = arith.muli %11, %arg7 : i32
  %23 = arith.muli %22, %18 : i32
  %24 = arith.addi %16, %23 : i32
  %25 = arith.index_cast %24 : i32 to index
  %26 = arith.addi %25, %c0 : index
  %27 = memref.load %arg0[%26] : memref<?xf32>
  %28 = arith.addi %21, %c0 : index
  memref.store %27, %arg2[%28] : memref<?xf32>
  %29 = arith.addi %arg8, %c1_i32 : i32
  scf.yield %29 : i32
}
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%14 = arith.cmpi slt, %arg6, %13 : i32
 - cannot hoist due to operand: <block argument> of type 'i32' at index: 0
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%16 = arith.cmpi slt, %arg7, %15 : i32
 - cannot hoist due to operand: <block argument> of type 'i32' at index: 0
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%15 = arith.muli %arg6, %arg7 : i32
 - cannot hoist due to operand: <block argument> of type 'i32' at index: 0
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%16 = arith.addi %arg8, %15 : i32
 - cannot hoist due to operand: <block argument> of type 'i32' at index: 1
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%17 = arith.muli %10, %arg7 : i32
 - cannot hoist due to operand: mlir-asm-printer: Verifying operation: builtin.module
%10 = arith.index_cast %9 : index to i32
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%19 = arith.muli %17, %18 : i32
 - cannot hoist due to operand: mlir-asm-printer: Verifying operation: builtin.module
%17 = arith.muli %10, %arg7 : i32
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%20 = arith.addi %16, %19 : i32
 - cannot hoist due to operand: mlir-asm-printer: Verifying operation: builtin.module
%16 = arith.addi %arg8, %15 : i32
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%21 = arith.index_cast %20 : i32 to index
 - cannot hoist due to operand: mlir-asm-printer: Verifying operation: builtin.module
%20 = arith.addi %16, %19 : i32
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%22 = arith.muli %11, %arg7 : i32
 - cannot hoist due to operand: mlir-asm-printer: Verifying operation: builtin.module
%11 = arith.addi %10, %c-1_i32 : i32
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%23 = arith.muli %22, %18 : i32
 - cannot hoist due to operand: mlir-asm-printer: Verifying operation: builtin.module
%22 = arith.muli %11, %arg7 : i32
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%24 = arith.addi %16, %23 : i32
 - cannot hoist due to operand: mlir-asm-printer: Verifying operation: builtin.module
%16 = arith.addi %arg8, %15 : i32
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%25 = arith.index_cast %24 : i32 to index
 - cannot hoist due to operand: mlir-asm-printer: Verifying operation: builtin.module
%24 = arith.addi %16, %23 : i32
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%26 = arith.addi %25, %c0 : index
 - cannot hoist due to operand: mlir-asm-printer: Verifying operation: builtin.module
%25 = arith.index_cast %24 : i32 to index
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%28 = arith.addi %21, %c0 : index
 - cannot hoist due to operand: mlir-asm-printer: Verifying operation: builtin.module
%21 = arith.index_cast %20 : i32 to index
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%29 = arith.addi %arg8, %c1_i32 : i32
 - cannot hoist due to operand: <block argument> of type 'i32' at index: 1
Checking for parallel hoist: mlir-asm-printer: Verifying operation: func.func
%14 = arith.addi %arg6, %c1_i32 : i32
 - cannot hoist due to operand: <block argument> of type 'i32' at index: 0


Modified loop:
mlir-asm-printer: Verifying operation: builtin.module
scf.for %arg5 = %c1 to %3 step %c1 {
  %7 = arith.subi %arg5, %c1 : index
  %8 = arith.muli %7, %c-1 : index
  %9 = arith.addi %4, %8 : index
  %10 = arith.index_cast %9 : index to i32
  %11 = arith.addi %10, %c-1_i32 : i32
  %12 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
    %13 = affine.load %5[0] : memref<1xi32>
    %14 = arith.cmpi slt, %arg6, %13 : i32
    scf.condition(%14) %arg6 : i32
  } do {
  ^bb0(%arg6: i32):
    %13:2 = scf.while (%arg7 = %c0_i32) : (i32) -> (i32, i32) {
      %15 = affine.load %6[0] : memref<1xi32>
      %16 = arith.cmpi slt, %arg7, %15 : i32
      scf.condition(%16) %15, %arg7 : i32, i32
    } do {
    ^bb0(%arg7: i32, %arg8: i32):
      %15 = arith.muli %arg6, %arg7 : i32
      %16 = arith.addi %arg8, %15 : i32
      %17 = arith.muli %10, %arg7 : i32
      %18 = affine.load %5[0] : memref<1xi32>
      %19 = arith.muli %17, %18 : i32
      %20 = arith.addi %16, %19 : i32
      %21 = arith.index_cast %20 : i32 to index
      %22 = arith.muli %11, %arg7 : i32
      %23 = arith.muli %22, %18 : i32
      %24 = arith.addi %16, %23 : i32
      %25 = arith.index_cast %24 : i32 to index
      %26 = arith.addi %25, %c0 : index
      %27 = memref.load %arg0[%26] : memref<?xf32>
      %28 = arith.addi %21, %c0 : index
      memref.store %27, %arg2[%28] : memref<?xf32>
      %29 = arith.addi %arg8, %c1_i32 : i32
      scf.yield %29 : i32
    }
    %14 = arith.addi %arg6, %c1_i32 : i32
    scf.yield %14 : i32
  }
}
//===-------------------------------------------===//
Processing operation : 'func.return'(0x7fbd9800c610) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x7fbd9b105a30) {

  * Pattern AlwaysAllocaScopeHoister<mlir::scf::ForOp> : 'scf.for -> ()' {
Trying to match "AlwaysAllocaScopeHoister<mlir::scf::ForOp>"
"AlwaysAllocaScopeHoister<mlir::scf::ForOp>" result 0
  } -> failure : pattern failed to match

  * Pattern InductiveVarRemoval : 'scf.for -> ()' {
Trying to match "InductiveVarRemoval"
"InductiveVarRemoval" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::ForOpIterArgsFolder"
"(anonymous namespace)::ForOpIterArgsFolder" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::SimplifyTrivialLoops"
"(anonymous namespace)::SimplifyTrivialLoops" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::LastTensorLoadCanonicalization"
"(anonymous namespace)::LastTensorLoadCanonicalization" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::ForOpTensorCastFolder"
"(anonymous namespace)::ForOpTensorCastFolder" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b106420) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b106870) {

  * Pattern (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock"
"(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveLoopInvariantValueYielded : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantValueYielded"
"(anonymous namespace)::RemoveLoopInvariantValueYielded" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileConditionTruth : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileConditionTruth"
"(anonymous namespace)::WhileConditionTruth" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileCmpCond : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileCmpCond"
"(anonymous namespace)::WhileCmpCond" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileUnusedResult : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileUnusedResult"
"(anonymous namespace)::WhileUnusedResult" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1056d0) {
  "scf.yield"(%20) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800bb40) {
  %20 = "arith.addi"(%arg6, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.while'(0x7fbd9b306c90) {

  * Pattern (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock"
"(anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveLoopInvariantValueYielded : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::RemoveLoopInvariantValueYielded"
"(anonymous namespace)::RemoveLoopInvariantValueYielded" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileConditionTruth : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileConditionTruth"
"(anonymous namespace)::WhileConditionTruth" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileCmpCond : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileCmpCond"
"(anonymous namespace)::WhileCmpCond" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::WhileUnusedResult : 'scf.while -> ()' {
Trying to match "(anonymous namespace)::WhileUnusedResult"
"(anonymous namespace)::WhileUnusedResult" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x7fbd9b1061f0) {
  "scf.yield"(%35) : (i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd983054f0) {
  %35 = "arith.addi"(%arg8, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.store'(0x7fbd9816a410) {
  "memref.store"(%33, %arg2, %34) : (f32, memref<?xf32>, index) -> ()


  * Pattern MetaPointer2Memref<mlir::memref::StoreOp> : 'memref.store -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::StoreOp>"
"MetaPointer2Memref<mlir::memref::StoreOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98165e60) {
  %34 = "arith.addi"(%27, %5) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.load'(0x7fbd9b004180) {
  %33 = "memref.load"(%arg0, %32) : (memref<?xf32>, index) -> f32


  * Pattern LoadSelect<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "LoadSelect<mlir::memref::LoadOp>"
"LoadSelect<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::memref::LoadOp> : 'memref.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::memref::LoadOp>"
"MetaPointer2Memref<mlir::memref::LoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b0040e0) {
  %32 = "arith.addi"(%31, %5) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd98304bd0) {
  %31 = "arith.index_cast"(%30) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd98304b30) {
  %30 = "arith.addi"(%22, %29) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304a90) {
  %29 = "arith.muli"(%28, %24) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd98304830) {
  %28 = "arith.muli"(%17, %arg7) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9816cb40) {
  %27 = "arith.index_cast"(%26) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816caa0) {
  %26 = "arith.addi"(%22, %25) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::ConstantOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816ca00) {
  %25 = "arith.muli"(%23, %24) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104ce0) {
  %24 = "affine.load"(%11) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c7a0) {
  %23 = "arith.muli"(%16, %arg7) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9816c450) {
  %22 = "arith.addi"(%arg8, %21) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9816c3b0) {
  %21 = "arith.muli"(%arg6, %arg7) : (i32, i32) -> i32


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b306b60) {
  "scf.condition"(%22, %21, %arg7) : (i1, i32, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd9816b7c0) {
  %22 = "arith.cmpi"(%arg7, %21) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104b90) {
  %21 = "affine.load"(%12) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.condition'(0x7fbd9b1044b0) {
  "scf.condition"(%20, %arg6) : (i1, i32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.cmpi'(0x7fbd98169d10) {
  %20 = "arith.cmpi"(%arg6, %19) {predicate = 2 : i64} : (i32, i32) -> i1


  * Pattern (anonymous namespace)::CmpIExtSI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtSI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtSI" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CmpIExtUI : 'arith.cmpi -> (arith.cmpi)' {
Trying to match "(anonymous namespace)::CmpIExtUI"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::CmpIExtUI" result 0
  } -> failure : pattern failed to match

  * Pattern CmpProp : 'arith.cmpi -> ()' {
Trying to match "CmpProp"
"CmpProp" result 0
  } -> failure : pattern failed to match

  * Pattern UndefCmpProp : 'arith.cmpi -> ()' {
Trying to match "UndefCmpProp"
"UndefCmpProp" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104c10) {
  %19 = "affine.load"(%11) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b004270) {
  %17 = "arith.addi"(%16, %3) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9b105c30) {
  %16 = "arith.index_cast"(%15) : (index) -> i32


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9b105750) {
  %15 = "arith.addi"(%10, %14) : (index, index) -> index


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.muli'(0x7fbd9b1048d0) {
  %14 = "arith.muli"(%13, %2) : (index, index) -> index


  * Pattern MulDivMul : 'arith.muli -> ()' {
Trying to match "MulDivMul"
"MulDivMul" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.subi'(0x7fbd9b306e10) {
  %13 = "arith.subi"(%arg5, %0) : (index, index) -> index


  * Pattern (anonymous namespace)::SubIRHSAddConstant : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubIRHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSAddConstant : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSAddConstant"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubIRHSSubConstantLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubIRHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubIRHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantRHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantRHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubILHSSubConstantLHS : 'arith.subi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::SubILHSSubConstantLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubILHSSubConstantLHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubISubILHSRHSLHS : 'arith.subi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::SubISubILHSRHSLHS"
    ** Failure : There's no operation that defines operand 0 of castedOp0
"(anonymous namespace)::SubISubILHSRHSLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd9816b600) {
  %12 = "memref.get_global"() {name = @im} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd98169a20) {
  %11 = "memref.get_global"() {name = @jm} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9b104380) {
  %10 = "arith.index_cast"(%7) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.index_cast'(0x7fbd9800baa0) {
  %9 = "arith.index_cast"(%8) : (i32) -> index


  * Pattern (anonymous namespace)::IndexCastOfIndexCast : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOfIndexCast"
    ** Failure : castedOp1 is not ::mlir::arith::IndexCastOp type
"(anonymous namespace)::IndexCastOfIndexCast" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::IndexCastOfExtSI : 'arith.index_cast -> (arith.index_cast)' {
Trying to match "(anonymous namespace)::IndexCastOfExtSI"
    ** Failure : castedOp1 is not ::mlir::arith::ExtSIOp type
"(anonymous namespace)::IndexCastOfExtSI" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x7fbd9800a840) {
  %8 = "arith.addi"(%7, %1) : (i32, i32) -> i32


  * Pattern (anonymous namespace)::AddIAddConstant : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddIAddConstant"
    ** Failure : castedOp1 is not ::mlir::arith::AddIOp type
"(anonymous namespace)::AddIAddConstant" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantRHS : 'arith.addi -> (arith.addi, arith.constant)' {
Trying to match "(anonymous namespace)::AddISubConstantRHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantRHS" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::AddISubConstantLHS : 'arith.addi -> (arith.constant, arith.subi)' {
Trying to match "(anonymous namespace)::AddISubConstantLHS"
    ** Failure : castedOp1 is not ::mlir::arith::SubIOp type
"(anonymous namespace)::AddISubConstantLHS" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.load'(0x7fbd9b104d70) {
  %7 = "affine.load"(%6) {map = affine_map<() -> (0)>} : (memref<1xi32>) -> i32


  * Pattern LoadSelect<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "LoadSelect<mlir::AffineLoadOp>"
"LoadSelect<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern MetaPointer2Memref<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "MetaPointer2Memref<mlir::AffineLoadOp>"
"MetaPointer2Memref<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp> : 'affine.load -> ()' {
Trying to match "(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>"
"(anonymous namespace)::SimplifyAffineOp<mlir::AffineLoadOp>" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.get_global'(0x7fbd981673f0) {
  %6 = "memref.get_global"() {name = @kbm3} : () -> memref<1xi32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9816cc60) {
  %5 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98167e90) {
  %4 = "arith.constant"() {value = 0 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b1054b0) {
  %3 = "arith.constant"() {value = -1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98009280) {
  %2 = "arith.constant"() {value = -1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd98304580) {
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x7fbd9b306d40) {
  %0 = "arith.constant"() {value = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
mlir-asm-printer: Verifying operation: builtin.module
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::StorageUserTrait::IsMutable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SubElementTypeInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ShapedType::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::StorageUserTrait::IsMutable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::TypedAttr::Trait<Empty>)
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>>, llvm.data_layout = "e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-apple-macosx13.0.0", "polygeist.target-cpu" = "penryn", "polygeist.target-features" = "+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87", "polygeist.tune-cpu" = "generic"} {
  memref.global @im : memref<1xi32>
  memref.global @jm : memref<1xi32>
  memref.global @kbm3 : memref<1xi32> = uninitialized
  func.func @example(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
    %c1 = arith.constant 1 : index
    %c1_i32 = arith.constant 1 : i32
    %c-1 = arith.constant -1 : index
    %c-1_i32 = arith.constant -1 : i32
    %c0_i32 = arith.constant 0 : i32
    %c0 = arith.constant 0 : index
    %0 = memref.get_global @kbm3 : memref<1xi32>
    %1 = affine.load %0[0] : memref<1xi32>
    %2 = arith.addi %1, %c1_i32 : i32
    %3 = arith.index_cast %2 : i32 to index
    %4 = arith.index_cast %1 : i32 to index
    %5 = memref.get_global @jm : memref<1xi32>
    %6 = memref.get_global @im : memref<1xi32>
    scf.for %arg5 = %c1 to %3 step %c1 {
      %7 = arith.subi %arg5, %c1 : index
      %8 = arith.muli %7, %c-1 : index
      %9 = arith.addi %4, %8 : index
      %10 = arith.index_cast %9 : index to i32
      %11 = arith.addi %10, %c-1_i32 : i32
      %12 = scf.while (%arg6 = %c0_i32) : (i32) -> i32 {
        %13 = affine.load %5[0] : memref<1xi32>
        %14 = arith.cmpi slt, %arg6, %13 : i32
        scf.condition(%14) %arg6 : i32
      } do {
      ^bb0(%arg6: i32):
        %13:2 = scf.while (%arg7 = %c0_i32) : (i32) -> (i32, i32) {
          %15 = affine.load %6[0] : memref<1xi32>
          %16 = arith.cmpi slt, %arg7, %15 : i32
          scf.condition(%16) %15, %arg7 : i32, i32
        } do {
        ^bb0(%arg7: i32, %arg8: i32):
          %15 = arith.muli %arg6, %arg7 : i32
          %16 = arith.addi %arg8, %15 : i32
          %17 = arith.muli %10, %arg7 : i32
          %18 = affine.load %5[0] : memref<1xi32>
          %19 = arith.muli %17, %18 : i32
          %20 = arith.addi %16, %19 : i32
          %21 = arith.index_cast %20 : i32 to index
          %22 = arith.muli %11, %arg7 : i32
          %23 = arith.muli %22, %18 : i32
          %24 = arith.addi %16, %23 : i32
          %25 = arith.index_cast %24 : i32 to index
          %26 = arith.addi %25, %c0 : index
          %27 = memref.load %arg0[%26] : memref<?xf32>
          %28 = arith.addi %21, %c0 : index
          memref.store %27, %arg2[%28] : memref<?xf32>
          %29 = arith.addi %arg8, %c1_i32 : i32
          scf.yield %29 : i32
        }
        %14 = arith.addi %arg6, %c1_i32 : i32
        scf.yield %14 : i32
      }
    }
    return
  }
}
